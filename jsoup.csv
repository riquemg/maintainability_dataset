repo_name,path,content
jhy/jsoup,src/test/java/org/jsoup/nodes/EntitiesTest.java,"package org.jsoup.nodes;

import org.jsoup.Jsoup;
import org.jsoup.parser.Parser;
import org.junit.jupiter.api.Test;

import static org.jsoup.nodes.Document.OutputSettings;
import static org.jsoup.nodes.Entities.EscapeMode.*;
import static org.junit.jupiter.api.Assertions.assertEquals;

public class EntitiesTest {
    @Test public void escape() {
        String text = ""Hello &<> √Ö √• œÄ Êñ∞ there ¬æ ¬© ¬ª"";
        String escapedAscii = Entities.escape(text, new OutputSettings().charset(""ascii"").escapeMode(base));
        String escapedAsciiFull = Entities.escape(text, new OutputSettings().charset(""ascii"").escapeMode(extended));
        String escapedAsciiXhtml = Entities.escape(text, new OutputSettings().charset(""ascii"").escapeMode(xhtml));
        String escapedUtfFull = Entities.escape(text, new OutputSettings().charset(""UTF-8"").escapeMode(extended));
        String escapedUtfMin = Entities.escape(text, new OutputSettings().charset(""UTF-8"").escapeMode(xhtml));

        assertEquals(""Hello &amp;&lt;&gt; &Aring; &aring; &#x3c0; &#x65b0; there &frac34; &copy; &raquo;"", escapedAscii);
        assertEquals(""Hello &amp;&lt;&gt; &angst; &aring; &pi; &#x65b0; there &frac34; &copy; &raquo;"", escapedAsciiFull);
        assertEquals(""Hello &amp;&lt;&gt; &#xc5; &#xe5; &#x3c0; &#x65b0; there &#xbe; &#xa9; &#xbb;"", escapedAsciiXhtml);
        assertEquals(""Hello &amp;&lt;&gt; √Ö √• œÄ Êñ∞ there ¬æ ¬© ¬ª"", escapedUtfFull);
        assertEquals(""Hello &amp;&lt;&gt; √Ö √• œÄ Êñ∞ there ¬æ ¬© ¬ª"", escapedUtfMin);
        // odd that it's defined as aring in base but angst in full

        // round trip
        assertEquals(text, Entities.unescape(escapedAscii));
        assertEquals(text, Entities.unescape(escapedAsciiFull));
        assertEquals(text, Entities.unescape(escapedAsciiXhtml));
        assertEquals(text, Entities.unescape(escapedUtfFull));
        assertEquals(text, Entities.unescape(escapedUtfMin));
    }

    @Test public void escapedSupplementary() {
        String text = ""\uD835\uDD59"";
        String escapedAscii = Entities.escape(text, new OutputSettings().charset(""ascii"").escapeMode(base));
        assertEquals(""&#x1d559;"", escapedAscii);
        String escapedAsciiFull = Entities.escape(text, new OutputSettings().charset(""ascii"").escapeMode(extended));
        assertEquals(""&hopf;"", escapedAsciiFull);
        String escapedUtf= Entities.escape(text, new OutputSettings().charset(""UTF-8"").escapeMode(extended));
        assertEquals(text, escapedUtf);
    }

    @Test public void unescapeMultiChars() {
        String text = ""&NestedGreaterGreater; &nGg; &nGt; &nGtv; &Gt; &gg;""; // gg is not combo, but 8811 could conflict with NestedGreaterGreater or others
        String un = ""‚â´ ‚ãôÃ∏ ‚â´‚Éí ‚â´Ã∏ ‚â´ ‚â´"";
        assertEquals(un, Entities.unescape(text));
        String escaped = Entities.escape(un, new OutputSettings().charset(""ascii"").escapeMode(extended));
        assertEquals(""&Gt; &Gg;&#x338; &Gt;&#x20d2; &Gt;&#x338; &Gt; &Gt;"", escaped);
        assertEquals(un, Entities.unescape(escaped));
    }

    @Test public void xhtml() {
        assertEquals(38, xhtml.codepointForName(""amp""));
        assertEquals(62, xhtml.codepointForName(""gt""));
        assertEquals(60, xhtml.codepointForName(""lt""));
        assertEquals(34, xhtml.codepointForName(""quot""));

        assertEquals(""amp"", xhtml.nameForCodepoint(38));
        assertEquals(""gt"", xhtml.nameForCodepoint(62));
        assertEquals(""lt"", xhtml.nameForCodepoint(60));
        assertEquals(""quot"", xhtml.nameForCodepoint(34));
    }

    @Test public void getByName() {
        assertEquals(""‚â´‚Éí"", Entities.getByName(""nGt""));
        assertEquals(""fj"", Entities.getByName(""fjlig""));
        assertEquals(""‚â´"", Entities.getByName(""gg""));
        assertEquals(""¬©"", Entities.getByName(""copy""));
    }

    @Test public void escapeSupplementaryCharacter() {
        String text = new String(Character.toChars(135361));
        String escapedAscii = Entities.escape(text, new OutputSettings().charset(""ascii"").escapeMode(base));
        assertEquals(""&#x210c1;"", escapedAscii);
        String escapedUtf = Entities.escape(text, new OutputSettings().charset(""UTF-8"").escapeMode(base));
        assertEquals(text, escapedUtf);
    }

    @Test public void notMissingMultis() {
        String text = ""&nparsl;"";
        String un = ""\u2AFD\u20E5"";
        assertEquals(un, Entities.unescape(text));
    }

    @Test public void notMissingSupplementals() {
        String text = ""&npolint; &qfr;"";
        String un = ""‚®î \uD835\uDD2E""; // ùîÆ
        assertEquals(un, Entities.unescape(text));
    }

    @Test public void unescape() {
        String text = ""Hello &AElig; &amp;&LT&gt; &reg &angst; &angst &#960; &#960 &#x65B0; there &! &frac34; &copy; &COPY;"";
        assertEquals(""Hello √Ü &<> ¬Æ √Ö &angst œÄ œÄ Êñ∞ there &! ¬æ ¬© ¬©"", Entities.unescape(text));

        assertEquals(""&0987654321; &unknown"", Entities.unescape(""&0987654321; &unknown""));
    }

    @Test public void strictUnescape() { // for attributes, enforce strict unescaping (must look like &#xxx; , not just &#xxx)
        String text = ""Hello &amp= &amp;"";
        assertEquals(""Hello &amp= &"", Entities.unescape(text, true));
        assertEquals(""Hello &= &"", Entities.unescape(text));
        assertEquals(""Hello &= &"", Entities.unescape(text, false));
    }


    @Test public void caseSensitive() {
        String unescaped = ""√ú √º & &"";
        assertEquals(""&Uuml; &uuml; &amp; &amp;"",
                Entities.escape(unescaped, new OutputSettings().charset(""ascii"").escapeMode(extended)));

        String escaped = ""&Uuml; &uuml; &amp; &AMP"";
        assertEquals(""√ú √º & &"", Entities.unescape(escaped));
    }

    @Test public void quoteReplacements() {
        String escaped = ""&#92; &#36;"";
        String unescaped = ""\\ $"";

        assertEquals(unescaped, Entities.unescape(escaped));
    }

    @Test public void letterDigitEntities() {
        String html = ""<p>&sup1;&sup2;&sup3;&frac14;&frac12;&frac34;</p>"";
        Document doc = Jsoup.parse(html);
        doc.outputSettings().charset(""ascii"");
        Element p = doc.select(""p"").first();
        assertEquals(""&sup1;&sup2;&sup3;&frac14;&frac12;&frac34;"", p.html());
        assertEquals(""¬π¬≤¬≥¬º¬Ω¬æ"", p.text());
        doc.outputSettings().charset(""UTF-8"");
        assertEquals(""¬π¬≤¬≥¬º¬Ω¬æ"", p.html());
    }

    @Test public void noSpuriousDecodes() {
        String string = ""http://www.foo.com?a=1&num_rooms=1&children=0&int=VA&b=2"";
        assertEquals(string, Entities.unescape(string));
    }

    @Test public void escapesGtInXmlAttributesButNotInHtml() {
        // https://github.com/jhy/jsoup/issues/528 - < is OK in HTML attribute values, but not in XML


        String docHtml = ""<a title='<p>One</p>'>One</a>"";
        Document doc = Jsoup.parse(docHtml);
        Element element = doc.select(""a"").first();

        doc.outputSettings().escapeMode(base);
        assertEquals(""<a title=\""<p>One</p>\"">One</a>"", element.outerHtml());

        doc.outputSettings().escapeMode(xhtml);
        assertEquals(""<a title=\""&lt;p>One&lt;/p>\"">One</a>"", element.outerHtml());
    }

    @Test public void controlCharactersAreEscaped() {
        // https://github.com/jhy/jsoup/issues/1556
        // we escape ascii control characters in both HTML and XML for compatibility. Required in XML and probably
        // easier to read in HTML
        String input = ""<a foo=\""&#x1b;esc&#x7;bell\"">Text &#x1b; &#x7;</a>"";
        Document doc = Jsoup.parse(input);
        assertEquals(input, doc.body().html());

        Document xml = Jsoup.parse(input, """", Parser.xmlParser());
        assertEquals(input, xml.html());
    }
}
"
jhy/jsoup,src/main/java/org/jsoup/examples/Wikipedia.java,"package org.jsoup.examples;

import org.jsoup.Jsoup;
import org.jsoup.nodes.Document;
import org.jsoup.nodes.Element;
import org.jsoup.select.Elements;

import java.io.IOException;

/**
 * A simple example, used on the jsoup website.
 */
public class Wikipedia {
    public static void main(String[] args) throws IOException {
        Document doc = Jsoup.connect(""http://en.wikipedia.org/"").get();
        log(doc.title());

        Elements newsHeadlines = doc.select(""#mp-itn b a"");
        for (Element headline : newsHeadlines) {
            log(""%s\n\t%s"", headline.attr(""title""), headline.absUrl(""href""));
        }
    }

    private static void log(String msg, String... vals) {
        System.out.println(String.format(msg, vals));
    }
}
"
jhy/jsoup,src/main/java/org/jsoup/nodes/DocumentType.java,"package org.jsoup.nodes;

import org.jsoup.internal.StringUtil;
import org.jsoup.helper.Validate;
import org.jsoup.nodes.Document.OutputSettings.Syntax;

import java.io.IOException;

/**
 * A {@code <!DOCTYPE>} node.
 */
public class DocumentType extends LeafNode {
    // todo needs a bit of a chunky cleanup. this level of detail isn't needed
    public static final String PUBLIC_KEY = ""PUBLIC"";
    public static final String SYSTEM_KEY = ""SYSTEM"";
    private static final String NAME = ""name"";
    private static final String PUB_SYS_KEY = ""pubSysKey""; // PUBLIC or SYSTEM
    private static final String PUBLIC_ID = ""publicId"";
    private static final String SYSTEM_ID = ""systemId"";
    // todo: quirk mode from publicId and systemId

    /**
     * Create a new doctype element.
     * @param name the doctype's name
     * @param publicId the doctype's public ID
     * @param systemId the doctype's system ID
     */
    public DocumentType(String name, String publicId, String systemId) {
        Validate.notNull(name);
        Validate.notNull(publicId);
        Validate.notNull(systemId);
        attr(NAME, name);
        attr(PUBLIC_ID, publicId);
        attr(SYSTEM_ID, systemId);
        updatePubSyskey();
    }

    public void setPubSysKey(String value) {
        if (value != null)
            attr(PUB_SYS_KEY, value);
    }

    private void updatePubSyskey() {
        if (has(PUBLIC_ID)) {
            attr(PUB_SYS_KEY, PUBLIC_KEY);
        } else if (has(SYSTEM_ID))
            attr(PUB_SYS_KEY, SYSTEM_KEY);
    }

    /**
     * Get this doctype's name (when set, or empty string)
     * @return doctype name
     */
    public String name() {
        return attr(NAME);
    }

    /**
     * Get this doctype's Public ID (when set, or empty string)
     * @return doctype Public ID
     */
    public String publicId() {
        return attr(PUBLIC_ID);
    }

    /**
     * Get this doctype's System ID (when set, or empty string)
     * @return doctype System ID
     */
    public String systemId() {
        return attr(SYSTEM_ID);
    }

    @Override
    public String nodeName() {
        return ""#doctype"";
    }

    @Override
    void outerHtmlHead(Appendable accum, int depth, Document.OutputSettings out) throws IOException {
        // add a newline if the doctype has a preceding node (which must be a comment)
        if (siblingIndex > 0 && out.prettyPrint())
            accum.append('\n');

        if (out.syntax() == Syntax.html && !has(PUBLIC_ID) && !has(SYSTEM_ID)) {
            // looks like a html5 doctype, go lowercase for aesthetics
            accum.append(""<!doctype"");
        } else {
            accum.append(""<!DOCTYPE"");
        }
        if (has(NAME))
            accum.append("" "").append(attr(NAME));
        if (has(PUB_SYS_KEY))
            accum.append("" "").append(attr(PUB_SYS_KEY));
        if (has(PUBLIC_ID))
            accum.append("" \"""").append(attr(PUBLIC_ID)).append('""');
        if (has(SYSTEM_ID))
            accum.append("" \"""").append(attr(SYSTEM_ID)).append('""');
        accum.append('>');
    }

    @Override
    void outerHtmlTail(Appendable accum, int depth, Document.OutputSettings out) {
    }

    private boolean has(final String attribute) {
        return !StringUtil.isBlank(attr(attribute));
    }
}
"
jhy/jsoup,src/main/java/org/jsoup/select/NodeTraversor.java,"package org.jsoup.select;

import org.jsoup.helper.Validate;
import org.jsoup.nodes.Element;
import org.jsoup.nodes.Node;
import org.jsoup.select.NodeFilter.FilterResult;

/**
 * Depth-first node traversor. Use to iterate through all nodes under and including the specified root node.
 * <p>
 * This implementation does not use recursion, so a deep DOM does not risk blowing the stack.
 * </p>
 */
public class NodeTraversor {
    /**
     * Start a depth-first traverse of the root and all of its descendants.
     * @param visitor Node visitor.
     * @param root the root node point to traverse.
     */
    public static void traverse(NodeVisitor visitor, Node root) {
        Validate.notNull(visitor);
        Validate.notNull(root);
        Node node = root;
        int depth = 0;
        
        while (node != null) {
            Node parent = node.parentNode(); // remember parent to find nodes that get replaced in .head
            int origSize = parent != null ? parent.childNodeSize() : 0;
            Node next = node.nextSibling();

            visitor.head(node, depth); // visit current node
            if (parent != null && !node.hasParent()) { // removed or replaced
                if (origSize == parent.childNodeSize()) { // replaced
                    node = parent.childNode(node.siblingIndex()); // replace ditches parent but keeps sibling index
                } else { // removed
                    node = next;
                    if (node == null) { // last one, go up
                        node = parent;
                        depth--;
                    }
                    continue; // don't tail removed
                }
            }

            if (node.childNodeSize() > 0) { // descend
                node = node.childNode(0);
                depth++;
            } else {
                while (true) {
                    assert node != null; // as depth > 0, will have parent
                    if (!(node.nextSibling() == null && depth > 0)) break;
                    visitor.tail(node, depth); // when no more siblings, ascend
                    node = node.parentNode();
                    depth--;
                }
                visitor.tail(node, depth);
                if (node == root)
                    break;
                node = node.nextSibling();
            }
        }
    }

    /**
     * Start a depth-first traverse of all elements.
     * @param visitor Node visitor.
     * @param elements Elements to filter.
     */
    public static void traverse(NodeVisitor visitor, Elements elements) {
        Validate.notNull(visitor);
        Validate.notNull(elements);
        for (Element el : elements)
            traverse(visitor, el);
    }

    /**
     * Start a depth-first filtering of the root and all of its descendants.
     * @param filter Node visitor.
     * @param root the root node point to traverse.
     * @return The filter result of the root node, or {@link FilterResult#STOP}.
     */
    public static FilterResult filter(NodeFilter filter, Node root) {
        Node node = root;
        int depth = 0;

        while (node != null) {
            FilterResult result = filter.head(node, depth);
            if (result == FilterResult.STOP)
                return result;
            // Descend into child nodes:
            if (result == FilterResult.CONTINUE && node.childNodeSize() > 0) {
                node = node.childNode(0);
                ++depth;
                continue;
            }
            // No siblings, move upwards:
            while (true) {
                assert node != null; // depth > 0, so has parent
                if (!(node.nextSibling() == null && depth > 0)) break;
                // 'tail' current node:
                if (result == FilterResult.CONTINUE || result == FilterResult.SKIP_CHILDREN) {
                    result = filter.tail(node, depth);
                    if (result == FilterResult.STOP)
                        return result;
                }
                Node prev = node; // In case we need to remove it below.
                node = node.parentNode();
                depth--;
                if (result == FilterResult.REMOVE)
                    prev.remove(); // Remove AFTER finding parent.
                result = FilterResult.CONTINUE; // Parent was not pruned.
            }
            // 'tail' current node, then proceed with siblings:
            if (result == FilterResult.CONTINUE || result == FilterResult.SKIP_CHILDREN) {
                result = filter.tail(node, depth);
                if (result == FilterResult.STOP)
                    return result;
            }
            if (node == root)
                return result;
            Node prev = node; // In case we need to remove it below.
            node = node.nextSibling();
            if (result == FilterResult.REMOVE)
                prev.remove(); // Remove AFTER finding sibling.
        }
        // root == null?
        return FilterResult.CONTINUE;
    }

    /**
     * Start a depth-first filtering of all elements.
     * @param filter Node filter.
     * @param elements Elements to filter.
     */
    public static void filter(NodeFilter filter, Elements elements) {
        Validate.notNull(filter);
        Validate.notNull(elements);
        for (Element el : elements)
            if (filter(filter, el) == FilterResult.STOP)
                break;
    }
}
"
jhy/jsoup,src/test/java/org/jsoup/nodes/TextNodeTest.java,"package org.jsoup.nodes;

import org.jsoup.Jsoup;
import org.jsoup.TextUtil;
import org.jsoup.internal.StringUtil;
import org.junit.jupiter.api.Test;

import java.util.List;

import static org.junit.jupiter.api.Assertions.*;

/**
 Test TextNodes

 @author Jonathan Hedley, jonathan@hedley.net */
public class TextNodeTest {
    @Test public void testBlank() {
        TextNode one = new TextNode("""");
        TextNode two = new TextNode(""     "");
        TextNode three = new TextNode(""  \n\n   "");
        TextNode four = new TextNode(""Hello"");
        TextNode five = new TextNode(""  \nHello "");

        assertTrue(one.isBlank());
        assertTrue(two.isBlank());
        assertTrue(three.isBlank());
        assertFalse(four.isBlank());
        assertFalse(five.isBlank());
    }

    @Test public void testTextBean() {
        Document doc = Jsoup.parse(""<p>One <span>two &amp;</span> three &amp;</p>"");
        Element p = doc.select(""p"").first();

        Element span = doc.select(""span"").first();
        assertEquals(""two &"", span.text());
        TextNode spanText = (TextNode) span.childNode(0);
        assertEquals(""two &"", spanText.text());

        TextNode tn = (TextNode) p.childNode(2);
        assertEquals("" three &"", tn.text());

        tn.text("" POW!"");
        assertEquals(""One <span>two &amp;</span> POW!"", TextUtil.stripNewlines(p.html()));

        tn.attr(tn.nodeName(), ""kablam &"");
        assertEquals(""kablam &"", tn.text());
        assertEquals(""One <span>two &amp;</span>kablam &amp;"", TextUtil.stripNewlines(p.html()));
    }

    @Test public void testSplitText() {
        Document doc = Jsoup.parse(""<div>Hello there</div>"");
        Element div = doc.select(""div"").first();
        TextNode tn = (TextNode) div.childNode(0);
        TextNode tail = tn.splitText(6);
        assertEquals(""Hello "", tn.getWholeText());
        assertEquals(""there"", tail.getWholeText());
        tail.text(""there!"");
        assertEquals(""Hello there!"", div.text());
        assertSame(tn.parent(), tail.parent());
    }

    @Test public void testSplitAnEmbolden() {
        Document doc = Jsoup.parse(""<div>Hello there</div>"");
        Element div = doc.select(""div"").first();
        TextNode tn = (TextNode) div.childNode(0);
        TextNode tail = tn.splitText(6);
        tail.wrap(""<b></b>"");

        assertEquals(""Hello <b>there</b>"", TextUtil.stripNewlines(div.html())); // not great that we get \n<b>there there... must correct
    }

    @Test public void testWithSupplementaryCharacter(){
        Document doc = Jsoup.parse(new String(Character.toChars(135361)));
        TextNode t = doc.body().textNodes().get(0);
        assertEquals(new String(Character.toChars(135361)), t.outerHtml().trim());
    }

    @Test public void testLeadNodesHaveNoChildren() {
        Document doc = Jsoup.parse(""<div>Hello there</div>"");
        Element div = doc.select(""div"").first();
        TextNode tn = (TextNode) div.childNode(0);
        List<Node> nodes = tn.childNodes();
        assertEquals(0, nodes.size());
    }

    @Test public void testSpaceNormalise() {
        // https://github.com/jhy/jsoup/issues/1309
        String whole = ""Two  spaces"";
        String norm = ""Two spaces"";
        TextNode tn = new TextNode(whole); // there are 2 spaces between the words
        assertEquals(whole, tn.getWholeText());
        assertEquals(norm, tn.text());
        assertEquals(norm, tn.outerHtml());
        assertEquals(norm, tn.toString());

        Element el = new Element(""p"");
        el.appendChild(tn); // this used to change the context
        //tn.setParentNode(el); // set any parent
        assertEquals(whole, tn.getWholeText());
        assertEquals(norm, tn.text());
        assertEquals(norm, tn.outerHtml());
        assertEquals(norm, tn.toString());

        assertEquals(""<p>"" + norm + ""</p>"", el.outerHtml());
        assertEquals(norm, el.html());
        assertEquals(whole, el.wholeText());
    }

    @Test
    public void testClone() {
        // https://github.com/jhy/jsoup/issues/1176
        TextNode x = new TextNode(""zzz"");
        TextNode y = x.clone();

        assertNotSame(x, y);
        assertEquals(x.outerHtml(), y.outerHtml());

        y.text(""yyy"");
        assertNotEquals(x.outerHtml(), y.outerHtml());
        assertEquals(""zzz"", x.text());

        x.attributes(); // already cloned so no impact
        y.text(""xxx"");
        assertEquals(""zzz"", x.text());
        assertEquals(""xxx"", y.text());
    }

    @Test
    public void testCloneAfterAttributesHit() {
        // https://github.com/jhy/jsoup/issues/1176
        TextNode x = new TextNode(""zzz"");
        x.attributes(); // moves content from leafnode value to attributes, which were missed in clone
        TextNode y = x.clone();
        y.text(""xxx"");
        assertEquals(""zzz"", x.text());
        assertEquals(""xxx"", y.text());
    }

    @Test
    public void testHasTextWhenIterating() {
        // https://github.com/jhy/jsoup/issues/1170
        Document doc = Jsoup.parse(""<div>One <p>Two <p>Three"");
        boolean foundFirst = false;
        for (Element el : doc.getAllElements()) {
            for (Node node : el.childNodes()) {
                if (node instanceof TextNode) {
                    TextNode textNode = (TextNode) node;
                    assertFalse(StringUtil.isBlank(textNode.text()));
                    if (!foundFirst) {
                        foundFirst = true;
                        assertEquals(""One "", textNode.text());
                        assertEquals(""One "", textNode.getWholeText());
                    }
                }
            }
        }
        assertTrue(foundFirst);
    }
}
"
jhy/jsoup,src/main/java/org/jsoup/helper/HttpConnection.java,"package org.jsoup.helper;

import org.jsoup.Connection;
import org.jsoup.HttpStatusException;
import org.jsoup.UncheckedIOException;
import org.jsoup.UnsupportedMimeTypeException;
import org.jsoup.internal.ConstrainableInputStream;
import org.jsoup.internal.StringUtil;
import org.jsoup.nodes.Document;
import org.jsoup.parser.Parser;
import org.jsoup.parser.TokenQueue;

import javax.annotation.Nullable;
import javax.net.ssl.HttpsURLConnection;
import javax.net.ssl.SSLSocketFactory;
import java.io.BufferedInputStream;
import java.io.BufferedWriter;
import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.OutputStreamWriter;
import java.net.CookieManager;
import java.net.CookieStore;
import java.net.HttpURLConnection;
import java.net.IDN;
import java.net.InetSocketAddress;
import java.net.MalformedURLException;
import java.net.Proxy;
import java.net.URI;
import java.net.URISyntaxException;
import java.net.URL;
import java.net.URLEncoder;
import java.nio.Buffer;
import java.nio.ByteBuffer;
import java.nio.charset.Charset;
import java.nio.charset.IllegalCharsetNameException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.regex.Pattern;
import java.util.zip.GZIPInputStream;
import java.util.zip.Inflater;
import java.util.zip.InflaterInputStream;

import static org.jsoup.Connection.Method.HEAD;
import static org.jsoup.internal.Normalizer.lowerCase;

/**
 * Implementation of {@link Connection}.
 * @see org.jsoup.Jsoup#connect(String)
 */
@SuppressWarnings(""CharsetObjectCanBeUsed"")
public class HttpConnection implements Connection {
    public static final String CONTENT_ENCODING = ""Content-Encoding"";
    /**
     * Many users would get caught by not setting a user-agent and therefore getting different responses on their desktop
     * vs in jsoup, which would otherwise default to {@code Java}. So by default, use a desktop UA.
     */
    public static final String DEFAULT_UA =
        ""Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/79.0.3945.130 Safari/537.36"";
    private static final String USER_AGENT = ""User-Agent"";
    public static final String CONTENT_TYPE = ""Content-Type"";
    public static final String MULTIPART_FORM_DATA = ""multipart/form-data"";
    public static final String FORM_URL_ENCODED = ""application/x-www-form-urlencoded"";
    private static final int HTTP_TEMP_REDIR = 307; // http/1.1 temporary redirect, not in Java's set.
    private static final String DefaultUploadType = ""application/octet-stream"";
    private static final Charset UTF_8 = Charset.forName(""UTF-8""); // Don't use StandardCharsets, not in Android API 10.
    private static final Charset ISO_8859_1 = Charset.forName(""ISO-8859-1"");

    /**
     Create a new Connection, with the request URL specified.
     @param url the URL to fetch from
     @return a new Connection object
     */
    public static Connection connect(String url) {
        Connection con = new HttpConnection();
        con.url(url);
        return con;
    }

    /**
     Create a new Connection, with the request URL specified.
     @param url the URL to fetch from
     @return a new Connection object
     */
    public static Connection connect(URL url) {
        Connection con = new HttpConnection();
        con.url(url);
        return con;
    }

    /**
     Creates a new, empty HttpConnection.
     */
    public HttpConnection() {
        req = new Request();
    }

    /**
     Create a new Request by deep-copying an existing Request
     @param copy the request to copy
     */
    HttpConnection(Request copy) {
        req = new Request(copy);
    }

    /**
     * Encodes the input URL into a safe ASCII URL string
     * @param url unescaped URL
     * @return escaped URL
     */
	private static String encodeUrl(String url) {
        try {
            URL u = new URL(url);
            return encodeUrl(u).toExternalForm();
        } catch (Exception e) {
            return url;
        }
	}

    static URL encodeUrl(URL u) {
	    u = punyUrl(u);
        try {
            //  odd way to encode urls, but it works!
            String urlS = u.toExternalForm(); // URL external form may have spaces which is illegal in new URL() (odd asymmetry)
            urlS = urlS.replace("" "", ""%20"");
            final URI uri = new URI(urlS);
            return new URL(uri.toASCIIString());
        } catch (URISyntaxException | MalformedURLException e) {
            // give up and return the original input
            return u;
        }
    }

    /**
     Convert an International URL to a Punycode URL.
     @param url input URL that may include an international hostname
     @return a punycode URL if required, or the original URL
     */
    private static URL punyUrl(URL url) {
        if (!StringUtil.isAscii(url.getHost())) {
            try {
                String puny = IDN.toASCII(url.getHost());
                url = new URL(url.getProtocol(), puny, url.getPort(), url.getFile()); // file will include ref, query if any
            } catch (MalformedURLException e) {
                // if passed a valid URL initially, cannot happen
                throw new IllegalArgumentException(e);
            }
        }
        return url;
    }

    private static String encodeMimeName(String val) {
        return val.replace(""\"""", ""%22"");
    }

    private HttpConnection.Request req;
    private @Nullable Connection.Response res;

    @Override
    public Connection newRequest() {
        // copy the prototype request for the different settings, cookie manager, etc
        return new HttpConnection(req);
    }

    /** Create a new Connection that just wraps the provided Request and Response */
    private HttpConnection(Request req, Response res) {
        this.req = req;
        this.res = res;
    }

    public Connection url(URL url) {
        req.url(url);
        return this;
    }

    public Connection url(String url) {
        Validate.notEmptyParam(url, ""url"");
        try {
            req.url(new URL(encodeUrl(url)));
        } catch (MalformedURLException e) {
            throw new IllegalArgumentException(String.format(""The supplied URL, '%s', is malformed. Make sure it is an absolute URL, and starts with 'http://' or 'https://'. See https://jsoup.org/cookbook/extracting-data/working-with-urls"", url), e);
        }
        return this;
    }

    public Connection proxy(@Nullable Proxy proxy) {
        req.proxy(proxy);
        return this;
    }

    public Connection proxy(String host, int port) {
        req.proxy(host, port);
        return this;
    }

    public Connection userAgent(String userAgent) {
        Validate.notNullParam(userAgent, ""userAgent"");
        req.header(USER_AGENT, userAgent);
        return this;
    }

    public Connection timeout(int millis) {
        req.timeout(millis);
        return this;
    }

    public Connection maxBodySize(int bytes) {
        req.maxBodySize(bytes);
        return this;
    }

    public Connection followRedirects(boolean followRedirects) {
        req.followRedirects(followRedirects);
        return this;
    }

    public Connection referrer(String referrer) {
        Validate.notNullParam(referrer, ""referrer"");
        req.header(""Referer"", referrer);
        return this;
    }

    public Connection method(Method method) {
        req.method(method);
        return this;
    }

    public Connection ignoreHttpErrors(boolean ignoreHttpErrors) {
		req.ignoreHttpErrors(ignoreHttpErrors);
		return this;
	}

    public Connection ignoreContentType(boolean ignoreContentType) {
        req.ignoreContentType(ignoreContentType);
        return this;
    }


    public Connection data(String key, String value) {
        req.data(KeyVal.create(key, value));
        return this;
    }

    public Connection sslSocketFactory(SSLSocketFactory sslSocketFactory) {
	    req.sslSocketFactory(sslSocketFactory);
	    return this;
    }

    public Connection data(String key, String filename, InputStream inputStream) {
        req.data(KeyVal.create(key, filename, inputStream));
        return this;
    }

    @Override
    public Connection data(String key, String filename, InputStream inputStream, String contentType) {
        req.data(KeyVal.create(key, filename, inputStream).contentType(contentType));
        return this;
    }

    public Connection data(Map<String, String> data) {
        Validate.notNullParam(data, ""data"");
        for (Map.Entry<String, String> entry : data.entrySet()) {
            req.data(KeyVal.create(entry.getKey(), entry.getValue()));
        }
        return this;
    }

    public Connection data(String... keyvals) {
        Validate.notNullParam(keyvals, ""keyvals"");
        Validate.isTrue(keyvals.length %2 == 0, ""Must supply an even number of key value pairs"");
        for (int i = 0; i < keyvals.length; i += 2) {
            String key = keyvals[i];
            String value = keyvals[i+1];
            Validate.notEmpty(key, ""Data key must not be empty"");
            Validate.notNull(value, ""Data value must not be null"");
            req.data(KeyVal.create(key, value));
        }
        return this;
    }

    public Connection data(Collection<Connection.KeyVal> data) {
        Validate.notNullParam(data, ""data"");
        for (Connection.KeyVal entry: data) {
            req.data(entry);
        }
        return this;
    }

    public Connection.KeyVal data(String key) {
        Validate.notEmptyParam(key, ""key"");
        for (Connection.KeyVal keyVal : request().data()) {
            if (keyVal.key().equals(key))
                return keyVal;
        }
        return null;
    }

    public Connection requestBody(String body) {
        req.requestBody(body);
        return this;
    }

    public Connection header(String name, String value) {
        req.header(name, value);
        return this;
    }

    public Connection headers(Map<String,String> headers) {
        Validate.notNullParam(headers, ""headers"");
        for (Map.Entry<String,String> entry : headers.entrySet()) {
            req.header(entry.getKey(),entry.getValue());
        }
        return this;
    }

    public Connection cookie(String name, String value) {
        req.cookie(name, value);
        return this;
    }

    public Connection cookies(Map<String, String> cookies) {
        Validate.notNullParam(cookies, ""cookies"");
        for (Map.Entry<String, String> entry : cookies.entrySet()) {
            req.cookie(entry.getKey(), entry.getValue());
        }
        return this;
    }

    @Override
    public Connection cookieStore(CookieStore cookieStore) {
        // create a new cookie manager using the new store
        req.cookieManager = new CookieManager(cookieStore, null);
        return this;
    }

    @Override
    public CookieStore cookieStore() {
        return req.cookieManager.getCookieStore();
    }

    public Connection parser(Parser parser) {
        req.parser(parser);
        return this;
    }

    public Document get() throws IOException {
        req.method(Method.GET);
        execute();
        Validate.notNull(res);
        return res.parse();
    }

    public Document post() throws IOException {
        req.method(Method.POST);
        execute();
        Validate.notNull(res);
        return res.parse();
    }

    public Connection.Response execute() throws IOException {
        res = Response.execute(req);
        return res;
    }

    public Connection.Request request() {
        return req;
    }

    public Connection request(Connection.Request request) {
        req = (HttpConnection.Request) request; // will throw a class-cast exception if the user has extended some but not all of Connection; that's desired
        return this;
    }

    public Connection.Response response() {
        if (res == null) {
            throw new IllegalArgumentException(""You must execute the request before getting a response."");
        }
        return res;
    }

    public Connection response(Connection.Response response) {
        res = response;
        return this;
    }

    public Connection postDataCharset(String charset) {
        req.postDataCharset(charset);
        return this;
    }


    @SuppressWarnings(""unchecked"")
    private static abstract class Base<T extends Connection.Base<T>> implements Connection.Base<T> {
        private static final URL UnsetUrl; // only used if you created a new Request()
        static {
            try {
                UnsetUrl = new URL(""http://undefined/"");
            } catch (MalformedURLException e) {
                throw new IllegalStateException(e);
            }
        }

        URL url = UnsetUrl;
        Method method = Method.GET;
        Map<String, List<String>> headers;
        Map<String, String> cookies;

        private Base() {
            headers = new LinkedHashMap<>();
            cookies = new LinkedHashMap<>();
        }

        private Base(Base<T> copy) {
            url = copy.url; // unmodifiable object
            method = copy.method;
            headers = new LinkedHashMap<>();
            for (Map.Entry<String, List<String>> entry : copy.headers.entrySet()) {
                headers.put(entry.getKey(), new ArrayList<>(entry.getValue()));
            }
            cookies = new LinkedHashMap<>(); cookies.putAll(copy.cookies); // just holds strings
        }

        public URL url() {
            if (url == UnsetUrl)
                throw new IllegalArgumentException(""URL not set. Make sure to call #url(...) before executing the request."");
            return url;
        }

        public T url(URL url) {
            Validate.notNullParam(url, ""url"");
            this.url = punyUrl(url); // if calling url(url) directly, does not go through encodeUrl, so we punycode it explicitly. todo - should we encode here as well?
            return (T) this;
        }

        public Method method() {
            return method;
        }

        public T method(Method method) {
            Validate.notNullParam(method, ""method"");
            this.method = method;
            return (T) this;
        }

        public String header(String name) {
            Validate.notNullParam(name, ""name"");
            List<String> vals = getHeadersCaseInsensitive(name);
            if (vals.size() > 0) {
                // https://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html#sec4.2
                return StringUtil.join(vals, "", "");
            }

            return null;
        }

        @Override
        public T addHeader(String name, String value) {
            Validate.notEmptyParam(name, ""name"");
            //noinspection ConstantConditions
            value = value == null ? """" : value;

            List<String> values = headers(name);
            if (values.isEmpty()) {
                values = new ArrayList<>();
                headers.put(name, values);
            }
            values.add(fixHeaderEncoding(value));

            return (T) this;
        }

        @Override
        public List<String> headers(String name) {
            Validate.notEmptyParam(name, ""name"");
            return getHeadersCaseInsensitive(name);
        }

        private static String fixHeaderEncoding(String val) {
            byte[] bytes = val.getBytes(ISO_8859_1);
            if (!looksLikeUtf8(bytes))
                return val;
            return new String(bytes, UTF_8);
        }

        private static boolean looksLikeUtf8(byte[] input) {
            int i = 0;
            // BOM:
            if (input.length >= 3
                && (input[0] & 0xFF) == 0xEF
                && (input[1] & 0xFF) == 0xBB
                && (input[2] & 0xFF) == 0xBF) {
                i = 3;
            }

            int end;
            for (int j = input.length; i < j; ++i) {
                int o = input[i];
                if ((o & 0x80) == 0) {
                    continue; // ASCII
                }

                // UTF-8 leading:
                if ((o & 0xE0) == 0xC0) {
                    end = i + 1;
                } else if ((o & 0xF0) == 0xE0) {
                    end = i + 2;
                } else if ((o & 0xF8) == 0xF0) {
                    end = i + 3;
                } else {
                    return false;
                }

                if (end >= input.length)
                    return false;

                while (i < end) {
                    i++;
                    o = input[i];
                    if ((o & 0xC0) != 0x80) {
                        return false;
                    }
                }
            }
            return true;
        }

        public T header(String name, String value) {
            Validate.notEmptyParam(name, ""name"");
            removeHeader(name); // ensures we don't get an ""accept-encoding"" and a ""Accept-Encoding""
            addHeader(name, value);
            return (T) this;
        }

        public boolean hasHeader(String name) {
            Validate.notEmptyParam(name, ""name"");
            return !getHeadersCaseInsensitive(name).isEmpty();
        }

        /**
         * Test if the request has a header with this value (case insensitive).
         */
        public boolean hasHeaderWithValue(String name, String value) {
            Validate.notEmpty(name);
            Validate.notEmpty(value);
            List<String> values = headers(name);
            for (String candidate : values) {
                if (value.equalsIgnoreCase(candidate))
                    return true;
            }
            return false;
        }

        public T removeHeader(String name) {
            Validate.notEmptyParam(name, ""name"");
            Map.Entry<String, List<String>> entry = scanHeaders(name); // remove is case-insensitive too
            if (entry != null)
                headers.remove(entry.getKey()); // ensures correct case
            return (T) this;
        }

        public Map<String, String> headers() {
            LinkedHashMap<String, String> map = new LinkedHashMap<>(headers.size());
            for (Map.Entry<String, List<String>> entry : headers.entrySet()) {
                String header = entry.getKey();
                List<String> values = entry.getValue();
                if (values.size() > 0)
                    map.put(header, values.get(0));
            }
            return map;
        }

        @Override
        public Map<String, List<String>> multiHeaders() {
            return headers;
        }

        private List<String> getHeadersCaseInsensitive(String name) {
            Validate.notNull(name);

            for (Map.Entry<String, List<String>> entry : headers.entrySet()) {
                if (name.equalsIgnoreCase(entry.getKey()))
                    return entry.getValue();
            }

            return Collections.emptyList();
        }

        private @Nullable Map.Entry<String, List<String>> scanHeaders(String name) {
            String lc = lowerCase(name);
            for (Map.Entry<String, List<String>> entry : headers.entrySet()) {
                if (lowerCase(entry.getKey()).equals(lc))
                    return entry;
            }
            return null;
        }

        public String cookie(String name) {
            Validate.notEmptyParam(name, ""name"");
            return cookies.get(name);
        }

        public T cookie(String name, String value) {
            Validate.notEmptyParam(name, ""name"");
            Validate.notNullParam(value, ""value"");
            cookies.put(name, value);
            return (T) this;
        }

        public boolean hasCookie(String name) {
            Validate.notEmptyParam(name, ""name"");
            return cookies.containsKey(name);
        }

        public T removeCookie(String name) {
            Validate.notEmptyParam(name, ""name"");
            cookies.remove(name);
            return (T) this;
        }

        public Map<String, String> cookies() {
            return cookies;
        }
    }

    public static class Request extends HttpConnection.Base<Connection.Request> implements Connection.Request {
        static {
            System.setProperty(""sun.net.http.allowRestrictedHeaders"", ""true"");
            // make sure that we can send Sec-Fetch-Site headers etc.
        }

        private @Nullable Proxy proxy;
        private int timeoutMilliseconds;
        private int maxBodySizeBytes;
        private boolean followRedirects;
        private final Collection<Connection.KeyVal> data;
        private @Nullable String body = null;
        private boolean ignoreHttpErrors = false;
        private boolean ignoreContentType = false;
        private Parser parser;
        private boolean parserDefined = false; // called parser(...) vs initialized in ctor
        private String postDataCharset = DataUtil.defaultCharsetName;
        private @Nullable SSLSocketFactory sslSocketFactory;
        private CookieManager cookieManager;
        private volatile boolean executing = false;

        Request() {
            super();
            timeoutMilliseconds = 30000; // 30 seconds
            maxBodySizeBytes = 1024 * 1024 * 2; // 2MB
            followRedirects = true;
            data = new ArrayList<>();
            method = Method.GET;
            addHeader(""Accept-Encoding"", ""gzip"");
            addHeader(USER_AGENT, DEFAULT_UA);
            parser = Parser.htmlParser();
            cookieManager = new CookieManager(); // creates a default InMemoryCookieStore
        }

        Request(Request copy) {
            super(copy);
            proxy = copy.proxy;
            postDataCharset = copy.postDataCharset;
            timeoutMilliseconds = copy.timeoutMilliseconds;
            maxBodySizeBytes = copy.maxBodySizeBytes;
            followRedirects = copy.followRedirects;
            data = new ArrayList<>(); data.addAll(copy.data()); // this is shallow, but holds immutable string keyval, and possibly an InputStream which can only be read once anyway, so using as a prototype would be unsupported
            body = copy.body;
            ignoreHttpErrors = copy.ignoreHttpErrors;
            ignoreContentType = copy.ignoreContentType;
            parser = copy.parser.newInstance(); // parsers and their tree-builders maintain state, so need a fresh copy
            parserDefined = copy.parserDefined;
            sslSocketFactory = copy.sslSocketFactory; // these are all synchronized so safe to share
            cookieManager = copy.cookieManager;
            executing = false;
        }

        public Proxy proxy() {
            return proxy;
        }

        public Request proxy(@Nullable Proxy proxy) {
            this.proxy = proxy;
            return this;
        }

        public Request proxy(String host, int port) {
            this.proxy = new Proxy(Proxy.Type.HTTP, InetSocketAddress.createUnresolved(host, port));
            return this;
        }

        public int timeout() {
            return timeoutMilliseconds;
        }

        public Request timeout(int millis) {
            Validate.isTrue(millis >= 0, ""Timeout milliseconds must be 0 (infinite) or greater"");
            timeoutMilliseconds = millis;
            return this;
        }

        public int maxBodySize() {
            return maxBodySizeBytes;
        }

        public Connection.Request maxBodySize(int bytes) {
            Validate.isTrue(bytes >= 0, ""maxSize must be 0 (unlimited) or larger"");
            maxBodySizeBytes = bytes;
            return this;
        }

        public boolean followRedirects() {
            return followRedirects;
        }

        public Connection.Request followRedirects(boolean followRedirects) {
            this.followRedirects = followRedirects;
            return this;
        }

        public boolean ignoreHttpErrors() {
            return ignoreHttpErrors;
        }

        public SSLSocketFactory sslSocketFactory() {
            return sslSocketFactory;
        }

        public void sslSocketFactory(SSLSocketFactory sslSocketFactory) {
            this.sslSocketFactory = sslSocketFactory;
        }

        public Connection.Request ignoreHttpErrors(boolean ignoreHttpErrors) {
            this.ignoreHttpErrors = ignoreHttpErrors;
            return this;
        }

        public boolean ignoreContentType() {
            return ignoreContentType;
        }

        public Connection.Request ignoreContentType(boolean ignoreContentType) {
            this.ignoreContentType = ignoreContentType;
            return this;
        }

        public Request data(Connection.KeyVal keyval) {
            Validate.notNullParam(keyval, ""keyval"");
            data.add(keyval);
            return this;
        }

        public Collection<Connection.KeyVal> data() {
            return data;
        }

        public Connection.Request requestBody(@Nullable String body) {
            this.body = body;
            return this;
        }

        public String requestBody() {
            return body;
        }

        public Request parser(Parser parser) {
            this.parser = parser;
            parserDefined = true;
            return this;
        }

        public Parser parser() {
            return parser;
        }

        public Connection.Request postDataCharset(String charset) {
            Validate.notNullParam(charset, ""charset"");
            if (!Charset.isSupported(charset)) throw new IllegalCharsetNameException(charset);
            this.postDataCharset = charset;
            return this;
        }

        public String postDataCharset() {
            return postDataCharset;
        }

        CookieManager cookieManager() {
            return cookieManager;
        }
    }

    public static class Response extends HttpConnection.Base<Connection.Response> implements Connection.Response {
        private static final int MAX_REDIRECTS = 20;
        private static final String LOCATION = ""Location"";
        private final int statusCode;
        private final String statusMessage;
        private @Nullable ByteBuffer byteData;
        private @Nullable InputStream bodyStream;
        private @Nullable HttpURLConnection conn;
        private @Nullable String charset;
        private @Nullable final String contentType;
        private boolean executed = false;
        private boolean inputStreamRead = false;
        private int numRedirects = 0;
        private final HttpConnection.Request req;

        /*
         * Matches XML content types (like text/xml, application/xhtml+xml;charset=UTF8, etc)
         */
        private static final Pattern xmlContentTypeRxp = Pattern.compile(""(application|text)/\\w*\\+?xml.*"");

        /**
         <b>Internal only! </b>Creates a dummy HttpConnection.Response, useful for testing. All actual responses
         are created from the HttpURLConnection and fields defined.
         */
        Response() {
            super();
            statusCode = 400;
            statusMessage = ""Request not made"";
            req = new Request();
            contentType = null;
        }

        static Response execute(HttpConnection.Request req) throws IOException {
            return execute(req, null);
        }

        static Response execute(HttpConnection.Request req, @Nullable Response previousResponse) throws IOException {
            synchronized (req) {
                Validate.isFalse(req.executing, ""Multiple threads were detected trying to execute the same request concurrently. Make sure to use Connection#newRequest() and do not share an executing request between threads."");
                req.executing = true;
            }
            Validate.notNullParam(req, ""req"");
            URL url = req.url();
            Validate.notNull(url, ""URL must be specified to connect"");
            String protocol = url.getProtocol();
            if (!protocol.equals(""http"") && !protocol.equals(""https""))
                throw new MalformedURLException(""Only http & https protocols supported"");
            final boolean methodHasBody = req.method().hasBody();
            final boolean hasRequestBody = req.requestBody() != null;
            if (!methodHasBody)
                Validate.isFalse(hasRequestBody, ""Cannot set a request body for HTTP method "" + req.method());

            // set up the request for execution
            String mimeBoundary = null;
            if (req.data().size() > 0 && (!methodHasBody || hasRequestBody))
                serialiseRequestUrl(req);
            else if (methodHasBody)
                mimeBoundary = setOutputContentType(req);

            long startTime = System.nanoTime();
            HttpURLConnection conn = createConnection(req);
            Response res = null;
            try {
                conn.connect();
                if (conn.getDoOutput()) {
                    OutputStream out = conn.getOutputStream();
                    try { writePost(req, out, mimeBoundary); }
                    catch (IOException e) { conn.disconnect(); throw e; }
                    finally { out.close(); }
                }

                int status = conn.getResponseCode();
                res = new Response(conn, req, previousResponse);

                // redirect if there's a location header (from 3xx, or 201 etc)
                if (res.hasHeader(LOCATION) && req.followRedirects()) {
                    if (status != HTTP_TEMP_REDIR) {
                        req.method(Method.GET); // always redirect with a get. any data param from original req are dropped.
                        req.data().clear();
                        req.requestBody(null);
                        req.removeHeader(CONTENT_TYPE);
                    }

                    String location = res.header(LOCATION);
                    Validate.notNull(location);
                    if (location.startsWith(""http:/"") && location.charAt(6) != '/') // fix broken Location: http:/temp/AAG_New/en/index.php
                        location = location.substring(6);
                    URL redir = StringUtil.resolve(req.url(), location);
                    req.url(encodeUrl(redir));

                    req.executing = false;
                    return execute(req, res);
                }
                if ((status < 200 || status >= 400) && !req.ignoreHttpErrors())
                        throw new HttpStatusException(""HTTP error fetching URL"", status, req.url().toString());

                // check that we can handle the returned content type; if not, abort before fetching it
                String contentType = res.contentType();
                if (contentType != null
                        && !req.ignoreContentType()
                        && !contentType.startsWith(""text/"")
                        && !xmlContentTypeRxp.matcher(contentType).matches()
                        )
                    throw new UnsupportedMimeTypeException(""Unhandled content type. Must be text/*, application/xml, or application/*+xml"",
                            contentType, req.url().toString());

                // switch to the XML parser if content type is xml and not parser not explicitly set
                if (contentType != null && xmlContentTypeRxp.matcher(contentType).matches()) {
                    if (!req.parserDefined) req.parser(Parser.xmlParser());
                }

                res.charset = DataUtil.getCharsetFromContentType(res.contentType); // may be null, readInputStream deals with it
                if (conn.getContentLength() != 0 && req.method() != HEAD) { // -1 means unknown, chunked. sun throws an IO exception on 500 response with no content when trying to read body
                    res.bodyStream = conn.getErrorStream() != null ? conn.getErrorStream() : conn.getInputStream();
                    Validate.notNull(res.bodyStream);
                    if (res.hasHeaderWithValue(CONTENT_ENCODING, ""gzip"")) {
                        res.bodyStream = new GZIPInputStream(res.bodyStream);
                    } else if (res.hasHeaderWithValue(CONTENT_ENCODING, ""deflate"")) {
                        res.bodyStream = new InflaterInputStream(res.bodyStream, new Inflater(true));
                    }
                    res.bodyStream = ConstrainableInputStream
                        .wrap(res.bodyStream, DataUtil.bufferSize, req.maxBodySize())
                        .timeout(startTime, req.timeout())
                    ;
                } else {
                    res.byteData = DataUtil.emptyByteBuffer();
                }
            } catch (IOException e) {
                if (res != null) res.safeClose(); // will be non-null if got to conn
                throw e;
            } finally {
                req.executing = false;
            }

            res.executed = true;
            return res;
        }

        public int statusCode() {
            return statusCode;
        }

        public String statusMessage() {
            return statusMessage;
        }

        public String charset() {
            return charset;
        }

        public Response charset(String charset) {
            this.charset = charset;
            return this;
        }

        public String contentType() {
            return contentType;
        }

        public Document parse() throws IOException {
            Validate.isTrue(executed, ""Request must be executed (with .execute(), .get(), or .post() before parsing response"");
            if (byteData != null) { // bytes have been read in to the buffer, parse that
                bodyStream = new ByteArrayInputStream(byteData.array());
                inputStreamRead = false; // ok to reparse if in bytes
            }
            Validate.isFalse(inputStreamRead, ""Input stream already read and parsed, cannot re-read."");
            Document doc = DataUtil.parseInputStream(bodyStream, charset, url.toExternalForm(), req.parser());
            doc.connection(new HttpConnection(req, this)); // because we're static, don't have the connection obj. // todo - maybe hold in the req?
            charset = doc.outputSettings().charset().name(); // update charset from meta-equiv, possibly
            inputStreamRead = true;
            safeClose();
            return doc;
        }

        private void prepareByteData() {
            Validate.isTrue(executed, ""Request must be executed (with .execute(), .get(), or .post() before getting response body"");
            if (bodyStream != null && byteData == null) {
                Validate.isFalse(inputStreamRead, ""Request has already been read (with .parse())"");
                try {
                    byteData = DataUtil.readToByteBuffer(bodyStream, req.maxBodySize());
                } catch (IOException e) {
                    throw new UncheckedIOException(e);
                } finally {
                    inputStreamRead = true;
                    safeClose();
                }
            }
        }

        public String body() {
            prepareByteData();
            Validate.notNull(byteData);
            // charset gets set from header on execute, and from meta-equiv on parse. parse may not have happened yet
            String body = (charset == null ? DataUtil.UTF_8 : Charset.forName(charset))
                .decode(byteData).toString();
            ((Buffer)byteData).rewind(); // cast to avoid covariant return type change in jdk9
            return body;
        }

        public byte[] bodyAsBytes() {
            prepareByteData();
            Validate.notNull(byteData);
            return byteData.array();
        }

        @Override
        public Connection.Response bufferUp() {
            prepareByteData();
            return this;
        }

        @Override
        public BufferedInputStream bodyStream() {
            Validate.isTrue(executed, ""Request must be executed (with .execute(), .get(), or .post() before getting response body"");
            Validate.isFalse(inputStreamRead, ""Request has already been read"");
            inputStreamRead = true;
            return ConstrainableInputStream.wrap(bodyStream, DataUtil.bufferSize, req.maxBodySize());
        }

        // set up connection defaults, and details from request
        private static HttpURLConnection createConnection(HttpConnection.Request req) throws IOException {
            Proxy proxy = req.proxy();
            final HttpURLConnection conn = (HttpURLConnection) (
                proxy == null ?
                req.url().openConnection() :
                req.url().openConnection(proxy)
            );

            conn.setRequestMethod(req.method().name());
            conn.setInstanceFollowRedirects(false); // don't rely on native redirection support
            conn.setConnectTimeout(req.timeout());
            conn.setReadTimeout(req.timeout() / 2); // gets reduced after connection is made and status is read

            if (req.sslSocketFactory() != null && conn instanceof HttpsURLConnection)
                ((HttpsURLConnection) conn).setSSLSocketFactory(req.sslSocketFactory());
            if (req.method().hasBody())
                conn.setDoOutput(true);
            CookieUtil.applyCookiesToRequest(req, conn); // from the Request key/val cookies and the Cookie Store
            for (Map.Entry<String, List<String>> header : req.multiHeaders().entrySet()) {
                for (String value : header.getValue()) {
                    conn.addRequestProperty(header.getKey(), value);
                }
            }
            return conn;
        }

        /**
         * Call on completion of stream read, to close the body (or error) stream. The connection.disconnect allows
         * keep-alives to work (as the underlying connection is actually held open, despite the name).
         */
        private void safeClose() {
            if (bodyStream != null) {
                try {
                    bodyStream.close();
                } catch (IOException e) {
                    // no-op
                } finally {
                    bodyStream = null;
                }
            }
            if (conn != null) {
                conn.disconnect();
                conn = null;
            }
        }

        // set up url, method, header, cookies
        private Response(HttpURLConnection conn, HttpConnection.Request request, @Nullable HttpConnection.Response previousResponse) throws IOException {
            this.conn = conn;
            this.req = request;
            method = Method.valueOf(conn.getRequestMethod());
            url = conn.getURL();
            statusCode = conn.getResponseCode();
            statusMessage = conn.getResponseMessage();
            contentType = conn.getContentType();

            Map<String, List<String>> resHeaders = createHeaderMap(conn);
            processResponseHeaders(resHeaders); // includes cookie key/val read during header scan
            CookieUtil.storeCookies(req, url, resHeaders); // add set cookies to cookie store

            if (previousResponse != null) { // was redirected
                // map previous response cookies into this response cookies() object
                for (Map.Entry<String, String> prevCookie : previousResponse.cookies().entrySet()) {
                    if (!hasCookie(prevCookie.getKey()))
                        cookie(prevCookie.getKey(), prevCookie.getValue());
                }
                previousResponse.safeClose();

                // enforce too many redirects:
                numRedirects = previousResponse.numRedirects + 1;
                if (numRedirects >= MAX_REDIRECTS)
                    throw new IOException(String.format(""Too many redirects occurred trying to load URL %s"", previousResponse.url()));
            }
        }

        private static LinkedHashMap<String, List<String>> createHeaderMap(HttpURLConnection conn) {
            // the default sun impl of conn.getHeaderFields() returns header values out of order
            final LinkedHashMap<String, List<String>> headers = new LinkedHashMap<>();
            int i = 0;
            while (true) {
                final String key = conn.getHeaderFieldKey(i);
                final String val = conn.getHeaderField(i);
                if (key == null && val == null)
                    break;
                i++;
                if (key == null || val == null)
                    continue; // skip http1.1 line

                if (headers.containsKey(key))
                    headers.get(key).add(val);
                else {
                    final ArrayList<String> vals = new ArrayList<>();
                    vals.add(val);
                    headers.put(key, vals);
                }
            }
            return headers;
        }

        void processResponseHeaders(Map<String, List<String>> resHeaders) {
            for (Map.Entry<String, List<String>> entry : resHeaders.entrySet()) {
                String name = entry.getKey();
                if (name == null)
                    continue; // http/1.1 line

                List<String> values = entry.getValue();
                if (name.equalsIgnoreCase(""Set-Cookie"")) {
                    for (String value : values) {
                        if (value == null)
                            continue;
                        TokenQueue cd = new TokenQueue(value);
                        String cookieName = cd.chompTo(""="").trim();
                        String cookieVal = cd.consumeTo("";"").trim();
                        // ignores path, date, domain, validateTLSCertificates et al. full details will be available in cookiestore if required
                        // name not blank, value not null
                        if (cookieName.length() > 0 && !cookies.containsKey(cookieName)) // if duplicates, only keep the first
                            cookie(cookieName, cookieVal);
                    }
                }
                for (String value : values) {
                    addHeader(name, value);
                }
            }
        }

        private @Nullable static String setOutputContentType(final Connection.Request req) {
            final String contentType = req.header(CONTENT_TYPE);
            String bound = null;
            if (contentType != null) {
                // no-op; don't add content type as already set (e.g. for requestBody())
                // todo - if content type already set, we could add charset

                // if user has set content type to multipart/form-data, auto add boundary.
                if(contentType.contains(MULTIPART_FORM_DATA) && !contentType.contains(""boundary"")) {
                    bound = DataUtil.mimeBoundary();
                    req.header(CONTENT_TYPE, MULTIPART_FORM_DATA + ""; boundary="" + bound);
                }

            }
            else if (needsMultipart(req)) {
                bound = DataUtil.mimeBoundary();
                req.header(CONTENT_TYPE, MULTIPART_FORM_DATA + ""; boundary="" + bound);
            } else {
                req.header(CONTENT_TYPE, FORM_URL_ENCODED + ""; charset="" + req.postDataCharset());
            }
            return bound;
        }

        private static void writePost(final Connection.Request req, final OutputStream outputStream, @Nullable final String boundary) throws IOException {
            final Collection<Connection.KeyVal> data = req.data();
            final BufferedWriter w = new BufferedWriter(new OutputStreamWriter(outputStream, Charset.forName(req.postDataCharset())));

            if (boundary != null) {
                // boundary will be set if we're in multipart mode
                for (Connection.KeyVal keyVal : data) {
                    w.write(""--"");
                    w.write(boundary);
                    w.write(""\r\n"");
                    w.write(""Content-Disposition: form-data; name=\"""");
                    w.write(encodeMimeName(keyVal.key())); // encodes "" to %22
                    w.write(""\"""");
                    final InputStream input = keyVal.inputStream();
                    if (input != null) {
                        w.write(""; filename=\"""");
                        w.write(encodeMimeName(keyVal.value()));
                        w.write(""\""\r\nContent-Type: "");
                        String contentType = keyVal.contentType();
                        w.write(contentType != null ? contentType : DefaultUploadType);
                        w.write(""\r\n\r\n"");
                        w.flush(); // flush
                        DataUtil.crossStreams(input, outputStream);
                        outputStream.flush();
                    } else {
                        w.write(""\r\n\r\n"");
                        w.write(keyVal.value());
                    }
                    w.write(""\r\n"");
                }
                w.write(""--"");
                w.write(boundary);
                w.write(""--"");
            } else {
                String body = req.requestBody();
                if (body != null) {
                    // data will be in query string, we're sending a plaintext body
                    w.write(body);
                }
                else {
                    // regular form data (application/x-www-form-urlencoded)
                    boolean first = true;
                    for (Connection.KeyVal keyVal : data) {
                        if (!first)
                            w.append('&');
                        else
                            first = false;

                        w.write(URLEncoder.encode(keyVal.key(), req.postDataCharset()));
                        w.write('=');
                        w.write(URLEncoder.encode(keyVal.value(), req.postDataCharset()));
                    }
                }
            }
            w.close();
        }

        // for get url reqs, serialise the data map into the url
        private static void serialiseRequestUrl(Connection.Request req) throws IOException {
            URL in = req.url();
            StringBuilder url = StringUtil.borrowBuilder();
            boolean first = true;
            // reconstitute the query, ready for appends
            url
                .append(in.getProtocol())
                .append(""://"")
                .append(in.getAuthority()) // includes host, port
                .append(in.getPath())
                .append(""?"");
            if (in.getQuery() != null) {
                url.append(in.getQuery());
                first = false;
            }
            for (Connection.KeyVal keyVal : req.data()) {
                Validate.isFalse(keyVal.hasInputStream(), ""InputStream data not supported in URL query string."");
                if (!first)
                    url.append('&');
                else
                    first = false;
                url
                    .append(URLEncoder.encode(keyVal.key(), DataUtil.defaultCharsetName))
                    .append('=')
                    .append(URLEncoder.encode(keyVal.value(), DataUtil.defaultCharsetName));
            }
            req.url(new URL(StringUtil.releaseBuilder(url)));
            req.data().clear(); // moved into url as get params
        }
    }

    private static boolean needsMultipart(Connection.Request req) {
        // multipart mode, for files. add the header if we see something with an inputstream, and return a non-null boundary
        for (Connection.KeyVal keyVal : req.data()) {
            if (keyVal.hasInputStream())
                return true;
        }
        return false;
    }

    public static class KeyVal implements Connection.KeyVal {
        private String key;
        private String value;
        private @Nullable InputStream stream;
        private @Nullable String contentType;

        public static KeyVal create(String key, String value) {
            return new KeyVal(key, value);
        }

        public static KeyVal create(String key, String filename, InputStream stream) {
            return new KeyVal(key, filename)
                .inputStream(stream);
        }

        private KeyVal(String key, String value) {
            Validate.notEmptyParam(key, ""key"");
            Validate.notNullParam(value, ""value"");
            this.key = key;
            this.value = value;
        }

        public KeyVal key(String key) {
            Validate.notEmptyParam(key, ""key"");
            this.key = key;
            return this;
        }

        public String key() {
            return key;
        }

        public KeyVal value(String value) {
            Validate.notNullParam(value, ""value"");
            this.value = value;
            return this;
        }

        public String value() {
            return value;
        }

        public KeyVal inputStream(InputStream inputStream) {
            Validate.notNullParam(value, ""inputStream"");
            this.stream = inputStream;
            return this;
        }

        public InputStream inputStream() {
            return stream;
        }

        public boolean hasInputStream() {
            return stream != null;
        }

        @Override
        public Connection.KeyVal contentType(String contentType) {
            Validate.notEmpty(contentType);
            this.contentType = contentType;
            return this;
        }

        @Override
        public String contentType() {
            return contentType;
        }

        @Override
        public String toString() {
            return key + ""="" + value;
        }
    }
}
"
jhy/jsoup,src/main/java/org/jsoup/parser/CharacterReader.java,"package org.jsoup.parser;

import org.jsoup.UncheckedIOException;
import org.jsoup.helper.Validate;

import javax.annotation.Nullable;
import java.io.IOException;
import java.io.Reader;
import java.io.StringReader;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Locale;

/**
 CharacterReader consumes tokens off a string. Used internally by jsoup. API subject to changes.
 */
public final class CharacterReader {
    static final char EOF = (char) -1;
    private static final int maxStringCacheLen = 12;
    static final int maxBufferLen = 1024 * 32; // visible for testing
    static final int readAheadLimit = (int) (maxBufferLen * 0.75); // visible for testing
    private static final int minReadAheadLen = 1024; // the minimum mark length supported. No HTML entities can be larger than this.

    private char[] charBuf;
    private Reader reader;
    private int bufLength;
    private int bufSplitPoint;
    private int bufPos;
    private int readerPos;
    private int bufMark = -1;
    private static final int stringCacheSize = 512;
    private String[] stringCache = new String[stringCacheSize]; // holds reused strings in this doc, to lessen garbage

    @Nullable private ArrayList<Integer> newlinePositions = null; // optionally track the pos() position of newlines - scans during bufferUp()
    private int lineNumberOffset = 1; // line numbers start at 1; += newlinePosition[indexof(pos)]

    public CharacterReader(Reader input, int sz) {
        Validate.notNull(input);
        Validate.isTrue(input.markSupported());
        reader = input;
        charBuf = new char[Math.min(sz, maxBufferLen)];
        bufferUp();
    }

    public CharacterReader(Reader input) {
        this(input, maxBufferLen);
    }

    public CharacterReader(String input) {
        this(new StringReader(input), input.length());
    }

    public void close() {
        if (reader == null)
            return;
        try {
            reader.close();
        } catch (IOException ignored) {
        } finally {
            reader = null;
            charBuf = null;
            stringCache = null;
        }
    }

    private boolean readFully; // if the underlying stream has been completely read, no value in further buffering
    private void bufferUp() {
        if (readFully || bufPos < bufSplitPoint)
            return;

        final int pos;
        final int offset;
        if (bufMark != -1) {
            pos = bufMark;
            offset = bufPos - bufMark;
        } else {
            pos = bufPos;
            offset = 0;
        }

        try {
            final long skipped = reader.skip(pos);
            reader.mark(maxBufferLen);
            int read = 0;
            while (read <= minReadAheadLen) {
                int thisRead = reader.read(charBuf, read, charBuf.length - read);
                if (thisRead == -1)
                    readFully = true;
                if (thisRead <= 0)
                    break;
                read += thisRead;
            }
            reader.reset();
            if (read > 0) {
                Validate.isTrue(skipped == pos); // Previously asserted that there is room in buf to skip, so this will be a WTF
                bufLength = read;
                readerPos += pos;
                bufPos = offset;
                if (bufMark != -1)
                    bufMark = 0;
                bufSplitPoint = Math.min(bufLength, readAheadLimit);
            }
        } catch (IOException e) {
            throw new UncheckedIOException(e);
        }
        scanBufferForNewlines(); // if enabled, we index newline positions for line number tracking
        lastIcSeq = null; // cache for last containsIgnoreCase(seq)
    }

    /**
     * Gets the position currently read to in the content. Starts at 0.
     * @return current position
     */
    public int pos() {
        return readerPos + bufPos;
    }

    /**
     Enables or disables line number tracking. By default, will be <b>off</b>.Tracking line numbers improves the
     legibility of parser error messages, for example. Tracking should be enabled before any content is read to be of
     use.

     @param track set tracking on|off
     @since 1.14.3
     */
    public void trackNewlines(boolean track) {
        if (track && newlinePositions == null) {
            newlinePositions = new ArrayList<>(maxBufferLen / 80); // rough guess of likely count
            scanBufferForNewlines(); // first pass when enabled; subsequently called during bufferUp
        }
        else if (!track)
            newlinePositions = null;
    }

    /**
     Check if the tracking of newlines is enabled.
     @return the current newline tracking state
     @since 1.14.3
     */
    public boolean isTrackNewlines() {
        return newlinePositions != null;
    }

    /**
     Get the current line number (that the reader has consumed to). Starts at line #1.
     @return the current line number, or 1 if line tracking is not enabled.
     @since 1.14.3
     @see #trackNewlines(boolean)
     */
    public int lineNumber() {
        return lineNumber(pos());
    }

    int lineNumber(int pos) {
        // note that this impl needs to be called before the next buffer up or line numberoffset will be wrong. if that
        // causes issues, can remove the reset of newlinepositions during buffer, at the cost of a larger tracking array
        if (!isTrackNewlines())
            return 1;

        int i = lineNumIndex(pos);
        if (i == -1)
            return lineNumberOffset; // first line
        return i + lineNumberOffset + 1;
    }

    /**
     Get the current column number (that the reader has consumed to). Starts at column #1.
     @return the current column number
     @since 1.14.3
     @see #trackNewlines(boolean)
     */
    public int columnNumber() {
        return columnNumber(pos());
    }

    int columnNumber(int pos) {
        if (!isTrackNewlines())
            return pos + 1;

        int i = lineNumIndex(pos);
        if (i == -1)
          return pos + 1;
        return pos - newlinePositions.get(i) + 1;
    }

    /**
     Get a formatted string representing the current line and cursor positions. E.g. <code>5:10</code> indicating line
     number 5 and column number 10.
     @return line:col position
     @since 1.14.3
     @see #trackNewlines(boolean)
     */
    String cursorPos() {
        return lineNumber() + "":"" + columnNumber();
    }

    private int lineNumIndex(int pos) {
        if (!isTrackNewlines()) return 0;
        int i = Collections.binarySearch(newlinePositions, pos);
        if (i < -1) i = Math.abs(i) - 2;
        return i;
    }

    /**
     Scans the buffer for newline position, and tracks their location in newlinePositions.
     */
    private void scanBufferForNewlines() {
        if (!isTrackNewlines())
            return;

        if (newlinePositions.size() > 0) {
            // work out the line number that we have read up to (as we have likely scanned past this point)
            int index = lineNumIndex(readerPos);
            if (index == -1) index = 0; // first line
            int linePos = newlinePositions.get(index);
            lineNumberOffset += index; // the num lines we've read up to
            newlinePositions.clear();
            newlinePositions.add(linePos); // roll the last read pos to first, for cursor num after buffer
        }

        for (int i = bufPos; i < bufLength; i++) {
            if (charBuf[i] == '\n')
                newlinePositions.add(1 + readerPos + i);
        }
    }

    /**
     * Tests if all the content has been read.
     * @return true if nothing left to read.
     */
    public boolean isEmpty() {
        bufferUp();
        return bufPos >= bufLength;
    }

    private boolean isEmptyNoBufferUp() {
        return bufPos >= bufLength;
    }

    /**
     * Get the char at the current position.
     * @return char
     */
    public char current() {
        bufferUp();
        return isEmptyNoBufferUp() ? EOF : charBuf[bufPos];
    }

    char consume() {
        bufferUp();
        char val = isEmptyNoBufferUp() ? EOF : charBuf[bufPos];
        bufPos++;
        return val;
    }

    /**
     Unconsume one character (bufPos--). MUST only be called directly after a consume(), and no chance of a bufferUp.
     */
    void unconsume() {
        if (bufPos < 1)
            throw new UncheckedIOException(new IOException(""WTF: No buffer left to unconsume."")); // a bug if this fires, need to trace it.

        bufPos--;
    }

    /**
     * Moves the current position by one.
     */
    public void advance() {
        bufPos++;
    }

    void mark() {
        // make sure there is enough look ahead capacity
        if (bufLength - bufPos < minReadAheadLen)
            bufSplitPoint = 0;

        bufferUp();
        bufMark = bufPos;
    }

    void unmark() {
        bufMark = -1;
    }

    void rewindToMark() {
        if (bufMark == -1)
            throw new UncheckedIOException(new IOException(""Mark invalid""));

        bufPos = bufMark;
        unmark();
    }

    /**
     * Returns the number of characters between the current position and the next instance of the input char
     * @param c scan target
     * @return offset between current position and next instance of target. -1 if not found.
     */
    int nextIndexOf(char c) {
        // doesn't handle scanning for surrogates
        bufferUp();
        for (int i = bufPos; i < bufLength; i++) {
            if (c == charBuf[i])
                return i - bufPos;
        }
        return -1;
    }

    /**
     * Returns the number of characters between the current position and the next instance of the input sequence
     *
     * @param seq scan target
     * @return offset between current position and next instance of target. -1 if not found.
     */
    int nextIndexOf(CharSequence seq) {
        bufferUp();
        // doesn't handle scanning for surrogates
        char startChar = seq.charAt(0);
        for (int offset = bufPos; offset < bufLength; offset++) {
            // scan to first instance of startchar:
            if (startChar != charBuf[offset])
                while(++offset < bufLength && startChar != charBuf[offset]) { /* empty */ }
            int i = offset + 1;
            int last = i + seq.length()-1;
            if (offset < bufLength && last <= bufLength) {
                for (int j = 1; i < last && seq.charAt(j) == charBuf[i]; i++, j++) { /* empty */ }
                if (i == last) // found full sequence
                    return offset - bufPos;
            }
        }
        return -1;
    }

    /**
     * Reads characters up to the specific char.
     * @param c the delimiter
     * @return the chars read
     */
    public String consumeTo(char c) {
        int offset = nextIndexOf(c);
        if (offset != -1) {
            String consumed = cacheString(charBuf, stringCache, bufPos, offset);
            bufPos += offset;
            return consumed;
        } else {
            return consumeToEnd();
        }
    }

    String consumeTo(String seq) {
        int offset = nextIndexOf(seq);
        if (offset != -1) {
            String consumed = cacheString(charBuf, stringCache, bufPos, offset);
            bufPos += offset;
            return consumed;
        } else if (bufLength - bufPos < seq.length()) {
            // nextIndexOf() did a bufferUp(), so if the buffer is shorter than the search string, we must be at EOF
            return consumeToEnd();
        } else {
            // the string we're looking for may be straddling a buffer boundary, so keep (length - 1) characters
            // unread in case they contain the beginning of the search string
            int endPos = bufLength - seq.length() + 1;
            String consumed = cacheString(charBuf, stringCache, bufPos, endPos - bufPos);
            bufPos = endPos;
            return consumed;
        }
    }

    /**
     * Read characters until the first of any delimiters is found.
     * @param chars delimiters to scan for
     * @return characters read up to the matched delimiter.
     */
    public String consumeToAny(final char... chars) {
        bufferUp();
        int pos = bufPos;
        final int start = pos;
        final int remaining = bufLength;
        final char[] val = charBuf;
        final int charLen = chars.length;
        int i;

        OUTER: while (pos < remaining) {
            for (i = 0; i < charLen; i++) {
                if (val[pos] == chars[i])
                    break OUTER;
            }
            pos++;
        }

        bufPos = pos;
        return pos > start ? cacheString(charBuf, stringCache, start, pos -start) : """";
    }

    String consumeToAnySorted(final char... chars) {
        bufferUp();
        int pos = bufPos;
        final int start = pos;
        final int remaining = bufLength;
        final char[] val = charBuf;

        while (pos < remaining) {
            if (Arrays.binarySearch(chars, val[pos]) >= 0)
                break;
            pos++;
        }
        bufPos = pos;
        return bufPos > start ? cacheString(charBuf, stringCache, start, pos -start) : """";
    }

    String consumeData() {
        // &, <, null
        //bufferUp(); // no need to bufferUp, just called consume()
        int pos = bufPos;
        final int start = pos;
        final int remaining = bufLength;
        final char[] val = charBuf;

        OUTER: while (pos < remaining) {
            switch (val[pos]) {
                case '&':
                case '<':
                case TokeniserState.nullChar:
                    break OUTER;
                default:
                    pos++;
            }
        }
        bufPos = pos;
        return pos > start ? cacheString(charBuf, stringCache, start, pos -start) : """";
    }

    String consumeAttributeQuoted(final boolean single) {
        // null, "" or ', &
        //bufferUp(); // no need to bufferUp, just called consume()
        int pos = bufPos;
        final int start = pos;
        final int remaining = bufLength;
        final char[] val = charBuf;

        OUTER: while (pos < remaining) {
            switch (val[pos]) {
                case '&':
                case TokeniserState.nullChar:
                    break OUTER;
                case '\'':
                    if (single) break OUTER;
                case '""':
                    if (!single) break OUTER;
                default:
                    pos++;
            }
        }
        bufPos = pos;
        return pos > start ? cacheString(charBuf, stringCache, start, pos -start) : """";
    }


    String consumeRawData() {
        // <, null
        //bufferUp(); // no need to bufferUp, just called consume()
        int pos = bufPos;
        final int start = pos;
        final int remaining = bufLength;
        final char[] val = charBuf;

        OUTER: while (pos < remaining) {
            switch (val[pos]) {
                case '<':
                case TokeniserState.nullChar:
                    break OUTER;
                default:
                    pos++;
            }
        }
        bufPos = pos;
        return pos > start ? cacheString(charBuf, stringCache, start, pos -start) : """";
    }

    String consumeTagName() {
        // '\t', '\n', '\r', '\f', ' ', '/', '>'
        // NOTE: out of spec, added '<' to fix common author bugs; does not stop and append on nullChar but eats
        bufferUp();
        int pos = bufPos;
        final int start = pos;
        final int remaining = bufLength;
        final char[] val = charBuf;

        OUTER: while (pos < remaining) {
            switch (val[pos]) {
                case '\t':
                case '\n':
                case '\r':
                case '\f':
                case ' ':
                case '/':
                case '>':
                case '<':
                    break OUTER;
            }
            pos++;
        }

        bufPos = pos;
        return pos > start ? cacheString(charBuf, stringCache, start, pos -start) : """";
    }

    String consumeToEnd() {
        bufferUp();
        String data = cacheString(charBuf, stringCache, bufPos, bufLength - bufPos);
        bufPos = bufLength;
        return data;
    }

    String consumeLetterSequence() {
        bufferUp();
        int start = bufPos;
        while (bufPos < bufLength) {
            char c = charBuf[bufPos];
            if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') || Character.isLetter(c))
                bufPos++;
            else
                break;
        }

        return cacheString(charBuf, stringCache, start, bufPos - start);
    }

    String consumeLetterThenDigitSequence() {
        bufferUp();
        int start = bufPos;
        while (bufPos < bufLength) {
            char c = charBuf[bufPos];
            if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') || Character.isLetter(c))
                bufPos++;
            else
                break;
        }
        while (!isEmptyNoBufferUp()) {
            char c = charBuf[bufPos];
            if (c >= '0' && c <= '9')
                bufPos++;
            else
                break;
        }

        return cacheString(charBuf, stringCache, start, bufPos - start);
    }

    String consumeHexSequence() {
        bufferUp();
        int start = bufPos;
        while (bufPos < bufLength) {
            char c = charBuf[bufPos];
            if ((c >= '0' && c <= '9') || (c >= 'A' && c <= 'F') || (c >= 'a' && c <= 'f'))
                bufPos++;
            else
                break;
        }
        return cacheString(charBuf, stringCache, start, bufPos - start);
    }

    String consumeDigitSequence() {
        bufferUp();
        int start = bufPos;
        while (bufPos < bufLength) {
            char c = charBuf[bufPos];
            if (c >= '0' && c <= '9')
                bufPos++;
            else
                break;
        }
        return cacheString(charBuf, stringCache, start, bufPos - start);
    }

    boolean matches(char c) {
        return !isEmpty() && charBuf[bufPos] == c;

    }

    boolean matches(String seq) {
        bufferUp();
        int scanLength = seq.length();
        if (scanLength > bufLength - bufPos)
            return false;

        for (int offset = 0; offset < scanLength; offset++)
            if (seq.charAt(offset) != charBuf[bufPos +offset])
                return false;
        return true;
    }

    boolean matchesIgnoreCase(String seq) {
        bufferUp();
        int scanLength = seq.length();
        if (scanLength > bufLength - bufPos)
            return false;

        for (int offset = 0; offset < scanLength; offset++) {
            char upScan = Character.toUpperCase(seq.charAt(offset));
            char upTarget = Character.toUpperCase(charBuf[bufPos + offset]);
            if (upScan != upTarget)
                return false;
        }
        return true;
    }

    boolean matchesAny(char... seq) {
        if (isEmpty())
            return false;

        bufferUp();
        char c = charBuf[bufPos];
        for (char seek : seq) {
            if (seek == c)
                return true;
        }
        return false;
    }

    boolean matchesAnySorted(char[] seq) {
        bufferUp();
        return !isEmpty() && Arrays.binarySearch(seq, charBuf[bufPos]) >= 0;
    }

    boolean matchesLetter() {
        if (isEmpty())
            return false;
        char c = charBuf[bufPos];
        return (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') || Character.isLetter(c);
    }

    /**
     Checks if the current pos matches an ascii alpha (A-Z a-z) per https://infra.spec.whatwg.org/#ascii-alpha
     @return if it matches or not
     */
    boolean matchesAsciiAlpha() {
        if (isEmpty())
            return false;
        char c = charBuf[bufPos];
        return (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z');
    }

    boolean matchesDigit() {
        if (isEmpty())
            return false;
        char c = charBuf[bufPos];
        return (c >= '0' && c <= '9');
    }

    boolean matchConsume(String seq) {
        bufferUp();
        if (matches(seq)) {
            bufPos += seq.length();
            return true;
        } else {
            return false;
        }
    }

    boolean matchConsumeIgnoreCase(String seq) {
        if (matchesIgnoreCase(seq)) {
            bufPos += seq.length();
            return true;
        } else {
            return false;
        }
    }

    // we maintain a cache of the previously scanned sequence, and return that if applicable on repeated scans.
    // that improves the situation where there is a sequence of <p<p<p<p<p<p<p...</title> and we're bashing on the <p
    // looking for the </title>. Resets in bufferUp()
    @Nullable private String lastIcSeq; // scan cache
    private int lastIcIndex; // nearest found indexOf

    /** Used to check presence of </title>, </style> when we're in RCData and see a <xxx. Only finds consistent case. */
    boolean containsIgnoreCase(String seq) {
        if (seq.equals(lastIcSeq)) {
            if (lastIcIndex == -1) return false;
            if (lastIcIndex >= bufPos) return true;
        }
        lastIcSeq = seq;

        String loScan = seq.toLowerCase(Locale.ENGLISH);
        int lo = nextIndexOf(loScan);
        if (lo > -1) {
            lastIcIndex = bufPos + lo; return true;
        }

        String hiScan = seq.toUpperCase(Locale.ENGLISH);
        int hi = nextIndexOf(hiScan);
        boolean found = hi > -1;
        lastIcIndex = found ? bufPos + hi : -1; // we don't care about finding the nearest, just that buf contains
        return found;
    }

    @Override
    public String toString() {
        if (bufLength - bufPos < 0)
            return """";
        return new String(charBuf, bufPos, bufLength - bufPos);
    }

    /**
     * Caches short strings, as a flyweight pattern, to reduce GC load. Just for this doc, to prevent leaks.
     * <p />
     * Simplistic, and on hash collisions just falls back to creating a new string, vs a full HashMap with Entry list.
     * That saves both having to create objects as hash keys, and running through the entry list, at the expense of
     * some more duplicates.
     */
    private static String cacheString(final char[] charBuf, final String[] stringCache, final int start, final int count) {
        // limit (no cache):
        if (count > maxStringCacheLen)
            return new String(charBuf, start, count);
        if (count < 1)
            return """";

        // calculate hash:
        int hash = 0;
        for (int i = 0; i < count; i++) {
            hash = 31 * hash + charBuf[start + i];
        }

        // get from cache
        final int index = hash & stringCacheSize - 1;
        String cached = stringCache[index];

        if (cached != null && rangeEquals(charBuf, start, count, cached)) // positive hit
            return cached;
        else {
            cached = new String(charBuf, start, count);
            stringCache[index] = cached; // add or replace, assuming most recently used are most likely to recur next
        }

        return cached;
    }

    /**
     * Check if the value of the provided range equals the string.
     */
    static boolean rangeEquals(final char[] charBuf, final int start, int count, final String cached) {
        if (count == cached.length()) {
            int i = start;
            int j = 0;
            while (count-- != 0) {
                if (charBuf[i++] != cached.charAt(j++))
                    return false;
            }
            return true;
        }
        return false;
    }

    // just used for testing
    boolean rangeEquals(final int start, final int count, final String cached) {
        return rangeEquals(charBuf, start, count, cached);
    }
}
"
jhy/jsoup,src/test/java/org/jsoup/helper/DataUtilTest.java,"package org.jsoup.helper;

import org.jsoup.Jsoup;
import org.jsoup.integration.ParseTest;
import org.jsoup.nodes.Document;
import org.jsoup.parser.Parser;
import org.junit.jupiter.api.Test;

import java.io.*;
import java.nio.ByteBuffer;
import java.nio.charset.Charset;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;

import static org.jsoup.integration.ParseTest.getFile;
import static org.junit.jupiter.api.Assertions.*;

public class DataUtilTest {
    @Test
    public void testCharset() {
        assertEquals(""utf-8"", DataUtil.getCharsetFromContentType(""text/html;charset=utf-8 ""));
        assertEquals(""UTF-8"", DataUtil.getCharsetFromContentType(""text/html; charset=UTF-8""));
        assertEquals(""ISO-8859-1"", DataUtil.getCharsetFromContentType(""text/html; charset=ISO-8859-1""));
        assertNull(DataUtil.getCharsetFromContentType(""text/html""));
        assertNull(DataUtil.getCharsetFromContentType(null));
        assertNull(DataUtil.getCharsetFromContentType(""text/html;charset=Unknown""));
    }

    @Test
    public void testQuotedCharset() {
        assertEquals(""utf-8"", DataUtil.getCharsetFromContentType(""text/html; charset=\""utf-8\""""));
        assertEquals(""UTF-8"", DataUtil.getCharsetFromContentType(""text/html;charset=\""UTF-8\""""));
        assertEquals(""ISO-8859-1"", DataUtil.getCharsetFromContentType(""text/html; charset=\""ISO-8859-1\""""));
        assertNull(DataUtil.getCharsetFromContentType(""text/html; charset=\""Unsupported\""""));
        assertEquals(""UTF-8"", DataUtil.getCharsetFromContentType(""text/html; charset='UTF-8'""));
    }

    private InputStream stream(String data) {
        return new ByteArrayInputStream(data.getBytes(StandardCharsets.UTF_8));
    }

    private InputStream stream(String data, String charset) {
        return new ByteArrayInputStream(data.getBytes(Charset.forName(charset)));
    }

    @Test
    public void discardsSpuriousByteOrderMark() throws IOException {
        String html = ""\uFEFF<html><head><title>One</title></head><body>Two</body></html>"";
        Document doc = DataUtil.parseInputStream(stream(html), ""UTF-8"", ""http://foo.com/"", Parser.htmlParser());
        assertEquals(""One"", doc.head().text());
    }

    @Test
    public void discardsSpuriousByteOrderMarkWhenNoCharsetSet() throws IOException {
        String html = ""\uFEFF<html><head><title>One</title></head><body>Two</body></html>"";
        Document doc = DataUtil.parseInputStream(stream(html), null, ""http://foo.com/"", Parser.htmlParser());
        assertEquals(""One"", doc.head().text());
        assertEquals(""UTF-8"", doc.outputSettings().charset().displayName());
    }

    @Test
    public void shouldNotThrowExceptionOnEmptyCharset() {
        assertNull(DataUtil.getCharsetFromContentType(""text/html; charset=""));
        assertNull(DataUtil.getCharsetFromContentType(""text/html; charset=;""));
    }

    @Test
    public void shouldSelectFirstCharsetOnWeirdMultileCharsetsInMetaTags() {
        assertEquals(""ISO-8859-1"", DataUtil.getCharsetFromContentType(""text/html; charset=ISO-8859-1, charset=1251""));
    }

    @Test
    public void shouldCorrectCharsetForDuplicateCharsetString() {
        assertEquals(""iso-8859-1"", DataUtil.getCharsetFromContentType(""text/html; charset=charset=iso-8859-1""));
    }

    @Test
    public void shouldReturnNullForIllegalCharsetNames() {
        assertNull(DataUtil.getCharsetFromContentType(""text/html; charset=$HJKDF¬ß$/(""));
    }

    @Test
    public void generatesMimeBoundaries() {
        String m1 = DataUtil.mimeBoundary();
        String m2 = DataUtil.mimeBoundary();

        assertEquals(DataUtil.boundaryLength, m1.length());
        assertEquals(DataUtil.boundaryLength, m2.length());
        assertNotSame(m1, m2);
    }

    @Test
    public void wrongMetaCharsetFallback() throws IOException {
        String html = ""<html><head><meta charset=iso-8></head><body></body></html>"";

        Document doc = DataUtil.parseInputStream(stream(html), null, ""http://example.com"", Parser.htmlParser());

        final String expected = ""<html>\n"" +
                "" <head>\n"" +
                ""  <meta charset=\""iso-8\"">\n"" +
                "" </head>\n"" +
                "" <body></body>\n"" +
                ""</html>"";

        assertEquals(expected, doc.toString());
    }

    @Test
    public void secondMetaElementWithContentTypeContainsCharsetParameter() throws Exception {
        String html = ""<html><head>"" +
                ""<meta http-equiv=\""Content-Type\"" content=\""text/html\"">"" +
                ""<meta http-equiv=\""Content-Type\"" content=\""text/html; charset=euc-kr\"">"" +
                ""</head><body>ÌïúÍµ≠Ïñ¥</body></html>"";

        Document doc = DataUtil.parseInputStream(stream(html, ""euc-kr""), null, ""http://example.com"", Parser.htmlParser());

        assertEquals(""ÌïúÍµ≠Ïñ¥"", doc.body().text());
    }

    @Test
    public void firstMetaElementWithCharsetShouldBeUsedForDecoding() throws Exception {
        String html = ""<html><head>"" +
                ""<meta http-equiv=\""Content-Type\"" content=\""text/html; charset=iso-8859-1\"">"" +
                ""<meta http-equiv=\""Content-Type\"" content=\""text/html; charset=koi8-u\"">"" +
                ""</head><body>√úbergr√∂√üentr√§ger</body></html>"";

        Document doc = DataUtil.parseInputStream(stream(html, ""iso-8859-1""), null, ""http://example.com"", Parser.htmlParser());

        assertEquals(""√úbergr√∂√üentr√§ger"", doc.body().text());
    }

    @Test
    public void parseSequenceInputStream() throws IOException {
        // https://github.com/jhy/jsoup/pull/1671
        File in = getFile(""/htmltests/medium.html"");
        String fileContent = new String(Files.readAllBytes(in.toPath()));
        int halfLength = fileContent.length() / 2;
        String firstPart = fileContent.substring(0, halfLength);
        String secondPart = fileContent.substring(halfLength);
        SequenceInputStream sequenceStream = new SequenceInputStream(
                stream(firstPart),
                stream(secondPart)
        );
        Document doc = DataUtil.parseInputStream(sequenceStream, null, """", Parser.htmlParser());
        assertEquals(fileContent, doc.outerHtml());
    }

    @Test
    public void supportsBOMinFiles() throws IOException {
        // test files from http://www.i18nl10n.com/korean/utftest/
        File in = getFile(""/bomtests/bom_utf16be.html"");
        Document doc = Jsoup.parse(in, null, ""http://example.com"");
        assertTrue(doc.title().contains(""UTF-16BE""));
        assertTrue(doc.text().contains(""Í∞ÄÍ∞ÅÍ∞ÇÍ∞ÉÍ∞ÑÍ∞Ö""));

        in = getFile(""/bomtests/bom_utf16le.html"");
        doc = Jsoup.parse(in, null, ""http://example.com"");
        assertTrue(doc.title().contains(""UTF-16LE""));
        assertTrue(doc.text().contains(""Í∞ÄÍ∞ÅÍ∞ÇÍ∞ÉÍ∞ÑÍ∞Ö""));

        in = getFile(""/bomtests/bom_utf32be.html"");
        doc = Jsoup.parse(in, null, ""http://example.com"");
        assertTrue(doc.title().contains(""UTF-32BE""));
        assertTrue(doc.text().contains(""Í∞ÄÍ∞ÅÍ∞ÇÍ∞ÉÍ∞ÑÍ∞Ö""));

        in = getFile(""/bomtests/bom_utf32le.html"");
        doc = Jsoup.parse(in, null, ""http://example.com"");
        assertTrue(doc.title().contains(""UTF-32LE""));
        assertTrue(doc.text().contains(""Í∞ÄÍ∞ÅÍ∞ÇÍ∞ÉÍ∞ÑÍ∞Ö""));
    }

    @Test
    public void supportsUTF8BOM() throws IOException {
        File in = getFile(""/bomtests/bom_utf8.html"");
        Document doc = Jsoup.parse(in, null, ""http://example.com"");
        assertEquals(""OK"", doc.head().select(""title"").text());
    }

    @Test
    public void noExtraNULLBytes() throws IOException {
    	final byte[] b = ""<html><head><meta charset=\""UTF-8\""></head><body><div><u>√º</u>√º</div></body></html>"".getBytes(StandardCharsets.UTF_8);
    	
    	Document doc = Jsoup.parse(new ByteArrayInputStream(b), null, """");
    	assertFalse( doc.outerHtml().contains(""\u0000"") );
    }

    @Test
    public void supportsZippedUTF8BOM() throws IOException {
        File in = getFile(""/bomtests/bom_utf8.html.gz"");
        Document doc = Jsoup.parse(in, null, ""http://example.com"");
        assertEquals(""OK"", doc.head().select(""title"").text());
        assertEquals(""There is a UTF8 BOM at the top (before the XML decl). If not read correctly, will look like a non-joining space."", doc.body().text());
    }

    @Test
    public void supportsXmlCharsetDeclaration() throws IOException {
        String encoding = ""iso-8859-1"";
        InputStream soup = new ByteArrayInputStream((
                ""<?xml version=\""1.0\"" encoding=\""iso-8859-1\""?>"" +
                        ""<!DOCTYPE html PUBLIC \""-//W3C//DTD XHTML 1.0 Strict//EN\"" \""http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd\"">"" +
                        ""<html xmlns=\""http://www.w3.org/1999/xhtml\"" lang=\""en\"" xml:lang=\""en\"">Hell√∂ W√∂rld!</html>""
        ).getBytes(Charset.forName(encoding)));

        Document doc = Jsoup.parse(soup, null, """");
        assertEquals(""Hell√∂ W√∂rld!"", doc.body().text());
    }


    @Test
    public void lLoadsGzipFile() throws IOException {
        File in = getFile(""/htmltests/gzip.html.gz"");
        Document doc = Jsoup.parse(in, null);
        assertEquals(""Gzip test"", doc.title());
        assertEquals(""This is a gzipped HTML file."", doc.selectFirst(""p"").text());
    }

    @Test
    public void loadsZGzipFile() throws IOException {
        // compressed on win, with z suffix
        File in = getFile(""/htmltests/gzip.html.z"");
        Document doc = Jsoup.parse(in, null);
        assertEquals(""Gzip test"", doc.title());
        assertEquals(""This is a gzipped HTML file."", doc.selectFirst(""p"").text());
    }

    @Test
    public void handlesFakeGzipFile() throws IOException {
        File in = getFile(""/htmltests/fake-gzip.html.gz"");
        Document doc = Jsoup.parse(in, null);
        assertEquals(""This is not gzipped"", doc.title());
        assertEquals(""And should still be readable."", doc.selectFirst(""p"").text());
    }

    // an input stream to give a range of output sizes, that changes on each read
    static class VaryingReadInputStream extends InputStream {
        final InputStream in;
        int stride = 0;

        VaryingReadInputStream(InputStream in) {
            this.in = in;
        }

        public int read() throws IOException {
            return in.read();
        }

        public int read(byte[] b) throws IOException {
            return in.read(b, 0, Math.min(b.length, ++stride));
        }

        public int read(byte[] b, int off, int len) throws IOException {
            return in.read(b, off, Math.min(len, ++stride));
        }
    }

    @Test
    void handlesChunkedInputStream() throws IOException {
        File inputFile = ParseTest.getFile(""/htmltests/large.html"");
        String input = ParseTest.getFileAsString(inputFile);
        VaryingReadInputStream stream = new VaryingReadInputStream(ParseTest.inputStreamFrom(input));

        Document expected = Jsoup.parse(input, ""https://example.com"");
        Document doc = Jsoup.parse(stream, null, ""https://example.com"");
        assertTrue(doc.hasSameValue(expected));
    }

    @Test
    void handlesUnlimitedRead() throws IOException {
        File inputFile = ParseTest.getFile(""/htmltests/large.html"");
        String input = ParseTest.getFileAsString(inputFile);
        VaryingReadInputStream stream = new VaryingReadInputStream(ParseTest.inputStreamFrom(input));

        ByteBuffer byteBuffer = DataUtil.readToByteBuffer(stream, 0);
        String read = new String(byteBuffer.array());

        assertEquals(input, read);
    }
}
"
jhy/jsoup,src/main/java/org/jsoup/Jsoup.java,"package org.jsoup;

import org.jsoup.helper.DataUtil;
import org.jsoup.helper.HttpConnection;
import org.jsoup.nodes.Document;
import org.jsoup.parser.Parser;
import org.jsoup.safety.Cleaner;
import org.jsoup.safety.Safelist;

import javax.annotation.Nullable;
import javax.annotation.WillClose;

import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.net.URL;

/**
 The core public access point to the jsoup functionality.

 @author Jonathan Hedley */

public class Jsoup {
    private Jsoup() {}

    /**
     Parse HTML into a Document. The parser will make a sensible, balanced document tree out of any HTML.

     @param html    HTML to parse
     @param baseUri The URL where the HTML was retrieved from. Used to resolve relative URLs to absolute URLs, that occur
     before the HTML declares a {@code <base href>} tag.
     @return sane HTML
     */
    public static Document parse(String html, String baseUri) {
        return Parser.parse(html, baseUri);
    }

    /**
     Parse HTML into a Document, using the provided Parser. You can provide an alternate parser, such as a simple XML
     (non-HTML) parser.

     @param html    HTML to parse
     @param baseUri The URL where the HTML was retrieved from. Used to resolve relative URLs to absolute URLs, that occur
     before the HTML declares a {@code <base href>} tag.
     @param parser alternate {@link Parser#xmlParser() parser} to use.
     @return sane HTML
     */
    public static Document parse(String html, String baseUri, Parser parser) {
        return parser.parseInput(html, baseUri);
    }

    /**
     Parse HTML into a Document, using the provided Parser. You can provide an alternate parser, such as a simple XML
     (non-HTML) parser.  As no base URI is specified, absolute URL resolution, if required, relies on the HTML including
     a {@code <base href>} tag.

     @param html    HTML to parse
     before the HTML declares a {@code <base href>} tag.
     @param parser alternate {@link Parser#xmlParser() parser} to use.
     @return sane HTML
     */
    public static Document parse(String html, Parser parser) {
        return parser.parseInput(html, """");
    }

    /**
     Parse HTML into a Document. As no base URI is specified, absolute URL resolution, if required, relies on the HTML
     including a {@code <base href>} tag.

     @param html HTML to parse
     @return sane HTML

     @see #parse(String, String)
     */
    public static Document parse(String html) {
        return Parser.parse(html, """");
    }

    /**
     * Creates a new {@link Connection} (session), with the defined request URL. Use to fetch and parse a HTML page.
     * <p>
     * Use examples:
     * <ul>
     *  <li><code>Document doc = Jsoup.connect(""http://example.com"").userAgent(""Mozilla"").data(""name"", ""jsoup"").get();</code></li>
     *  <li><code>Document doc = Jsoup.connect(""http://example.com"").cookie(""auth"", ""token"").post();</code></li>
     * </ul>
     * @param url URL to connect to. The protocol must be {@code http} or {@code https}.
     * @return the connection. You can add data, cookies, and headers; set the user-agent, referrer, method; and then execute.
     * @see #newSession()
     * @see Connection#newRequest()
     */
    public static Connection connect(String url) {
        return HttpConnection.connect(url);
    }

    /**
     Creates a new {@link Connection} to use as a session. Connection settings (user-agent, timeouts, URL, etc), and
     cookies will be maintained for the session. Use examples:
<pre><code>
Connection session = Jsoup.newSession()
     .timeout(20 * 1000)
     .userAgent(""FooBar 2000"");

Document doc1 = session.newRequest()
     .url(""https://jsoup.org/"").data(""ref"", ""example"")
     .get();
Document doc2 = session.newRequest()
     .url(""https://en.wikipedia.org/wiki/Main_Page"")
     .get();
Connection con3 = session.newRequest();
</code></pre>

     <p>For multi-threaded requests, it is safe to use this session between threads, but take care to call {@link
    Connection#newRequest()} per request and not share that instance between threads when executing or parsing.</p>

     @return a connection
     @since 1.14.1
     */
    public static Connection newSession() {
        return new HttpConnection();
    }

    /**
     Parse the contents of a file as HTML.

     @param file          file to load HTML from. Supports gzipped files (ending in .z or .gz).
     @param charsetName (optional) character set of file contents. Set to {@code null} to determine from {@code http-equiv} meta tag, if
     present, or fall back to {@code UTF-8} (which is often safe to do).
     @param baseUri     The URL where the HTML was retrieved from, to resolve relative links against.
     @return sane HTML

     @throws IOException if the file could not be found, or read, or if the charsetName is invalid.
     */
    public static Document parse(File file, @Nullable String charsetName, String baseUri) throws IOException {
        return DataUtil.load(file, charsetName, baseUri);
    }

    /**
     Parse the contents of a file as HTML. The location of the file is used as the base URI to qualify relative URLs.

     @param file        file to load HTML from. Supports gzipped files (ending in .z or .gz).
     @param charsetName (optional) character set of file contents. Set to {@code null} to determine from {@code http-equiv} meta tag, if
     present, or fall back to {@code UTF-8} (which is often safe to do).
     @return sane HTML

     @throws IOException if the file could not be found, or read, or if the charsetName is invalid.
     @see #parse(File, String, String) parse(file, charset, baseUri)
     */
    public static Document parse(File file, @Nullable String charsetName) throws IOException {
        return DataUtil.load(file, charsetName, file.getAbsolutePath());
    }

    /**
     Parse the contents of a file as HTML. The location of the file is used as the base URI to qualify relative URLs.
     The charset used to read the file will be determined by the byte-order-mark (BOM), or a {@code <meta charset>} tag,
     or if neither is present, will be {@code UTF-8}.

     <p>This is the equivalent of calling {@link #parse(File, String) parse(file, null)}</p>

     @param file the file to load HTML from. Supports gzipped files (ending in .z or .gz).
     @return sane HTML
     @throws IOException if the file could not be found or read.
     @see #parse(File, String, String) parse(file, charset, baseUri)
     @since 1.15.1
     */
    public static Document parse(File file) throws IOException {
        return DataUtil.load(file, null, file.getAbsolutePath());
    }

    /**
     Parse the contents of a file as HTML.

     @param file          file to load HTML from. Supports gzipped files (ending in .z or .gz).
     @param charsetName (optional) character set of file contents. Set to {@code null} to determine from {@code http-equiv} meta tag, if
     present, or fall back to {@code UTF-8} (which is often safe to do).
     @param baseUri     The URL where the HTML was retrieved from, to resolve relative links against.
     @param parser alternate {@link Parser#xmlParser() parser} to use.
     @return sane HTML

     @throws IOException if the file could not be found, or read, or if the charsetName is invalid.
     @since 1.14.2
     */
    public static Document parse(File file, @Nullable String charsetName, String baseUri, Parser parser) throws IOException {
        return DataUtil.load(file, charsetName, baseUri, parser);
    }

     /**
     Read an input stream, and parse it to a Document.

     @param in          input stream to read. The stream will be closed after reading.
     @param charsetName (optional) character set of file contents. Set to {@code null} to determine from {@code http-equiv} meta tag, if
     present, or fall back to {@code UTF-8} (which is often safe to do).
     @param baseUri     The URL where the HTML was retrieved from, to resolve relative links against.
     @return sane HTML

     @throws IOException if the file could not be found, or read, or if the charsetName is invalid.
     */
    public static Document parse(@WillClose InputStream in, @Nullable String charsetName, String baseUri) throws IOException {
        return DataUtil.load(in, charsetName, baseUri);
    }

    /**
     Read an input stream, and parse it to a Document. You can provide an alternate parser, such as a simple XML
     (non-HTML) parser.

     @param in          input stream to read. Make sure to close it after parsing.
     @param charsetName (optional) character set of file contents. Set to {@code null} to determine from {@code http-equiv} meta tag, if
     present, or fall back to {@code UTF-8} (which is often safe to do).
     @param baseUri     The URL where the HTML was retrieved from, to resolve relative links against.
     @param parser alternate {@link Parser#xmlParser() parser} to use.
     @return sane HTML

     @throws IOException if the file could not be found, or read, or if the charsetName is invalid.
     */
    public static Document parse(InputStream in, @Nullable String charsetName, String baseUri, Parser parser) throws IOException {
        return DataUtil.load(in, charsetName, baseUri, parser);
    }

    /**
     Parse a fragment of HTML, with the assumption that it forms the {@code body} of the HTML.

     @param bodyHtml body HTML fragment
     @param baseUri  URL to resolve relative URLs against.
     @return sane HTML document

     @see Document#body()
     */
    public static Document parseBodyFragment(String bodyHtml, String baseUri) {
        return Parser.parseBodyFragment(bodyHtml, baseUri);
    }

    /**
     Parse a fragment of HTML, with the assumption that it forms the {@code body} of the HTML.

     @param bodyHtml body HTML fragment
     @return sane HTML document

     @see Document#body()
     */
    public static Document parseBodyFragment(String bodyHtml) {
        return Parser.parseBodyFragment(bodyHtml, """");
    }

    /**
     Fetch a URL, and parse it as HTML. Provided for compatibility; in most cases use {@link #connect(String)} instead.
     <p>
     The encoding character set is determined by the content-type header or http-equiv meta tag, or falls back to {@code UTF-8}.

     @param url           URL to fetch (with a GET). The protocol must be {@code http} or {@code https}.
     @param timeoutMillis Connection and read timeout, in milliseconds. If exceeded, IOException is thrown.
     @return The parsed HTML.

     @throws java.net.MalformedURLException if the request URL is not a HTTP or HTTPS URL, or is otherwise malformed
     @throws HttpStatusException if the response is not OK and HTTP response errors are not ignored
     @throws UnsupportedMimeTypeException if the response mime type is not supported and those errors are not ignored
     @throws java.net.SocketTimeoutException if the connection times out
     @throws IOException if a connection or read error occurs

     @see #connect(String)
     */
    public static Document parse(URL url, int timeoutMillis) throws IOException {
        Connection con = HttpConnection.connect(url);
        con.timeout(timeoutMillis);
        return con.get();
    }

    /**
     Get safe HTML from untrusted input HTML, by parsing input HTML and filtering it through an allow-list of safe
     tags and attributes.

     @param bodyHtml  input untrusted HTML (body fragment)
     @param baseUri   URL to resolve relative URLs against
     @param safelist  list of permitted HTML elements
     @return safe HTML (body fragment)

     @see Cleaner#clean(Document)
     */
    public static String clean(String bodyHtml, String baseUri, Safelist safelist) {
        Document dirty = parseBodyFragment(bodyHtml, baseUri);
        Cleaner cleaner = new Cleaner(safelist);
        Document clean = cleaner.clean(dirty);
        return clean.body().html();
    }

    /**
     Get safe HTML from untrusted input HTML, by parsing input HTML and filtering it through a safe-list of permitted
     tags and attributes.

     <p>Note that as this method does not take a base href URL to resolve attributes with relative URLs against, those
     URLs will be removed, unless the input HTML contains a {@code <base href> tag}. If you wish to preserve those, use
     the {@link Jsoup#clean(String html, String baseHref, Safelist)} method instead, and enable
     {@link Safelist#preserveRelativeLinks(boolean)}.</p>

     @param bodyHtml input untrusted HTML (body fragment)
     @param safelist list of permitted HTML elements
     @return safe HTML (body fragment)
     @see Cleaner#clean(Document)
     */
    public static String clean(String bodyHtml, Safelist safelist) {
        return clean(bodyHtml, """", safelist);
    }

    /**
     * Get safe HTML from untrusted input HTML, by parsing input HTML and filtering it through a safe-list of
     * permitted tags and attributes.
     * <p>The HTML is treated as a body fragment; it's expected the cleaned HTML will be used within the body of an
     * existing document. If you want to clean full documents, use {@link Cleaner#clean(Document)} instead, and add
     * structural tags (<code>html, head, body</code> etc) to the safelist.
     *
     * @param bodyHtml input untrusted HTML (body fragment)
     * @param baseUri URL to resolve relative URLs against
     * @param safelist list of permitted HTML elements
     * @param outputSettings document output settings; use to control pretty-printing and entity escape modes
     * @return safe HTML (body fragment)
     * @see Cleaner#clean(Document)
     */
    public static String clean(String bodyHtml, String baseUri, Safelist safelist, Document.OutputSettings outputSettings) {
        Document dirty = parseBodyFragment(bodyHtml, baseUri);
        Cleaner cleaner = new Cleaner(safelist);
        Document clean = cleaner.clean(dirty);
        clean.outputSettings(outputSettings);
        return clean.body().html();
    }

    /**
     Test if the input body HTML has only tags and attributes allowed by the Safelist. Useful for form validation.
     <p>The input HTML should still be run through the cleaner to set up enforced attributes, and to tidy the output.
     <p>Assumes the HTML is a body fragment (i.e. will be used in an existing HTML document body.)
     @param bodyHtml HTML to test
     @param safelist safelist to test against
     @return true if no tags or attributes were removed; false otherwise
     @see #clean(String, Safelist)
     */
    public static boolean isValid(String bodyHtml, Safelist safelist) {
        return new Cleaner(safelist).isValidBodyHtml(bodyHtml);
    }
}
"
jhy/jsoup,src/test/java/org/jsoup/integration/SafelistExtensionTest.java,"package org.jsoup.integration;

import org.jsoup.Jsoup;
import org.jsoup.TextUtil;
import org.jsoup.nodes.Attribute;
import org.jsoup.nodes.Element;
import org.jsoup.safety.Safelist;
import org.junit.jupiter.api.Test;

import static org.junit.jupiter.api.Assertions.assertEquals;

/**
 Check that we can extend Safelist methods
 */
public class SafelistExtensionTest {
    @Test public void canCustomizeSafeTests() {
        OpenSafelist openSafelist = new OpenSafelist(Safelist.relaxed());
        Safelist safelist = Safelist.relaxed();

        String html = ""<p><opentag openattr>Hello</opentag></p>"";

        String openClean = Jsoup.clean(html, openSafelist);
        String clean = Jsoup.clean(html, safelist);

        assertEquals(""<p><opentag openattr=\""\"">Hello</opentag></p>"", TextUtil.stripNewlines(openClean));
        assertEquals(""<p>Hello</p>"", clean);
    }

    // passes tags and attributes starting with ""open""
    private static class OpenSafelist extends Safelist {
        public OpenSafelist(Safelist safelist) {
            super(safelist);
        }

        @Override
        protected boolean isSafeAttribute(String tagName, Element el, Attribute attr) {
            if (attr.getKey().startsWith(""open""))
                return true;
            return super.isSafeAttribute(tagName, el, attr);
        }

        @Override
        protected boolean isSafeTag(String tag) {
            if (tag.startsWith(""open""))
                return true;
            return super.isSafeTag(tag);
        }
    }
}
"
jhy/jsoup,src/main/java/org/jsoup/select/NodeVisitor.java,"package org.jsoup.select;

import org.jsoup.nodes.Element;
import org.jsoup.nodes.Node;

/**
 * Node visitor interface. Provide an implementing class to {@link NodeTraversor} to iterate through nodes.
 * <p>
 * This interface provides two methods, {@code head} and {@code tail}. The head method is called when the node is first
 * seen, and the tail method when all of the node's children have been visited. As an example, {@code head} can be used to
 * emit a start tag for a node, and {@code tail} to create the end tag.
 * </p>
 */
public interface NodeVisitor {
    /**
     Callback for when a node is first visited.
     <p>The node may be modified (e.g. {@link Node#attr(String)}, replaced {@link Node#replaceWith(Node)}) or removed
     {@link Node#remove()}. If it's {@code instanceOf Element}, you may cast it to an {@link Element} and access those
     methods.</p>

     @param node the node being visited.
     @param depth the depth of the node, relative to the root node. E.g., the root node has depth 0, and a child node
     of that will have depth 1.
     */
    void head(Node node, int depth);

    /**
     Callback for when a node is last visited, after all of its descendants have been visited.
     <p>This method has a default no-op implementation.</p>
     <p>Note that neither replacement with {@link Node#replaceWith(Node)} nor removal with {@link Node#remove()} is
     supported during {@code tail()}.

     @param node the node being visited.
     @param depth the depth of the node, relative to the root node. E.g., the root node has depth 0, and a child node
     of that will have depth 1.
     */
    default void tail(Node node, int depth) {
        // no-op by default, to allow just specifying the head() method
    }
}
"
jhy/jsoup,src/main/java/org/jsoup/helper/package-info.java,"/**
 Package containing classes supporting the core jsoup code.
 */
@NonnullByDefault
package org.jsoup.helper;

import org.jsoup.internal.NonnullByDefault;
"
jhy/jsoup,src/main/java/org/jsoup/package-info.java,"/**
 Contains the main {@link org.jsoup.Jsoup} class, which provides convenient static access to the jsoup functionality.
 */
@NonnullByDefault
package org.jsoup;

import org.jsoup.internal.NonnullByDefault;
"
jhy/jsoup,src/test/java/org/jsoup/nodes/ElementTest.java,"package org.jsoup.nodes;

import org.jsoup.Jsoup;
import org.jsoup.TextUtil;
import org.jsoup.helper.ValidationException;
import org.jsoup.internal.StringUtil;
import org.jsoup.parser.ParseSettings;
import org.jsoup.parser.Parser;
import org.jsoup.parser.Tag;
import org.jsoup.select.Elements;
import org.jsoup.select.Evaluator;
import org.jsoup.select.NodeFilter;
import org.jsoup.select.NodeVisitor;
import org.jsoup.select.QueryParser;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.MethodSource;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.stream.Stream;

import static org.junit.jupiter.api.Assertions.*;

/**
 Tests for Element (DOM stuff mostly).

 @author Jonathan Hedley */
public class ElementTest {
    private String reference = ""<div id=div1><p>Hello</p><p>Another <b>element</b></p><div id=div2><img src=foo.png></div></div>"";

    private static void validateScriptContents(String src, Element el) {
        assertEquals("""", el.text()); // it's not text
        assertEquals("""", el.ownText());
        assertEquals("""", el.wholeText());
        assertEquals(src, el.html());
        assertEquals(src, el.data());
    }

    private static void validateXmlScriptContents(Element el) {
        assertEquals(""var foo = 5 < 2; var bar = 1 && 2;"", el.text());
        assertEquals(""var foo = 5 < 2; var bar = 1 && 2;"", el.ownText());
        assertEquals(""var foo = 5 < 2;\nvar bar = 1 && 2;"", el.wholeText());
        assertEquals(""var foo = 5 &lt; 2;\nvar bar = 1 &amp;&amp; 2;"", el.html());
        assertEquals("""", el.data());
    }

    @Test
    public void testId() {
        Document doc = Jsoup.parse(""<div id=Foo>"");
        Element el = doc.selectFirst(""div"");
        assertEquals(""Foo"", el.id());
    }

    @Test
    public void testSetId() {
        Document doc = Jsoup.parse(""<div id=Boo>"");
        Element el = doc.selectFirst(""div"");
        el.id(""Foo"");
        assertEquals(""Foo"", el.id());
    }

    @Test
    public void getElementsByTagName() {
        Document doc = Jsoup.parse(reference);
        List<Element> divs = doc.getElementsByTag(""div"");
        assertEquals(2, divs.size());
        assertEquals(""div1"", divs.get(0).id());
        assertEquals(""div2"", divs.get(1).id());

        List<Element> ps = doc.getElementsByTag(""p"");
        assertEquals(2, ps.size());
        assertEquals(""Hello"", ((TextNode) ps.get(0).childNode(0)).getWholeText());
        assertEquals(""Another "", ((TextNode) ps.get(1).childNode(0)).getWholeText());
        List<Element> ps2 = doc.getElementsByTag(""P"");
        assertEquals(ps, ps2);

        List<Element> imgs = doc.getElementsByTag(""img"");
        assertEquals(""foo.png"", imgs.get(0).attr(""src""));

        List<Element> empty = doc.getElementsByTag(""wtf"");
        assertEquals(0, empty.size());
    }

    @Test
    public void getNamespacedElementsByTag() {
        Document doc = Jsoup.parse(""<div><abc:def id=1>Hello</abc:def></div>"");
        Elements els = doc.getElementsByTag(""abc:def"");
        assertEquals(1, els.size());
        assertEquals(""1"", els.first().id());
        assertEquals(""abc:def"", els.first().tagName());
    }

    @Test
    public void testGetElementById() {
        Document doc = Jsoup.parse(reference);
        Element div = doc.getElementById(""div1"");
        assertEquals(""div1"", div.id());
        assertNull(doc.getElementById(""none""));

        Document doc2 = Jsoup.parse(""<div id=1><div id=2><p>Hello <span id=2>world!</span></p></div></div>"");
        Element div2 = doc2.getElementById(""2"");
        assertEquals(""div"", div2.tagName()); // not the span
        Element span = div2.child(0).getElementById(""2""); // called from <p> context should be span
        assertEquals(""span"", span.tagName());
    }

    @Test
    public void testGetText() {
        Document doc = Jsoup.parse(reference);
        assertEquals(""Hello Another element"", doc.text());
        assertEquals(""Another element"", doc.getElementsByTag(""p"").get(1).text());
    }

    @Test
    public void testGetChildText() {
        Document doc = Jsoup.parse(""<p>Hello <b>there</b> now"");
        Element p = doc.select(""p"").first();
        assertEquals(""Hello there now"", p.text());
        assertEquals(""Hello now"", p.ownText());
    }

    @Test
    public void testNormalisesText() {
        String h = ""<p>Hello<p>There.</p> \n <p>Here <b>is</b> \n s<b>om</b>e text."";
        Document doc = Jsoup.parse(h);
        String text = doc.text();
        assertEquals(""Hello There. Here is some text."", text);
    }

    @Test
    public void testKeepsPreText() {
        String h = ""<p>Hello \n \n there.</p> <div><pre>  What's \n\n  that?</pre>"";
        Document doc = Jsoup.parse(h);
        assertEquals(""Hello there.   What's \n\n  that?"", doc.text());
    }

    @Test
    public void testKeepsPreTextInCode() {
        String h = ""<pre><code>code\n\ncode</code></pre>"";
        Document doc = Jsoup.parse(h);
        assertEquals(""code\n\ncode"", doc.text());
        assertEquals(""<pre><code>code\n\ncode</code></pre>"", doc.body().html());
    }

    @Test
    public void testKeepsPreTextAtDepth() {
        String h = ""<pre><code><span><b>code\n\ncode</b></span></code></pre>"";
        Document doc = Jsoup.parse(h);
        assertEquals(""code\n\ncode"", doc.text());
        assertEquals(""<pre><code><span><b>code\n\ncode</b></span></code></pre>"", doc.body().html());
    }

    @Test
    public void testBrHasSpace() {
        Document doc = Jsoup.parse(""<p>Hello<br>there</p>"");
        assertEquals(""Hello there"", doc.text());
        assertEquals(""Hello there"", doc.select(""p"").first().ownText());

        doc = Jsoup.parse(""<p>Hello <br> there</p>"");
        assertEquals(""Hello there"", doc.text());
    }

    @Test
    public void testBrHasSpaceCaseSensitive() {
        Document doc = Jsoup.parse(""<p>Hello<br>there<BR>now</p>"", Parser.htmlParser().settings(ParseSettings.preserveCase));
        assertEquals(""Hello there now"", doc.text());
        assertEquals(""Hello there now"", doc.select(""p"").first().ownText());

        doc = Jsoup.parse(""<p>Hello <br> there <BR> now</p>"");
        assertEquals(""Hello there now"", doc.text());
    }

    @Test
    public void testWholeText() {
        Document doc = Jsoup.parse(""<p> Hello\nthere &nbsp;  </p>"");
        assertEquals("" Hello\nthere ¬†  "", doc.wholeText());

        doc = Jsoup.parse(""<p>Hello  \n  there</p>"");
        assertEquals(""Hello  \n  there"", doc.wholeText());

        doc = Jsoup.parse(""<p>Hello  <div>\n  there</div></p>"");
        assertEquals(""Hello  \n  there"", doc.wholeText());
    }

    @Test
    public void testGetSiblings() {
        Document doc = Jsoup.parse(""<div><p>Hello<p id=1>there<p>this<p>is<p>an<p id=last>element</div>"");
        Element p = doc.getElementById(""1"");
        assertEquals(""there"", p.text());
        assertEquals(""Hello"", p.previousElementSibling().text());
        assertEquals(""this"", p.nextElementSibling().text());
        assertEquals(""Hello"", p.firstElementSibling().text());
        assertEquals(""element"", p.lastElementSibling().text());
    }

    @Test
    public void testGetSiblingsWithDuplicateContent() {
        Document doc = Jsoup.parse(""<div><p>Hello<p id=1>there<p>this<p>this<p>is<p>an<p id=last>element</div>"");
        Element p = doc.getElementById(""1"");
        assertEquals(""there"", p.text());
        assertEquals(""Hello"", p.previousElementSibling().text());
        assertEquals(""this"", p.nextElementSibling().text());
        assertEquals(""this"", p.nextElementSibling().nextElementSibling().text());
        assertEquals(""is"", p.nextElementSibling().nextElementSibling().nextElementSibling().text());
        assertEquals(""Hello"", p.firstElementSibling().text());
        assertEquals(""element"", p.lastElementSibling().text());
    }

    @Test
    public void testFirstElementSiblingOnOrphan() {
        Element p = new Element(""p"");
        assertSame(p, p.firstElementSibling());
        assertSame(p, p.lastElementSibling());
    }

    @Test
    public void testFirstAndLastSiblings() {
        Document doc = Jsoup.parse(""<div><p>One<p>Two<p>Three"");
        Element div = doc.selectFirst(""div"");
        Element one = div.child(0);
        Element two = div.child(1);
        Element three = div.child(2);

        assertSame(one, one.firstElementSibling());
        assertSame(one, two.firstElementSibling());
        assertSame(three, three.lastElementSibling());
        assertSame(three, two.lastElementSibling());
    }

    @Test
    public void testGetParents() {
        Document doc = Jsoup.parse(""<div><p>Hello <span>there</span></div>"");
        Element span = doc.select(""span"").first();
        Elements parents = span.parents();

        assertEquals(4, parents.size());
        assertEquals(""p"", parents.get(0).tagName());
        assertEquals(""div"", parents.get(1).tagName());
        assertEquals(""body"", parents.get(2).tagName());
        assertEquals(""html"", parents.get(3).tagName());
    }

    @Test
    public void testElementSiblingIndex() {
        Document doc = Jsoup.parse(""<div><p>One</p>...<p>Two</p>...<p>Three</p>"");
        Elements ps = doc.select(""p"");
        assertEquals(0, ps.get(0).elementSiblingIndex());
        assertEquals(1, ps.get(1).elementSiblingIndex());
        assertEquals(2, ps.get(2).elementSiblingIndex());
    }

    @Test
    public void testElementSiblingIndexSameContent() {
        Document doc = Jsoup.parse(""<div><p>One</p>...<p>One</p>...<p>One</p>"");
        Elements ps = doc.select(""p"");
        assertEquals(0, ps.get(0).elementSiblingIndex());
        assertEquals(1, ps.get(1).elementSiblingIndex());
        assertEquals(2, ps.get(2).elementSiblingIndex());
    }

    @Test
    public void testGetElementsWithClass() {
        Document doc = Jsoup.parse(""<div class='mellow yellow'><span class=mellow>Hello <b class='yellow'>Yellow!</b></span><p>Empty</p></div>"");

        List<Element> els = doc.getElementsByClass(""mellow"");
        assertEquals(2, els.size());
        assertEquals(""div"", els.get(0).tagName());
        assertEquals(""span"", els.get(1).tagName());

        List<Element> els2 = doc.getElementsByClass(""yellow"");
        assertEquals(2, els2.size());
        assertEquals(""div"", els2.get(0).tagName());
        assertEquals(""b"", els2.get(1).tagName());

        List<Element> none = doc.getElementsByClass(""solo"");
        assertEquals(0, none.size());
    }

    @Test
    public void testGetElementsWithAttribute() {
        Document doc = Jsoup.parse(""<div style='bold'><p title=qux><p><b style></b></p></div>"");
        List<Element> els = doc.getElementsByAttribute(""style"");
        assertEquals(2, els.size());
        assertEquals(""div"", els.get(0).tagName());
        assertEquals(""b"", els.get(1).tagName());

        List<Element> none = doc.getElementsByAttribute(""class"");
        assertEquals(0, none.size());
    }

    @Test
    public void testGetElementsWithAttributeDash() {
        Document doc = Jsoup.parse(""<meta http-equiv=content-type value=utf8 id=1> <meta name=foo content=bar id=2> <div http-equiv=content-type value=utf8 id=3>"");
        Elements meta = doc.select(""meta[http-equiv=content-type], meta[charset]"");
        assertEquals(1, meta.size());
        assertEquals(""1"", meta.first().id());
    }

    @Test
    public void testGetElementsWithAttributeValue() {
        Document doc = Jsoup.parse(""<div style='bold'><p><p><b style></b></p></div>"");
        List<Element> els = doc.getElementsByAttributeValue(""style"", ""bold"");
        assertEquals(1, els.size());
        assertEquals(""div"", els.get(0).tagName());

        List<Element> none = doc.getElementsByAttributeValue(""style"", ""none"");
        assertEquals(0, none.size());
    }

    @Test
    public void testClassDomMethods() {
        Document doc = Jsoup.parse(""<div><span class=' mellow yellow '>Hello <b>Yellow</b></span></div>"");
        List<Element> els = doc.getElementsByAttribute(""class"");
        Element span = els.get(0);
        assertEquals(""mellow yellow"", span.className());
        assertTrue(span.hasClass(""mellow""));
        assertTrue(span.hasClass(""yellow""));
        Set<String> classes = span.classNames();
        assertEquals(2, classes.size());
        assertTrue(classes.contains(""mellow""));
        assertTrue(classes.contains(""yellow""));

        assertEquals("""", doc.className());
        classes = doc.classNames();
        assertEquals(0, classes.size());
        assertFalse(doc.hasClass(""mellow""));
    }

    @Test
    public void testHasClassDomMethods() {
        Tag tag = Tag.valueOf(""a"");
        Attributes attribs = new Attributes();
        Element el = new Element(tag, """", attribs);

        attribs.put(""class"", ""toto"");
        boolean hasClass = el.hasClass(""toto"");
        assertTrue(hasClass);

        attribs.put(""class"", "" toto"");
        hasClass = el.hasClass(""toto"");
        assertTrue(hasClass);

        attribs.put(""class"", ""toto "");
        hasClass = el.hasClass(""toto"");
        assertTrue(hasClass);

        attribs.put(""class"", ""\ttoto "");
        hasClass = el.hasClass(""toto"");
        assertTrue(hasClass);

        attribs.put(""class"", ""  toto "");
        hasClass = el.hasClass(""toto"");
        assertTrue(hasClass);

        attribs.put(""class"", ""ab"");
        hasClass = el.hasClass(""toto"");
        assertFalse(hasClass);

        attribs.put(""class"", ""     "");
        hasClass = el.hasClass(""toto"");
        assertFalse(hasClass);

        attribs.put(""class"", ""tototo"");
        hasClass = el.hasClass(""toto"");
        assertFalse(hasClass);

        attribs.put(""class"", ""raulpismuth  "");
        hasClass = el.hasClass(""raulpismuth"");
        assertTrue(hasClass);

        attribs.put(""class"", "" abcd  raulpismuth efgh "");
        hasClass = el.hasClass(""raulpismuth"");
        assertTrue(hasClass);

        attribs.put(""class"", "" abcd efgh raulpismuth"");
        hasClass = el.hasClass(""raulpismuth"");
        assertTrue(hasClass);

        attribs.put(""class"", "" abcd efgh raulpismuth "");
        hasClass = el.hasClass(""raulpismuth"");
        assertTrue(hasClass);
    }

    @Test
    public void testClassUpdates() {
        Document doc = Jsoup.parse(""<div class='mellow yellow'></div>"");
        Element div = doc.select(""div"").first();

        div.addClass(""green"");
        assertEquals(""mellow yellow green"", div.className());
        div.removeClass(""red""); // noop
        div.removeClass(""yellow"");
        assertEquals(""mellow green"", div.className());
        div.toggleClass(""green"").toggleClass(""red"");
        assertEquals(""mellow red"", div.className());
    }

    @Test
    public void testOuterHtml() {
        Document doc = Jsoup.parse(""<div title='Tags &amp;c.'><img src=foo.png><p><!-- comment -->Hello<p>there"");
        assertEquals(""<html><head></head><body><div title=\""Tags &amp;c.\""><img src=\""foo.png\""><p><!-- comment -->Hello</p><p>there</p></div></body></html>"",
            TextUtil.stripNewlines(doc.outerHtml()));
    }

    @Test
    public void testInnerHtml() {
        Document doc = Jsoup.parse(""<div>\n <p>Hello</p> </div>"");
        assertEquals(""<p>Hello</p>"", doc.getElementsByTag(""div"").get(0).html());
    }

    @Test
    public void testFormatHtml() {
        Document doc = Jsoup.parse(""<title>Format test</title><div><p>Hello <span>jsoup <span>users</span></span></p><p>Good.</p></div>"");
        assertEquals(""<html>\n <head>\n  <title>Format test</title>\n </head>\n <body>\n  <div>\n   <p>Hello <span>jsoup <span>users</span></span></p>\n   <p>Good.</p>\n  </div>\n </body>\n</html>"", doc.html());
    }

    @Test
    public void testFormatOutline() {
        Document doc = Jsoup.parse(""<title>Format test</title><div><p>Hello <span>jsoup <span>users</span></span></p><p>Good.</p></div>"");
        doc.outputSettings().outline(true);
        assertEquals(""<html>\n <head>\n  <title>Format test</title>\n </head>\n <body>\n  <div>\n   <p>\n    Hello \n    <span>\n     jsoup \n     <span>users</span>\n    </span>\n   </p>\n   <p>Good.</p>\n  </div>\n </body>\n</html>"", doc.html());
    }

    @Test
    public void testSetIndent() {
        Document doc = Jsoup.parse(""<div><p>Hello\nthere</p></div>"");
        doc.outputSettings().indentAmount(0);
        assertEquals(""<html>\n<head></head>\n<body>\n<div>\n<p>Hello there</p>\n</div>\n</body>\n</html>"", doc.html());
    }

    @Test void testIndentLevel() {
        // deep to test default and extended max
        StringBuilder divs = new StringBuilder();
        for (int i = 0; i < 40; i++) {
            divs.append(""<div>"");
        }
        divs.append(""Foo"");
        Document doc = Jsoup.parse(divs.toString());
        Document.OutputSettings settings = doc.outputSettings();

        int defaultMax = 30;
        assertEquals(defaultMax, settings.maxPaddingWidth());
        String html = doc.html();
        assertTrue(html.contains(""                              <div>\n"" +
            ""                              Foo\n"" +
            ""                              </div>""));

        settings.maxPaddingWidth(32);
        assertEquals(32, settings.maxPaddingWidth());
        html = doc.html();
        assertTrue(html.contains(""                                <div>\n"" +
            ""                                Foo\n"" +
            ""                                </div>""));

        settings.maxPaddingWidth(-1);
        assertEquals(-1, settings.maxPaddingWidth());
        html = doc.html();
        assertTrue(html.contains(""                                         <div>\n"" +
            ""                                          Foo\n"" +
            ""                                         </div>""));
    }

    @Test
    public void testNotPretty() {
        Document doc = Jsoup.parse(""<div>   \n<p>Hello\n there\n</p></div>"");
        doc.outputSettings().prettyPrint(false);
        assertEquals(""<html><head></head><body><div>   \n<p>Hello\n there\n</p></div></body></html>"", doc.html());

        Element div = doc.select(""div"").first();
        assertEquals(""   \n<p>Hello\n there\n</p>"", div.html());
    }

    @Test
    public void testNotPrettyWithEnDashBody() {
        String html = ""<div><span>1:15</span>&ndash;<span>2:15</span>&nbsp;p.m.</div>"";
        Document document = Jsoup.parse(html);
        document.outputSettings().prettyPrint(false);

        assertEquals(""<div><span>1:15</span>‚Äì<span>2:15</span>&nbsp;p.m.</div>"", document.body().html());
    }

    @Test
    public void testPrettyWithEnDashBody() {
        String html = ""<div><span>1:15</span>&ndash;<span>2:15</span>&nbsp;p.m.</div>"";
        Document document = Jsoup.parse(html);

        assertEquals(""<div>\n <span>1:15</span>‚Äì<span>2:15</span>&nbsp;p.m.\n</div>"", document.body().html());
    }

    @Test
    public void testPrettyAndOutlineWithEnDashBody() {
        String html = ""<div><span>1:15</span>&ndash;<span>2:15</span>&nbsp;p.m.</div>"";
        Document document = Jsoup.parse(html);
        document.outputSettings().outline(true);

        assertEquals(""<div>\n <span>1:15</span>\n ‚Äì\n <span>2:15</span>\n &nbsp;p.m.\n</div>"", document.body().html());
    }

    @Test
    public void testBasicFormats() {
        String html = ""<span>0</span>.<div><span>1</span>-<span>2</span><p><span>3</span>-<span>4</span><div>5</div>"";
        Document doc = Jsoup.parse(html);
        assertEquals(
            ""<span>0</span>.\n"" +
                ""<div>\n"" +
                "" <span>1</span>-<span>2</span>\n"" +
                "" <p><span>3</span>-<span>4</span></p>\n"" +
                "" <div>\n"" +
                ""  5\n"" +
                "" </div>\n"" +
                ""</div>"", doc.body().html());
    }

    @Test
    public void testEmptyElementFormatHtml() {
        // don't put newlines into empty blocks
        Document doc = Jsoup.parse(""<section><div></div></section>"");
        assertEquals(""<section>\n <div></div>\n</section>"", doc.select(""section"").first().outerHtml());
    }

    @Test
    public void testNoIndentOnScriptAndStyle() {
        // don't newline+indent closing </script> and </style> tags
        Document doc = Jsoup.parse(""<script>one\ntwo</script>\n<style>three\nfour</style>"");
        assertEquals(""<script>one\ntwo</script>\n<style>three\nfour</style>"", doc.head().html());
    }

    @Test
    public void testContainerOutput() {
        Document doc = Jsoup.parse(""<title>Hello there</title> <div><p>Hello</p><p>there</p></div> <div>Another</div>"");
        assertEquals(""<title>Hello there</title>"", doc.select(""title"").first().outerHtml());
        assertEquals(""<div>\n <p>Hello</p>\n <p>there</p>\n</div>"", doc.select(""div"").first().outerHtml());
        assertEquals(""<div>\n <p>Hello</p>\n <p>there</p>\n</div>\n<div>\n Another\n</div>"", doc.select(""body"").first().html());
    }

    @Test
    public void testSetText() {
        String h = ""<div id=1>Hello <p>there <b>now</b></p></div>"";
        Document doc = Jsoup.parse(h);
        assertEquals(""Hello there now"", doc.text()); // need to sort out node whitespace
        assertEquals(""there now"", doc.select(""p"").get(0).text());

        Element div = doc.getElementById(""1"").text(""Gone"");
        assertEquals(""Gone"", div.text());
        assertEquals(0, doc.select(""p"").size());
    }

    @Test
    public void testAddNewElement() {
        Document doc = Jsoup.parse(""<div id=1><p>Hello</p></div>"");
        Element div = doc.getElementById(""1"");
        div.appendElement(""p"").text(""there"");
        div.appendElement(""P"").attr(""CLASS"", ""second"").text(""now"");
        // manually specifying tag and attributes should maintain case based on parser settings
        assertEquals(""<html><head></head><body><div id=\""1\""><p>Hello</p><p>there</p><p class=\""second\"">now</p></div></body></html>"",
            TextUtil.stripNewlines(doc.html()));

        // check sibling index (with short circuit on reindexChildren):
        Elements ps = doc.select(""p"");
        for (int i = 0; i < ps.size(); i++) {
            assertEquals(i, ps.get(i).siblingIndex);
        }
    }

    @Test
    public void testAddBooleanAttribute() {
        Element div = new Element(Tag.valueOf(""div""), """");

        div.attr(""true"", true);

        div.attr(""false"", ""value"");
        div.attr(""false"", false);

        assertTrue(div.hasAttr(""true""));
        assertEquals("""", div.attr(""true""));

        List<Attribute> attributes = div.attributes().asList();
        assertEquals(1, attributes.size(), ""There should be one attribute"");
        assertFalse(div.hasAttr(""false""));

        assertEquals(""<div true></div>"", div.outerHtml());
    }

    @Test
    public void testAppendRowToTable() {
        Document doc = Jsoup.parse(""<table><tr><td>1</td></tr></table>"");
        Element table = doc.select(""tbody"").first();
        table.append(""<tr><td>2</td></tr>"");

        assertEquals(""<table><tbody><tr><td>1</td></tr><tr><td>2</td></tr></tbody></table>"", TextUtil.stripNewlines(doc.body().html()));
    }

    @Test
    public void testPrependRowToTable() {
        Document doc = Jsoup.parse(""<table><tr><td>1</td></tr></table>"");
        Element table = doc.select(""tbody"").first();
        table.prepend(""<tr><td>2</td></tr>"");

        assertEquals(""<table><tbody><tr><td>2</td></tr><tr><td>1</td></tr></tbody></table>"", TextUtil.stripNewlines(doc.body().html()));

        // check sibling index (reindexChildren):
        Elements ps = doc.select(""tr"");
        for (int i = 0; i < ps.size(); i++) {
            assertEquals(i, ps.get(i).siblingIndex);
        }
    }

    @Test
    public void testPrependElement() {
        Document doc = Jsoup.parse(""<div id=1><p>Hello</p></div>"");
        Element div = doc.getElementById(""1"");
        div.prependElement(""p"").text(""Before"");
        assertEquals(""Before"", div.child(0).text());
        assertEquals(""Hello"", div.child(1).text());
    }

    @Test
    public void testAddNewText() {
        Document doc = Jsoup.parse(""<div id=1><p>Hello</p></div>"");
        Element div = doc.getElementById(""1"");
        div.appendText("" there & now >"");
        assertEquals (""Hello there & now >"", div.text());
        assertEquals(""<p>Hello</p> there &amp; now &gt;"", TextUtil.stripNewlines(div.html()));
    }

    @Test
    public void testPrependText() {
        Document doc = Jsoup.parse(""<div id=1><p>Hello</p></div>"");
        Element div = doc.getElementById(""1"");
        div.prependText(""there & now > "");
        assertEquals(""there & now > Hello"", div.text());
        assertEquals(""there &amp; now &gt; <p>Hello</p>"", TextUtil.stripNewlines(div.html()));
    }

    @Test
    public void testThrowsOnAddNullText() {
        assertThrows(IllegalArgumentException.class, () -> {
            Document doc = Jsoup.parse(""<div id=1><p>Hello</p></div>"");
            Element div = doc.getElementById(""1"");
            div.appendText(null);
        });
    }

    @Test
    public void testThrowsOnPrependNullText() {
        assertThrows(IllegalArgumentException.class, () -> {
            Document doc = Jsoup.parse(""<div id=1><p>Hello</p></div>"");
            Element div = doc.getElementById(""1"");
            div.prependText(null);
        });
    }

    @Test
    public void testAddNewHtml() {
        Document doc = Jsoup.parse(""<div id=1><p>Hello</p></div>"");
        Element div = doc.getElementById(""1"");
        div.append(""<p>there</p><p>now</p>"");
        assertEquals(""<p>Hello</p><p>there</p><p>now</p>"", TextUtil.stripNewlines(div.html()));

        // check sibling index (no reindexChildren):
        Elements ps = doc.select(""p"");
        for (int i = 0; i < ps.size(); i++) {
            assertEquals(i, ps.get(i).siblingIndex);
        }
    }

    @Test
    public void testPrependNewHtml() {
        Document doc = Jsoup.parse(""<div id=1><p>Hello</p></div>"");
        Element div = doc.getElementById(""1"");
        div.prepend(""<p>there</p><p>now</p>"");
        assertEquals(""<p>there</p><p>now</p><p>Hello</p>"", TextUtil.stripNewlines(div.html()));

        // check sibling index (reindexChildren):
        Elements ps = doc.select(""p"");
        for (int i = 0; i < ps.size(); i++) {
            assertEquals(i, ps.get(i).siblingIndex);
        }
    }

    @Test
    public void testSetHtml() {
        Document doc = Jsoup.parse(""<div id=1><p>Hello</p></div>"");
        Element div = doc.getElementById(""1"");
        div.html(""<p>there</p><p>now</p>"");
        assertEquals(""<p>there</p><p>now</p>"", TextUtil.stripNewlines(div.html()));
    }

    @Test
    public void testSetHtmlTitle() {
        Document doc = Jsoup.parse(""<html><head id=2><title id=1></title></head></html>"");

        Element title = doc.getElementById(""1"");
        title.html(""good"");
        assertEquals(""good"", title.html());
        title.html(""<i>bad</i>"");
        assertEquals(""&lt;i&gt;bad&lt;/i&gt;"", title.html());

        Element head = doc.getElementById(""2"");
        head.html(""<title><i>bad</i></title>"");
        assertEquals(""<title>&lt;i&gt;bad&lt;/i&gt;</title>"", head.html());
    }

    @Test
    public void testWrap() {
        Document doc = Jsoup.parse(""<div><p>Hello</p><p>There</p></div>"");
        Element p = doc.select(""p"").first();
        p.wrap(""<div class='head'></div>"");
        assertEquals(""<div><div class=\""head\""><p>Hello</p></div><p>There</p></div>"", TextUtil.stripNewlines(doc.body().html()));

        Element ret = p.wrap(""<div><div class=foo></div><p>What?</p></div>"");
        assertEquals(""<div><div class=\""head\""><div><div class=\""foo\""><p>Hello</p></div><p>What?</p></div></div><p>There</p></div>"",
            TextUtil.stripNewlines(doc.body().html()));

        assertEquals(ret, p);
    }

    @Test
    public void testWrapNoop() {
        Document doc = Jsoup.parse(""<div><p>Hello</p></div>"");
        Node p = doc.select(""p"").first();
        Node wrapped = p.wrap(""Some junk"");
        assertSame(p, wrapped);
        assertEquals(""<div><p>Hello</p></div>"", TextUtil.stripNewlines(doc.body().html()));
        // should be a NOOP
    }

    @Test
    public void testWrapOnOrphan() {
        Element orphan = new Element(""span"").text(""Hello!"");
        assertFalse(orphan.hasParent());
        Element wrapped = orphan.wrap(""<div></div> There!"");
        assertSame(orphan, wrapped);
        assertTrue(orphan.hasParent()); // should now be in the DIV
        assertNotNull(orphan.parent());
        assertEquals(""div"", orphan.parent().tagName());
        assertEquals(""<div>\n <span>Hello!</span>\n</div>"", orphan.parent().outerHtml());
    }

    @Test
    public void testWrapArtificialStructure() {
        // div normally couldn't get into a p, but explicitly want to wrap
        Document doc = Jsoup.parse(""<p>Hello <i>there</i> now."");
        Element i = doc.selectFirst(""i"");
        i.wrap(""<div id=id1></div> quite"");
        assertEquals(""div"", i.parent().tagName());
        assertEquals(""<p>Hello <div id=\""id1\""><i>there</i></div> quite now.</p>"", TextUtil.stripNewlines(doc.body().html()));
    }

    @Test
    public void before() {
        Document doc = Jsoup.parse(""<div><p>Hello</p><p>There</p></div>"");
        Element p1 = doc.select(""p"").first();
        p1.before(""<div>one</div><div>two</div>"");
        assertEquals(""<div><div>one</div><div>two</div><p>Hello</p><p>There</p></div>"", TextUtil.stripNewlines(doc.body().html()));

        doc.select(""p"").last().before(""<p>Three</p><!-- four -->"");
        assertEquals(""<div><div>one</div><div>two</div><p>Hello</p><p>Three</p><!-- four --><p>There</p></div>"", TextUtil.stripNewlines(doc.body().html()));
    }

    @Test
    public void after() {
        Document doc = Jsoup.parse(""<div><p>Hello</p><p>There</p></div>"");
        Element p1 = doc.select(""p"").first();
        p1.after(""<div>one</div><div>two</div>"");
        assertEquals(""<div><p>Hello</p><div>one</div><div>two</div><p>There</p></div>"", TextUtil.stripNewlines(doc.body().html()));

        doc.select(""p"").last().after(""<p>Three</p><!-- four -->"");
        assertEquals(""<div><p>Hello</p><div>one</div><div>two</div><p>There</p><p>Three</p><!-- four --></div>"", TextUtil.stripNewlines(doc.body().html()));
    }

    @Test
    public void testWrapWithRemainder() {
        Document doc = Jsoup.parse(""<div><p>Hello</p></div>"");
        Element p = doc.select(""p"").first();
        p.wrap(""<div class='head'></div><p>There!</p>"");
        assertEquals(""<div><div class=\""head\""><p>Hello</p></div><p>There!</p></div>"", TextUtil.stripNewlines(doc.body().html()));
    }

    @Test
    public void testWrapWithSimpleRemainder() {
        Document doc = Jsoup.parse(""<p>Hello"");
        Element p = doc.selectFirst(""p"");
        Element body = p.parent();
        assertNotNull(body);
        assertEquals(""body"", body.tagName());

        p.wrap(""<div></div> There"");
        Element div = p.parent();
        assertNotNull(div);
        assertEquals(""div"", div.tagName());
        assertSame(div, p.parent());
        assertSame(body, div.parent());

        assertEquals(""<div><p>Hello</p></div> There"", TextUtil.stripNewlines(doc.body().html()));
    }

    @Test
    public void testHasText() {
        Document doc = Jsoup.parse(""<div><p>Hello</p><p></p></div>"");
        Element div = doc.select(""div"").first();
        Elements ps = doc.select(""p"");

        assertTrue(div.hasText());
        assertTrue(ps.first().hasText());
        assertFalse(ps.last().hasText());
    }

    @Test
    public void dataset() {
        Document doc = Jsoup.parse(""<div id=1 data-name=jsoup class=new data-package=jar>Hello</div><p id=2>Hello</p>"");
        Element div = doc.select(""div"").first();
        Map<String, String> dataset = div.dataset();
        Attributes attributes = div.attributes();

        // size, get, set, add, remove
        assertEquals(2, dataset.size());
        assertEquals(""jsoup"", dataset.get(""name""));
        assertEquals(""jar"", dataset.get(""package""));

        dataset.put(""name"", ""jsoup updated"");
        dataset.put(""language"", ""java"");
        dataset.remove(""package"");

        assertEquals(2, dataset.size());
        assertEquals(4, attributes.size());
        assertEquals(""jsoup updated"", attributes.get(""data-name""));
        assertEquals(""jsoup updated"", dataset.get(""name""));
        assertEquals(""java"", attributes.get(""data-language""));
        assertEquals(""java"", dataset.get(""language""));

        attributes.put(""data-food"", ""bacon"");
        assertEquals(3, dataset.size());
        assertEquals(""bacon"", dataset.get(""food""));

        attributes.put(""data-"", ""empty"");
        assertNull(dataset.get("""")); // data- is not a data attribute

        Element p = doc.select(""p"").first();
        assertEquals(0, p.dataset().size());

    }

    @Test
    public void parentlessToString() {
        Document doc = Jsoup.parse(""<img src='foo'>"");
        Element img = doc.select(""img"").first();
        assertEquals(""<img src=\""foo\"">"", img.toString());

        img.remove(); // lost its parent
        assertEquals(""<img src=\""foo\"">"", img.toString());
    }

    @Test
    public void orphanDivToString() {
        Element orphan = new Element(""div"").id(""foo"").text(""Hello"");
        assertEquals(""<div id=\""foo\"">\n Hello\n</div>"", orphan.toString());
    }

    @Test
    public void testClone() {
        Document doc = Jsoup.parse(""<div><p>One<p><span>Two</div>"");

        Element p = doc.select(""p"").get(1);
        Element clone = p.clone();

        assertNotNull(clone.parentNode); // should be a cloned document just containing this clone
        assertEquals(1, clone.parentNode.childNodeSize());
        assertSame(clone.ownerDocument(), clone.parentNode);

        assertEquals(0, clone.siblingIndex);
        assertEquals(1, p.siblingIndex);
        assertNotNull(p.parent());

        clone.append(""<span>Three"");
        assertEquals(""<p><span>Two</span><span>Three</span></p>"", TextUtil.stripNewlines(clone.outerHtml()));
        assertEquals(""<div><p>One</p><p><span>Two</span></p></div>"", TextUtil.stripNewlines(doc.body().html())); // not modified

        doc.body().appendChild(clone); // adopt
        assertNotNull(clone.parent());
        assertEquals(""<div><p>One</p><p><span>Two</span></p></div><p><span>Two</span><span>Three</span></p>"", TextUtil.stripNewlines(doc.body().html()));
    }

    @Test
    public void testClonesClassnames() {
        Document doc = Jsoup.parse(""<div class='one two'></div>"");
        Element div = doc.select(""div"").first();
        Set<String> classes = div.classNames();
        assertEquals(2, classes.size());
        assertTrue(classes.contains(""one""));
        assertTrue(classes.contains(""two""));

        Element copy = div.clone();
        Set<String> copyClasses = copy.classNames();
        assertEquals(2, copyClasses.size());
        assertTrue(copyClasses.contains(""one""));
        assertTrue(copyClasses.contains(""two""));
        copyClasses.add(""three"");
        copyClasses.remove(""one"");

        assertTrue(classes.contains(""one""));
        assertFalse(classes.contains(""three""));
        assertFalse(copyClasses.contains(""one""));
        assertTrue(copyClasses.contains(""three""));

        assertEquals("""", div.html());
        assertEquals("""", copy.html());
    }

    @Test
    public void testShallowClone() {
        String base = ""http://example.com/"";
        Document doc = Jsoup.parse(""<div id=1 class=one><p id=2 class=two>One"", base);
        Element d = doc.selectFirst(""div"");
        Element p = doc.selectFirst(""p"");
        TextNode t = p.textNodes().get(0);

        Element d2 = d.shallowClone();
        Element p2 = p.shallowClone();
        TextNode t2 = (TextNode) t.shallowClone();

        assertEquals(1, d.childNodeSize());
        assertEquals(0, d2.childNodeSize());

        assertEquals(1, p.childNodeSize());
        assertEquals(0, p2.childNodeSize());

        assertEquals("""", p2.text());
        assertEquals(""One"", t2.text());

        assertEquals(""two"", p2.className());
        p2.removeClass(""two"");
        assertEquals(""two"", p.className());

        d2.append(""<p id=3>Three"");
        assertEquals(1, d2.childNodeSize());
        assertEquals(""Three"", d2.text());
        assertEquals(""One"", d.text());
        assertEquals(base, d2.baseUri());
    }

    @Test
    public void testTagNameSet() {
        Document doc = Jsoup.parse(""<div><i>Hello</i>"");
        doc.select(""i"").first().tagName(""em"");
        assertEquals(0, doc.select(""i"").size());
        assertEquals(1, doc.select(""em"").size());
        assertEquals(""<em>Hello</em>"", doc.select(""div"").first().html());
    }

    @Test
    public void testHtmlContainsOuter() {
        Document doc = Jsoup.parse(""<title>Check</title> <div>Hello there</div>"");
        doc.outputSettings().indentAmount(0);
        assertTrue(doc.html().contains(doc.select(""title"").outerHtml()));
        assertTrue(doc.html().contains(doc.select(""div"").outerHtml()));
    }

    @Test
    public void testGetTextNodes() {
        Document doc = Jsoup.parse(""<p>One <span>Two</span> Three <br> Four</p>"");
        List<TextNode> textNodes = doc.select(""p"").first().textNodes();

        assertEquals(3, textNodes.size());
        assertEquals(""One "", textNodes.get(0).text());
        assertEquals("" Three "", textNodes.get(1).text());
        assertEquals("" Four"", textNodes.get(2).text());

        assertEquals(0, doc.select(""br"").first().textNodes().size());
    }

    @Test
    public void testManipulateTextNodes() {
        Document doc = Jsoup.parse(""<p>One <span>Two</span> Three <br> Four</p>"");
        Element p = doc.select(""p"").first();
        List<TextNode> textNodes = p.textNodes();

        textNodes.get(1).text("" three-more "");
        textNodes.get(2).splitText(3).text(""-ur"");

        assertEquals(""One Two three-more Fo-ur"", p.text());
        assertEquals(""One three-more Fo-ur"", p.ownText());
        assertEquals(4, p.textNodes().size()); // grew because of split
    }

    @Test
    public void testGetDataNodes() {
        Document doc = Jsoup.parse(""<script>One Two</script> <style>Three Four</style> <p>Fix Six</p>"");
        Element script = doc.select(""script"").first();
        Element style = doc.select(""style"").first();
        Element p = doc.select(""p"").first();

        List<DataNode> scriptData = script.dataNodes();
        assertEquals(1, scriptData.size());
        assertEquals(""One Two"", scriptData.get(0).getWholeData());

        List<DataNode> styleData = style.dataNodes();
        assertEquals(1, styleData.size());
        assertEquals(""Three Four"", styleData.get(0).getWholeData());

        List<DataNode> pData = p.dataNodes();
        assertEquals(0, pData.size());
    }

    @Test
    public void elementIsNotASiblingOfItself() {
        Document doc = Jsoup.parse(""<div><p>One<p>Two<p>Three</div>"");
        Element p2 = doc.select(""p"").get(1);

        assertEquals(""Two"", p2.text());
        Elements els = p2.siblingElements();
        assertEquals(2, els.size());
        assertEquals(""<p>One</p>"", els.get(0).outerHtml());
        assertEquals(""<p>Three</p>"", els.get(1).outerHtml());
    }

    @Test
    public void testChildThrowsIndexOutOfBoundsOnMissing() {
        Document doc = Jsoup.parse(""<div><p>One</p><p>Two</p></div>"");
        Element div = doc.select(""div"").first();

        assertEquals(2, div.children().size());
        assertEquals(""One"", div.child(0).text());

        try {
            div.child(3);
            fail(""Should throw index out of bounds"");
        } catch (IndexOutOfBoundsException e) {
        }
    }

    @Test
    public void moveByAppend() {
        // test for https://github.com/jhy/jsoup/issues/239
        // can empty an element and append its children to another element
        Document doc = Jsoup.parse(""<div id=1>Text <p>One</p> Text <p>Two</p></div><div id=2></div>"");
        Element div1 = doc.select(""div"").get(0);
        Element div2 = doc.select(""div"").get(1);

        assertEquals(4, div1.childNodeSize());
        List<Node> children = div1.childNodes();
        assertEquals(4, children.size());

        div2.insertChildren(0, children);

        assertEquals(4, children.size()); // children is NOT backed by div1.childNodes but a wrapper, so should still be 4 (but re-parented)
        assertEquals(0, div1.childNodeSize());
        assertEquals(4, div2.childNodeSize());
        assertEquals(""<div id=\""1\""></div>\n<div id=\""2\"">\n Text \n <p>One</p> Text \n <p>Two</p>\n</div>"",
            doc.body().html());
    }

    @Test
    public void insertChildrenArgumentValidation() {
        Document doc = Jsoup.parse(""<div id=1>Text <p>One</p> Text <p>Two</p></div><div id=2></div>"");
        Element div1 = doc.select(""div"").get(0);
        Element div2 = doc.select(""div"").get(1);
        List<Node> children = div1.childNodes();

        try {
            div2.insertChildren(6, children);
            fail();
        } catch (IllegalArgumentException e) {
        }

        try {
            div2.insertChildren(-5, children);
            fail();
        } catch (IllegalArgumentException e) {
        }

        try {
            div2.insertChildren(0, (Collection<? extends Node>) null);
            fail();
        } catch (IllegalArgumentException e) {
        }
    }

    @Test
    public void insertChildrenAtPosition() {
        Document doc = Jsoup.parse(""<div id=1>Text1 <p>One</p> Text2 <p>Two</p></div><div id=2>Text3 <p>Three</p></div>"");
        Element div1 = doc.select(""div"").get(0);
        Elements p1s = div1.select(""p"");
        Element div2 = doc.select(""div"").get(1);

        assertEquals(2, div2.childNodeSize());
        div2.insertChildren(-1, p1s);
        assertEquals(2, div1.childNodeSize()); // moved two out
        assertEquals(4, div2.childNodeSize());
        assertEquals(3, p1s.get(1).siblingIndex()); // should be last

        List<Node> els = new ArrayList<>();
        Element el1 = new Element(Tag.valueOf(""span""), """").text(""Span1"");
        Element el2 = new Element(Tag.valueOf(""span""), """").text(""Span2"");
        TextNode tn1 = new TextNode(""Text4"");
        els.add(el1);
        els.add(el2);
        els.add(tn1);

        assertNull(el1.parent());
        div2.insertChildren(-2, els);
        assertEquals(div2, el1.parent());
        assertEquals(7, div2.childNodeSize());
        assertEquals(3, el1.siblingIndex());
        assertEquals(4, el2.siblingIndex());
        assertEquals(5, tn1.siblingIndex());
    }

    @Test
    public void insertChildrenAsCopy() {
        Document doc = Jsoup.parse(""<div id=1>Text <p>One</p> Text <p>Two</p></div><div id=2></div>"");
        Element div1 = doc.select(""div"").get(0);
        Element div2 = doc.select(""div"").get(1);
        Elements ps = doc.select(""p"").clone();
        ps.first().text(""One cloned"");
        div2.insertChildren(-1, ps);

        assertEquals(4, div1.childNodeSize()); // not moved -- cloned
        assertEquals(2, div2.childNodeSize());
        assertEquals(""<div id=\""1\"">Text <p>One</p> Text <p>Two</p></div><div id=\""2\""><p>One cloned</p><p>Two</p></div>"",
            TextUtil.stripNewlines(doc.body().html()));
    }

    @Test
    public void testCssPath() {
        Document doc = Jsoup.parse(""<div id=\""id1\"">A</div><div>B</div><div class=\""c1 c2\"">C</div>"");
        Element divA = doc.select(""div"").get(0);
        Element divB = doc.select(""div"").get(1);
        Element divC = doc.select(""div"").get(2);
        assertEquals(divA.cssSelector(), ""#id1"");
        assertEquals(divB.cssSelector(), ""html > body > div:nth-child(2)"");
        assertEquals(divC.cssSelector(), ""html > body > div.c1.c2"");

        assertSame(divA, doc.select(divA.cssSelector()).first());
        assertSame(divB, doc.select(divB.cssSelector()).first());
        assertSame(divC, doc.select(divC.cssSelector()).first());
    }

    @Test
    public void testCssPathDuplicateIds() {
        // https://github.com/jhy/jsoup/issues/1147 - multiple elements with same ID, use the non-ID form
        Document doc = Jsoup.parse(""<article><div id=dupe>A</div><div id=dupe>B</div><div id=dupe class=c1>"");
        Element divA = doc.select(""div"").get(0);
        Element divB = doc.select(""div"").get(1);
        Element divC = doc.select(""div"").get(2);

        assertEquals(divA.cssSelector(), ""html > body > article > div:nth-child(1)"");
        assertEquals(divB.cssSelector(), ""html > body > article > div:nth-child(2)"");
        assertEquals(divC.cssSelector(), ""html > body > article > div.c1"");

        assertSame(divA, doc.select(divA.cssSelector()).first());
        assertSame(divB, doc.select(divB.cssSelector()).first());
        assertSame(divC, doc.select(divC.cssSelector()).first());
    }

    @Test
    public void testClassNames() {
        Document doc = Jsoup.parse(""<div class=\""c1 c2\"">C</div>"");
        Element div = doc.select(""div"").get(0);

        assertEquals(""c1 c2"", div.className());

        final Set<String> set1 = div.classNames();
        final Object[] arr1 = set1.toArray();
        assertEquals(2, arr1.length);
        assertEquals(""c1"", arr1[0]);
        assertEquals(""c2"", arr1[1]);

        // Changes to the set should not be reflected in the Elements getters
        set1.add(""c3"");
        assertEquals(2, div.classNames().size());
        assertEquals(""c1 c2"", div.className());

        // Update the class names to a fresh set
        final Set<String> newSet = new LinkedHashSet<>(3);
        newSet.addAll(set1);
        newSet.add(""c3"");

        div.classNames(newSet);

        assertEquals(""c1 c2 c3"", div.className());

        final Set<String> set2 = div.classNames();
        final Object[] arr2 = set2.toArray();
        assertEquals(3, arr2.length);
        assertEquals(""c1"", arr2[0]);
        assertEquals(""c2"", arr2[1]);
        assertEquals(""c3"", arr2[2]);
    }

    @Test
    public void testHashAndEqualsAndValue() {
        // .equals and hashcode are identity. value is content.

        String doc1 = ""<div id=1><p class=one>One</p><p class=one>One</p><p class=one>Two</p><p class=two>One</p></div>"" +
            ""<div id=2><p class=one>One</p><p class=one>One</p><p class=one>Two</p><p class=two>One</p></div>"";

        Document doc = Jsoup.parse(doc1);
        Elements els = doc.select(""p"");

        /*
        for (Element el : els) {
            System.out.println(el.hashCode() + "" - "" + el.outerHtml());
        }

        0 1534787905 - <p class=""one"">One</p>
        1 1534787905 - <p class=""one"">One</p>
        2 1539683239 - <p class=""one"">Two</p>
        3 1535455211 - <p class=""two"">One</p>
        4 1534787905 - <p class=""one"">One</p>
        5 1534787905 - <p class=""one"">One</p>
        6 1539683239 - <p class=""one"">Two</p>
        7 1535455211 - <p class=""two"">One</p>
        */
        assertEquals(8, els.size());
        Element e0 = els.get(0);
        Element e1 = els.get(1);
        Element e2 = els.get(2);
        Element e3 = els.get(3);
        Element e4 = els.get(4);
        Element e5 = els.get(5);
        Element e6 = els.get(6);
        Element e7 = els.get(7);

        assertEquals(e0, e0);
        assertTrue(e0.hasSameValue(e1));
        assertTrue(e0.hasSameValue(e4));
        assertTrue(e0.hasSameValue(e5));
        assertNotEquals(e0, e2);
        assertFalse(e0.hasSameValue(e2));
        assertFalse(e0.hasSameValue(e3));
        assertFalse(e0.hasSameValue(e6));
        assertFalse(e0.hasSameValue(e7));

        assertEquals(e0.hashCode(), e0.hashCode());
        assertNotEquals(e0.hashCode(), (e2.hashCode()));
        assertNotEquals(e0.hashCode(), (e3).hashCode());
        assertNotEquals(e0.hashCode(), (e6).hashCode());
        assertNotEquals(e0.hashCode(), (e7).hashCode());
    }

    @Test
    public void testRelativeUrls() {
        String html = ""<body><a href='./one.html'>One</a> <a href='two.html'>two</a> <a href='../three.html'>Three</a> <a href='//example2.com/four/'>Four</a> <a href='https://example2.com/five/'>Five</a> <a>Six</a> <a href=''>Seven</a>"";
        Document doc = Jsoup.parse(html, ""http://example.com/bar/"");
        Elements els = doc.select(""a"");

        assertEquals(""http://example.com/bar/one.html"", els.get(0).absUrl(""href""));
        assertEquals(""http://example.com/bar/two.html"", els.get(1).absUrl(""href""));
        assertEquals(""http://example.com/three.html"", els.get(2).absUrl(""href""));
        assertEquals(""http://example2.com/four/"", els.get(3).absUrl(""href""));
        assertEquals(""https://example2.com/five/"", els.get(4).absUrl(""href""));
        assertEquals("""", els.get(5).absUrl(""href""));
        assertEquals(""http://example.com/bar/"", els.get(6).absUrl(""href""));
    }

    @Test
    public void testRelativeIdnUrls() {
        String idn = ""https://www.ÊµãËØï.ÊµãËØï/"";
        String idnFoo = idn + ""foo.html?bar"";

        Document doc = Jsoup.parse(""<a href=''>One</a><a href='/bar.html?qux'>Two</a>"", idnFoo);
        Elements els = doc.select(""a"");
        Element one = els.get(0);
        Element two = els.get(1);
        String hrefOne = one.absUrl(""href"");
        String hrefTwo = two.absUrl(""href"");
        assertEquals(idnFoo, hrefOne);
        assertEquals(""https://www.ÊµãËØï.ÊµãËØï/bar.html?qux"", hrefTwo);
    }

    @Test
    public void appendMustCorrectlyMoveChildrenInsideOneParentElement() {
        Document doc = new Document("""");
        Element body = doc.appendElement(""body"");
        body.appendElement(""div1"");
        body.appendElement(""div2"");
        final Element div3 = body.appendElement(""div3"");
        div3.text(""Check"");
        final Element div4 = body.appendElement(""div4"");

        ArrayList<Element> toMove = new ArrayList<>();
        toMove.add(div3);
        toMove.add(div4);

        body.insertChildren(0, toMove);

        String result = doc.toString().replaceAll(""\\s+"", """");
        assertEquals(""<body><div3>Check</div3><div4></div4><div1></div1><div2></div2></body>"", result);
    }

    @Test
    public void testHashcodeIsStableWithContentChanges() {
        Element root = new Element(Tag.valueOf(""root""), """");

        HashSet<Element> set = new HashSet<>();
        // Add root node:
        set.add(root);

        root.appendChild(new Element(Tag.valueOf(""a""), """"));
        assertTrue(set.contains(root));
    }

    @Test
    public void testNamespacedElements() {
        // Namespaces with ns:tag in HTML must be translated to ns|tag in CSS.
        String html = ""<html><body><fb:comments /></body></html>"";
        Document doc = Jsoup.parse(html, ""http://example.com/bar/"");
        Elements els = doc.select(""fb|comments"");
        assertEquals(1, els.size());
        assertEquals(""html > body > fb|comments"", els.get(0).cssSelector());
    }

    @Test
    public void testChainedRemoveAttributes() {
        String html = ""<a one two three four>Text</a>"";
        Document doc = Jsoup.parse(html);
        Element a = doc.select(""a"").first();
        a
            .removeAttr(""zero"")
            .removeAttr(""one"")
            .removeAttr(""two"")
            .removeAttr(""three"")
            .removeAttr(""four"")
            .removeAttr(""five"");
        assertEquals(""<a>Text</a>"", a.outerHtml());
    }

    @Test
    public void testLoopedRemoveAttributes() {
        String html = ""<a one two three four>Text</a><p foo>Two</p>"";
        Document doc = Jsoup.parse(html);
        for (Element el : doc.getAllElements()) {
            el.clearAttributes();
        }

        assertEquals(""<a>Text</a>\n<p>Two</p>"", doc.body().html());
    }

    @Test
    public void testIs() {
        String html = ""<div><p>One <a class=big>Two</a> Three</p><p>Another</p>"";
        Document doc = Jsoup.parse(html);
        Element p = doc.select(""p"").first();

        assertTrue(p.is(""p""));
        assertFalse(p.is(""div""));
        assertTrue(p.is(""p:has(a)""));
        assertFalse(p.is(""a"")); // does not descend
        assertTrue(p.is(""p:first-child""));
        assertFalse(p.is(""p:last-child""));
        assertTrue(p.is(""*""));
        assertTrue(p.is(""div p""));

        Element q = doc.select(""p"").last();
        assertTrue(q.is(""p""));
        assertTrue(q.is(""p ~ p""));
        assertTrue(q.is(""p + p""));
        assertTrue(q.is(""p:last-child""));
        assertFalse(q.is(""p a""));
        assertFalse(q.is(""a""));
    }

    @Test
    public void testEvalMethods() {
        Document doc = Jsoup.parse(""<div><p>One <a class=big>Two</a> Three</p><p>Another</p>"");
        Element p = doc.selectFirst(QueryParser.parse((""p"")));
        assertEquals(""One Three"", p.ownText());

        assertTrue(p.is(QueryParser.parse(""p"")));
        Evaluator aEval = QueryParser.parse(""a"");
        assertFalse(p.is(aEval));

        Element a = p.selectFirst(aEval);
        assertEquals(""div"", a.closest(QueryParser.parse(""div:has( > p)"")).tagName());
        Element body = p.closest(QueryParser.parse(""body""));
        assertEquals(""body"", body.nodeName());
    }

    @Test
    public void testClosest() {
        String html = ""<article>\n"" +
            ""  <div id=div-01>Here is div-01\n"" +
            ""    <div id=div-02>Here is div-02\n"" +
            ""      <div id=div-03>Here is div-03</div>\n"" +
            ""    </div>\n"" +
            ""  </div>\n"" +
            ""</article>"";

        Document doc = Jsoup.parse(html);
        Element el = doc.selectFirst(""#div-03"");
        assertEquals(""Here is div-03"", el.text());
        assertEquals(""div-03"", el.id());

        assertEquals(""div-02"", el.closest(""#div-02"").id());
        assertEquals(el, el.closest(""div div"")); // closest div in a div is itself
        assertEquals(""div-01"", el.closest(""article > div"").id());
        assertEquals(""article"", el.closest("":not(div)"").tagName());
        assertNull(el.closest(""p""));
    }

    @Test
    public void elementByTagName() {
        Element a = new Element(""P"");
        assertEquals(""P"", a.tagName());
    }

    @Test
    public void testChildrenElements() {
        String html = ""<div><p><a>One</a></p><p><a>Two</a></p>Three</div><span>Four</span><foo></foo><img>"";
        Document doc = Jsoup.parse(html);
        Element div = doc.select(""div"").first();
        Element p = doc.select(""p"").first();
        Element span = doc.select(""span"").first();
        Element foo = doc.select(""foo"").first();
        Element img = doc.select(""img"").first();

        Elements docChildren = div.children();
        assertEquals(2, docChildren.size());
        assertEquals(""<p><a>One</a></p>"", docChildren.get(0).outerHtml());
        assertEquals(""<p><a>Two</a></p>"", docChildren.get(1).outerHtml());
        assertEquals(3, div.childNodes().size());
        assertEquals(""Three"", div.childNodes().get(2).outerHtml());

        assertEquals(1, p.children().size());
        assertEquals(""One"", p.children().text());

        assertEquals(0, span.children().size());
        assertEquals(1, span.childNodes().size());
        assertEquals(""Four"", span.childNodes().get(0).outerHtml());

        assertEquals(0, foo.children().size());
        assertEquals(0, foo.childNodes().size());
        assertEquals(0, img.children().size());
        assertEquals(0, img.childNodes().size());
    }

    @Test
    public void testShadowElementsAreUpdated() {
        String html = ""<div><p><a>One</a></p><p><a>Two</a></p>Three</div><span>Four</span><foo></foo><img>"";
        Document doc = Jsoup.parse(html);
        Element div = doc.select(""div"").first();
        Elements els = div.children();
        List<Node> nodes = div.childNodes();

        assertEquals(2, els.size()); // the two Ps
        assertEquals(3, nodes.size()); // the ""Three"" textnode

        Element p3 = new Element(""p"").text(""P3"");
        Element p4 = new Element(""p"").text(""P4"");
        div.insertChildren(1, p3);
        div.insertChildren(3, p4);
        Elements els2 = div.children();

        // first els should not have changed
        assertEquals(2, els.size());
        assertEquals(4, els2.size());

        assertEquals(""<p><a>One</a></p>\n"" +
            ""<p>P3</p>\n"" +
            ""<p><a>Two</a></p>\n"" +
            ""<p>P4</p>Three"", div.html());
        assertEquals(""P3"", els2.get(1).text());
        assertEquals(""P4"", els2.get(3).text());

        p3.after(""<span>Another</span"");

        Elements els3 = div.children();
        assertEquals(5, els3.size());
        assertEquals(""span"", els3.get(2).tagName());
        assertEquals(""Another"", els3.get(2).text());

        assertEquals(""<p><a>One</a></p>\n"" +
            ""<p>P3</p><span>Another</span>\n"" +
            ""<p><a>Two</a></p>\n"" +
            ""<p>P4</p>Three"", div.html());
    }

    @Test
    public void classNamesAndAttributeNameIsCaseInsensitive() {
        String html = ""<p Class='SomeText AnotherText'>One</p>"";
        Document doc = Jsoup.parse(html);
        Element p = doc.select(""p"").first();
        assertEquals(""SomeText AnotherText"", p.className());
        assertTrue(p.classNames().contains(""SomeText""));
        assertTrue(p.classNames().contains(""AnotherText""));
        assertTrue(p.hasClass(""SomeText""));
        assertTrue(p.hasClass(""sometext""));
        assertTrue(p.hasClass(""AnotherText""));
        assertTrue(p.hasClass(""anothertext""));

        Element p1 = doc.select("".SomeText"").first();
        Element p2 = doc.select("".sometext"").first();
        Element p3 = doc.select(""[class=SomeText AnotherText]"").first();
        Element p4 = doc.select(""[Class=SomeText AnotherText]"").first();
        Element p5 = doc.select(""[class=sometext anothertext]"").first();
        Element p6 = doc.select(""[class=SomeText AnotherText]"").first();
        Element p7 = doc.select(""[class^=sometext]"").first();
        Element p8 = doc.select(""[class$=nothertext]"").first();
        Element p9 = doc.select(""[class^=sometext]"").first();
        Element p10 = doc.select(""[class$=AnotherText]"").first();

        assertEquals(""One"", p1.text());
        assertEquals(p1, p2);
        assertEquals(p1, p3);
        assertEquals(p1, p4);
        assertEquals(p1, p5);
        assertEquals(p1, p6);
        assertEquals(p1, p7);
        assertEquals(p1, p8);
        assertEquals(p1, p9);
        assertEquals(p1, p10);
    }

    @Test
    public void testAppendTo() {
        String parentHtml = ""<div class='a'></div>"";
        String childHtml = ""<div class='b'></div><p>Two</p>"";

        Document parentDoc = Jsoup.parse(parentHtml);
        Element parent = parentDoc.body();
        Document childDoc = Jsoup.parse(childHtml);

        Element div = childDoc.select(""div"").first();
        Element p = childDoc.select(""p"").first();
        Element appendTo1 = div.appendTo(parent);
        assertEquals(div, appendTo1);

        Element appendTo2 = p.appendTo(div);
        assertEquals(p, appendTo2);

        assertEquals(""<div class=\""a\""></div>\n<div class=\""b\"">\n <p>Two</p>\n</div>"", parentDoc.body().html());
        assertEquals("""", childDoc.body().html()); // got moved out
    }

    @Test
    public void testNormalizesNbspInText() {
        String escaped = ""You can't always get what you&nbsp;want."";
        String withNbsp = ""You can't always get what you¬†want.""; // there is an nbsp char in there
        Document doc = Jsoup.parse(""<p>"" + escaped);
        Element p = doc.select(""p"").first();
        assertEquals(""You can't always get what you want."", p.text()); // text is normalized

        assertEquals(""<p>"" + escaped + ""</p>"", p.outerHtml()); // html / whole text keeps &nbsp;
        assertEquals(withNbsp, p.textNodes().get(0).getWholeText());
        assertEquals(160, withNbsp.charAt(29));

        Element matched = doc.select(""p:contains(get what you want)"").first();
        assertEquals(""p"", matched.nodeName());
        assertTrue(matched.is("":containsOwn(get what you want)""));
    }

    @Test
    public void testNormalizesInvisiblesInText() {
        String escaped = ""This&shy;is&#x200b;one&shy;long&shy;word"";
        String decoded = ""This\u00ADis\u200Bone\u00ADlong\u00ADword""; // browser would not display those soft hyphens / other chars, so we don't want them in the text

        Document doc = Jsoup.parse(""<p>"" + escaped);
        Element p = doc.select(""p"").first();
        doc.outputSettings().charset(""ascii""); // so that the outer html is easier to see with escaped invisibles
        assertEquals(""Thisisonelongword"", p.text()); // text is normalized
        assertEquals(""<p>"" + escaped + ""</p>"", p.outerHtml()); // html / whole text keeps &shy etc;
        assertEquals(decoded, p.textNodes().get(0).getWholeText());

        Element matched = doc.select(""p:contains(Thisisonelongword)"").first(); // really just oneloneword, no invisibles
        assertEquals(""p"", matched.nodeName());
        assertTrue(matched.is("":containsOwn(Thisisonelongword)""));

    }

    @Test
    public void testRemoveBeforeIndex() {
        Document doc = Jsoup.parse(
            ""<html><body><div><p>before1</p><p>before2</p><p>XXX</p><p>after1</p><p>after2</p></div></body></html>"",
            """");
        Element body = doc.select(""body"").first();
        Elements elems = body.select(""p:matchesOwn(XXX)"");
        Element xElem = elems.first();
        Elements beforeX = xElem.parent().getElementsByIndexLessThan(xElem.elementSiblingIndex());

        for (Element p : beforeX) {
            p.remove();
        }

        assertEquals(""<body><div><p>XXX</p><p>after1</p><p>after2</p></div></body>"", TextUtil.stripNewlines(body.outerHtml()));
    }

    @Test
    public void testRemoveAfterIndex() {
        Document doc2 = Jsoup.parse(
            ""<html><body><div><p>before1</p><p>before2</p><p>XXX</p><p>after1</p><p>after2</p></div></body></html>"",
            """");
        Element body = doc2.select(""body"").first();
        Elements elems = body.select(""p:matchesOwn(XXX)"");
        Element xElem = elems.first();
        Elements afterX = xElem.parent().getElementsByIndexGreaterThan(xElem.elementSiblingIndex());

        for (Element p : afterX) {
            p.remove();
        }

        assertEquals(""<body><div><p>before1</p><p>before2</p><p>XXX</p></div></body>"", TextUtil.stripNewlines(body.outerHtml()));
    }

    @Test
    public void whiteSpaceClassElement() {
        Tag tag = Tag.valueOf(""a"");
        Attributes attribs = new Attributes();
        Element el = new Element(tag, """", attribs);

        attribs.put(""class"", ""abc "");
        boolean hasClass = el.hasClass(""ab"");
        assertFalse(hasClass);
    }

    @Test
    public void testNextElementSiblingAfterClone() {
        // via https://github.com/jhy/jsoup/issues/951
        String html = ""<!DOCTYPE html><html lang=\""en\""><head></head><body><div>Initial element</div></body></html>"";
        String expectedText = ""New element"";
        String cloneExpect = ""New element in clone"";

        Document original = Jsoup.parse(html);
        Document clone = original.clone();

        Element originalElement = original.body().child(0);
        originalElement.after(""<div>"" + expectedText + ""</div>"");
        Element originalNextElementSibling = originalElement.nextElementSibling();
        Element originalNextSibling = (Element) originalElement.nextSibling();
        assertEquals(expectedText, originalNextElementSibling.text());
        assertEquals(expectedText, originalNextSibling.text());

        Element cloneElement = clone.body().child(0);
        cloneElement.after(""<div>"" + cloneExpect + ""</div>"");
        Element cloneNextElementSibling = cloneElement.nextElementSibling();
        Element cloneNextSibling = (Element) cloneElement.nextSibling();
        assertEquals(cloneExpect, cloneNextElementSibling.text());
        assertEquals(cloneExpect, cloneNextSibling.text());
    }

    @Test
    public void testRemovingEmptyClassAttributeWhenLastClassRemoved() {
        // https://github.com/jhy/jsoup/issues/947
        Document doc = Jsoup.parse(""<img class=\""one two\"" />"");
        Element img = doc.select(""img"").first();
        img.removeClass(""one"");
        img.removeClass(""two"");
        assertFalse(doc.body().html().contains(""class=\""\""""));
    }

    @Test
    public void booleanAttributeOutput() {
        Document doc = Jsoup.parse(""<img src=foo noshade='' nohref async=async autofocus=false>"");
        Element img = doc.selectFirst(""img"");

        assertEquals(""<img src=\""foo\"" noshade nohref async autofocus=\""false\"">"", img.outerHtml());
    }

    @Test
    public void textHasSpaceAfterBlockTags() {
        Document doc = Jsoup.parse(""<div>One</div>Two"");
        assertEquals(""One Two"", doc.text());
    }

    @Test
    public void textHasSpaceBetweenDivAndCenterTags() {
        Document doc = Jsoup.parse(""<div>One</div><div>Two</div><center>Three</center><center>Four</center>"");
        assertEquals(""One Two Three Four"", doc.text());
    }

    @Test
    public void testNextElementSiblings() {
        Document doc = Jsoup.parse(""<ul id='ul'>"" +
            ""<li id='a'>a</li>"" +
            ""<li id='b'>b</li>"" +
            ""<li id='c'>c</li>"" +
            ""</ul> Not An Element but a node"" +
            ""<div id='div'>"" +
            ""<li id='d'>d</li>"" +
            ""</div>"");

        Element element = doc.getElementById(""a"");
        Elements elementSiblings = element.nextElementSiblings();
        assertNotNull(elementSiblings);
        assertEquals(2, elementSiblings.size());
        assertEquals(""b"", elementSiblings.get(0).id());
        assertEquals(""c"", elementSiblings.get(1).id());

        Element element1 = doc.getElementById(""b"");
        List<Element> elementSiblings1 = element1.nextElementSiblings();
        assertNotNull(elementSiblings1);
        assertEquals(1, elementSiblings1.size());
        assertEquals(""c"", elementSiblings1.get(0).id());

        Element element2 = doc.getElementById(""c"");
        List<Element> elementSiblings2 = element2.nextElementSiblings();
        assertEquals(0, elementSiblings2.size());

        Element ul = doc.getElementById(""ul"");
        List<Element> elementSiblings3 = ul.nextElementSiblings();
        assertNotNull(elementSiblings3);
        assertEquals(1, elementSiblings3.size());
        assertEquals(""div"", elementSiblings3.get(0).id());

        Element div = doc.getElementById(""div"");
        List<Element> elementSiblings4 = div.nextElementSiblings();
        assertEquals(0, elementSiblings4.size());
    }

    @Test
    public void testPreviousElementSiblings() {
        Document doc = Jsoup.parse(""<ul id='ul'>"" +
            ""<li id='a'>a</li>"" +
            ""<li id='b'>b</li>"" +
            ""<li id='c'>c</li>"" +
            ""</ul>"" +
            ""<div id='div'>"" +
            ""<li id='d'>d</li>"" +
            ""</div>"");

        Element element = doc.getElementById(""b"");
        Elements elementSiblings = element.previousElementSiblings();
        assertNotNull(elementSiblings);
        assertEquals(1, elementSiblings.size());
        assertEquals(""a"", elementSiblings.get(0).id());

        Element element1 = doc.getElementById(""a"");
        List<Element> elementSiblings1 = element1.previousElementSiblings();
        assertEquals(0, elementSiblings1.size());

        Element element2 = doc.getElementById(""c"");
        List<Element> elementSiblings2 = element2.previousElementSiblings();
        assertNotNull(elementSiblings2);
        assertEquals(2, elementSiblings2.size());
        assertEquals(""b"", elementSiblings2.get(0).id());
        assertEquals(""a"", elementSiblings2.get(1).id());

        Element ul = doc.getElementById(""ul"");
        List<Element> elementSiblings3 = ul.previousElementSiblings();
        assertEquals(0, elementSiblings3.size());
    }

    @Test
    public void testClearAttributes() {
        Element el = new Element(""a"").attr(""href"", ""http://example.com"").text(""Hello"");
        assertEquals(""<a href=\""http://example.com\"">Hello</a>"", el.outerHtml());
        Element el2 = el.clearAttributes(); // really just force testing the return type is Element
        assertSame(el, el2);
        assertEquals(""<a>Hello</a>"", el2.outerHtml());
    }

    @Test
    public void testRemoveAttr() {
        Element el = new Element(""a"")
            .attr(""href"", ""http://example.com"")
            .attr(""id"", ""1"")
            .text(""Hello"");
        assertEquals(""<a href=\""http://example.com\"" id=\""1\"">Hello</a>"", el.outerHtml());
        Element el2 = el.removeAttr(""href""); // really just force testing the return type is Element
        assertSame(el, el2);
        assertEquals(""<a id=\""1\"">Hello</a>"", el2.outerHtml());
    }

    @Test
    public void testRoot() {
        Element el = new Element(""a"");
        el.append(""<span>Hello</span>"");
        assertEquals(""<a><span>Hello</span></a>"", el.outerHtml());
        Element span = el.selectFirst(""span"");
        assertNotNull(span);
        Element el2 = span.root();
        assertSame(el, el2);

        Document doc = Jsoup.parse(""<div><p>One<p>Two<p>Three"");
        Element div = doc.selectFirst(""div"");
        assertSame(doc, div.root());
        assertSame(doc, div.ownerDocument());
    }

    @Test
    public void testTraverse() {
        Document doc = Jsoup.parse(""<div><p>One<p>Two<p>Three"");
        Element div = doc.selectFirst(""div"");
        assertNotNull(div);
        final AtomicInteger counter = new AtomicInteger(0);

        Element div2 = div.traverse(new NodeVisitor() {

            @Override
            public void head(Node node, int depth) {
                counter.incrementAndGet();
            }

            @Override
            public void tail(Node node, int depth) {

            }
        });

        assertEquals(7, counter.get());
        assertEquals(div2, div);
    }

    @Test void testTraverseLambda() {
        Document doc = Jsoup.parse(""<div><p>One<p>Two<p>Three"");
        Element div = doc.selectFirst(""div"");
        assertNotNull(div);
        final AtomicInteger counter = new AtomicInteger(0);

        Element div2 = div.traverse((node, depth) -> counter.incrementAndGet());

        assertEquals(7, counter.get());
        assertEquals(div2, div);
    }

    @Test
    public void testFilterCallReturnsElement() {
        // doesn't actually test the filter so much as the return type for Element. See node.nodeFilter for an actual test
        Document doc = Jsoup.parse(""<div><p>One<p>Two<p>Three"");
        Element div = doc.selectFirst(""div"");
        assertNotNull(div);
        Element div2 = div.filter(new NodeFilter() {
            @Override
            public FilterResult head(Node node, int depth) {
                return FilterResult.CONTINUE;
            }

            @Override
            public FilterResult tail(Node node, int depth) {
                return FilterResult.CONTINUE;
            }
        });

        assertSame(div, div2);
    }

    @Test void testFilterAsLambda() {
        Document doc = Jsoup.parse(""<div><p>One<p id=2>Two<p>Three"");
        doc.filter((node, depth) -> node.attr(""id"").equals(""2"")
            ? NodeFilter.FilterResult.REMOVE
            : NodeFilter.FilterResult.CONTINUE);

        assertEquals(""<div><p>One</p><p>Three</p></div>"", TextUtil.stripNewlines(doc.body().html()));
    }

    @Test void testForEach() {
        Document doc = Jsoup.parse(""<div><p>Hello</p></div><div>There</div><div id=1>Gone<p></div>"");
        doc.forEach(el -> {
            if (el.id().equals(""1""))
                el.remove();
            else if (el.text().equals(""There"")) {
                el.text(""There Now"");
                el.append(""<p>Another</p>"");
            }
        });
        assertEquals(""<div><p>Hello</p></div><div>There Now<p>Another</p></div>"", TextUtil.stripNewlines(doc.body().html()));
    }

    @Test
    public void doesntDeleteZWJWhenNormalizingText() {
        String text = ""\uD83D\uDC69\u200D\uD83D\uDCBB\uD83E\uDD26\uD83C\uDFFB\u200D\u2642\uFE0F"";

        Document doc = Jsoup.parse(""<p>"" + text + ""</p><div>One&zwj;Two</div>"");
        Element p = doc.selectFirst(""p"");
        Element d = doc.selectFirst(""div"");

        assertEquals(12, p.text().length());
        assertEquals(text, p.text());
        assertEquals(7, d.text().length());
        assertEquals(""One\u200DTwo"", d.text());
        Element found = doc.selectFirst(""div:contains(One\u200DTwo)"");
        assertTrue(found.hasSameValue(d));
    }

    @Test
    public void testReparentSeperateNodes() {
        String html = ""<div><p>One<p>Two"";
        Document doc = Jsoup.parse(html);
        Element new1 = new Element(""p"").text(""Three"");
        Element new2 = new Element(""p"").text(""Four"");

        doc.body().insertChildren(-1, new1, new2);
        assertEquals(""<div><p>One</p><p>Two</p></div><p>Three</p><p>Four</p>"", TextUtil.stripNewlines(doc.body().html()));

        // note that these get moved from the above - as not copied
        doc.body().insertChildren(0, new1, new2);
        assertEquals(""<p>Three</p><p>Four</p><div><p>One</p><p>Two</p></div>"", TextUtil.stripNewlines(doc.body().html()));

        doc.body().insertChildren(0, new2.clone(), new1.clone());
        assertEquals(""<p>Four</p><p>Three</p><p>Three</p><p>Four</p><div><p>One</p><p>Two</p></div>"", TextUtil.stripNewlines(doc.body().html()));

        // shifted to end
        doc.body().appendChild(new1);
        assertEquals(""<p>Four</p><p>Three</p><p>Four</p><div><p>One</p><p>Two</p></div><p>Three</p>"", TextUtil.stripNewlines(doc.body().html()));
    }

    @Test
    public void testNotActuallyAReparent() {
        // prep
        String html = ""<div>"";
        Document doc = Jsoup.parse(html);
        Element div = doc.selectFirst(""div"");
        Element new1 = new Element(""p"").text(""One"");
        Element new2 = new Element(""p"").text(""Two"");
        div.addChildren(new1, new2);

        assertEquals(""<div><p>One</p><p>Two</p></div>"", TextUtil.stripNewlines(div.outerHtml()));

        // and the issue setup:
        Element new3 = new Element(""p"").text(""Three"");
        Element wrap = new Element(""nav"");
        wrap.addChildren(0, new1, new3);

        assertEquals(""<nav><p>One</p><p>Three</p></nav>"", TextUtil.stripNewlines(wrap.outerHtml()));
        div.addChildren(wrap);
        // now should be that One moved into wrap, leaving Two in div.

        assertEquals(""<div><p>Two</p><nav><p>One</p><p>Three</p></nav></div>"", TextUtil.stripNewlines(div.outerHtml()));
        assertEquals(""<div><p>Two</p><nav><p>One</p><p>Three</p></nav></div>"", TextUtil.stripNewlines(div.outerHtml()));
    }

    @Test
    public void testChildSizeWithMixedContent() {
        Document doc = Jsoup.parse(""<table><tbody>\n<tr>\n<td>15:00</td>\n<td>sport</td>\n</tr>\n</tbody></table>"");
        Element row = doc.selectFirst(""table tbody tr"");
        assertEquals(2, row.childrenSize());
        assertEquals(5, row.childNodeSize());
    }

    @Test
    public void isBlock() {
        String html = ""<div><p><span>Hello</span>"";
        Document doc = Jsoup.parse(html);
        assertTrue(doc.selectFirst(""div"").isBlock());
        assertTrue(doc.selectFirst(""p"").isBlock());
        assertFalse(doc.selectFirst(""span"").isBlock());
    }

    @Test
    public void testScriptTextHtmlSetAsData() {
        String src = ""var foo = 5 < 2;\nvar bar = 1 && 2;"";
        String html = ""<script>"" + src + ""</script>"";
        Document doc = Jsoup.parse(html);
        Element el = doc.selectFirst(""script"");
        assertNotNull(el);

        validateScriptContents(src, el);

        src = ""var foo = 4 < 2;\nvar bar > 1 && 2;"";
        el.html(src);
        validateScriptContents(src, el);

        // special case for .text (in HTML; in XML will just be regular text)
        el.text(src);
        validateScriptContents(src, el);

        // XML, no special treatment, get escaped correctly
        Document xml = Parser.xmlParser().parseInput(html, """");
        Element xEl = xml.selectFirst(""script"");
        assertNotNull(xEl);
        src = ""var foo = 5 < 2;\nvar bar = 1 && 2;"";
        String escaped = ""var foo = 5 &lt; 2;\nvar bar = 1 &amp;&amp; 2;"";
        validateXmlScriptContents(xEl);
        xEl.text(src);
        validateXmlScriptContents(xEl);
        xEl.html(src);
        validateXmlScriptContents(xEl);

        assertEquals(""<script>var foo = 4 < 2;\nvar bar > 1 && 2;</script>"", el.outerHtml());
        assertEquals(""<script>"" + escaped + ""</script>"", xEl.outerHtml()); // escaped in xml as no special treatment

    }

    @Test
    public void testShallowCloneToString() {
        // https://github.com/jhy/jsoup/issues/1410
        Document doc = Jsoup.parse(""<p><i>Hello</i></p>"");
        Element p = doc.selectFirst(""p"");
        Element i = doc.selectFirst(""i"");
        String pH = p.shallowClone().toString();
        String iH = i.shallowClone().toString();

        assertEquals(""<p></p>"", pH); // shallow, so no I
        assertEquals(""<i></i>"", iH);

        assertEquals(p.outerHtml(), p.toString());
        assertEquals(i.outerHtml(), i.toString());
    }

    @Test
    public void styleHtmlRoundTrips() {
        String styleContents = ""foo < bar > qux {color:white;}"";
        String html = ""<head><style>"" + styleContents + ""</style></head>"";
        Document doc = Jsoup.parse(html);

        Element head = doc.head();
        Element style = head.selectFirst(""style"");
        assertNotNull(style);
        assertEquals(styleContents, style.html());
        style.html(styleContents);
        assertEquals(styleContents, style.html());
        assertEquals("""", style.text());
        style.text(styleContents); // pushes the HTML, not the Text
        assertEquals("""", style.text());
        assertEquals(styleContents, style.html());
    }

    @Test
    public void moveChildren() {
        Document doc = Jsoup.parse(""<div><p>One<p>Two<p>Three</div><div></div>"");
        Elements divs = doc.select(""div"");
        Element a = divs.get(0);
        Element b = divs.get(1);

        b.insertChildren(-1, a.childNodes());

        assertEquals(""<div></div>\n<div>\n <p>One</p>\n <p>Two</p>\n <p>Three</p>\n</div>"",
            doc.body().html());
    }

    @Test
    public void moveChildrenToOuter() {
        Document doc = Jsoup.parse(""<div><p>One<p>Two<p>Three</div><div></div>"");
        Elements divs = doc.select(""div"");
        Element a = divs.get(0);
        Element b = doc.body();

        b.insertChildren(-1, a.childNodes());

        assertEquals(""<div></div>\n<div></div>\n<p>One</p>\n<p>Two</p>\n<p>Three</p>"",
            doc.body().html());
    }

    @Test
    public void appendChildren() {
        Document doc = Jsoup.parse(""<div><p>One<p>Two<p>Three</div><div><p>Four</div>"");
        Elements divs = doc.select(""div"");
        Element a = divs.get(0);
        Element b = divs.get(1);

        b.appendChildren(a.childNodes());

        assertEquals(""<div></div>\n<div>\n <p>Four</p>\n <p>One</p>\n <p>Two</p>\n <p>Three</p>\n</div>"",
            doc.body().html());
    }

    @Test
    public void prependChildren() {
        Document doc = Jsoup.parse(""<div><p>One<p>Two<p>Three</div><div><p>Four</div>"");
        Elements divs = doc.select(""div"");
        Element a = divs.get(0);
        Element b = divs.get(1);

        b.prependChildren(a.childNodes());

        assertEquals(""<div></div>\n<div>\n <p>One</p>\n <p>Two</p>\n <p>Three</p>\n <p>Four</p>\n</div>"",
            doc.body().html());
    }

    @Test
    public void loopMoveChildren() {
        Document doc = Jsoup.parse(""<div><p>One<p>Two<p>Three</div><div><p>Four</div>"");
        Elements divs = doc.select(""div"");
        Element a = divs.get(0);
        Element b = divs.get(1);

        Element outer = b.parent();
        assertNotNull(outer);
        for (Node node : a.childNodes()) {
            outer.appendChild(node);
        }

        assertEquals(""<div></div>\n<div>\n <p>Four</p>\n</div>\n<p>One</p>\n<p>Two</p>\n<p>Three</p>"",
            doc.body().html());
    }

    @Test
    public void accessorsDoNotVivifyAttributes() throws NoSuchFieldException, IllegalAccessException {
        // internally, we don't want to create empty Attribute objects unless actually used for something
        Document doc = Jsoup.parse(""<div><p><a href=foo>One</a>"");
        Element div = doc.selectFirst(""div"");
        Element p = doc.selectFirst(""p"");
        Element a = doc.selectFirst(""a"");

        // should not create attributes
        assertEquals("""", div.attr(""href""));
        p.removeAttr(""href"");

        Elements hrefs = doc.select(""[href]"");
        assertEquals(1, hrefs.size());

        assertFalse(div.hasAttributes());
        assertFalse(p.hasAttributes());
        assertTrue(a.hasAttributes());
    }

    @Test
    public void childNodesAccessorDoesNotVivify() {
        Document doc = Jsoup.parse(""<p></p>"");
        Element p = doc.selectFirst(""p"");
        assertFalse(p.hasChildNodes());

        assertEquals(0, p.childNodeSize());
        assertEquals(0, p.childrenSize());

        List<Node> childNodes = p.childNodes();
        assertEquals(0, childNodes.size());

        Elements children = p.children();
        assertEquals(0, children.size());

        assertFalse(p.hasChildNodes());
    }

    @Test void emptyChildrenElementsIsModifiable() {
        // using unmodifiable empty in childElementList as short circuit, but people may be modifying Elements.
        Element p = new Element(""p"");
        Elements els = p.children();
        assertEquals(0, els.size());
        els.add(new Element(""a""));
        assertEquals(1, els.size());
    }

    @Test public void attributeSizeDoesNotAutoVivify() {
        Document doc = Jsoup.parse(""<p></p>"");
        Element p = doc.selectFirst(""p"");
        assertNotNull(p);
        assertFalse(p.hasAttributes());
        assertEquals(0, p.attributesSize());
        assertFalse(p.hasAttributes());

        p.attr(""foo"", ""bar"");
        assertEquals(1, p.attributesSize());
        assertTrue(p.hasAttributes());

        p.removeAttr(""foo"");
        assertEquals(0, p.attributesSize());
    }

    @Test void clonedElementsHaveOwnerDocsAndIndependentSettings() {
        // https://github.com/jhy/jsoup/issues/763
        Document doc = Jsoup.parse(""<div>Text</div><div>Two</div>"");
        doc.outputSettings().prettyPrint(false);
        Element div = doc.selectFirst(""div"");
        assertNotNull(div);
        Node text = div.childNode(0);
        assertNotNull(text);

        Element divClone = div.clone();
        Document docClone = divClone.ownerDocument();
        assertNotNull(docClone);
        assertFalse(docClone.outputSettings().prettyPrint());
        assertNotSame(doc, docClone);
        assertSame(docClone, divClone.childNode(0).ownerDocument());
        // the cloned text has same owner doc as the cloned div

        doc.outputSettings().prettyPrint(true);
        assertTrue(doc.outputSettings().prettyPrint());
        assertFalse(docClone.outputSettings().prettyPrint());
        assertEquals(1, docClone.children().size()); // check did not get the second div as the owner's children
        assertEquals(divClone, docClone.child(0)); // note not the head or the body -- not normalized
    }

    private static Stream<Document.OutputSettings> testOutputSettings() {
        return Stream.of(
            new Document.OutputSettings().prettyPrint(true).indentAmount(4),
            new Document.OutputSettings().prettyPrint(true).indentAmount(1),
            new Document.OutputSettings().prettyPrint(true).indentAmount(4).outline(true),
            new Document.OutputSettings().prettyPrint(false)
        );
    }

    @ParameterizedTest
    @MethodSource(""testOutputSettings"")
    void prettySerializationRoundTrips(Document.OutputSettings settings) {
        // https://github.com/jhy/jsoup/issues/1688
        // tests that repeated html() and parse() does not accumulate errant spaces / newlines
        Document doc = Jsoup.parse(""<div>\nFoo\n<p>\nBar\nqux</p></div>\n<script>\n alert('Hello!');\n</script>"");
        doc.outputSettings(settings);
        String html = doc.html();
        Document doc2 = Jsoup.parse(html);
        doc2.outputSettings(settings);
        String html2 = doc2.html();

        assertEquals(html, html2);
    }

    @Test void prettyPrintScriptsDoesNotGrowOnRepeat() {
        Document doc = Jsoup.parse(""<div>\nFoo\n<p>\nBar\nqux</p></div>\n<script>\n alert('Hello!');\n</script>"");
        Document.OutputSettings settings = doc.outputSettings();
        settings
            .prettyPrint(true)
            .outline(true)
            .indentAmount(4)
            ;

        String html = doc.html();
        Document doc2 = Jsoup.parse(html);
        doc2.outputSettings(settings);
        String html2 = doc2.html();
        assertEquals(html, html2);
    }

    @Test void elementBrText() {
        // testcase for https://github.com/jhy/jsoup/issues/1437
        String html = ""<p>Hello<br>World</p>"";
        Document doc = Jsoup.parse(html);
        Element p = doc.select(""p"").first();
        assertNotNull(p);
        assertEquals(html, p.outerHtml());
        assertEquals(""Hello World"", p.text());
        assertEquals(""Hello\nWorld"", p.wholeText());
    }

    @Test void preformatFlowsToChildTextNodes() {
        // https://github.com/jhy/jsoup/issues/1776
        String html = ""<div><pre>One\n<span>\nTwo</span>\n <span>  \nThree</span>\n <span>Four <span>Five</span>\n  Six\n</pre>"";
        Document doc = Jsoup.parse(html);
        doc.outputSettings().indentAmount(2).prettyPrint(true);

        Element div = doc.selectFirst(""div"");
        assertNotNull(div);
        String actual = div.outerHtml();
        String expect = ""<div>\n"" +
            ""  <pre>One\n"" +
            ""<span>\n"" +
            ""Two</span>\n"" +
            "" <span>  \n"" +
            ""Three</span>\n"" +
            "" <span>Four <span>Five</span>\n"" +
            ""  Six\n"" +
            ""</span></pre>\n"" +
            ""</div>"";
        assertEquals(expect, actual);

        String expectText = ""One\n"" +
            ""\n"" +
            ""Two\n"" +
            ""   \n"" +
            ""Three\n"" +
            "" Four Five\n"" +
            ""  Six\n"";
        assertEquals(expectText, div.wholeText());

        String expectOwn = ""One\n"" +
            ""\n"" +
            "" \n"" +
            "" "";
        assertEquals(expectOwn, div.child(0).wholeOwnText());
    }

    @Test void testExpectFirst() {
        Document doc = Jsoup.parse(""<p>One</p><p>Two <span>Three</span> <span>Four</span>"");

        Element span = doc.expectFirst(""span"");
        assertEquals(""Three"", span.text());

        assertNull(doc.selectFirst(""div""));
        boolean threw = false;
        try {
            Element div = doc.expectFirst(""div"");
        } catch (IllegalArgumentException e) {
            threw = true;
        }
        assertTrue(threw);
    }

    @Test void testExpectFirstMessage() {
        Document doc = Jsoup.parse(""<p>One</p><p>Two <span>Three</span> <span>Four</span>"");
        boolean threw = false;
        Element p = doc.expectFirst(""P"");
        try {
            Element span = p.expectFirst(""span.doesNotExist"");
        } catch (ValidationException e) {
            threw = true;
            assertEquals(""No elements matched the query 'span.doesNotExist' on element 'p'."", e.getMessage());
        }
        assertTrue(threw);
    }

    @Test void testExpectFirstMessageDoc() {
        Document doc = Jsoup.parse(""<p>One</p><p>Two <span>Three</span> <span>Four</span>"");
        boolean threw = false;
        Element p = doc.expectFirst(""P"");
        try {
            Element span = doc.expectFirst(""span.doesNotExist"");
        } catch (ValidationException e) {
            threw = true;
            assertEquals(""No elements matched the query 'span.doesNotExist' in the document."", e.getMessage());
        }
        assertTrue(threw);
    }

    @Test void spanRunsMaintainSpace() {
        // https://github.com/jhy/jsoup/issues/1787
        Document doc = Jsoup.parse(""<p><span>One</span>\n<span>Two</span>\n<span>Three</span></p>"");
        String text = ""One Two Three"";
        Element body = doc.body();
        assertEquals(text, body.text());

        Element p = doc.expectFirst(""p"");
        String html = p.html();
        p.html(html);
        assertEquals(text, body.text());

        assertEquals(""<p><span>One</span> <span>Two</span> <span>Three</span></p>"", body.html());
    }

    @Test void doctypeIsPrettyPrinted() {
        // resolves underlying issue raised in https://github.com/jhy/jsoup/pull/1664
        Document doc1 = Jsoup.parse(""<!--\nlicense\n-->\n \n<!doctype html>\n<html>"");
        Document doc2 = Jsoup.parse(""\n  <!doctype html><html>"");
        Document doc3 = Jsoup.parse(""<!doctype html>\n<html>"");
        Document doc4 = Jsoup.parse(""\n<!doctype html>\n<html>"");
        Document doc5 = Jsoup.parse(""\n<!--\n comment \n -->  <!doctype html>\n<html>"");
        Document doc6 = Jsoup.parse(""<!--\n comment \n -->  <!doctype html>\n<html>"");

        assertEquals(""<!--\nlicense\n-->\n<!doctype html>\n<html>\n <head></head>\n <body></body>\n</html>"", doc1.html());
        doc1.outputSettings().prettyPrint(false);
        assertEquals(""<!--\nlicense\n--><!doctype html>\n<html><head></head><body></body></html>"", doc1.html());
        // note that the whitespace between the comment and the doctype is not retained, in Initial state

        assertEquals(""<!doctype html>\n<html>\n <head></head>\n <body></body>\n</html>"", doc2.html());
        assertEquals(""<!doctype html>\n<html>\n <head></head>\n <body></body>\n</html>"", doc3.html());
        assertEquals(""<!doctype html>\n<html>\n <head></head>\n <body></body>\n</html>"", doc4.html());
        assertEquals(""<!--\n comment \n -->\n<!doctype html>\n<html>\n <head></head>\n <body></body>\n</html>"", doc5.html());
        assertEquals(""<!--\n comment \n -->\n<!doctype html>\n<html>\n <head></head>\n <body></body>\n</html>"", doc6.html());
    }

    @Test void textnodeInBlockIndent() {
        String html =""<div>\n{{ msg }} \n </div>\n<div>\n{{ msg }} \n </div>"";
        Document doc = Jsoup.parse(html);
        assertEquals(""<div>\n {{ msg }}\n</div>\n<div>\n {{ msg }}\n</div>"", doc.body().html());
    }

    @Test void stripTrailing() {
        String html = ""<p> This <span>is </span>fine. </p>"";
        Document doc = Jsoup.parse(html);
        assertEquals(""<p>This <span>is </span>fine.</p>"", doc.body().html());
    }

    @Test void elementIndentAndSpaceTrims() {
        String html = ""<body><div> <p> One Two </p> <a>  Hello </a><p>\nSome text \n</p>\n </div>"";
        Document doc = Jsoup.parse(html);
        assertEquals(""<div>\n"" +
            "" <p>One Two</p> <a> Hello </a>\n"" +
            "" <p>Some text</p>\n"" +
            ""</div>"", doc.body().html());
    }

    @Test void divAInlineable() {
        String html = ""<body><div> <a>Text</a>"";
        Document doc = Jsoup.parse(html);
        assertEquals(""<div><a>Text</a>\n</div>"", doc.body().html());
    }
}"
jhy/jsoup,src/main/java/org/jsoup/nodes/Document.java,"package org.jsoup.nodes;

import org.jsoup.Connection;
import org.jsoup.Jsoup;
import org.jsoup.helper.DataUtil;
import org.jsoup.helper.Validate;
import org.jsoup.internal.StringUtil;
import org.jsoup.parser.ParseSettings;
import org.jsoup.parser.Parser;
import org.jsoup.parser.Tag;
import org.jsoup.select.Elements;
import org.jsoup.select.Evaluator;

import javax.annotation.Nullable;
import java.nio.charset.Charset;
import java.nio.charset.CharsetEncoder;
import java.util.ArrayList;
import java.util.List;

/**
 A HTML Document.

 @author Jonathan Hedley, jonathan@hedley.net */
public class Document extends Element {
    private @Nullable Connection connection; // the connection this doc was fetched from, if any
    private OutputSettings outputSettings = new OutputSettings();
    private Parser parser; // the parser used to parse this document
    private QuirksMode quirksMode = QuirksMode.noQuirks;
    private final String location;
    private boolean updateMetaCharset = false;

    /**
     Create a new, empty Document.
     @param baseUri base URI of document
     @see org.jsoup.Jsoup#parse
     @see #createShell
     */
    public Document(String baseUri) {
        super(Tag.valueOf(""#root"", ParseSettings.htmlDefault), baseUri);
        this.location = baseUri;
        this.parser = Parser.htmlParser(); // default, but overridable
    }

    /**
     Create a valid, empty shell of a document, suitable for adding more elements to.
     @param baseUri baseUri of document
     @return document with html, head, and body elements.
     */
    public static Document createShell(String baseUri) {
        Validate.notNull(baseUri);

        Document doc = new Document(baseUri);
        doc.parser = doc.parser();
        Element html = doc.appendElement(""html"");
        html.appendElement(""head"");
        html.appendElement(""body"");

        return doc;
    }

    /**
     * Get the URL this Document was parsed from. If the starting URL is a redirect,
     * this will return the final URL from which the document was served from.
     * <p>Will return an empty string if the location is unknown (e.g. if parsed from a String).
     * @return location
     */
    public String location() {
        return location;
    }

    /**
     Returns the Connection (Request/Response) object that was used to fetch this document, if any; otherwise, a new
     default Connection object. This can be used to continue a session, preserving settings and cookies, etc.
     @return the Connection (session) associated with this Document, or an empty one otherwise.
     @see Connection#newRequest()
     */
    public Connection connection() {
        if (connection == null)
            return Jsoup.newSession();
        else
            return connection;
    }

    /**
     * Returns this Document's doctype.
     * @return document type, or null if not set
     */
    public @Nullable DocumentType documentType() {
        for (Node node : childNodes) {
            if (node instanceof DocumentType)
                return (DocumentType) node;
            else if (!(node instanceof LeafNode)) // scans forward across comments, text, processing instructions etc
                break;
        }
        return null;
        // todo - add a set document type?
    }

    /**
     Find the root HTML element, or create it if it doesn't exist.
     @return the root HTML element.
     */
    private Element htmlEl() {
        for (Element el: childElementsList()) {
            if (el.normalName().equals(""html""))
                return el;
        }
        return appendElement(""html"");
    }

    /**
     Get this document's {@code head} element.
     <p>
     As a side-effect, if this Document does not already have a HTML structure, it will be created. If you do not want
     that, use {@code #selectFirst(""head"")} instead.

     @return {@code head} element.
     */
    public Element head() {
        Element html = htmlEl();
        for (Element el: html.childElementsList()) {
            if (el.normalName().equals(""head""))
                return el;
        }
        return html.prependElement(""head"");
    }

    /**
     Get this document's {@code <body>} or {@code <frameset>} element.
     <p>
     As a <b>side-effect</b>, if this Document does not already have a HTML structure, it will be created with a {@code
    <body>} element. If you do not want that, use {@code #selectFirst(""body"")} instead.

     @return {@code body} element for documents with a {@code <body>}, a new {@code <body>} element if the document
     had no contents, or the outermost {@code <frameset> element} for frameset documents.
     */
    public Element body() {
        Element html = htmlEl();
        for (Element el: html.childElementsList()) {
            if (""body"".equals(el.normalName()) || ""frameset"".equals(el.normalName()))
                return el;
        }
        return html.appendElement(""body"");
    }

    /**
     Get the string contents of the document's {@code title} element.
     @return Trimmed title, or empty string if none set.
     */
    public String title() {
        // title is a preserve whitespace tag (for document output), but normalised here
        Element titleEl = head().selectFirst(titleEval);
        return titleEl != null ? StringUtil.normaliseWhitespace(titleEl.text()).trim() : """";
    }
    private static final Evaluator titleEval = new Evaluator.Tag(""title"");

    /**
     Set the document's {@code title} element. Updates the existing element, or adds {@code title} to {@code head} if
     not present
     @param title string to set as title
     */
    public void title(String title) {
        Validate.notNull(title);
        Element titleEl = head().selectFirst(titleEval);
        if (titleEl == null) // add to head
            titleEl = head().appendElement(""title"");
        titleEl.text(title);
    }

    /**
     Create a new Element, with this document's base uri. Does not make the new element a child of this document.
     @param tagName element tag name (e.g. {@code a})
     @return new element
     */
    public Element createElement(String tagName) {
        return new Element(Tag.valueOf(tagName, ParseSettings.preserveCase), this.baseUri());
    }

    /**
     Normalise the document. This happens after the parse phase so generally does not need to be called.
     Moves any text content that is not in the body element into the body.
     @return this document after normalisation
     */
    public Document normalise() {
        Element htmlEl = htmlEl(); // these all create if not found
        Element head = head();
        body();

        // pull text nodes out of root, html, and head els, and push into body. non-text nodes are already taken care
        // of. do in inverse order to maintain text order.
        normaliseTextNodes(head);
        normaliseTextNodes(htmlEl);
        normaliseTextNodes(this);

        normaliseStructure(""head"", htmlEl);
        normaliseStructure(""body"", htmlEl);
        
        ensureMetaCharsetElement();
        
        return this;
    }

    // does not recurse.
    private void normaliseTextNodes(Element element) {
        List<Node> toMove = new ArrayList<>();
        for (Node node: element.childNodes) {
            if (node instanceof TextNode) {
                TextNode tn = (TextNode) node;
                if (!tn.isBlank())
                    toMove.add(tn);
            }
        }

        for (int i = toMove.size()-1; i >= 0; i--) {
            Node node = toMove.get(i);
            element.removeChild(node);
            body().prependChild(new TextNode("" ""));
            body().prependChild(node);
        }
    }

    // merge multiple <head> or <body> contents into one, delete the remainder, and ensure they are owned by <html>
    private void normaliseStructure(String tag, Element htmlEl) {
        Elements elements = this.getElementsByTag(tag);
        Element master = elements.first(); // will always be available as created above if not existent
        if (elements.size() > 1) { // dupes, move contents to master
            List<Node> toMove = new ArrayList<>();
            for (int i = 1; i < elements.size(); i++) {
                Node dupe = elements.get(i);
                toMove.addAll(dupe.ensureChildNodes());
                dupe.remove();
            }

            for (Node dupe : toMove)
                master.appendChild(dupe);
        }
        // ensure parented by <html>
        if (master.parent() != null && !master.parent().equals(htmlEl)) {
            htmlEl.appendChild(master); // includes remove()            
        }
    }

    @Override
    public String outerHtml() {
        return super.html(); // no outer wrapper tag
    }

    /**
     Set the text of the {@code body} of this document. Any existing nodes within the body will be cleared.
     @param text unencoded text
     @return this document
     */
    @Override
    public Element text(String text) {
        body().text(text); // overridden to not nuke doc structure
        return this;
    }

    @Override
    public String nodeName() {
        return ""#document"";
    }
    
    /**
     * Sets the charset used in this document. This method is equivalent
     * to {@link OutputSettings#charset(java.nio.charset.Charset)
     * OutputSettings.charset(Charset)} but in addition it updates the
     * charset / encoding element within the document.
     * 
     * <p>This enables
     * {@link #updateMetaCharsetElement(boolean) meta charset update}.</p>
     * 
     * <p>If there's no element with charset / encoding information yet it will
     * be created. Obsolete charset / encoding definitions are removed!</p>
     * 
     * <p><b>Elements used:</b></p>
     * 
     * <ul>
     * <li><b>Html:</b> <i>&lt;meta charset=""CHARSET""&gt;</i></li>
     * <li><b>Xml:</b> <i>&lt;?xml version=""1.0"" encoding=""CHARSET""&gt;</i></li>
     * </ul>
     * 
     * @param charset Charset
     * 
     * @see #updateMetaCharsetElement(boolean) 
     * @see OutputSettings#charset(java.nio.charset.Charset) 
     */
    public void charset(Charset charset) {
        updateMetaCharsetElement(true);
        outputSettings.charset(charset);
        ensureMetaCharsetElement();
    }
    
    /**
     * Returns the charset used in this document. This method is equivalent
     * to {@link OutputSettings#charset()}.
     * 
     * @return Current Charset
     * 
     * @see OutputSettings#charset() 
     */
    public Charset charset() {
        return outputSettings.charset();
    }
    
    /**
     * Sets whether the element with charset information in this document is
     * updated on changes through {@link #charset(java.nio.charset.Charset)
     * Document.charset(Charset)} or not.
     * 
     * <p>If set to <tt>false</tt> <i>(default)</i> there are no elements
     * modified.</p>
     * 
     * @param update If <tt>true</tt> the element updated on charset
     * changes, <tt>false</tt> if not
     * 
     * @see #charset(java.nio.charset.Charset) 
     */
    public void updateMetaCharsetElement(boolean update) {
        this.updateMetaCharset = update;
    }
    
    /**
     * Returns whether the element with charset information in this document is
     * updated on changes through {@link #charset(java.nio.charset.Charset)
     * Document.charset(Charset)} or not.
     * 
     * @return Returns <tt>true</tt> if the element is updated on charset
     * changes, <tt>false</tt> if not
     */
    public boolean updateMetaCharsetElement() {
        return updateMetaCharset;
    }

    @Override
    public Document clone() {
        Document clone = (Document) super.clone();
        clone.outputSettings = this.outputSettings.clone();
        return clone;
    }

    @Override
    public Document shallowClone() {
        Document clone = new Document(baseUri());
        if (attributes != null)
            clone.attributes = attributes.clone();
        clone.outputSettings = this.outputSettings.clone();
        return clone;
    }
    
    /**
     * Ensures a meta charset (html) or xml declaration (xml) with the current
     * encoding used. This only applies with
     * {@link #updateMetaCharsetElement(boolean) updateMetaCharset} set to
     * <tt>true</tt>, otherwise this method does nothing.
     * 
     * <ul>
     * <li>An existing element gets updated with the current charset</li>
     * <li>If there's no element yet it will be inserted</li>
     * <li>Obsolete elements are removed</li>
     * </ul>
     * 
     * <p><b>Elements used:</b></p>
     * 
     * <ul>
     * <li><b>Html:</b> <i>&lt;meta charset=""CHARSET""&gt;</i></li>
     * <li><b>Xml:</b> <i>&lt;?xml version=""1.0"" encoding=""CHARSET""&gt;</i></li>
     * </ul>
     */
    private void ensureMetaCharsetElement() {
        if (updateMetaCharset) {
            OutputSettings.Syntax syntax = outputSettings().syntax();

            if (syntax == OutputSettings.Syntax.html) {
                Element metaCharset = selectFirst(""meta[charset]"");
                if (metaCharset != null) {
                    metaCharset.attr(""charset"", charset().displayName());
                } else {
                    head().appendElement(""meta"").attr(""charset"", charset().displayName());
                }
                select(""meta[name=charset]"").remove(); // Remove obsolete elements
            } else if (syntax == OutputSettings.Syntax.xml) {
                Node node = ensureChildNodes().get(0);
                if (node instanceof XmlDeclaration) {
                    XmlDeclaration decl = (XmlDeclaration) node;
                    if (decl.name().equals(""xml"")) {
                        decl.attr(""encoding"", charset().displayName());
                        if (decl.hasAttr(""version""))
                            decl.attr(""version"", ""1.0"");
                    } else {
                        decl = new XmlDeclaration(""xml"", false);
                        decl.attr(""version"", ""1.0"");
                        decl.attr(""encoding"", charset().displayName());
                        prependChild(decl);
                    }
                } else {
                    XmlDeclaration decl = new XmlDeclaration(""xml"", false);
                    decl.attr(""version"", ""1.0"");
                    decl.attr(""encoding"", charset().displayName());
                    prependChild(decl);
                }
            }
        }
    }
    

    /**
     * A Document's output settings control the form of the text() and html() methods.
     */
    public static class OutputSettings implements Cloneable {
        /**
         * The output serialization syntax.
         */
        public enum Syntax {html, xml}

        private Entities.EscapeMode escapeMode = Entities.EscapeMode.base;
        private Charset charset = DataUtil.UTF_8;
        private final ThreadLocal<CharsetEncoder> encoderThreadLocal = new ThreadLocal<>(); // initialized by start of OuterHtmlVisitor
        @Nullable Entities.CoreCharset coreCharset; // fast encoders for ascii and utf8

        private boolean prettyPrint = true;
        private boolean outline = false;
        private int indentAmount = 1;
        private int maxPaddingWidth = 30;
        private Syntax syntax = Syntax.html;

        public OutputSettings() {}
        
        /**
         * Get the document's current HTML escape mode: <code>base</code>, which provides a limited set of named HTML
         * entities and escapes other characters as numbered entities for maximum compatibility; or <code>extended</code>,
         * which uses the complete set of HTML named entities.
         * <p>
         * The default escape mode is <code>base</code>.
         * @return the document's current escape mode
         */
        public Entities.EscapeMode escapeMode() {
            return escapeMode;
        }

        /**
         * Set the document's escape mode, which determines how characters are escaped when the output character set
         * does not support a given character:- using either a named or a numbered escape.
         * @param escapeMode the new escape mode to use
         * @return the document's output settings, for chaining
         */
        public OutputSettings escapeMode(Entities.EscapeMode escapeMode) {
            this.escapeMode = escapeMode;
            return this;
        }

        /**
         * Get the document's current output charset, which is used to control which characters are escaped when
         * generating HTML (via the <code>html()</code> methods), and which are kept intact.
         * <p>
         * Where possible (when parsing from a URL or File), the document's output charset is automatically set to the
         * input charset. Otherwise, it defaults to UTF-8.
         * @return the document's current charset.
         */
        public Charset charset() {
            return charset;
        }

        /**
         * Update the document's output charset.
         * @param charset the new charset to use.
         * @return the document's output settings, for chaining
         */
        public OutputSettings charset(Charset charset) {
            this.charset = charset;
            return this;
        }

        /**
         * Update the document's output charset.
         * @param charset the new charset (by name) to use.
         * @return the document's output settings, for chaining
         */
        public OutputSettings charset(String charset) {
            charset(Charset.forName(charset));
            return this;
        }

        CharsetEncoder prepareEncoder() {
            // created at start of OuterHtmlVisitor so each pass has own encoder, so OutputSettings can be shared among threads
            CharsetEncoder encoder = charset.newEncoder();
            encoderThreadLocal.set(encoder);
            coreCharset = Entities.CoreCharset.byName(encoder.charset().name());
            return encoder;
        }

        CharsetEncoder encoder() {
            CharsetEncoder encoder = encoderThreadLocal.get();
            return encoder != null ? encoder : prepareEncoder();
        }

        /**
         * Get the document's current output syntax.
         * @return current syntax
         */
        public Syntax syntax() {
            return syntax;
        }

        /**
         * Set the document's output syntax. Either {@code html}, with empty tags and boolean attributes (etc), or
         * {@code xml}, with self-closing tags.
         * @param syntax serialization syntax
         * @return the document's output settings, for chaining
         */
        public OutputSettings syntax(Syntax syntax) {
            this.syntax = syntax;
            return this;
        }

        /**
         * Get if pretty printing is enabled. Default is true. If disabled, the HTML output methods will not re-format
         * the output, and the output will generally look like the input.
         * @return if pretty printing is enabled.
         */
        public boolean prettyPrint() {
            return prettyPrint;
        }

        /**
         * Enable or disable pretty printing.
         * @param pretty new pretty print setting
         * @return this, for chaining
         */
        public OutputSettings prettyPrint(boolean pretty) {
            prettyPrint = pretty;
            return this;
        }
        
        /**
         * Get if outline mode is enabled. Default is false. If enabled, the HTML output methods will consider
         * all tags as block.
         * @return if outline mode is enabled.
         */
        public boolean outline() {
            return outline;
        }
        
        /**
         * Enable or disable HTML outline mode.
         * @param outlineMode new outline setting
         * @return this, for chaining
         */
        public OutputSettings outline(boolean outlineMode) {
            outline = outlineMode;
            return this;
        }

        /**
         * Get the current tag indent amount, used when pretty printing.
         * @return the current indent amount
         */
        public int indentAmount() {
            return indentAmount;
        }

        /**
         * Set the indent amount for pretty printing
         * @param indentAmount number of spaces to use for indenting each level. Must be {@literal >=} 0.
         * @return this, for chaining
         */
        public OutputSettings indentAmount(int indentAmount) {
            Validate.isTrue(indentAmount >= 0);
            this.indentAmount = indentAmount;
            return this;
        }

        /**
         * Get the current max padding amount, used when pretty printing
         * so very deeply nested nodes don't get insane padding amounts.
         * @return the current indent amount
         */
        public int maxPaddingWidth() {
            return maxPaddingWidth;
        }

        /**
         * Set the max padding amount for pretty printing so very deeply nested nodes don't get insane padding amounts.
         * @param maxPaddingWidth number of spaces to use for indenting each level of nested nodes. Must be {@literal >=} -1.
         *        Default is 30 and -1 means unlimited.
         * @return this, for chaining
         */
        public OutputSettings maxPaddingWidth(int maxPaddingWidth) {
            Validate.isTrue(maxPaddingWidth >= -1);
            this.maxPaddingWidth = maxPaddingWidth;
            return this;
        }

        @Override
        public OutputSettings clone() {
            OutputSettings clone;
            try {
                clone = (OutputSettings) super.clone();
            } catch (CloneNotSupportedException e) {
                throw new RuntimeException(e);
            }
            clone.charset(charset.name()); // new charset and charset encoder
            clone.escapeMode = Entities.EscapeMode.valueOf(escapeMode.name());
            // indentAmount, maxPaddingWidth, and prettyPrint are primitives so object.clone() will handle
            return clone;
        }
    }

    /**
     * Get the document's current output settings.
     * @return the document's current output settings.
     */
    public OutputSettings outputSettings() {
        return outputSettings;
    }

    /**
     * Set the document's output settings.
     * @param outputSettings new output settings.
     * @return this document, for chaining.
     */
    public Document outputSettings(OutputSettings outputSettings) {
        Validate.notNull(outputSettings);
        this.outputSettings = outputSettings;
        return this;
    }

    public enum QuirksMode {
        noQuirks, quirks, limitedQuirks
    }

    public QuirksMode quirksMode() {
        return quirksMode;
    }

    public Document quirksMode(QuirksMode quirksMode) {
        this.quirksMode = quirksMode;
        return this;
    }

    /**
     * Get the parser that was used to parse this document.
     * @return the parser
     */
    public Parser parser() {
        return parser;
    }

    /**
     * Set the parser used to create this document. This parser is then used when further parsing within this document
     * is required.
     * @param parser the configured parser to use when further parsing is required for this document.
     * @return this document, for chaining.
     */
    public Document parser(Parser parser) {
        this.parser = parser;
        return this;
    }

    /**
     Set the Connection used to fetch this document. This Connection is used as a session object when further requests are
     made (e.g. when a form is submitted).

     @param connection to set
     @return this document, for chaining
     @see Connection#newRequest()
     @since 1.14.1
     */
    public Document connection(Connection connection) {
        Validate.notNull(connection);
        this.connection = connection;
        return this;
    }
}
"
jhy/jsoup,src/test/java/org/jsoup/MultiLocaleExtension.java,"package org.jsoup;

import org.junit.jupiter.api.extension.AfterEachCallback;
import org.junit.jupiter.api.extension.ExtendWith;
import org.junit.jupiter.api.extension.ExtensionContext;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.Arguments;
import org.junit.jupiter.params.provider.ArgumentsProvider;
import org.junit.jupiter.params.provider.ArgumentsSource;

import java.lang.annotation.*;
import java.util.Locale;
import java.util.stream.Stream;

public class MultiLocaleExtension implements AfterEachCallback, ArgumentsProvider {
    private final Locale defaultLocale = Locale.getDefault();

    @Override
    public void afterEach(ExtensionContext context) {
        Locale.setDefault(defaultLocale);
    }

    @Override
    public Stream<? extends Arguments> provideArguments(ExtensionContext extensionContext) {
        return Stream.of(Arguments.of(Locale.ENGLISH), Arguments.arguments(new Locale(""tr"")));
    }


    @Documented
    @Target(ElementType.METHOD)
    @Retention(RetentionPolicy.RUNTIME)
    @ArgumentsSource(MultiLocaleExtension.class)
    @ExtendWith(MultiLocaleExtension.class)
    @ParameterizedTest
    public @interface MultiLocaleTest {
    }

}
"
jhy/jsoup,src/main/java/org/jsoup/examples/package-info.java,"/**
 Contains example programs and use of jsoup. See the <a href=""https://jsoup.org/cookbook/"">jsoup cookbook</a>.
 */
package org.jsoup.examples;"
jhy/jsoup,src/main/java/org/jsoup/nodes/NodeUtils.java,"package org.jsoup.nodes;

import org.jsoup.helper.Validate;
import org.jsoup.helper.W3CDom;
import org.jsoup.parser.HtmlTreeBuilder;
import org.jsoup.parser.Parser;
import org.jsoup.select.Elements;
import org.w3c.dom.NodeList;

import java.util.List;

/**
 * Internal helpers for Nodes, to keep the actual node APIs relatively clean. A jsoup internal class, so don't use it as
 * there is no contract API).
 */
final class NodeUtils {
    /**
     * Get the output setting for this node,  or if this node has no document (or parent), retrieve the default output
     * settings
     */
    static Document.OutputSettings outputSettings(Node node) {
        Document owner = node.ownerDocument();
        return owner != null ? owner.outputSettings() : (new Document("""")).outputSettings();
    }

    /**
     * Get the parser that was used to make this node, or the default HTML parser if it has no parent.
     */
    static Parser parser(Node node) {
        Document doc = node.ownerDocument();
        return doc != null && doc.parser() != null ? doc.parser() : new Parser(new HtmlTreeBuilder());
    }

    /**
     This impl works by compiling the input xpath expression, and then evaluating it against a W3C Document converted
     from the original jsoup element. The original jsoup elements are then fetched from the w3c doc user data (where we
     stashed them during conversion). This process could potentially be optimized by transpiling the compiled xpath
     expression to a jsoup Evaluator when there's 1:1 support, thus saving the W3C document conversion stage.
     */
    static <T extends Node> List<T> selectXpath(String xpath, Element el, Class<T> nodeType) {
        Validate.notEmpty(xpath);
        Validate.notNull(el);
        Validate.notNull(nodeType);

        W3CDom w3c = new W3CDom().namespaceAware(false);
        org.w3c.dom.Document wDoc = w3c.fromJsoup(el);
        org.w3c.dom.Node contextNode = w3c.contextNode(wDoc);
        NodeList nodeList = w3c.selectXpath(xpath, contextNode);
        return w3c.sourceNodes(nodeList, nodeType);
    }
}
"
jhy/jsoup,src/main/java/org/jsoup/internal/package-info.java,"/**
 * Util methods used by Jsoup. Please don't depend on the APIs implemented here as the contents may change without
 * notice.
 */
package org.jsoup.internal;
"
jhy/jsoup,src/test/java/org/jsoup/parser/ParserTest.java,"package org.jsoup.parser;

import org.jsoup.Jsoup;
import org.jsoup.nodes.Document;
import org.junit.jupiter.api.Test;

import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.nio.charset.StandardCharsets;

import static org.junit.jupiter.api.Assertions.assertEquals;

public class ParserTest {

    @Test
    public void unescapeEntities() {
        String s = Parser.unescapeEntities(""One &amp; Two"", false);
        assertEquals(""One & Two"", s);
    }

    @Test
    public void unescapeEntitiesHandlesLargeInput() {
        StringBuilder longBody = new StringBuilder(500000);
        do {
            longBody.append(""SomeNonEncodedInput"");
        } while (longBody.length() < 64 * 1024);

        String body = longBody.toString();
        assertEquals(body, Parser.unescapeEntities(body, false));
    }

    @Test
    public void testUtf8() throws IOException {
        // testcase for https://github.com/jhy/jsoup/issues/1557. no repro.
        Document parsed = Jsoup.parse(new ByteArrayInputStream(""<p>H\u00E9llo, w\u00F6rld!"".getBytes(StandardCharsets.UTF_8)), null, """");
        String text = parsed.selectFirst(""p"").wholeText();
        assertEquals(text, ""H\u00E9llo, w\u00F6rld!"");
    }
}
"
jhy/jsoup,src/main/java/org/jsoup/nodes/TextNode.java,"package org.jsoup.nodes;

import org.jsoup.helper.Validate;
import org.jsoup.internal.StringUtil;

import java.io.IOException;

/**
 A text node.

 @author Jonathan Hedley, jonathan@hedley.net */
public class TextNode extends LeafNode {
    /**
     Create a new TextNode representing the supplied (unencoded) text).

     @param text raw text
     @see #createFromEncoded(String)
     */
    public TextNode(String text) {
        value = text;
    }

	public String nodeName() {
        return ""#text"";
    }
    
    /**
     * Get the text content of this text node.
     * @return Unencoded, normalised text.
     * @see TextNode#getWholeText()
     */
    public String text() {
        return StringUtil.normaliseWhitespace(getWholeText());
    }
    
    /**
     * Set the text content of this text node.
     * @param text unencoded text
     * @return this, for chaining
     */
    public TextNode text(String text) {
        coreValue(text);
        return this;
    }

    /**
     Get the (unencoded) text of this text node, including any newlines and spaces present in the original.
     @return text
     */
    public String getWholeText() {
        return coreValue();
    }

    /**
     Test if this text node is blank -- that is, empty or only whitespace (including newlines).
     @return true if this document is empty or only whitespace, false if it contains any text content.
     */
    public boolean isBlank() {
        return StringUtil.isBlank(coreValue());
    }

    /**
     * Split this text node into two nodes at the specified string offset. After splitting, this node will contain the
     * original text up to the offset, and will have a new text node sibling containing the text after the offset.
     * @param offset string offset point to split node at.
     * @return the newly created text node containing the text after the offset.
     */
    public TextNode splitText(int offset) {
        final String text = coreValue();
        Validate.isTrue(offset >= 0, ""Split offset must be not be negative"");
        Validate.isTrue(offset < text.length(), ""Split offset must not be greater than current text length"");

        String head = text.substring(0, offset);
        String tail = text.substring(offset);
        text(head);
        TextNode tailNode = new TextNode(tail);
        if (parentNode != null)
            parentNode.addChildren(siblingIndex()+1, tailNode);

        return tailNode;
    }

    void outerHtmlHead(Appendable accum, int depth, Document.OutputSettings out) throws IOException {
        final boolean prettyPrint = out.prettyPrint();
        final Element parent = parentNode instanceof Element ? ((Element) parentNode) : null;
        final boolean normaliseWhite = prettyPrint && !Element.preserveWhitespace(parentNode);

        boolean trimLeading = false;
        boolean trimTrailing = false;
        if (normaliseWhite) {
            trimLeading = (siblingIndex == 0 && parent != null && parent.tag().isBlock()) ||
                parentNode instanceof Document;
            trimTrailing = nextSibling() == null && parent != null && parent.tag().isBlock();

            // if this text is just whitespace, and the next node will cause an indent, skip this text:
            Node next = this.nextSibling();
            boolean couldSkip = (next instanceof Element && ((Element) next).shouldIndent(out)) // next will indent
                || (next instanceof TextNode && (((TextNode) next).isBlank())); // next is blank text, from re-parenting
            if (couldSkip && isBlank()) return;

            if ((siblingIndex == 0 && parent != null && parent.tag().formatAsBlock() && !isBlank()) ||
                (out.outline() && siblingNodes().size() > 0 && !isBlank()))
                indent(accum, depth, out);
        }

        Entities.escape(accum, coreValue(), out, false, normaliseWhite, trimLeading, trimTrailing);
    }

	void outerHtmlTail(Appendable accum, int depth, Document.OutputSettings out) {}

    @Override
    public String toString() {
        return outerHtml();
    }

    @Override
    public TextNode clone() {
        return (TextNode) super.clone();
    }

    /**
     * Create a new TextNode from HTML encoded (aka escaped) data.
     * @param encodedText Text containing encoded HTML (e.g. &amp;lt;)
     * @return TextNode containing unencoded data (e.g. &lt;)
     */
    public static TextNode createFromEncoded(String encodedText) {
        String text = Entities.unescape(encodedText);
        return new TextNode(text);
    }

    static String normaliseWhitespace(String text) {
        text = StringUtil.normaliseWhitespace(text);
        return text;
    }

    static String stripLeadingWhitespace(String text) {
        return text.replaceFirst(""^\\s+"", """");
    }

    static boolean lastCharIsWhitespace(StringBuilder sb) {
        return sb.length() != 0 && sb.charAt(sb.length() - 1) == ' ';
    }


}
"
jhy/jsoup,src/main/java/org/jsoup/UncheckedIOException.java,"package org.jsoup;

import java.io.IOException;

public class UncheckedIOException extends RuntimeException {
    public UncheckedIOException(IOException cause) {
        super(cause);
    }

    public UncheckedIOException(String message) {
        super(new IOException(message));
    }

    public IOException ioException() {
        return (IOException) getCause();
    }
}
"
jhy/jsoup,src/main/java/org/jsoup/parser/ParseErrorList.java,"package org.jsoup.parser;

import java.util.ArrayList;

/**
 * A container for ParseErrors.
 * 
 * @author Jonathan Hedley
 */
public class ParseErrorList extends ArrayList<ParseError>{
    private static final int INITIAL_CAPACITY = 16;
    private final int initialCapacity;
    private final int maxSize;
    
    ParseErrorList(int initialCapacity, int maxSize) {
        super(initialCapacity);
        this.initialCapacity = initialCapacity;
        this.maxSize = maxSize;
    }

    /**
     Create a new ParseErrorList with the same settings, but no errors in the list
     @param copy initial and max size details to copy
     */
    ParseErrorList(ParseErrorList copy) {
        this(copy.initialCapacity, copy.maxSize);
    }
    
    boolean canAddError() {
        return size() < maxSize;
    }

    int getMaxSize() {
        return maxSize;
    }

    public static ParseErrorList noTracking() {
        return new ParseErrorList(0, 0);
    }
    
    public static ParseErrorList tracking(int maxSize) {
        return new ParseErrorList(INITIAL_CAPACITY, maxSize);
    }

    @Override
    public Object clone() {
        // all class fields are primitive, so native clone is enough.
        return super.clone();
    }
}
"
jhy/jsoup,src/main/java/org/jsoup/select/Evaluator.java,"package org.jsoup.select;

import org.jsoup.helper.Validate;
import org.jsoup.internal.StringUtil;
import org.jsoup.nodes.Comment;
import org.jsoup.nodes.Document;
import org.jsoup.nodes.DocumentType;
import org.jsoup.nodes.Element;
import org.jsoup.nodes.Node;
import org.jsoup.nodes.PseudoTextElement;
import org.jsoup.nodes.TextNode;
import org.jsoup.nodes.XmlDeclaration;

import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import static org.jsoup.internal.Normalizer.lowerCase;
import static org.jsoup.internal.Normalizer.normalize;
import static org.jsoup.internal.StringUtil.normaliseWhitespace;


/**
 * Evaluates that an element matches the selector.
 */
public abstract class Evaluator {
    protected Evaluator() {
    }

    /**
     * Test if the element meets the evaluator's requirements.
     *
     * @param root    Root of the matching subtree
     * @param element tested element
     * @return Returns <tt>true</tt> if the requirements are met or
     * <tt>false</tt> otherwise
     */
    public abstract boolean matches(Element root, Element element);

    /**
     * Evaluator for tag name
     */
    public static final class Tag extends Evaluator {
        private final String tagName;

        public Tag(String tagName) {
            this.tagName = tagName;
        }

        @Override
        public boolean matches(Element root, Element element) {
            return (element.normalName().equals(tagName));
        }

        @Override
        public String toString() {
            return String.format(""%s"", tagName);
        }
    }


    /**
     * Evaluator for tag name that ends with
     */
    public static final class TagEndsWith extends Evaluator {
        private final String tagName;

        public TagEndsWith(String tagName) {
            this.tagName = tagName;
        }

        @Override
        public boolean matches(Element root, Element element) {
            return (element.normalName().endsWith(tagName));
        }

        @Override
        public String toString() {
            return String.format(""%s"", tagName);
        }
    }

    /**
     * Evaluator for element id
     */
    public static final class Id extends Evaluator {
        private final String id;

        public Id(String id) {
            this.id = id;
        }

        @Override
        public boolean matches(Element root, Element element) {
            return (id.equals(element.id()));
        }

        @Override
        public String toString() {
            return String.format(""#%s"", id);
        }

    }

    /**
     * Evaluator for element class
     */
    public static final class Class extends Evaluator {
        private final String className;

        public Class(String className) {
            this.className = className;
        }

        @Override
        public boolean matches(Element root, Element element) {
            return (element.hasClass(className));
        }

        @Override
        public String toString() {
            return String.format("".%s"", className);
        }

    }

    /**
     * Evaluator for attribute name matching
     */
    public static final class Attribute extends Evaluator {
        private final String key;

        public Attribute(String key) {
            this.key = key;
        }

        @Override
        public boolean matches(Element root, Element element) {
            return element.hasAttr(key);
        }

        @Override
        public String toString() {
            return String.format(""[%s]"", key);
        }

    }

    /**
     * Evaluator for attribute name prefix matching
     */
    public static final class AttributeStarting extends Evaluator {
        private final String keyPrefix;

        public AttributeStarting(String keyPrefix) {
            Validate.notEmpty(keyPrefix);
            this.keyPrefix = lowerCase(keyPrefix);
        }

        @Override
        public boolean matches(Element root, Element element) {
            List<org.jsoup.nodes.Attribute> values = element.attributes().asList();
            for (org.jsoup.nodes.Attribute attribute : values) {
                if (lowerCase(attribute.getKey()).startsWith(keyPrefix))
                    return true;
            }
            return false;
        }

        @Override
        public String toString() {
            return String.format(""[^%s]"", keyPrefix);
        }

    }

    /**
     * Evaluator for attribute name/value matching
     */
    public static final class AttributeWithValue extends AttributeKeyPair {
        public AttributeWithValue(String key, String value) {
            super(key, value);
        }

        @Override
        public boolean matches(Element root, Element element) {
            return element.hasAttr(key) && value.equalsIgnoreCase(element.attr(key).trim());
        }

        @Override
        public String toString() {
            return String.format(""[%s=%s]"", key, value);
        }

    }

    /**
     * Evaluator for attribute name != value matching
     */
    public static final class AttributeWithValueNot extends AttributeKeyPair {
        public AttributeWithValueNot(String key, String value) {
            super(key, value);
        }

        @Override
        public boolean matches(Element root, Element element) {
            return !value.equalsIgnoreCase(element.attr(key));
        }

        @Override
        public String toString() {
            return String.format(""[%s!=%s]"", key, value);
        }

    }

    /**
     * Evaluator for attribute name/value matching (value prefix)
     */
    public static final class AttributeWithValueStarting extends AttributeKeyPair {
        public AttributeWithValueStarting(String key, String value) {
            super(key, value, false);
        }

        @Override
        public boolean matches(Element root, Element element) {
            return element.hasAttr(key) && lowerCase(element.attr(key)).startsWith(value); // value is lower case already
        }

        @Override
        public String toString() {
            return String.format(""[%s^=%s]"", key, value);
        }

    }

    /**
     * Evaluator for attribute name/value matching (value ending)
     */
    public static final class AttributeWithValueEnding extends AttributeKeyPair {
        public AttributeWithValueEnding(String key, String value) {
            super(key, value, false);
        }

        @Override
        public boolean matches(Element root, Element element) {
            return element.hasAttr(key) && lowerCase(element.attr(key)).endsWith(value); // value is lower case
        }

        @Override
        public String toString() {
            return String.format(""[%s$=%s]"", key, value);
        }

    }

    /**
     * Evaluator for attribute name/value matching (value containing)
     */
    public static final class AttributeWithValueContaining extends AttributeKeyPair {
        public AttributeWithValueContaining(String key, String value) {
            super(key, value);
        }

        @Override
        public boolean matches(Element root, Element element) {
            return element.hasAttr(key) && lowerCase(element.attr(key)).contains(value); // value is lower case
        }

        @Override
        public String toString() {
            return String.format(""[%s*=%s]"", key, value);
        }

    }

    /**
     * Evaluator for attribute name/value matching (value regex matching)
     */
    public static final class AttributeWithValueMatching extends Evaluator {
        String key;
        Pattern pattern;

        public AttributeWithValueMatching(String key, Pattern pattern) {
            this.key = normalize(key);
            this.pattern = pattern;
        }

        @Override
        public boolean matches(Element root, Element element) {
            return element.hasAttr(key) && pattern.matcher(element.attr(key)).find();
        }

        @Override
        public String toString() {
            return String.format(""[%s~=%s]"", key, pattern.toString());
        }

    }

    /**
     * Abstract evaluator for attribute name/value matching
     */
    public abstract static class AttributeKeyPair extends Evaluator {
        String key;
        String value;

        public AttributeKeyPair(String key, String value) {
            this(key, value, true);
        }

        public AttributeKeyPair(String key, String value, boolean trimValue) {
            Validate.notEmpty(key);
            Validate.notEmpty(value);

            this.key = normalize(key);
            boolean isStringLiteral = value.startsWith(""'"") && value.endsWith(""'"")
                                        || value.startsWith(""\"""") && value.endsWith(""\"""");
            if (isStringLiteral) {
                value = value.substring(1, value.length()-1);
            }

            this.value = trimValue ? normalize(value) : normalize(value, isStringLiteral);
        }
    }

    /**
     * Evaluator for any / all element matching
     */
    public static final class AllElements extends Evaluator {

        @Override
        public boolean matches(Element root, Element element) {
            return true;
        }

        @Override
        public String toString() {
            return ""*"";
        }
    }

    /**
     * Evaluator for matching by sibling index number (e {@literal <} idx)
     */
    public static final class IndexLessThan extends IndexEvaluator {
        public IndexLessThan(int index) {
            super(index);
        }

        @Override
        public boolean matches(Element root, Element element) {
            return root != element && element.elementSiblingIndex() < index;
        }

        @Override
        public String toString() {
            return String.format("":lt(%d)"", index);
        }

    }

    /**
     * Evaluator for matching by sibling index number (e {@literal >} idx)
     */
    public static final class IndexGreaterThan extends IndexEvaluator {
        public IndexGreaterThan(int index) {
            super(index);
        }

        @Override
        public boolean matches(Element root, Element element) {
            return element.elementSiblingIndex() > index;
        }

        @Override
        public String toString() {
            return String.format("":gt(%d)"", index);
        }

    }

    /**
     * Evaluator for matching by sibling index number (e = idx)
     */
    public static final class IndexEquals extends IndexEvaluator {
        public IndexEquals(int index) {
            super(index);
        }

        @Override
        public boolean matches(Element root, Element element) {
            return element.elementSiblingIndex() == index;
        }

        @Override
        public String toString() {
            return String.format("":eq(%d)"", index);
        }

    }

    /**
     * Evaluator for matching the last sibling (css :last-child)
     */
    public static final class IsLastChild extends Evaluator {
		@Override
		public boolean matches(Element root, Element element) {
			final Element p = element.parent();
			return p != null && !(p instanceof Document) && element.elementSiblingIndex() == p.children().size()-1;
		}

		@Override
		public String toString() {
			return "":last-child"";
		}
    }

    public static final class IsFirstOfType extends IsNthOfType {
		public IsFirstOfType() {
			super(0,1);
		}
		@Override
		public String toString() {
			return "":first-of-type"";
		}
    }

    public static final class IsLastOfType extends IsNthLastOfType {
		public IsLastOfType() {
			super(0,1);
		}
		@Override
		public String toString() {
			return "":last-of-type"";
		}
    }


    public static abstract class CssNthEvaluator extends Evaluator {
    	protected final int a, b;

    	public CssNthEvaluator(int a, int b) {
    		this.a = a;
    		this.b = b;
    	}
    	public CssNthEvaluator(int b) {
    		this(0,b);
    	}

    	@Override
    	public boolean matches(Element root, Element element) {
    		final Element p = element.parent();
    		if (p == null || (p instanceof Document)) return false;

    		final int pos = calculatePosition(root, element);
    		if (a == 0) return pos == b;

    		return (pos-b)*a >= 0 && (pos-b)%a==0;
    	}

		@Override
		public String toString() {
			if (a == 0)
				return String.format("":%s(%d)"",getPseudoClass(), b);
			if (b == 0)
				return String.format("":%s(%dn)"",getPseudoClass(), a);
			return String.format("":%s(%dn%+d)"", getPseudoClass(),a, b);
		}

		protected abstract String getPseudoClass();
		protected abstract int calculatePosition(Element root, Element element);
    }


    /**
     * css-compatible Evaluator for :eq (css :nth-child)
     *
     * @see IndexEquals
     */
    public static final class IsNthChild extends CssNthEvaluator {

    	public IsNthChild(int a, int b) {
    		super(a,b);
		}

		protected int calculatePosition(Element root, Element element) {
			return element.elementSiblingIndex()+1;
		}


		protected String getPseudoClass() {
			return ""nth-child"";
		}
    }

    /**
     * css pseudo class :nth-last-child)
     *
     * @see IndexEquals
     */
    public static final class IsNthLastChild extends CssNthEvaluator {
    	public IsNthLastChild(int a, int b) {
    		super(a,b);
    	}

        @Override
        protected int calculatePosition(Element root, Element element) {
    	    if (element.parent() == null)
    	        return 0;
        	return element.parent().children().size() - element.elementSiblingIndex();
        }

		@Override
		protected String getPseudoClass() {
			return ""nth-last-child"";
		}
    }

    /**
     * css pseudo class nth-of-type
     *
     */
    public static class IsNthOfType extends CssNthEvaluator {
    	public IsNthOfType(int a, int b) {
    		super(a,b);
    	}

		protected int calculatePosition(Element root, Element element) {
			int pos = 0;
            if (element.parent() == null)
                return 0;
        	Elements family = element.parent().children();
            for (Element el : family) {
                if (el.tag().equals(element.tag())) pos++;
                if (el == element) break;
            }
			return pos;
		}

		@Override
		protected String getPseudoClass() {
			return ""nth-of-type"";
		}
    }

    public static class IsNthLastOfType extends CssNthEvaluator {

		public IsNthLastOfType(int a, int b) {
			super(a, b);
		}

		@Override
		protected int calculatePosition(Element root, Element element) {
			int pos = 0;
            if (element.parent() == null)
                return 0;
        	Elements family = element.parent().children();
        	for (int i = element.elementSiblingIndex(); i < family.size(); i++) {
        		if (family.get(i).tag().equals(element.tag())) pos++;
        	}
			return pos;
		}

		@Override
		protected String getPseudoClass() {
			return ""nth-last-of-type"";
		}
    }

    /**
     * Evaluator for matching the first sibling (css :first-child)
     */
    public static final class IsFirstChild extends Evaluator {
    	@Override
    	public boolean matches(Element root, Element element) {
    		final Element p = element.parent();
    		return p != null && !(p instanceof Document) && element.elementSiblingIndex() == 0;
    	}

    	@Override
    	public String toString() {
    		return "":first-child"";
    	}
    }

    /**
     * css3 pseudo-class :root
     * @see <a href=""http://www.w3.org/TR/selectors/#root-pseudo"">:root selector</a>
     *
     */
    public static final class IsRoot extends Evaluator {
    	@Override
    	public boolean matches(Element root, Element element) {
    		final Element r = root instanceof Document?root.child(0):root;
    		return element == r;
    	}
    	@Override
    	public String toString() {
    		return "":root"";
    	}
    }

    public static final class IsOnlyChild extends Evaluator {
		@Override
		public boolean matches(Element root, Element element) {
			final Element p = element.parent();
			return p!=null && !(p instanceof Document) && element.siblingElements().isEmpty();
		}
    	@Override
    	public String toString() {
    		return "":only-child"";
    	}
    }

    public static final class IsOnlyOfType extends Evaluator {
		@Override
		public boolean matches(Element root, Element element) {
			final Element p = element.parent();
			if (p==null || p instanceof Document) return false;

			int pos = 0;
        	Elements family = p.children();
            for (Element el : family) {
                if (el.tag().equals(element.tag())) pos++;
            }
        	return pos == 1;
		}
    	@Override
    	public String toString() {
    		return "":only-of-type"";
    	}
    }

    public static final class IsEmpty extends Evaluator {
		@Override
		public boolean matches(Element root, Element element) {
        	List<Node> family = element.childNodes();
            for (Node n : family) {
                if (!(n instanceof Comment || n instanceof XmlDeclaration || n instanceof DocumentType)) return false;
            }
        	return true;
		}
    	@Override
    	public String toString() {
    		return "":empty"";
    	}
    }

    /**
     * Abstract evaluator for sibling index matching
     *
     * @author ant
     */
    public abstract static class IndexEvaluator extends Evaluator {
        int index;

        public IndexEvaluator(int index) {
            this.index = index;
        }
    }

    /**
     * Evaluator for matching Element (and its descendants) text
     */
    public static final class ContainsText extends Evaluator {
        private final String searchText;

        public ContainsText(String searchText) {
            this.searchText = lowerCase(normaliseWhitespace(searchText));
        }

        @Override
        public boolean matches(Element root, Element element) {
            return lowerCase(element.text()).contains(searchText);
        }

        @Override
        public String toString() {
            return String.format("":contains(%s)"", searchText);
        }
    }

    /**
     * Evaluator for matching Element (and its descendants) wholeText. Neither the input nor the element text is
     * normalized. <code>:containsWholeText()</code>
     * @since 1.15.1.
     */
    public static final class ContainsWholeText extends Evaluator {
        private final String searchText;

        public ContainsWholeText(String searchText) {
            this.searchText = searchText;
        }

        @Override
        public boolean matches(Element root, Element element) {
            return element.wholeText().contains(searchText);
        }

        @Override
        public String toString() {
            return String.format("":containsWholeText(%s)"", searchText);
        }
    }

    /**
     * Evaluator for matching Element (but <b>not</b> its descendants) wholeText. Neither the input nor the element text is
     * normalized. <code>:containsWholeOwnText()</code>
     * @since 1.15.1.
     */
    public static final class ContainsWholeOwnText extends Evaluator {
        private final String searchText;

        public ContainsWholeOwnText(String searchText) {
            this.searchText = searchText;
        }

        @Override
        public boolean matches(Element root, Element element) {
            return element.wholeOwnText().contains(searchText);
        }

        @Override
        public String toString() {
            return String.format("":containsWholeOwnText(%s)"", searchText);
        }
    }

    /**
     * Evaluator for matching Element (and its descendants) data
     */
    public static final class ContainsData extends Evaluator {
        private final String searchText;

        public ContainsData(String searchText) {
            this.searchText = lowerCase(searchText);
        }

        @Override
        public boolean matches(Element root, Element element) {
            return lowerCase(element.data()).contains(searchText); // not whitespace normalized
        }

        @Override
        public String toString() {
            return String.format("":containsData(%s)"", searchText);
        }
    }

    /**
     * Evaluator for matching Element's own text
     */
    public static final class ContainsOwnText extends Evaluator {
        private final String searchText;

        public ContainsOwnText(String searchText) {
            this.searchText = lowerCase(normaliseWhitespace(searchText));
        }

        @Override
        public boolean matches(Element root, Element element) {
            return lowerCase(element.ownText()).contains(searchText);
        }

        @Override
        public String toString() {
            return String.format("":containsOwn(%s)"", searchText);
        }
    }

    /**
     * Evaluator for matching Element (and its descendants) text with regex
     */
    public static final class Matches extends Evaluator {
        private final Pattern pattern;

        public Matches(Pattern pattern) {
            this.pattern = pattern;
        }

        @Override
        public boolean matches(Element root, Element element) {
            Matcher m = pattern.matcher(element.text());
            return m.find();
        }

        @Override
        public String toString() {
            return String.format("":matches(%s)"", pattern);
        }
    }

    /**
     * Evaluator for matching Element's own text with regex
     */
    public static final class MatchesOwn extends Evaluator {
        private final Pattern pattern;

        public MatchesOwn(Pattern pattern) {
            this.pattern = pattern;
        }

        @Override
        public boolean matches(Element root, Element element) {
            Matcher m = pattern.matcher(element.ownText());
            return m.find();
        }

        @Override
        public String toString() {
            return String.format("":matchesOwn(%s)"", pattern);
        }
    }

    /**
     * Evaluator for matching Element (and its descendants) whole text with regex.
     * @since 1.15.1.
     */
    public static final class MatchesWholeText extends Evaluator {
        private final Pattern pattern;

        public MatchesWholeText(Pattern pattern) {
            this.pattern = pattern;
        }

        @Override
        public boolean matches(Element root, Element element) {
            Matcher m = pattern.matcher(element.wholeText());
            return m.find();
        }

        @Override
        public String toString() {
            return String.format("":matchesWholeText(%s)"", pattern);
        }
    }

    /**
     * Evaluator for matching Element's own whole text with regex.
     * @since 1.15.1.
     */
    public static final class MatchesWholeOwnText extends Evaluator {
        private final Pattern pattern;

        public MatchesWholeOwnText(Pattern pattern) {
            this.pattern = pattern;
        }

        @Override
        public boolean matches(Element root, Element element) {
            Matcher m = pattern.matcher(element.wholeOwnText());
            return m.find();
        }

        @Override
        public String toString() {
            return String.format("":matchesWholeOwnText(%s)"", pattern);
        }
    }

    public static final class MatchText extends Evaluator {

        @Override
        public boolean matches(Element root, Element element) {
            if (element instanceof PseudoTextElement)
                return true;

            List<TextNode> textNodes = element.textNodes();
            for (TextNode textNode : textNodes) {
                PseudoTextElement pel = new PseudoTextElement(
                    org.jsoup.parser.Tag.valueOf(element.tagName()), element.baseUri(), element.attributes());
                textNode.replaceWith(pel);
                pel.appendChild(textNode);
            }
            return false;
        }

        @Override
        public String toString() {
            return "":matchText"";
        }
    }
}
"
jhy/jsoup,src/main/java/org/jsoup/helper/W3CDom.java,"package org.jsoup.helper;

import org.jsoup.internal.StringUtil;
import org.jsoup.nodes.Attribute;
import org.jsoup.nodes.Attributes;
import org.jsoup.select.NodeTraversor;
import org.jsoup.select.NodeVisitor;
import org.jsoup.select.Selector;
import org.w3c.dom.Comment;
import org.w3c.dom.DOMException;
import org.w3c.dom.DOMImplementation;
import org.w3c.dom.Document;
import org.w3c.dom.DocumentType;
import org.w3c.dom.Element;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import org.w3c.dom.Text;

import javax.annotation.Nullable;
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import javax.xml.transform.OutputKeys;
import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerException;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.stream.StreamResult;
import javax.xml.xpath.XPathConstants;
import javax.xml.xpath.XPathExpression;
import javax.xml.xpath.XPathExpressionException;
import javax.xml.xpath.XPathFactory;
import javax.xml.xpath.XPathFactoryConfigurationException;
import java.io.StringWriter;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Properties;
import java.util.Stack;

import static javax.xml.transform.OutputKeys.METHOD;
import static org.jsoup.nodes.Document.OutputSettings.Syntax;

/**
 * Helper class to transform a {@link org.jsoup.nodes.Document} to a {@link org.w3c.dom.Document org.w3c.dom.Document},
 * for integration with toolsets that use the W3C DOM.
 */
public class W3CDom {
    /** For W3C Documents created by this class, this property is set on each node to link back to the original jsoup node. */
    public static final String SourceProperty = ""jsoupSource"";
    private static final String ContextProperty = ""jsoupContextSource""; // tracks the jsoup context element on w3c doc
    private static final String ContextNodeProperty = ""jsoupContextNode""; // the w3c node used as the creating context

    /**
     To get support for XPath versions &gt; 1, set this property to the classname of an alternate XPathFactory
     implementation. (For e.g. {@code net.sf.saxon.xpath.XPathFactoryImpl}).
     */
    public static final String XPathFactoryProperty = ""javax.xml.xpath.XPathFactory:jsoup"";

    protected DocumentBuilderFactory factory;
    private boolean namespaceAware = true; // false when using selectXpath, for user's query convenience

    public W3CDom() {
        factory = DocumentBuilderFactory.newInstance();
        factory.setNamespaceAware(true);
    }

    /**
     Returns if this W3C DOM is namespace aware. By default, this will be {@code true}, but is disabled for simplicity
     when using XPath selectors in {@link org.jsoup.nodes.Element#selectXpath(String)}.
     @return the current namespace aware setting.
     */
    public boolean namespaceAware() {
        return namespaceAware;
    }

    /**
     Update the namespace aware setting. This impacts the factory that is used to create W3C nodes from jsoup nodes.
     @param namespaceAware the updated setting
     @return this W3CDom, for chaining.
     */
    public W3CDom namespaceAware(boolean namespaceAware) {
        this.namespaceAware = namespaceAware;
        factory.setNamespaceAware(namespaceAware);
        return this;
    }

    /**
     * Converts a jsoup DOM to a W3C DOM.
     *
     * @param in jsoup Document
     * @return W3C Document
     */
    public static Document convert(org.jsoup.nodes.Document in) {
        return (new W3CDom().fromJsoup(in));
    }

    /**
     * Serialize a W3C document to a String. Provide Properties to define output settings including if HTML or XML. If
     * you don't provide the properties ({@code null}), the output will be auto-detected based on the content of the
     * document.
     *
     * @param doc Document
     * @param properties (optional/nullable) the output properties to use. See {@link
     *     Transformer#setOutputProperties(Properties)} and {@link OutputKeys}
     * @return Document as string
     * @see #OutputHtml
     * @see #OutputXml
     * @see OutputKeys#ENCODING
     * @see OutputKeys#OMIT_XML_DECLARATION
     * @see OutputKeys#STANDALONE
     * @see OutputKeys#STANDALONE
     * @see OutputKeys#DOCTYPE_PUBLIC
     * @see OutputKeys#CDATA_SECTION_ELEMENTS
     * @see OutputKeys#INDENT
     * @see OutputKeys#MEDIA_TYPE
     */
    public static String asString(Document doc, @Nullable Map<String, String> properties) {
        try {
            DOMSource domSource = new DOMSource(doc);
            StringWriter writer = new StringWriter();
            StreamResult result = new StreamResult(writer);
            TransformerFactory tf = TransformerFactory.newInstance();
            Transformer transformer = tf.newTransformer();
            if (properties != null)
                transformer.setOutputProperties(propertiesFromMap(properties));

            if (doc.getDoctype() != null) {
                DocumentType doctype = doc.getDoctype();
                if (!StringUtil.isBlank(doctype.getPublicId()))
                    transformer.setOutputProperty(OutputKeys.DOCTYPE_PUBLIC, doctype.getPublicId());
                if (!StringUtil.isBlank(doctype.getSystemId()))
                    transformer.setOutputProperty(OutputKeys.DOCTYPE_SYSTEM, doctype.getSystemId());
                    // handle <!doctype html> for legacy dom. TODO: nicer if <!doctype html>
                else if (doctype.getName().equalsIgnoreCase(""html"")
                    && StringUtil.isBlank(doctype.getPublicId())
                    && StringUtil.isBlank(doctype.getSystemId()))
                    transformer.setOutputProperty(OutputKeys.DOCTYPE_SYSTEM, ""about:legacy-compat"");
            }

            transformer.transform(domSource, result);
            return writer.toString();

        } catch (TransformerException e) {
            throw new IllegalStateException(e);
        }
    }

    static Properties propertiesFromMap(Map<String, String> map) {
        Properties props = new Properties();
        props.putAll(map);
        return props;
    }

    /** Canned default for HTML output. */
    public static HashMap<String, String> OutputHtml() {
        return methodMap(""html"");
    }

    /** Canned default for XML output. */
    public static HashMap<String, String> OutputXml() {
        return methodMap(""xml"");
    }

    private static HashMap<String, String> methodMap(String method) {
        HashMap<String, String> map = new HashMap<>();
        map.put(METHOD, method);
        return map;
    }

    /**
     * Convert a jsoup Document to a W3C Document. The created nodes will link back to the original
     * jsoup nodes in the user property {@link #SourceProperty} (but after conversion, changes on one side will not
     * flow to the other).
     *
     * @param in jsoup doc
     * @return a W3C DOM Document representing the jsoup Document or Element contents.
     */
    public Document fromJsoup(org.jsoup.nodes.Document in) {
        // just method API backcompat
        return fromJsoup((org.jsoup.nodes.Element) in);
    }

    /**
     * Convert a jsoup DOM to a W3C Document. The created nodes will link back to the original
     * jsoup nodes in the user property {@link #SourceProperty} (but after conversion, changes on one side will not
     * flow to the other). The input Element is used as a context node, but the whole surrounding jsoup Document is
     * converted. (If you just want a subtree converted, use {@link #convert(org.jsoup.nodes.Element, Document)}.)
     *
     * @param in jsoup element or doc
     * @return a W3C DOM Document representing the jsoup Document or Element contents.
     * @see #sourceNodes(NodeList, Class)
     * @see #contextNode(Document)
     */
    public Document fromJsoup(org.jsoup.nodes.Element in) {
        Validate.notNull(in);
        DocumentBuilder builder;
        try {
            builder = factory.newDocumentBuilder();
            DOMImplementation impl = builder.getDOMImplementation();
            Document out = builder.newDocument();
            org.jsoup.nodes.Document inDoc = in.ownerDocument();
            org.jsoup.nodes.DocumentType doctype = inDoc != null ? inDoc.documentType() : null;
            if (doctype != null) {
                org.w3c.dom.DocumentType documentType = impl.createDocumentType(doctype.name(), doctype.publicId(), doctype.systemId());
                out.appendChild(documentType);
            }
            out.setXmlStandalone(true);
            // if in is Document, use the root element, not the wrapping document, as the context:
            org.jsoup.nodes.Element context = (in instanceof org.jsoup.nodes.Document) ? in.child(0) : in;
            out.setUserData(ContextProperty, context, null);
            convert(inDoc != null ? inDoc : in, out);
            return out;
        } catch (ParserConfigurationException e) {
            throw new IllegalStateException(e);
        }
    }

    /**
     * Converts a jsoup document into the provided W3C Document. If required, you can set options on the output
     * document before converting.
     *
     * @param in jsoup doc
     * @param out w3c doc
     * @see org.jsoup.helper.W3CDom#fromJsoup(org.jsoup.nodes.Element)
     */
    public void convert(org.jsoup.nodes.Document in, Document out) {
        // just provides method API backcompat
        convert((org.jsoup.nodes.Element) in, out);
    }

    /**
     * Converts a jsoup element into the provided W3C Document. If required, you can set options on the output
     * document before converting.
     *
     * @param in jsoup element
     * @param out w3c doc
     * @see org.jsoup.helper.W3CDom#fromJsoup(org.jsoup.nodes.Element)
     */
    public void convert(org.jsoup.nodes.Element in, Document out) {
        W3CBuilder builder = new W3CBuilder(out);
        builder.namespaceAware = namespaceAware;
        org.jsoup.nodes.Document inDoc = in.ownerDocument();
        if (inDoc != null) {
            if (!StringUtil.isBlank(inDoc.location())) {
                out.setDocumentURI(inDoc.location());
            }
            builder.syntax = inDoc.outputSettings().syntax();
        }
        org.jsoup.nodes.Element rootEl = in instanceof org.jsoup.nodes.Document ? in.child(0) : in; // skip the #root node if a Document
        NodeTraversor.traverse(builder, rootEl);
    }

    /**
     Evaluate an XPath query against the supplied document, and return the results.
     @param xpath an XPath query
     @param doc the document to evaluate against
     @return the matches nodes
     */
    public NodeList selectXpath(String xpath, Document doc) {
        return selectXpath(xpath, (Node) doc);
    }

    /**
     Evaluate an XPath query against the supplied context node, and return the results.
     @param xpath an XPath query
     @param contextNode the context node to evaluate against
     @return the matches nodes
     */
    public NodeList selectXpath(String xpath, Node contextNode) {
        Validate.notEmptyParam(xpath, ""xpath"");
        Validate.notNullParam(contextNode, ""contextNode"");

        NodeList nodeList;
        try {
            // if there is a configured XPath factory, use that instead of the Java base impl:
            String property = System.getProperty(XPathFactoryProperty);
            final XPathFactory xPathFactory = property != null ?
                XPathFactory.newInstance(""jsoup"") :
                XPathFactory.newInstance();

            XPathExpression expression = xPathFactory.newXPath().compile(xpath);
            nodeList = (NodeList) expression.evaluate(contextNode, XPathConstants.NODESET); // love the strong typing here /s
            Validate.notNull(nodeList);
        } catch (XPathExpressionException | XPathFactoryConfigurationException e) {
            throw new Selector.SelectorParseException(""Could not evaluate XPath query [%s]: %s"", xpath, e.getMessage());
        }
        return nodeList;
    }

    /**
     Retrieves the original jsoup DOM nodes from a nodelist created by this convertor.
     @param nodeList the W3C nodes to get the original jsoup nodes from
     @param nodeType the jsoup node type to retrieve (e.g. Element, DataNode, etc)
     @param <T> node type
     @return a list of the original nodes
     */
    public <T extends org.jsoup.nodes.Node> List<T> sourceNodes(NodeList nodeList, Class<T> nodeType) {
        Validate.notNull(nodeList);
        Validate.notNull(nodeType);
        List<T> nodes = new ArrayList<>(nodeList.getLength());

        for (int i = 0; i < nodeList.getLength(); i++) {
            org.w3c.dom.Node node = nodeList.item(i);
            Object source = node.getUserData(W3CDom.SourceProperty);
            if (nodeType.isInstance(source))
                nodes.add(nodeType.cast(source));
        }

        return nodes;
    }

    /**
     For a Document created by {@link #fromJsoup(org.jsoup.nodes.Element)}, retrieves the W3C context node.
     @param wDoc Document created by this class
     @return the corresponding W3C Node to the jsoup Element that was used as the creating context.
     */
    public Node contextNode(Document wDoc) {
        return (Node) wDoc.getUserData(ContextNodeProperty);
    }

    /**
     * Serialize a W3C document to a String. The output format will be XML or HTML depending on the content of the doc.
     *
     * @param doc Document
     * @return Document as string
     * @see W3CDom#asString(Document, Map)
     */
    public String asString(Document doc) {
        return asString(doc, null);
    }

    /**
     * Implements the conversion by walking the input.
     */
    protected static class W3CBuilder implements NodeVisitor {
        private static final String xmlnsKey = ""xmlns"";
        private static final String xmlnsPrefix = ""xmlns:"";

        private final Document doc;
        private boolean namespaceAware = true;
        private final Stack<HashMap<String, String>> namespacesStack = new Stack<>(); // stack of namespaces, prefix => urn
        private Node dest;
        private Syntax syntax = Syntax.xml; // the syntax (to coerce attributes to). From the input doc if available.
        @Nullable private final org.jsoup.nodes.Element contextElement;

        public W3CBuilder(Document doc) {
            this.doc = doc;
            namespacesStack.push(new HashMap<>());
            dest = doc;
            contextElement = (org.jsoup.nodes.Element) doc.getUserData(ContextProperty); // Track the context jsoup Element, so we can save the corresponding w3c element
        }

        public void head(org.jsoup.nodes.Node source, int depth) {
            namespacesStack.push(new HashMap<>(namespacesStack.peek())); // inherit from above on the stack
            if (source instanceof org.jsoup.nodes.Element) {
                org.jsoup.nodes.Element sourceEl = (org.jsoup.nodes.Element) source;

                String prefix = updateNamespaces(sourceEl);
                String namespace = namespaceAware ? namespacesStack.peek().get(prefix) : null;
                String tagName = sourceEl.tagName();

                /* Tag names in XML are quite permissive, but less permissive than HTML. Rather than reimplement the validation,
                we just try to use it as-is. If it fails, insert as a text node instead. We don't try to normalize the
                tagname to something safe, because that isn't going to be meaningful downstream. This seems(?) to be
                how browsers handle the situation, also. https://github.com/jhy/jsoup/issues/1093 */
                try {
                    Element el = namespace == null && tagName.contains("":"") ?
                        doc.createElementNS("""", tagName) : // doesn't have a real namespace defined
                        doc.createElementNS(namespace, tagName);
                    copyAttributes(sourceEl, el);
                    append(el, sourceEl);
                    if (sourceEl == contextElement)
                        doc.setUserData(ContextNodeProperty, el, null);
                    dest = el; // descend
                } catch (DOMException e) {
                    append(doc.createTextNode(""<"" + tagName + "">""), sourceEl);
                }
            } else if (source instanceof org.jsoup.nodes.TextNode) {
                org.jsoup.nodes.TextNode sourceText = (org.jsoup.nodes.TextNode) source;
                Text text = doc.createTextNode(sourceText.getWholeText());
                append(text, sourceText);
            } else if (source instanceof org.jsoup.nodes.Comment) {
                org.jsoup.nodes.Comment sourceComment = (org.jsoup.nodes.Comment) source;
                Comment comment = doc.createComment(sourceComment.getData());
                append(comment, sourceComment);
            } else if (source instanceof org.jsoup.nodes.DataNode) {
                org.jsoup.nodes.DataNode sourceData = (org.jsoup.nodes.DataNode) source;
                Text node = doc.createTextNode(sourceData.getWholeData());
                append(node, sourceData);
            } else {
                // unhandled. note that doctype is not handled here - rather it is used in the initial doc creation
            }
        }

        private void append(Node append, org.jsoup.nodes.Node source) {
            append.setUserData(SourceProperty, source, null);
            dest.appendChild(append);
        }

        public void tail(org.jsoup.nodes.Node source, int depth) {
            if (source instanceof org.jsoup.nodes.Element && dest.getParentNode() instanceof Element) {
                dest = dest.getParentNode(); // undescend
            }
            namespacesStack.pop();
        }

        private void copyAttributes(org.jsoup.nodes.Node source, Element el) {
            for (Attribute attribute : source.attributes()) {
                String key = Attribute.getValidKey(attribute.getKey(), syntax);
                if (key != null) { // null if couldn't be coerced to validity
                    el.setAttribute(key, attribute.getValue());
                }
            }
        }

        /**
         * Finds any namespaces defined in this element. Returns any tag prefix.
         */
        private String updateNamespaces(org.jsoup.nodes.Element el) {
            // scan the element for namespace declarations
            // like: xmlns=""blah"" or xmlns:prefix=""blah""
            Attributes attributes = el.attributes();
            for (Attribute attr : attributes) {
                String key = attr.getKey();
                String prefix;
                if (key.equals(xmlnsKey)) {
                    prefix = """";
                } else if (key.startsWith(xmlnsPrefix)) {
                    prefix = key.substring(xmlnsPrefix.length());
                } else {
                    continue;
                }
                namespacesStack.peek().put(prefix, attr.getValue());
            }

            // get the element prefix if any
            int pos = el.tagName().indexOf(':');
            return pos > 0 ? el.tagName().substring(0, pos) : """";
        }

    }
}
"
jhy/jsoup,src/main/java/org/jsoup/parser/TreeBuilder.java,"package org.jsoup.parser;

import org.jsoup.helper.Validate;
import org.jsoup.nodes.Attributes;
import org.jsoup.nodes.Document;
import org.jsoup.nodes.Element;
import org.jsoup.nodes.Node;
import org.jsoup.nodes.Range;

import javax.annotation.Nullable;
import javax.annotation.ParametersAreNonnullByDefault;
import java.io.Reader;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * @author Jonathan Hedley
 */
abstract class TreeBuilder {
    protected Parser parser;
    CharacterReader reader;
    Tokeniser tokeniser;
    protected Document doc; // current doc we are building into
    protected ArrayList<Element> stack; // the stack of open elements
    protected String baseUri; // current base uri, for creating new elements
    protected Token currentToken; // currentToken is used only for error tracking.
    protected ParseSettings settings;
    protected Map<String, Tag> seenTags; // tags we've used in this parse; saves tag GC for custom tags.

    private Token.StartTag start = new Token.StartTag(); // start tag to process
    private Token.EndTag end  = new Token.EndTag();
    abstract ParseSettings defaultSettings();

    private boolean trackSourceRange;  // optionally tracks the source range of nodes

    @ParametersAreNonnullByDefault
    protected void initialiseParse(Reader input, String baseUri, Parser parser) {
        Validate.notNullParam(input, ""input"");
        Validate.notNullParam(baseUri, ""baseUri"");
        Validate.notNull(parser);

        doc = new Document(baseUri);
        doc.parser(parser);
        this.parser = parser;
        settings = parser.settings();
        reader = new CharacterReader(input);
        trackSourceRange = parser.isTrackPosition();
        reader.trackNewlines(parser.isTrackErrors() || trackSourceRange); // when tracking errors or source ranges, enable newline tracking for better legibility
        currentToken = null;
        tokeniser = new Tokeniser(reader, parser.getErrors());
        stack = new ArrayList<>(32);
        seenTags = new HashMap<>();
        this.baseUri = baseUri;
    }

    @ParametersAreNonnullByDefault
    Document parse(Reader input, String baseUri, Parser parser) {
        initialiseParse(input, baseUri, parser);
        runParser();

        // tidy up - as the Parser and Treebuilder are retained in document for settings / fragments
        reader.close();
        reader = null;
        tokeniser = null;
        stack = null;
        seenTags = null;

        return doc;
    }

    /**
     Create a new copy of this TreeBuilder
     @return copy, ready for a new parse
     */
    abstract TreeBuilder newInstance();

    abstract List<Node> parseFragment(String inputFragment, Element context, String baseUri, Parser parser);

    protected void runParser() {
        final Tokeniser tokeniser = this.tokeniser;
        final Token.TokenType eof = Token.TokenType.EOF;

        while (true) {
            Token token = tokeniser.read();
            process(token);
            token.reset();

            if (token.type == eof)
                break;
        }
    }

    protected abstract boolean process(Token token);

    protected boolean processStartTag(String name) {
        // these are ""virtual"" start tags (auto-created by the treebuilder), so not tracking the start position
        final Token.StartTag start = this.start;
        if (currentToken == start) { // don't recycle an in-use token
            return process(new Token.StartTag().name(name));
        }
        return process(start.reset().name(name));
    }

    public boolean processStartTag(String name, Attributes attrs) {
        final Token.StartTag start = this.start;
        if (currentToken == start) { // don't recycle an in-use token
            return process(new Token.StartTag().nameAttr(name, attrs));
        }
        start.reset();
        start.nameAttr(name, attrs);
        return process(start);
    }

    protected boolean processEndTag(String name) {
        if (currentToken == end) { // don't recycle an in-use token
            return process(new Token.EndTag().name(name));
        }
        return process(end.reset().name(name));
    }


    /**
     Get the current element (last on the stack). If all items have been removed, returns the document instead
     (which might not actually be on the stack; use stack.size() == 0 to test if required.
     @return the last element on the stack, if any; or the root document
     */
    protected Element currentElement() {
        int size = stack.size();
        return size > 0 ? stack.get(size-1) : doc;
    }

    /**
     Checks if the Current Element's normal name equals the supplied name.
     @param normalName name to check
     @return true if there is a current element on the stack, and its name equals the supplied
     */
    protected boolean currentElementIs(String normalName) {
        if (stack.size() == 0)
            return false;
        Element current = currentElement();
        return current != null && current.normalName().equals(normalName);
    }

    /**
     * If the parser is tracking errors, add an error at the current position.
     * @param msg error message
     */
    protected void error(String msg) {
        error(msg, (Object[]) null);
    }

    /**
     * If the parser is tracking errors, add an error at the current position.
     * @param msg error message template
     * @param args template arguments
     */
    protected void error(String msg, Object... args) {
        ParseErrorList errors = parser.getErrors();
        if (errors.canAddError())
            errors.add(new ParseError(reader, msg, args));
    }

    /**
     (An internal method, visible for Element. For HTML parse, signals that script and style text should be treated as
     Data Nodes).
     */
    protected boolean isContentForTagData(String normalName) {
        return false;
    }

    protected Tag tagFor(String tagName, ParseSettings settings) {
        Tag tag = seenTags.get(tagName); // note that we don't normalize the cache key. But tag via valueOf may be normalized.
        if (tag == null) {
            tag = Tag.valueOf(tagName, settings);
            seenTags.put(tagName, tag);
        }
        return tag;
    }

    /**
     Called by implementing TreeBuilders when a node has been inserted. This implementation includes optionally tracking
     the source range of the node.
     * @param node the node that was just inserted
     * @param token the (optional) token that created this node
     */
    protected void onNodeInserted(Node node, @Nullable Token token) {
        trackNodePosition(node, token, true);
    }

    /**
     Called by implementing TreeBuilders when a node is explicitly closed. This implementation includes optionally
     tracking the closing source range of the node.
     * @param node the node being closed
     * @param token the end-tag token that closed this node
     */
    protected void onNodeClosed(Node node, Token token) {
        trackNodePosition(node, token, false);
    }

    private void trackNodePosition(Node node, @Nullable Token token, boolean start) {
        if (trackSourceRange && token != null) {
            int startPos = token.startPos();
            if (startPos == Token.Unset) return; // untracked, virtual token

            Range.Position startRange = new Range.Position(startPos, reader.lineNumber(startPos), reader.columnNumber(startPos));
            int endPos = token.endPos();
            Range.Position endRange = new Range.Position(endPos, reader.lineNumber(endPos), reader.columnNumber(endPos));
            Range range = new Range(startRange, endRange);
            range.track(node, start);
        }
    }
}
"
jhy/jsoup,src/main/java/org/jsoup/safety/Safelist.java,"package org.jsoup.safety;

/*
    Thank you to Ryan Grove (wonko.com) for the Ruby HTML cleaner http://github.com/rgrove/sanitize/, which inspired
    this safe-list configuration, and the initial defaults.
 */

import org.jsoup.helper.Validate;
import org.jsoup.nodes.Attribute;
import org.jsoup.nodes.Attributes;
import org.jsoup.nodes.Element;

import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;

import static org.jsoup.internal.Normalizer.lowerCase;


/**
 Safe-lists define what HTML (elements and attributes) to allow through the cleaner. Everything else is removed.
 <p>
 Start with one of the defaults:
 </p>
 <ul>
 <li>{@link #none}
 <li>{@link #simpleText}
 <li>{@link #basic}
 <li>{@link #basicWithImages}
 <li>{@link #relaxed}
 </ul>
 <p>
 If you need to allow more through (please be careful!), tweak a base safelist with:
 </p>
 <ul>
 <li>{@link #addTags(String... tagNames)}
 <li>{@link #addAttributes(String tagName, String... attributes)}
 <li>{@link #addEnforcedAttribute(String tagName, String attribute, String value)}
 <li>{@link #addProtocols(String tagName, String attribute, String... protocols)}
 </ul>
 <p>
 You can remove any setting from an existing safelist with:
 </p>
 <ul>
 <li>{@link #removeTags(String... tagNames)}
 <li>{@link #removeAttributes(String tagName, String... attributes)}
 <li>{@link #removeEnforcedAttribute(String tagName, String attribute)}
 <li>{@link #removeProtocols(String tagName, String attribute, String... removeProtocols)}
 </ul>

 <p>
 The cleaner and these safelists assume that you want to clean a <code>body</code> fragment of HTML (to add user
 supplied HTML into a templated page), and not to clean a full HTML document. If the latter is the case, either wrap the
 document HTML around the cleaned body HTML, or create a safelist that allows <code>html</code> and <code>head</code>
 elements as appropriate.
 </p>
 <p>
 If you are going to extend a safelist, please be very careful. Make sure you understand what attributes may lead to
 XSS attack vectors. URL attributes are particularly vulnerable and require careful validation. See 
 the <a href=""https://owasp.org/www-community/xss-filter-evasion-cheatsheet"">XSS Filter Evasion Cheat Sheet</a> for some
 XSS attack examples (that jsoup will safegaurd against the default Cleaner and Safelist configuration).
 </p>
 */
public class Safelist {
    private final Set<TagName> tagNames; // tags allowed, lower case. e.g. [p, br, span]
    private final Map<TagName, Set<AttributeKey>> attributes; // tag -> attribute[]. allowed attributes [href] for a tag.
    private final Map<TagName, Map<AttributeKey, AttributeValue>> enforcedAttributes; // always set these attribute values
    private final Map<TagName, Map<AttributeKey, Set<Protocol>>> protocols; // allowed URL protocols for attributes
    private boolean preserveRelativeLinks; // option to preserve relative links

    /**
     This safelist allows only text nodes: all HTML will be stripped.

     @return safelist
     */
    public static Safelist none() {
        return new Safelist();
    }

    /**
     This safelist allows only simple text formatting: <code>b, em, i, strong, u</code>. All other HTML (tags and
     attributes) will be removed.

     @return safelist
     */
    public static Safelist simpleText() {
        return new Safelist()
                .addTags(""b"", ""em"", ""i"", ""strong"", ""u"")
                ;
    }

    /**
     <p>
     This safelist allows a fuller range of text nodes: <code>a, b, blockquote, br, cite, code, dd, dl, dt, em, i, li,
     ol, p, pre, q, small, span, strike, strong, sub, sup, u, ul</code>, and appropriate attributes.
     </p>
     <p>
     Links (<code>a</code> elements) can point to <code>http, https, ftp, mailto</code>, and have an enforced
     <code>rel=nofollow</code> attribute.
     </p>
     <p>
     Does not allow images.
     </p>

     @return safelist
     */
    public static Safelist basic() {
        return new Safelist()
                .addTags(
                        ""a"", ""b"", ""blockquote"", ""br"", ""cite"", ""code"", ""dd"", ""dl"", ""dt"", ""em"",
                        ""i"", ""li"", ""ol"", ""p"", ""pre"", ""q"", ""small"", ""span"", ""strike"", ""strong"", ""sub"",
                        ""sup"", ""u"", ""ul"")

                .addAttributes(""a"", ""href"")
                .addAttributes(""blockquote"", ""cite"")
                .addAttributes(""q"", ""cite"")

                .addProtocols(""a"", ""href"", ""ftp"", ""http"", ""https"", ""mailto"")
                .addProtocols(""blockquote"", ""cite"", ""http"", ""https"")
                .addProtocols(""cite"", ""cite"", ""http"", ""https"")

                .addEnforcedAttribute(""a"", ""rel"", ""nofollow"")
                ;

    }

    /**
     This safelist allows the same text tags as {@link #basic}, and also allows <code>img</code> tags, with appropriate
     attributes, with <code>src</code> pointing to <code>http</code> or <code>https</code>.

     @return safelist
     */
    public static Safelist basicWithImages() {
        return basic()
                .addTags(""img"")
                .addAttributes(""img"", ""align"", ""alt"", ""height"", ""src"", ""title"", ""width"")
                .addProtocols(""img"", ""src"", ""http"", ""https"")
                ;
    }

    /**
     This safelist allows a full range of text and structural body HTML: <code>a, b, blockquote, br, caption, cite,
     code, col, colgroup, dd, div, dl, dt, em, h1, h2, h3, h4, h5, h6, i, img, li, ol, p, pre, q, small, span, strike, strong, sub,
     sup, table, tbody, td, tfoot, th, thead, tr, u, ul</code>
     <p>
     Links do not have an enforced <code>rel=nofollow</code> attribute, but you can add that if desired.
     </p>

     @return safelist
     */
    public static Safelist relaxed() {
        return new Safelist()
                .addTags(
                        ""a"", ""b"", ""blockquote"", ""br"", ""caption"", ""cite"", ""code"", ""col"",
                        ""colgroup"", ""dd"", ""div"", ""dl"", ""dt"", ""em"", ""h1"", ""h2"", ""h3"", ""h4"", ""h5"", ""h6"",
                        ""i"", ""img"", ""li"", ""ol"", ""p"", ""pre"", ""q"", ""small"", ""span"", ""strike"", ""strong"",
                        ""sub"", ""sup"", ""table"", ""tbody"", ""td"", ""tfoot"", ""th"", ""thead"", ""tr"", ""u"",
                        ""ul"")

                .addAttributes(""a"", ""href"", ""title"")
                .addAttributes(""blockquote"", ""cite"")
                .addAttributes(""col"", ""span"", ""width"")
                .addAttributes(""colgroup"", ""span"", ""width"")
                .addAttributes(""img"", ""align"", ""alt"", ""height"", ""src"", ""title"", ""width"")
                .addAttributes(""ol"", ""start"", ""type"")
                .addAttributes(""q"", ""cite"")
                .addAttributes(""table"", ""summary"", ""width"")
                .addAttributes(""td"", ""abbr"", ""axis"", ""colspan"", ""rowspan"", ""width"")
                .addAttributes(
                        ""th"", ""abbr"", ""axis"", ""colspan"", ""rowspan"", ""scope"",
                        ""width"")
                .addAttributes(""ul"", ""type"")

                .addProtocols(""a"", ""href"", ""ftp"", ""http"", ""https"", ""mailto"")
                .addProtocols(""blockquote"", ""cite"", ""http"", ""https"")
                .addProtocols(""cite"", ""cite"", ""http"", ""https"")
                .addProtocols(""img"", ""src"", ""http"", ""https"")
                .addProtocols(""q"", ""cite"", ""http"", ""https"")
                ;
    }

    /**
     Create a new, empty safelist. Generally it will be better to start with a default prepared safelist instead.

     @see #basic()
     @see #basicWithImages()
     @see #simpleText()
     @see #relaxed()
     */
    public Safelist() {
        tagNames = new HashSet<>();
        attributes = new HashMap<>();
        enforcedAttributes = new HashMap<>();
        protocols = new HashMap<>();
        preserveRelativeLinks = false;
    }

    /**
     Deep copy an existing Safelist to a new Safelist.
     @param copy the Safelist to copy
     */
    public Safelist(Safelist copy) {
        this();
        tagNames.addAll(copy.tagNames);
        for (Map.Entry<TagName, Set<AttributeKey>> copyTagAttributes : copy.attributes.entrySet()) {
            attributes.put(copyTagAttributes.getKey(), new HashSet<>(copyTagAttributes.getValue()));
        }
        for (Map.Entry<TagName, Map<AttributeKey, AttributeValue>> enforcedEntry : copy.enforcedAttributes.entrySet()) {
            enforcedAttributes.put(enforcedEntry.getKey(), new HashMap<>(enforcedEntry.getValue()));
        }
        for (Map.Entry<TagName, Map<AttributeKey, Set<Protocol>>> protocolsEntry : copy.protocols.entrySet()) {
            Map<AttributeKey, Set<Protocol>> attributeProtocolsCopy = new HashMap<>();
            for (Map.Entry<AttributeKey, Set<Protocol>> attributeProtocols : protocolsEntry.getValue().entrySet()) {
                attributeProtocolsCopy.put(attributeProtocols.getKey(), new HashSet<>(attributeProtocols.getValue()));
            }
            protocols.put(protocolsEntry.getKey(), attributeProtocolsCopy);
        }
        preserveRelativeLinks = copy.preserveRelativeLinks;
    }

    /**
     Add a list of allowed elements to a safelist. (If a tag is not allowed, it will be removed from the HTML.)

     @param tags tag names to allow
     @return this (for chaining)
     */
    public Safelist addTags(String... tags) {
        Validate.notNull(tags);

        for (String tagName : tags) {
            Validate.notEmpty(tagName);
            tagNames.add(TagName.valueOf(tagName));
        }
        return this;
    }

    /**
     Remove a list of allowed elements from a safelist. (If a tag is not allowed, it will be removed from the HTML.)

     @param tags tag names to disallow
     @return this (for chaining)
     */
    public Safelist removeTags(String... tags) {
        Validate.notNull(tags);

        for(String tag: tags) {
            Validate.notEmpty(tag);
            TagName tagName = TagName.valueOf(tag);

            if(tagNames.remove(tagName)) { // Only look in sub-maps if tag was allowed
                attributes.remove(tagName);
                enforcedAttributes.remove(tagName);
                protocols.remove(tagName);
            }
        }
        return this;
    }

    /**
     Add a list of allowed attributes to a tag. (If an attribute is not allowed on an element, it will be removed.)
     <p>
     E.g.: <code>addAttributes(""a"", ""href"", ""class"")</code> allows <code>href</code> and <code>class</code> attributes
     on <code>a</code> tags.
     </p>
     <p>
     To make an attribute valid for <b>all tags</b>, use the pseudo tag <code>:all</code>, e.g.
     <code>addAttributes("":all"", ""class"")</code>.
     </p>

     @param tag  The tag the attributes are for. The tag will be added to the allowed tag list if necessary.
     @param attributes List of valid attributes for the tag
     @return this (for chaining)
     */
    public Safelist addAttributes(String tag, String... attributes) {
        Validate.notEmpty(tag);
        Validate.notNull(attributes);
        Validate.isTrue(attributes.length > 0, ""No attribute names supplied."");

        TagName tagName = TagName.valueOf(tag);
        tagNames.add(tagName);
        Set<AttributeKey> attributeSet = new HashSet<>();
        for (String key : attributes) {
            Validate.notEmpty(key);
            attributeSet.add(AttributeKey.valueOf(key));
        }
        if (this.attributes.containsKey(tagName)) {
            Set<AttributeKey> currentSet = this.attributes.get(tagName);
            currentSet.addAll(attributeSet);
        } else {
            this.attributes.put(tagName, attributeSet);
        }
        return this;
    }

    /**
     Remove a list of allowed attributes from a tag. (If an attribute is not allowed on an element, it will be removed.)
     <p>
     E.g.: <code>removeAttributes(""a"", ""href"", ""class"")</code> disallows <code>href</code> and <code>class</code>
     attributes on <code>a</code> tags.
     </p>
     <p>
     To make an attribute invalid for <b>all tags</b>, use the pseudo tag <code>:all</code>, e.g.
     <code>removeAttributes("":all"", ""class"")</code>.
     </p>

     @param tag  The tag the attributes are for.
     @param attributes List of invalid attributes for the tag
     @return this (for chaining)
     */
    public Safelist removeAttributes(String tag, String... attributes) {
        Validate.notEmpty(tag);
        Validate.notNull(attributes);
        Validate.isTrue(attributes.length > 0, ""No attribute names supplied."");

        TagName tagName = TagName.valueOf(tag);
        Set<AttributeKey> attributeSet = new HashSet<>();
        for (String key : attributes) {
            Validate.notEmpty(key);
            attributeSet.add(AttributeKey.valueOf(key));
        }
        if(tagNames.contains(tagName) && this.attributes.containsKey(tagName)) { // Only look in sub-maps if tag was allowed
            Set<AttributeKey> currentSet = this.attributes.get(tagName);
            currentSet.removeAll(attributeSet);

            if(currentSet.isEmpty()) // Remove tag from attribute map if no attributes are allowed for tag
                this.attributes.remove(tagName);
        }
        if(tag.equals("":all"")) // Attribute needs to be removed from all individually set tags
            for(TagName name: this.attributes.keySet()) {
                Set<AttributeKey> currentSet = this.attributes.get(name);
                currentSet.removeAll(attributeSet);

                if(currentSet.isEmpty()) // Remove tag from attribute map if no attributes are allowed for tag
                    this.attributes.remove(name);
            }
        return this;
    }

    /**
     Add an enforced attribute to a tag. An enforced attribute will always be added to the element. If the element
     already has the attribute set, it will be overridden with this value.
     <p>
     E.g.: <code>addEnforcedAttribute(""a"", ""rel"", ""nofollow"")</code> will make all <code>a</code> tags output as
     <code>&lt;a href=""..."" rel=""nofollow""&gt;</code>
     </p>

     @param tag   The tag the enforced attribute is for. The tag will be added to the allowed tag list if necessary.
     @param attribute   The attribute name
     @param value The enforced attribute value
     @return this (for chaining)
     */
    public Safelist addEnforcedAttribute(String tag, String attribute, String value) {
        Validate.notEmpty(tag);
        Validate.notEmpty(attribute);
        Validate.notEmpty(value);

        TagName tagName = TagName.valueOf(tag);
        tagNames.add(tagName);
        AttributeKey attrKey = AttributeKey.valueOf(attribute);
        AttributeValue attrVal = AttributeValue.valueOf(value);

        if (enforcedAttributes.containsKey(tagName)) {
            enforcedAttributes.get(tagName).put(attrKey, attrVal);
        } else {
            Map<AttributeKey, AttributeValue> attrMap = new HashMap<>();
            attrMap.put(attrKey, attrVal);
            enforcedAttributes.put(tagName, attrMap);
        }
        return this;
    }

    /**
     Remove a previously configured enforced attribute from a tag.

     @param tag   The tag the enforced attribute is for.
     @param attribute   The attribute name
     @return this (for chaining)
     */
    public Safelist removeEnforcedAttribute(String tag, String attribute) {
        Validate.notEmpty(tag);
        Validate.notEmpty(attribute);

        TagName tagName = TagName.valueOf(tag);
        if(tagNames.contains(tagName) && enforcedAttributes.containsKey(tagName)) {
            AttributeKey attrKey = AttributeKey.valueOf(attribute);
            Map<AttributeKey, AttributeValue> attrMap = enforcedAttributes.get(tagName);
            attrMap.remove(attrKey);

            if(attrMap.isEmpty()) // Remove tag from enforced attribute map if no enforced attributes are present
                enforcedAttributes.remove(tagName);
        }
        return this;
    }

    /**
     * Configure this Safelist to preserve relative links in an element's URL attribute, or convert them to absolute
     * links. By default, this is <b>false</b>: URLs will be  made absolute (e.g. start with an allowed protocol, like
     * e.g. {@code http://}.
     * <p>
     * Note that when handling relative links, the input document must have an appropriate {@code base URI} set when
     * parsing, so that the link's protocol can be confirmed. Regardless of the setting of the {@code preserve relative
     * links} option, the link must be resolvable against the base URI to an allowed protocol; otherwise the attribute
     * will be removed.
     * </p>
     *
     * @param preserve {@code true} to allow relative links, {@code false} (default) to deny
     * @return this Safelist, for chaining.
     * @see #addProtocols
     */
    public Safelist preserveRelativeLinks(boolean preserve) {
        preserveRelativeLinks = preserve;
        return this;
    }

    /**
     Add allowed URL protocols for an element's URL attribute. This restricts the possible values of the attribute to
     URLs with the defined protocol.
     <p>
     E.g.: <code>addProtocols(""a"", ""href"", ""ftp"", ""http"", ""https"")</code>
     </p>
     <p>
     To allow a link to an in-page URL anchor (i.e. <code>&lt;a href=""#anchor""&gt;</code>, add a <code>#</code>:<br>
     E.g.: <code>addProtocols(""a"", ""href"", ""#"")</code>
     </p>

     @param tag       Tag the URL protocol is for
     @param attribute       Attribute name
     @param protocols List of valid protocols
     @return this, for chaining
     */
    public Safelist addProtocols(String tag, String attribute, String... protocols) {
        Validate.notEmpty(tag);
        Validate.notEmpty(attribute);
        Validate.notNull(protocols);

        TagName tagName = TagName.valueOf(tag);
        AttributeKey attrKey = AttributeKey.valueOf(attribute);
        Map<AttributeKey, Set<Protocol>> attrMap;
        Set<Protocol> protSet;

        if (this.protocols.containsKey(tagName)) {
            attrMap = this.protocols.get(tagName);
        } else {
            attrMap = new HashMap<>();
            this.protocols.put(tagName, attrMap);
        }
        if (attrMap.containsKey(attrKey)) {
            protSet = attrMap.get(attrKey);
        } else {
            protSet = new HashSet<>();
            attrMap.put(attrKey, protSet);
        }
        for (String protocol : protocols) {
            Validate.notEmpty(protocol);
            Protocol prot = Protocol.valueOf(protocol);
            protSet.add(prot);
        }
        return this;
    }

    /**
     Remove allowed URL protocols for an element's URL attribute. If you remove all protocols for an attribute, that
     attribute will allow any protocol.
     <p>
     E.g.: <code>removeProtocols(""a"", ""href"", ""ftp"")</code>
     </p>

     @param tag Tag the URL protocol is for
     @param attribute Attribute name
     @param removeProtocols List of invalid protocols
     @return this, for chaining
     */
    public Safelist removeProtocols(String tag, String attribute, String... removeProtocols) {
        Validate.notEmpty(tag);
        Validate.notEmpty(attribute);
        Validate.notNull(removeProtocols);

        TagName tagName = TagName.valueOf(tag);
        AttributeKey attr = AttributeKey.valueOf(attribute);

        // make sure that what we're removing actually exists; otherwise can open the tag to any data and that can
        // be surprising
        Validate.isTrue(protocols.containsKey(tagName), ""Cannot remove a protocol that is not set."");
        Map<AttributeKey, Set<Protocol>> tagProtocols = protocols.get(tagName);
        Validate.isTrue(tagProtocols.containsKey(attr), ""Cannot remove a protocol that is not set."");

        Set<Protocol> attrProtocols = tagProtocols.get(attr);
        for (String protocol : removeProtocols) {
            Validate.notEmpty(protocol);
            attrProtocols.remove(Protocol.valueOf(protocol));
        }

        if (attrProtocols.isEmpty()) { // Remove protocol set if empty
            tagProtocols.remove(attr);
            if (tagProtocols.isEmpty()) // Remove entry for tag if empty
                protocols.remove(tagName);
        }
        return this;
    }

    /**
     * Test if the supplied tag is allowed by this safelist
     * @param tag test tag
     * @return true if allowed
     */
    protected boolean isSafeTag(String tag) {
        return tagNames.contains(TagName.valueOf(tag));
    }

    /**
     * Test if the supplied attribute is allowed by this safelist for this tag
     * @param tagName tag to consider allowing the attribute in
     * @param el element under test, to confirm protocol
     * @param attr attribute under test
     * @return true if allowed
     */
    protected boolean isSafeAttribute(String tagName, Element el, Attribute attr) {
        TagName tag = TagName.valueOf(tagName);
        AttributeKey key = AttributeKey.valueOf(attr.getKey());

        Set<AttributeKey> okSet = attributes.get(tag);
        if (okSet != null && okSet.contains(key)) {
            if (protocols.containsKey(tag)) {
                Map<AttributeKey, Set<Protocol>> attrProts = protocols.get(tag);
                // ok if not defined protocol; otherwise test
                return !attrProts.containsKey(key) || testValidProtocol(el, attr, attrProts.get(key));
            } else { // attribute found, no protocols defined, so OK
                return true;
            }
        }
        // might be an enforced attribute?
        Map<AttributeKey, AttributeValue> enforcedSet = enforcedAttributes.get(tag);
        if (enforcedSet != null) {
            Attributes expect = getEnforcedAttributes(tagName);
            String attrKey = attr.getKey();
            if (expect.hasKeyIgnoreCase(attrKey)) {
                return expect.getIgnoreCase(attrKey).equals(attr.getValue());
            }
        }
        // no attributes defined for tag, try :all tag
        return !tagName.equals("":all"") && isSafeAttribute("":all"", el, attr);
    }

    private boolean testValidProtocol(Element el, Attribute attr, Set<Protocol> protocols) {
        // try to resolve relative urls to abs, and optionally update the attribute so output html has abs.
        // rels without a baseuri get removed
        String value = el.absUrl(attr.getKey());
        if (value.length() == 0)
            value = attr.getValue(); // if it could not be made abs, run as-is to allow custom unknown protocols
        if (!preserveRelativeLinks)
            attr.setValue(value);
        
        for (Protocol protocol : protocols) {
            String prot = protocol.toString();

            if (prot.equals(""#"")) { // allows anchor links
                if (isValidAnchor(value)) {
                    return true;
                } else {
                    continue;
                }
            }

            prot += "":"";

            if (lowerCase(value).startsWith(prot)) {
                return true;
            }
        }
        return false;
    }

    private boolean isValidAnchor(String value) {
        return value.startsWith(""#"") && !value.matches("".*\\s.*"");
    }

    Attributes getEnforcedAttributes(String tagName) {
        Attributes attrs = new Attributes();
        TagName tag = TagName.valueOf(tagName);
        if (enforcedAttributes.containsKey(tag)) {
            Map<AttributeKey, AttributeValue> keyVals = enforcedAttributes.get(tag);
            for (Map.Entry<AttributeKey, AttributeValue> entry : keyVals.entrySet()) {
                attrs.put(entry.getKey().toString(), entry.getValue().toString());
            }
        }
        return attrs;
    }
    
    // named types for config. All just hold strings, but here for my sanity.

    static class TagName extends TypedValue {
        TagName(String value) {
            super(value);
        }

        static TagName valueOf(String value) {
            return new TagName(value);
        }
    }

    static class AttributeKey extends TypedValue {
        AttributeKey(String value) {
            super(value);
        }

        static AttributeKey valueOf(String value) {
            return new AttributeKey(value);
        }
    }

    static class AttributeValue extends TypedValue {
        AttributeValue(String value) {
            super(value);
        }

        static AttributeValue valueOf(String value) {
            return new AttributeValue(value);
        }
    }

    static class Protocol extends TypedValue {
        Protocol(String value) {
            super(value);
        }

        static Protocol valueOf(String value) {
            return new Protocol(value);
        }
    }

    abstract static class TypedValue {
        private final String value;

        TypedValue(String value) {
            Validate.notNull(value);
            this.value = value;
        }

        @Override
        public int hashCode() {
            final int prime = 31;
            int result = 1;
            result = prime * result + ((value == null) ? 0 : value.hashCode());
            return result;
        }

        @Override
        public boolean equals(Object obj) {
            if (this == obj) return true;
            if (obj == null) return false;
            if (getClass() != obj.getClass()) return false;
            TypedValue other = (TypedValue) obj;
            if (value == null) {
                return other.value == null;
            } else return value.equals(other.value);
        }

        @Override
        public String toString() {
            return value;
        }
    }
}
"
jhy/jsoup,src/main/java/org/jsoup/parser/ParseError.java,"package org.jsoup.parser;

/**
 * A Parse Error records an error in the input HTML that occurs in either the tokenisation or the tree building phase.
 */
public class ParseError {
    private int pos;
    private String cursorPos;
    private String errorMsg;

    ParseError(CharacterReader reader, String errorMsg) {
        pos = reader.pos();
        cursorPos = reader.cursorPos();
        this.errorMsg = errorMsg;
    }

    ParseError(CharacterReader reader, String errorFormat, Object... args) {
        pos = reader.pos();
        cursorPos = reader.cursorPos();
        this.errorMsg = String.format(errorFormat, args);
    }

    ParseError(int pos, String errorMsg) {
        this.pos = pos;
        cursorPos = String.valueOf(pos);
        this.errorMsg = errorMsg;
    }

    ParseError(int pos, String errorFormat, Object... args) {
        this.pos = pos;
        cursorPos = String.valueOf(pos);
        this.errorMsg = String.format(errorFormat, args);
    }

    /**
     * Retrieve the error message.
     * @return the error message.
     */
    public String getErrorMessage() {
        return errorMsg;
    }

    /**
     * Retrieves the offset of the error.
     * @return error offset within input
     */
    public int getPosition() {
        return pos;
    }

    /**
     Get the formatted line:column cursor position where the error occurred.
     @return line:number cursor position
     */
    public String getCursorPos() {
        return cursorPos;
    }

    @Override
    public String toString() {
        return ""<"" + cursorPos + "">: "" + errorMsg;
    }
}
"
jhy/jsoup,src/test/java/org/jsoup/integration/ConnectTest.java,"package org.jsoup.integration;

import org.jsoup.Connection;
import org.jsoup.HttpStatusException;
import org.jsoup.Jsoup;
import org.jsoup.helper.W3CDom;
import org.jsoup.integration.servlets.*;
import org.jsoup.internal.StringUtil;
import org.jsoup.nodes.Document;
import org.jsoup.nodes.Element;
import org.jsoup.nodes.FormElement;
import org.jsoup.parser.HtmlTreeBuilder;
import org.jsoup.parser.Parser;
import org.jsoup.parser.XmlTreeBuilder;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Test;

import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.net.MalformedURLException;
import java.net.URL;
import java.util.List;
import java.util.Map;

import static org.jsoup.helper.HttpConnection.CONTENT_TYPE;
import static org.jsoup.helper.HttpConnection.MULTIPART_FORM_DATA;
import static org.jsoup.integration.UrlConnectTest.browserUa;
import static org.junit.jupiter.api.Assertions.*;

/**
 * Tests Jsoup.connect against a local server.
 */
public class ConnectTest {
    private static String echoUrl;

    @BeforeAll
    public static void setUp() {
        TestServer.start();
        echoUrl = EchoServlet.Url;
    }

    @Test
    public void canConnectToLocalServer() throws IOException {
        String url = HelloServlet.Url;
        Document doc = Jsoup.connect(url).get();
        Element p = doc.selectFirst(""p"");
        assertEquals(""Hello, World!"", p.text());
    }

    @Test
    public void fetchURl() throws IOException {
        Document doc = Jsoup.parse(new URL(echoUrl), 10 * 1000);
        assertTrue(doc.title().contains(""Environment Variables""));
    }

    @Test
    public void fetchURIWithWhitespace() throws IOException {
        Connection con = Jsoup.connect(echoUrl + ""#with whitespaces"");
        Document doc = con.get();
        assertTrue(doc.title().contains(""Environment Variables""));
    }

    @Test
    public void exceptOnUnsupportedProtocol() {
        String url = ""file://etc/passwd"";
        boolean threw = false;
        try {
            Document doc = Jsoup.connect(url).get();
        } catch (MalformedURLException e) {
            threw = true;
            assertEquals(""java.net.MalformedURLException: Only http & https protocols supported"", e.toString());
        } catch (IOException e) {
        }
        assertTrue(threw);
    }

    private static String ihVal(String key, Document doc) {
        final Element first = doc.select(""th:contains("" + key + "") + td"").first();
        return first != null ? first.text() : null;
    }

    @Test
    public void throwsExceptionOn404() {
        String url = EchoServlet.Url;
        Connection con = Jsoup.connect(url).header(EchoServlet.CodeParam, ""404"");

        boolean threw = false;
        try {
            Document doc = con.get();
        } catch (HttpStatusException e) {
            threw = true;
            assertEquals(""org.jsoup.HttpStatusException: HTTP error fetching URL. Status=404, URL=["" + e.getUrl() + ""]"", e.toString());
            assertTrue(e.getUrl().startsWith(url));
            assertEquals(404, e.getStatusCode());
        } catch (IOException e) {
        }
        assertTrue(threw);
    }

    @Test
    public void ignoresExceptionIfSoConfigured() throws IOException {
        String url = EchoServlet.Url;
        Connection con = Jsoup.connect(url)
            .header(EchoServlet.CodeParam, ""404"")
            .ignoreHttpErrors(true);
        Connection.Response res = con.execute();
        Document doc = res.parse();
        assertEquals(404, res.statusCode());
        assertEquals(""Webserver Environment Variables"", doc.title());
    }

    @Test
    public void doesPost() throws IOException {
        Document doc = Jsoup.connect(echoUrl)
            .data(""uname"", ""Jsoup"", ""uname"", ""Jonathan"", ""Áôæ"", ""Â∫¶‰∏Ä‰∏ã"")
            .cookie(""auth"", ""token"")
            .post();

        assertEquals(""POST"", ihVal(""Method"", doc));
        assertEquals(""gzip"", ihVal(""Accept-Encoding"", doc));
        assertEquals(""auth=token"", ihVal(""Cookie"", doc));
        assertEquals(""Â∫¶‰∏Ä‰∏ã"", ihVal(""Áôæ"", doc));
        assertEquals(""Jsoup, Jonathan"", ihVal(""uname"", doc));
        assertEquals(""application/x-www-form-urlencoded; charset=UTF-8"", ihVal(""Content-Type"", doc));
    }

    @Test
    public void doesPostMultipartWithoutInputstream() throws IOException {
        Document doc = Jsoup.connect(echoUrl)
                .header(CONTENT_TYPE, MULTIPART_FORM_DATA)
                .userAgent(browserUa)
                .data(""uname"", ""Jsoup"", ""uname"", ""Jonathan"", ""Áôæ"", ""Â∫¶‰∏Ä‰∏ã"")
                .post();

        assertTrue(ihVal(""Content-Type"", doc).contains(MULTIPART_FORM_DATA));

        assertTrue(ihVal(""Content-Type"", doc).contains(""boundary"")); // should be automatically set
        assertEquals(""Jsoup, Jonathan"", ihVal(""uname"", doc));
        assertEquals(""Â∫¶‰∏Ä‰∏ã"", ihVal(""Áôæ"", doc));
    }

    @Test
    public void canSendSecFetchHeaders() throws IOException {
        // https://github.com/jhy/jsoup/issues/1461
        Document doc = Jsoup.connect(echoUrl)
            .header(""Random-Header-name"", ""hello"")
            .header(""Sec-Fetch-Site"", ""cross-site"")
            .header(""Sec-Fetch-Mode"", ""cors"")
            .get();

        assertEquals(""hello"", ihVal(""Random-Header-name"", doc));
        assertEquals(""cross-site"", ihVal(""Sec-Fetch-Site"", doc));
        assertEquals(""cors"", ihVal(""Sec-Fetch-Mode"", doc));
    }

    @Test
    public void secFetchHeadersSurviveRedirect() throws IOException {
        Document doc = Jsoup
            .connect(RedirectServlet.Url)
            .data(RedirectServlet.LocationParam, echoUrl)
            .header(""Random-Header-name"", ""hello"")
            .header(""Sec-Fetch-Site"", ""cross-site"")
            .header(""Sec-Fetch-Mode"", ""cors"")
            .get();

        assertEquals(""hello"", ihVal(""Random-Header-name"", doc));
        assertEquals(""cross-site"", ihVal(""Sec-Fetch-Site"", doc));
        assertEquals(""cors"", ihVal(""Sec-Fetch-Mode"", doc));
    }

    @Test
    public void sendsRequestBodyJsonWithData() throws IOException {
        final String body = ""{key:value}"";
        Document doc = Jsoup.connect(echoUrl)
            .requestBody(body)
            .header(""Content-Type"", ""application/json"")
            .userAgent(browserUa)
            .data(""foo"", ""true"")
            .post();
        assertEquals(""POST"", ihVal(""Method"", doc));
        assertEquals(""application/json"", ihVal(""Content-Type"", doc));
        assertEquals(""foo=true"", ihVal(""Query String"", doc));
        assertEquals(body, ihVal(""Post Data"", doc));
    }

    @Test
    public void sendsRequestBodyJsonWithoutData() throws IOException {
        final String body = ""{key:value}"";
        Document doc = Jsoup.connect(echoUrl)
            .requestBody(body)
            .header(""Content-Type"", ""application/json"")
            .userAgent(browserUa)
            .post();
        assertEquals(""POST"", ihVal(""Method"", doc));
        assertEquals(""application/json"", ihVal(""Content-Type"", doc));
        assertEquals(body, ihVal(""Post Data"", doc));
    }

    @Test
    public void sendsRequestBody() throws IOException {
        final String body = ""{key:value}"";
        Document doc = Jsoup.connect(echoUrl)
            .requestBody(body)
            .header(""Content-Type"", ""text/plain"")
            .userAgent(browserUa)
            .post();
        assertEquals(""POST"", ihVal(""Method"", doc));
        assertEquals(""text/plain"", ihVal(""Content-Type"", doc));
        assertEquals(body, ihVal(""Post Data"", doc));
    }

    @Test
    public void sendsRequestBodyWithUrlParams() throws IOException {
        final String body = ""{key:value}"";
        Document doc = Jsoup.connect(echoUrl)
            .requestBody(body)
            .data(""uname"", ""Jsoup"", ""uname"", ""Jonathan"", ""Áôæ"", ""Â∫¶‰∏Ä‰∏ã"")
            .header(""Content-Type"", ""text/plain"") // todo - if user sets content-type, we should append postcharset
            .userAgent(browserUa)
            .post();
        assertEquals(""POST"", ihVal(""Method"", doc));
        assertEquals(""uname=Jsoup&uname=Jonathan&%E7%99%BE=%E5%BA%A6%E4%B8%80%E4%B8%8B"", ihVal(""Query String"", doc));
        assertEquals(body, ihVal(""Post Data"", doc));
    }

    @Test
    public void doesGet() throws IOException {
        Connection con = Jsoup.connect(echoUrl + ""?what=the"")
            .userAgent(""Mozilla"")
            .referrer(""http://example.com"")
            .data(""what"", ""about & me?"");

        Document doc = con.get();
        assertEquals(""what=the&what=about+%26+me%3F"", ihVal(""Query String"", doc));
        assertEquals(""the, about & me?"", ihVal(""what"", doc));
        assertEquals(""Mozilla"", ihVal(""User-Agent"", doc));
        assertEquals(""http://example.com"", ihVal(""Referer"", doc));
    }

    @Test
    public void doesPut() throws IOException {
        Connection.Response res = Jsoup.connect(echoUrl)
            .data(""uname"", ""Jsoup"", ""uname"", ""Jonathan"", ""Áôæ"", ""Â∫¶‰∏Ä‰∏ã"")
            .cookie(""auth"", ""token"")
            .method(Connection.Method.PUT)
            .execute();

        Document doc = res.parse();
        assertEquals(""PUT"", ihVal(""Method"", doc));
        assertEquals(""gzip"", ihVal(""Accept-Encoding"", doc));
        assertEquals(""auth=token"", ihVal(""Cookie"", doc));
    }

    /**
     * Tests upload of content to a remote service.
     */
    @Test
    public void postFiles() throws IOException {
        File thumb = ParseTest.getFile(""/htmltests/thumb.jpg"");
        File html = ParseTest.getFile(""/htmltests/google-ipod.html.gz"");

        Document res = Jsoup
            .connect(EchoServlet.Url)
            .data(""firstname"", ""Jay"")
            .data(""firstPart"", thumb.getName(), new FileInputStream(thumb), ""image/jpeg"")
            .data(""secondPart"", html.getName(), new FileInputStream(html)) // defaults to ""application-octetstream"";
            .data(""surname"", ""Soup"")
            .post();

        assertEquals(""4"", ihVal(""Parts"", res));

        assertEquals(""application/octet-stream"", ihVal(""Part secondPart ContentType"", res));
        assertEquals(""secondPart"", ihVal(""Part secondPart Name"", res));
        assertEquals(""google-ipod.html.gz"", ihVal(""Part secondPart Filename"", res));
        assertEquals(""12212"", ihVal(""Part secondPart Size"", res));

        assertEquals(""image/jpeg"", ihVal(""Part firstPart ContentType"", res));
        assertEquals(""firstPart"", ihVal(""Part firstPart Name"", res));
        assertEquals(""thumb.jpg"", ihVal(""Part firstPart Filename"", res));
        assertEquals(""1052"", ihVal(""Part firstPart Size"", res));

        assertEquals(""Jay"", ihVal(""firstname"", res));
        assertEquals(""Soup"", ihVal(""surname"", res));

        /*
        <tr><th>Part secondPart ContentType</th><td>application/octet-stream</td></tr>
        <tr><th>Part secondPart Name</th><td>secondPart</td></tr>
        <tr><th>Part secondPart Filename</th><td>google-ipod.html</td></tr>
        <tr><th>Part secondPart Size</th><td>43972</td></tr>
        <tr><th>Part firstPart ContentType</th><td>image/jpeg</td></tr>
        <tr><th>Part firstPart Name</th><td>firstPart</td></tr>
        <tr><th>Part firstPart Filename</th><td>thumb.jpg</td></tr>
        <tr><th>Part firstPart Size</th><td>1052</td></tr>
         */
    }

    @Test
    public void multipleParsesOkAfterBufferUp() throws IOException {
        Connection.Response res = Jsoup.connect(echoUrl).execute().bufferUp();

        Document doc = res.parse();
        assertTrue(doc.title().contains(""Environment""));

        Document doc2 = res.parse();
        assertTrue(doc2.title().contains(""Environment""));
    }

    @Test
    public void bodyAfterParseThrowsValidationError() {
        assertThrows(IllegalArgumentException.class, () -> {
            Connection.Response res = Jsoup.connect(echoUrl).execute();
            Document doc = res.parse();
            String body = res.body();
        });
    }

    @Test
    public void bodyAndBytesAvailableBeforeParse() throws IOException {
        Connection.Response res = Jsoup.connect(echoUrl).execute();
        String body = res.body();
        assertTrue(body.contains(""Environment""));
        byte[] bytes = res.bodyAsBytes();
        assertTrue(bytes.length > 100);

        Document doc = res.parse();
        assertTrue(doc.title().contains(""Environment""));
    }

    @Test
    public void parseParseThrowsValidates() {
        assertThrows(IllegalArgumentException.class, () -> {
            Connection.Response res = Jsoup.connect(echoUrl).execute();
            Document doc = res.parse();
            assertTrue(doc.title().contains(""Environment""));
            Document doc2 = res.parse(); // should blow up because the response input stream has been drained
        });
    }


    @Test
    public void multiCookieSet() throws IOException {
        Connection con = Jsoup
                .connect(RedirectServlet.Url)
                .data(RedirectServlet.CodeParam, ""302"")
                .data(RedirectServlet.SetCookiesParam, ""true"")
                .data(RedirectServlet.LocationParam, echoUrl);
        Connection.Response res = con.execute();

        // test cookies set by redirect:
        Map<String, String> cookies = res.cookies();
        assertEquals(""asdfg123"", cookies.get(""token""));
        assertEquals(""jhy"", cookies.get(""uid""));

        // send those cookies into the echo URL by map:
        Document doc = Jsoup.connect(echoUrl).cookies(cookies).get();
        assertEquals(""token=asdfg123; uid=jhy"", ihVal(""Cookie"", doc));
    }

    @Test public void requestCookiesSurviveRedirect() throws IOException {
        // this test makes sure that Request keyval cookies (not in the cookie store) are sent on subsequent redirections,
        // when not using the session method
        Connection con = Jsoup.connect(RedirectServlet.Url)
            .data(RedirectServlet.LocationParam, echoUrl)
            .cookie(""LetMeIn"", ""True"")
            .cookie(""DoesItWork"", ""Yes"");

        Connection.Response res = con.execute();
        assertEquals(0, res.cookies().size()); // were not set by Redir or Echo servlet
        Document doc = res.parse();
        assertEquals(echoUrl, doc.location());
        assertEquals(""True"", ihVal(""Cookie: LetMeIn"", doc));
        assertEquals(""Yes"", ihVal(""Cookie: DoesItWork"", doc));
    }

    @Test
    public void supportsDeflate() throws IOException {
        Connection.Response res = Jsoup.connect(Deflateservlet.Url).execute();
        assertEquals(""deflate"", res.header(""Content-Encoding""));

        Document doc = res.parse();
        assertEquals(""Hello, World!"", doc.selectFirst(""p"").text());
    }

    @Test
    public void handlesLargerContentLengthParseRead() throws IOException {
        // this handles situations where the remote server sets a content length greater than it actually writes

        Connection.Response res = Jsoup.connect(InterruptedServlet.Url)
            .data(InterruptedServlet.Magnitude, InterruptedServlet.Larger)
            .timeout(400)
            .execute();

        Document document = res.parse();
        assertEquals(""Something"", document.title());
        assertEquals(0, document.select(""p"").size());
        // current impl, jetty won't write past content length
        // todo - find way to trick jetty into writing larger than set header. Take over the stream?
    }

    @Test
    public void handlesWrongContentLengthDuringBufferedRead() throws IOException {
        Connection.Response res = Jsoup.connect(InterruptedServlet.Url)
                .timeout(400)
                .execute();
        // this servlet writes max_buffer data, but sets content length to max_buffer/2. So will read up to that.
        // previous versions of jetty would allow to write less, and would throw except here

        res.bufferUp();
        Document doc = res.parse();
        assertEquals(0, doc.select(""p"").size());
    }

    @Test public void handlesRedirect() throws IOException {
        Document doc = Jsoup.connect(RedirectServlet.Url)
            .data(RedirectServlet.LocationParam, HelloServlet.Url)
            .get();

        Element p = doc.selectFirst(""p"");
        assertEquals(""Hello, World!"", p.text());

        assertEquals(HelloServlet.Url, doc.location());
    }

    @Test public void handlesEmptyRedirect() {
        boolean threw = false;
        try {
            Connection.Response res = Jsoup.connect(RedirectServlet.Url)
                .execute();
        } catch (IOException e) {
            assertTrue(e.getMessage().contains(""Too many redirects""));
            threw = true;
        }
        assertTrue(threw);
    }

    @Test public void doesNotPostFor302() throws IOException {
        final Document doc = Jsoup.connect(RedirectServlet.Url)
            .data(""Hello"", ""there"")
            .data(RedirectServlet.LocationParam, EchoServlet.Url)
            .post();

        assertEquals(EchoServlet.Url, doc.location());
        assertEquals(""GET"", ihVal(""Method"", doc));
        assertNull(ihVal(""Hello"", doc)); // data not sent
    }

    @Test public void doesPostFor307() throws IOException {
        final Document doc = Jsoup.connect(RedirectServlet.Url)
            .data(""Hello"", ""there"")
            .data(RedirectServlet.LocationParam, EchoServlet.Url)
            .data(RedirectServlet.CodeParam, ""307"")
            .post();

        assertEquals(EchoServlet.Url, doc.location());
        assertEquals(""POST"", ihVal(""Method"", doc));
        assertEquals(""there"", ihVal(""Hello"", doc));
    }

    @Test public void getUtf8Bom() throws IOException {
        Connection con = Jsoup.connect(FileServlet.urlTo(""/bomtests/bom_utf8.html""));
        Document doc = con.get();

        assertEquals(""UTF-8"", con.response().charset());
        assertEquals(""OK"", doc.title());
    }

    @Test
    public void testBinaryContentTypeThrowsException() {
        Connection con = Jsoup.connect(FileServlet.urlTo(""/htmltests/thumb.jpg""));
        con.data(FileServlet.ContentTypeParam, ""image/jpeg"");

        boolean threw = false;
        try {
            con.execute();
            Document doc = con.response().parse();
        } catch (IOException e) {
            threw = true;
            assertEquals(""Unhandled content type. Must be text/*, application/xml, or application/*+xml"", e.getMessage());
        }
        assertTrue(threw);
    }

    @Test public void testParseRss() throws IOException {
        // test that we switch automatically to xml, and we support application/rss+xml
        Connection con = Jsoup.connect(FileServlet.urlTo(""/htmltests/test-rss.xml""));
        con.data(FileServlet.ContentTypeParam, ""application/rss+xml"");
        Document doc = con.get();
        Element title = doc.selectFirst(""title"");
        assertNotNull(title);
        assertEquals(""jsoup RSS news"", title.text());
        assertEquals(""channel"", title.parent().nodeName());
        assertEquals("""", doc.title()); // the document title is unset, this tag is channel>title, not html>head>title
        assertEquals(3, doc.select(""link"").size());
        assertEquals(""application/rss+xml"", con.response().contentType());
        assertTrue(doc.parser().getTreeBuilder() instanceof XmlTreeBuilder);
        assertEquals(Document.OutputSettings.Syntax.xml, doc.outputSettings().syntax());
    }

    @Test
    public void canFetchBinaryAsBytes() throws IOException {
        Connection.Response res = Jsoup.connect(FileServlet.urlTo(""/htmltests/thumb.jpg""))
            .data(FileServlet.ContentTypeParam, ""image/jpeg"")
            .ignoreContentType(true)
            .execute();

        byte[] bytes = res.bodyAsBytes();
        assertEquals(1052, bytes.length);
    }

    @Test
    public void handlesUnknownEscapesAcrossBuffer() throws IOException {
        String localPath = ""/htmltests/escapes-across-buffer.html"";
        String localUrl = FileServlet.urlTo(localPath);

        Document docFromLocalServer = Jsoup.connect(localUrl).get();
        Document docFromFileRead = Jsoup.parse(ParseTest.getFile(localPath), ""UTF-8"");

        String text = docFromLocalServer.body().text();
        assertEquals(14766, text.length());
        assertEquals(text, docFromLocalServer.body().text());
        assertEquals(text, docFromFileRead.body().text());
    }

    /**
     * Test fetching a form, and submitting it with a file attached.
     */
    @Test
    public void postHtmlFile() throws IOException {
        Document index = Jsoup.connect(FileServlet.urlTo(""/htmltests/upload-form.html"")).get();
        List<FormElement> forms = index.select(""[name=tidy]"").forms();
        assertEquals(1, forms.size());
        FormElement form = forms.get(0);
        Connection post = form.submit();

        File uploadFile = ParseTest.getFile(""/htmltests/google-ipod.html.gz"");
        FileInputStream stream = new FileInputStream(uploadFile);

        Connection.KeyVal fileData = post.data(""_file"");
        assertNotNull(fileData);
        fileData.value(""check.html"");
        fileData.inputStream(stream);

        Connection.Response res;
        try {
            res = post.execute();
        } finally {
            stream.close();
        }

        Document doc = res.parse();
        assertEquals(ihVal(""Method"", doc), ""POST""); // from form action
        assertEquals(ihVal(""Part _file Filename"", doc), ""check.html"");
        assertEquals(ihVal(""Part _file Name"", doc), ""_file"");
        assertEquals(ihVal(""_function"", doc), ""tidy"");
    }

    @Test
    public void fetchHandlesXml() throws IOException {
        String[] types = {""text/xml"", ""application/xml"", ""application/rss+xml"", ""application/xhtml+xml""};
        for (String type : types) {
            fetchHandlesXml(type);
        }
    }

    void fetchHandlesXml(String contentType) throws IOException {
        // should auto-detect xml and use XML parser, unless explicitly requested the html parser
        String xmlUrl = FileServlet.urlTo(""/htmltests/xml-test.xml"");
        Connection con = Jsoup.connect(xmlUrl);
        con.data(FileServlet.ContentTypeParam, contentType);
        Document doc = con.get();
        Connection.Request req = con.request();
        assertTrue(req.parser().getTreeBuilder() instanceof XmlTreeBuilder);
        assertEquals(""<doc><val>One<val>Two</val>Three</val></doc>\n"", doc.outerHtml());
        assertEquals(con.response().contentType(), contentType);
    }

    @Test
    public void fetchHandlesXmlAsHtmlWhenParserSet() throws IOException {
        // should auto-detect xml and use XML parser, unless explicitly requested the html parser
        String xmlUrl = FileServlet.urlTo(""/htmltests/xml-test.xml"");
        Connection con = Jsoup.connect(xmlUrl).parser(Parser.htmlParser());
        con.data(FileServlet.ContentTypeParam, ""application/xml"");
        Document doc = con.get();
        Connection.Request req = con.request();
        assertTrue(req.parser().getTreeBuilder() instanceof HtmlTreeBuilder);
        assertEquals(""<html> <head></head> <body> <doc> <val> One <val> Two </val>Three </val> </doc> </body> </html>"", StringUtil.normaliseWhitespace(doc.outerHtml()));
    }

    @Test
    public void combinesSameHeadersWithComma() throws IOException {
        // http://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html#sec4.2
        Connection con = Jsoup.connect(echoUrl);
        con.get();

        Connection.Response res = con.response();
        assertEquals(""text/html;charset=utf-8"", res.header(""Content-Type""));
        assertEquals(""no-cache, no-store"", res.header(""Cache-Control""));

        List<String> header = res.headers(""Cache-Control"");
        assertEquals(2, header.size());
        assertEquals(""no-cache"", header.get(0));
        assertEquals(""no-store"", header.get(1));
    }

    @Test
    public void sendHeadRequest() throws IOException {
        String url = FileServlet.urlTo(""/htmltests/xml-test.xml"");
        Connection con = Jsoup.connect(url)
            .method(Connection.Method.HEAD)
            .data(FileServlet.ContentTypeParam, ""text/xml"");
        final Connection.Response response = con.execute();
        assertEquals(""text/xml"", response.header(""Content-Type""));
        assertEquals("""", response.body()); // head ought to have no body
        Document doc = response.parse();
        assertEquals("""", doc.text());
    }

    @Test
    public void fetchToW3c() throws IOException {
        String url = FileServlet.urlTo(""/htmltests/upload-form.html"");
        Document doc = Jsoup.connect(url).get();

        W3CDom dom = new W3CDom();
        org.w3c.dom.Document wDoc = dom.fromJsoup(doc);
        assertEquals(url, wDoc.getDocumentURI());
        String html = dom.asString(wDoc);
        assertTrue(html.contains(""Upload""));
    }

    @Test
    public void baseHrefCorrectAfterHttpEquiv() throws IOException {
        // https://github.com/jhy/jsoup/issues/440
        Connection.Response res = Jsoup.connect(FileServlet.urlTo(""/htmltests/charset-base.html"")).execute();
        Document doc = res.parse();
        assertEquals(""http://example.com/foo.jpg"", doc.select(""img"").first().absUrl(""src""));
    }

    @Test
    public void maxBodySize() throws IOException {
        String url = FileServlet.urlTo(""/htmltests/large.html""); // 280 K

        Connection.Response defaultRes = Jsoup.connect(url).execute();
        Connection.Response smallRes = Jsoup.connect(url).maxBodySize(50 * 1024).execute(); // crops
        Connection.Response mediumRes = Jsoup.connect(url).maxBodySize(200 * 1024).execute(); // crops
        Connection.Response largeRes = Jsoup.connect(url).maxBodySize(300 * 1024).execute(); // does not crop
        Connection.Response unlimitedRes = Jsoup.connect(url).maxBodySize(0).execute();

        int actualDocText = 269535;
        assertEquals(actualDocText, defaultRes.parse().text().length());
        assertEquals(49165, smallRes.parse().text().length());
        assertEquals(196577, mediumRes.parse().text().length());
        assertEquals(actualDocText, largeRes.parse().text().length());
        assertEquals(actualDocText, unlimitedRes.parse().text().length());
    }

    @Test public void repeatable() throws IOException {
        String url = FileServlet.urlTo(""/htmltests/large.html""); // 280 K
        Connection con = Jsoup.connect(url).parser(Parser.xmlParser());
        Document doc1 = con.get();
        Document doc2 = con.get();
        assertEquals(""Large HTML"", doc1.title());
        assertEquals(""Large HTML"", doc2.title());
    }

    @Test
    public void maxBodySizeInReadToByteBuffer() throws IOException {
        // https://github.com/jhy/jsoup/issues/1774
        // when calling readToByteBuffer, contents were not buffered up
        String url = FileServlet.urlTo(""/htmltests/large.html""); // 280 K

        Connection.Response defaultRes = Jsoup.connect(url).execute();
        Connection.Response smallRes = Jsoup.connect(url).maxBodySize(50 * 1024).execute(); // crops
        Connection.Response mediumRes = Jsoup.connect(url).maxBodySize(200 * 1024).execute(); // crops
        Connection.Response largeRes = Jsoup.connect(url).maxBodySize(300 * 1024).execute(); // does not crop
        Connection.Response unlimitedRes = Jsoup.connect(url).maxBodySize(0).execute();

        int actualDocText = 280735;
        assertEquals(actualDocText, defaultRes.body().length());
        assertEquals(50 * 1024, smallRes.body().length());
        assertEquals(200 * 1024, mediumRes.body().length());
        assertEquals(actualDocText, largeRes.body().length());
        assertEquals(actualDocText, unlimitedRes.body().length());
    }
}
"
jhy/jsoup,src/test/java/org/jsoup/nodes/ElementIT.java,"package org.jsoup.nodes;

import org.jsoup.Jsoup;
import org.junit.jupiter.api.Test;

import java.util.List;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertTrue;

public class ElementIT {
    @Test
    public void testFastReparent() {
        StringBuilder htmlBuf = new StringBuilder();
        int rows = 300000;
        for (int i = 1; i <= rows; i++) {
            htmlBuf
                .append(""<p>El-"")
                .append(i)
                .append(""</p>"");
        }
        String html = htmlBuf.toString();
        Document doc = Jsoup.parse(html);
        long start = System.currentTimeMillis();

        Element wrapper = new Element(""div"");
        List<Node> childNodes = doc.body().childNodes();
        wrapper.insertChildren(0, childNodes);

        long runtime = System.currentTimeMillis() - start;
        assertEquals(rows, wrapper.childNodes.size());
        assertEquals(rows, childNodes.size()); // child nodes is a wrapper, so still there
        assertEquals(0, doc.body().childNodes().size()); // but on a fresh look, all gone

        doc.body().empty().appendChild(wrapper);
        Element wrapperAcutal = doc.body().children().get(0);
        assertEquals(wrapper, wrapperAcutal);
        assertEquals(""El-1"", wrapperAcutal.children().get(0).text());
        assertEquals(""El-"" + rows, wrapperAcutal.children().get(rows - 1).text());
        assertTrue(runtime <= 10000);
    }

    @Test
    public void testFastReparentExistingContent() {
        StringBuilder htmlBuf = new StringBuilder();
        int rows = 300000;
        for (int i = 1; i <= rows; i++) {
            htmlBuf
                .append(""<p>El-"")
                .append(i)
                .append(""</p>"");
        }
        String html = htmlBuf.toString();
        Document doc = Jsoup.parse(html);
        long start = System.currentTimeMillis();

        Element wrapper = new Element(""div"");
        wrapper.append(""<p>Prior Content</p>"");
        wrapper.append(""<p>End Content</p>"");
        assertEquals(2, wrapper.childNodes.size());

        List<Node> childNodes = doc.body().childNodes();
        wrapper.insertChildren(1, childNodes);

        long runtime = System.currentTimeMillis() - start;
        assertEquals(rows + 2, wrapper.childNodes.size());
        assertEquals(rows, childNodes.size()); // child nodes is a wrapper, so still there
        assertEquals(0, doc.body().childNodes().size()); // but on a fresh look, all gone

        doc.body().empty().appendChild(wrapper);
        Element wrapperAcutal = doc.body().children().get(0);
        assertEquals(wrapper, wrapperAcutal);
        assertEquals(""Prior Content"", wrapperAcutal.children().get(0).text());
        assertEquals(""El-1"", wrapperAcutal.children().get(1).text());

        assertEquals(""El-"" + rows, wrapperAcutal.children().get(rows).text());
        assertEquals(""End Content"", wrapperAcutal.children().get(rows + 1).text());

        assertTrue(runtime <= 10000);
    }
}
"
jhy/jsoup,src/test/java/org/jsoup/TextUtil.java,"package org.jsoup;

import java.util.regex.Pattern;

/**
 Text utils to ease testing

 @author Jonathan Hedley, jonathan@hedley.net */
public class TextUtil {
    static Pattern stripper = Pattern.compile(""\\r?\\n\\s*"");
    static Pattern stripLines = Pattern.compile(""\\r?\\n?"");
    static Pattern spaceCollapse = Pattern.compile(""\\s{2,}"");
    static Pattern tagSpaceCollapse = Pattern.compile("">\\s+<"");
    static Pattern stripCRs = Pattern.compile(""\\r*"");

    public static String stripNewlines(String text) {
        return stripper.matcher(text).replaceAll("""");
    }

    public static String normalizeSpaces(String text) {
        text = stripLines.matcher(text).replaceAll("""");
        text = stripper.matcher(text).replaceAll("""");
        text = spaceCollapse.matcher(text).replaceAll("" "");
        text = tagSpaceCollapse.matcher(text).replaceAll(""><"");
        return text;
    }

    public static String stripCRs(String text) {
        return stripCRs.matcher(text).replaceAll("""");
    }
}
"
jhy/jsoup,src/main/java/org/jsoup/helper/ChangeNotifyingArrayList.java,"package org.jsoup.helper;

import java.util.ArrayList;
import java.util.Collection;

/**
 * Implementation of ArrayList that watches out for changes to the contents.
 */
public abstract class ChangeNotifyingArrayList<E> extends ArrayList<E> {
    public ChangeNotifyingArrayList(int initialCapacity) {
        super(initialCapacity);
    }

    public abstract void onContentsChanged();

    @Override
    public E set(int index, E element) {
        onContentsChanged();
        return super.set(index, element);
    }

    @Override
    public boolean add(E e) {
        onContentsChanged();
        return super.add(e);
    }

    @Override
    public void add(int index, E element) {
        onContentsChanged();
        super.add(index, element);
    }

    @Override
    public E remove(int index) {
        onContentsChanged();
        return super.remove(index);
    }

    @Override
    public boolean remove(Object o) {
        onContentsChanged();
        return super.remove(o);
    }

    @Override
    public void clear() {
        onContentsChanged();
        super.clear();
    }

    @Override
    public boolean addAll(Collection<? extends E> c) {
        onContentsChanged();
        return super.addAll(c);
    }

    @Override
    public boolean addAll(int index, Collection<? extends E> c) {
        onContentsChanged();
        return super.addAll(index, c);
    }

    @Override
    protected void removeRange(int fromIndex, int toIndex) {
        onContentsChanged();
        super.removeRange(fromIndex, toIndex);
    }

    @Override
    public boolean removeAll(Collection<?> c) {
        onContentsChanged();
        return super.removeAll(c);
    }

    @Override
    public boolean retainAll(Collection<?> c) {
        onContentsChanged();
        return super.retainAll(c);
    }

}
"
jhy/jsoup,src/main/java/org/jsoup/parser/TokeniserState.java,"package org.jsoup.parser;

import org.jsoup.nodes.DocumentType;

/**
 * States and transition activations for the Tokeniser.
 */
enum TokeniserState {
    Data {
        // in data state, gather characters until a character reference or tag is found
        void read(Tokeniser t, CharacterReader r) {
            switch (r.current()) {
                case '&':
                    t.advanceTransition(CharacterReferenceInData);
                    break;
                case '<':
                    t.advanceTransition(TagOpen);
                    break;
                case nullChar:
                    t.error(this); // NOT replacement character (oddly?)
                    t.emit(r.consume());
                    break;
                case eof:
                    t.emit(new Token.EOF());
                    break;
                default:
                    String data = r.consumeData();
                    t.emit(data);
                    break;
            }
        }
    },
    CharacterReferenceInData {
        // from & in data
        void read(Tokeniser t, CharacterReader r) {
            readCharRef(t, Data);
        }
    },
    Rcdata {
        /// handles data in title, textarea etc
        void read(Tokeniser t, CharacterReader r) {
            switch (r.current()) {
                case '&':
                    t.advanceTransition(CharacterReferenceInRcdata);
                    break;
                case '<':
                    t.advanceTransition(RcdataLessthanSign);
                    break;
                case nullChar:
                    t.error(this);
                    r.advance();
                    t.emit(replacementChar);
                    break;
                case eof:
                    t.emit(new Token.EOF());
                    break;
                default:
                    String data = r.consumeData();
                    t.emit(data);
                    break;
            }
        }
    },
    CharacterReferenceInRcdata {
        void read(Tokeniser t, CharacterReader r) {
            readCharRef(t, Rcdata);
        }
    },
    Rawtext {
        void read(Tokeniser t, CharacterReader r) {
            readRawData(t, r, this, RawtextLessthanSign);
        }
    },
    ScriptData {
        void read(Tokeniser t, CharacterReader r) {
            readRawData(t, r, this, ScriptDataLessthanSign);
        }
    },
    PLAINTEXT {
        void read(Tokeniser t, CharacterReader r) {
            switch (r.current()) {
                case nullChar:
                    t.error(this);
                    r.advance();
                    t.emit(replacementChar);
                    break;
                case eof:
                    t.emit(new Token.EOF());
                    break;
                default:
                    String data = r.consumeTo(nullChar);
                    t.emit(data);
                    break;
            }
        }
    },
    TagOpen {
        // from < in data
        void read(Tokeniser t, CharacterReader r) {
            switch (r.current()) {
                case '!':
                    t.advanceTransition(MarkupDeclarationOpen);
                    break;
                case '/':
                    t.advanceTransition(EndTagOpen);
                    break;
                case '?':
                    t.createBogusCommentPending();
                    t.transition(BogusComment);
                    break;
                default:
                    if (r.matchesAsciiAlpha()) {
                        t.createTagPending(true);
                        t.transition(TagName);
                    } else {
                        t.error(this);
                        t.emit('<'); // char that got us here
                        t.transition(Data);
                    }
                    break;
            }
        }
    },
    EndTagOpen {
        void read(Tokeniser t, CharacterReader r) {
            if (r.isEmpty()) {
                t.eofError(this);
                t.emit(""</"");
                t.transition(Data);
            } else if (r.matchesAsciiAlpha()) {
                t.createTagPending(false);
                t.transition(TagName);
            } else if (r.matches('>')) {
                t.error(this);
                t.advanceTransition(Data);
            } else {
                t.error(this);
                t.createBogusCommentPending();
                t.commentPending.append('/'); // push the / back on that got us here
                t.transition(BogusComment);
            }
        }
    },
    TagName {
        // from < or </ in data, will have start or end tag pending
        void read(Tokeniser t, CharacterReader r) {
            // previous TagOpen state did NOT consume, will have a letter char in current
            String tagName = r.consumeTagName();
            t.tagPending.appendTagName(tagName);

            char c = r.consume();
            switch (c) {
                case '\t':
                case '\n':
                case '\r':
                case '\f':
                case ' ':
                    t.transition(BeforeAttributeName);
                    break;
                case '/':
                    t.transition(SelfClosingStartTag);
                    break;
                case '<': // NOTE: out of spec, but clear author intent
                    r.unconsume();
                    t.error(this);
                    // intended fall through to next >
                case '>':
                    t.emitTagPending();
                    t.transition(Data);
                    break;
                case nullChar: // replacement
                    t.tagPending.appendTagName(replacementStr);
                    break;
                case eof: // should emit pending tag?
                    t.eofError(this);
                    t.transition(Data);
                    break;
                default: // buffer underrun
                    t.tagPending.appendTagName(c);
            }
        }
    },
    RcdataLessthanSign {
        // from < in rcdata
        void read(Tokeniser t, CharacterReader r) {
            if (r.matches('/')) {
                t.createTempBuffer();
                t.advanceTransition(RCDATAEndTagOpen);
            } else if (r.matchesAsciiAlpha() && t.appropriateEndTagName() != null && !r.containsIgnoreCase(t.appropriateEndTagSeq())) {
                // diverge from spec: got a start tag, but there's no appropriate end tag (</title>), so rather than
                // consuming to EOF; break out here
                t.tagPending = t.createTagPending(false).name(t.appropriateEndTagName());
                t.emitTagPending();
                t.transition(TagOpen); // straight into TagOpen, as we came from < and looks like we're on a start tag
            } else {
                t.emit(""<"");
                t.transition(Rcdata);
            }
        }
    },
    RCDATAEndTagOpen {
        void read(Tokeniser t, CharacterReader r) {
            if (r.matchesAsciiAlpha()) {
                t.createTagPending(false);
                t.tagPending.appendTagName(r.current());
                t.dataBuffer.append(r.current());
                t.advanceTransition(RCDATAEndTagName);
            } else {
                t.emit(""</"");
                t.transition(Rcdata);
            }
        }
    },
    RCDATAEndTagName {
        void read(Tokeniser t, CharacterReader r) {
            if (r.matchesAsciiAlpha()) {
                String name = r.consumeLetterSequence();
                t.tagPending.appendTagName(name);
                t.dataBuffer.append(name);
                return;
            }

            char c = r.consume();
            switch (c) {
                case '\t':
                case '\n':
                case '\r':
                case '\f':
                case ' ':
                    if (t.isAppropriateEndTagToken())
                        t.transition(BeforeAttributeName);
                    else
                        anythingElse(t, r);
                    break;
                case '/':
                    if (t.isAppropriateEndTagToken())
                        t.transition(SelfClosingStartTag);
                    else
                        anythingElse(t, r);
                    break;
                case '>':
                    if (t.isAppropriateEndTagToken()) {
                        t.emitTagPending();
                        t.transition(Data);
                    }
                    else
                        anythingElse(t, r);
                    break;
                default:
                    anythingElse(t, r);
            }
        }

        private void anythingElse(Tokeniser t, CharacterReader r) {
            t.emit(""</"");
            t.emit(t.dataBuffer);
            r.unconsume();
            t.transition(Rcdata);
        }
    },
    RawtextLessthanSign {
        void read(Tokeniser t, CharacterReader r) {
            if (r.matches('/')) {
                t.createTempBuffer();
                t.advanceTransition(RawtextEndTagOpen);
            } else {
                t.emit('<');
                t.transition(Rawtext);
            }
        }
    },
    RawtextEndTagOpen {
        void read(Tokeniser t, CharacterReader r) {
            readEndTag(t, r, RawtextEndTagName, Rawtext);
        }
    },
    RawtextEndTagName {
        void read(Tokeniser t, CharacterReader r) {
            handleDataEndTag(t, r, Rawtext);
        }
    },
    ScriptDataLessthanSign {
        void read(Tokeniser t, CharacterReader r) {
            switch (r.consume()) {
                case '/':
                    t.createTempBuffer();
                    t.transition(ScriptDataEndTagOpen);
                    break;
                case '!':
                    t.emit(""<!"");
                    t.transition(ScriptDataEscapeStart);
                    break;
                case eof:
                    t.emit(""<"");
                    t.eofError(this);
                    t.transition(Data);
                    break;
                default:
                    t.emit(""<"");
                    r.unconsume();
                    t.transition(ScriptData);
            }
        }
    },
    ScriptDataEndTagOpen {
        void read(Tokeniser t, CharacterReader r) {
            readEndTag(t, r, ScriptDataEndTagName, ScriptData);
        }
    },
    ScriptDataEndTagName {
        void read(Tokeniser t, CharacterReader r) {
            handleDataEndTag(t, r, ScriptData);
        }
    },
    ScriptDataEscapeStart {
        void read(Tokeniser t, CharacterReader r) {
            if (r.matches('-')) {
                t.emit('-');
                t.advanceTransition(ScriptDataEscapeStartDash);
            } else {
                t.transition(ScriptData);
            }
        }
    },
    ScriptDataEscapeStartDash {
        void read(Tokeniser t, CharacterReader r) {
            if (r.matches('-')) {
                t.emit('-');
                t.advanceTransition(ScriptDataEscapedDashDash);
            } else {
                t.transition(ScriptData);
            }
        }
    },
    ScriptDataEscaped {
        void read(Tokeniser t, CharacterReader r) {
            if (r.isEmpty()) {
                t.eofError(this);
                t.transition(Data);
                return;
            }

            switch (r.current()) {
                case '-':
                    t.emit('-');
                    t.advanceTransition(ScriptDataEscapedDash);
                    break;
                case '<':
                    t.advanceTransition(ScriptDataEscapedLessthanSign);
                    break;
                case nullChar:
                    t.error(this);
                    r.advance();
                    t.emit(replacementChar);
                    break;
                default:
                    String data = r.consumeToAny('-', '<', nullChar);
                    t.emit(data);
            }
        }
    },
    ScriptDataEscapedDash {
        void read(Tokeniser t, CharacterReader r) {
            if (r.isEmpty()) {
                t.eofError(this);
                t.transition(Data);
                return;
            }

            char c = r.consume();
            switch (c) {
                case '-':
                    t.emit(c);
                    t.transition(ScriptDataEscapedDashDash);
                    break;
                case '<':
                    t.transition(ScriptDataEscapedLessthanSign);
                    break;
                case nullChar:
                    t.error(this);
                    t.emit(replacementChar);
                    t.transition(ScriptDataEscaped);
                    break;
                default:
                    t.emit(c);
                    t.transition(ScriptDataEscaped);
            }
        }
    },
    ScriptDataEscapedDashDash {
        void read(Tokeniser t, CharacterReader r) {
            if (r.isEmpty()) {
                t.eofError(this);
                t.transition(Data);
                return;
            }

            char c = r.consume();
            switch (c) {
                case '-':
                    t.emit(c);
                    break;
                case '<':
                    t.transition(ScriptDataEscapedLessthanSign);
                    break;
                case '>':
                    t.emit(c);
                    t.transition(ScriptData);
                    break;
                case nullChar:
                    t.error(this);
                    t.emit(replacementChar);
                    t.transition(ScriptDataEscaped);
                    break;
                default:
                    t.emit(c);
                    t.transition(ScriptDataEscaped);
            }
        }
    },
    ScriptDataEscapedLessthanSign {
        void read(Tokeniser t, CharacterReader r) {
            if (r.matchesAsciiAlpha()) {
                t.createTempBuffer();
                t.dataBuffer.append(r.current());
                t.emit(""<"");
                t.emit(r.current());
                t.advanceTransition(ScriptDataDoubleEscapeStart);
            } else if (r.matches('/')) {
                t.createTempBuffer();
                t.advanceTransition(ScriptDataEscapedEndTagOpen);
            } else {
                t.emit('<');
                t.transition(ScriptDataEscaped);
            }
        }
    },
    ScriptDataEscapedEndTagOpen {
        void read(Tokeniser t, CharacterReader r) {
            if (r.matchesAsciiAlpha()) {
                t.createTagPending(false);
                t.tagPending.appendTagName(r.current());
                t.dataBuffer.append(r.current());
                t.advanceTransition(ScriptDataEscapedEndTagName);
            } else {
                t.emit(""</"");
                t.transition(ScriptDataEscaped);
            }
        }
    },
    ScriptDataEscapedEndTagName {
        void read(Tokeniser t, CharacterReader r) {
            handleDataEndTag(t, r, ScriptDataEscaped);
        }
    },
    ScriptDataDoubleEscapeStart {
        void read(Tokeniser t, CharacterReader r) {
            handleDataDoubleEscapeTag(t, r, ScriptDataDoubleEscaped, ScriptDataEscaped);
        }
    },
    ScriptDataDoubleEscaped {
        void read(Tokeniser t, CharacterReader r) {
            char c = r.current();
            switch (c) {
                case '-':
                    t.emit(c);
                    t.advanceTransition(ScriptDataDoubleEscapedDash);
                    break;
                case '<':
                    t.emit(c);
                    t.advanceTransition(ScriptDataDoubleEscapedLessthanSign);
                    break;
                case nullChar:
                    t.error(this);
                    r.advance();
                    t.emit(replacementChar);
                    break;
                case eof:
                    t.eofError(this);
                    t.transition(Data);
                    break;
                default:
                    String data = r.consumeToAny('-', '<', nullChar);
                    t.emit(data);
            }
        }
    },
    ScriptDataDoubleEscapedDash {
        void read(Tokeniser t, CharacterReader r) {
            char c = r.consume();
            switch (c) {
                case '-':
                    t.emit(c);
                    t.transition(ScriptDataDoubleEscapedDashDash);
                    break;
                case '<':
                    t.emit(c);
                    t.transition(ScriptDataDoubleEscapedLessthanSign);
                    break;
                case nullChar:
                    t.error(this);
                    t.emit(replacementChar);
                    t.transition(ScriptDataDoubleEscaped);
                    break;
                case eof:
                    t.eofError(this);
                    t.transition(Data);
                    break;
                default:
                    t.emit(c);
                    t.transition(ScriptDataDoubleEscaped);
            }
        }
    },
    ScriptDataDoubleEscapedDashDash {
        void read(Tokeniser t, CharacterReader r) {
            char c = r.consume();
            switch (c) {
                case '-':
                    t.emit(c);
                    break;
                case '<':
                    t.emit(c);
                    t.transition(ScriptDataDoubleEscapedLessthanSign);
                    break;
                case '>':
                    t.emit(c);
                    t.transition(ScriptData);
                    break;
                case nullChar:
                    t.error(this);
                    t.emit(replacementChar);
                    t.transition(ScriptDataDoubleEscaped);
                    break;
                case eof:
                    t.eofError(this);
                    t.transition(Data);
                    break;
                default:
                    t.emit(c);
                    t.transition(ScriptDataDoubleEscaped);
            }
        }
    },
    ScriptDataDoubleEscapedLessthanSign {
        void read(Tokeniser t, CharacterReader r) {
            if (r.matches('/')) {
                t.emit('/');
                t.createTempBuffer();
                t.advanceTransition(ScriptDataDoubleEscapeEnd);
            } else {
                t.transition(ScriptDataDoubleEscaped);
            }
        }
    },
    ScriptDataDoubleEscapeEnd {
        void read(Tokeniser t, CharacterReader r) {
            handleDataDoubleEscapeTag(t,r, ScriptDataEscaped, ScriptDataDoubleEscaped);
        }
    },
    BeforeAttributeName {
        // from tagname <xxx
        void read(Tokeniser t, CharacterReader r) {
            char c = r.consume();
            switch (c) {
                case '\t':
                case '\n':
                case '\r':
                case '\f':
                case ' ':
                    break; // ignore whitespace
                case '/':
                    t.transition(SelfClosingStartTag);
                    break;
                case '<': // NOTE: out of spec, but clear (spec has this as a part of the attribute name)
                    r.unconsume();
                    t.error(this);
                    // intended fall through as if >
                case '>':
                    t.emitTagPending();
                    t.transition(Data);
                    break;
                case nullChar:
                    r.unconsume();
                    t.error(this);
                    t.tagPending.newAttribute();
                    t.transition(AttributeName);
                    break;
                case eof:
                    t.eofError(this);
                    t.transition(Data);
                    break;
                case '""':
                case '\'':
                case '=':
                    t.error(this);
                    t.tagPending.newAttribute();
                    t.tagPending.appendAttributeName(c);
                    t.transition(AttributeName);
                    break;
                default: // A-Z, anything else
                    t.tagPending.newAttribute();
                    r.unconsume();
                    t.transition(AttributeName);
            }
        }
    },
    AttributeName {
        // from before attribute name
        void read(Tokeniser t, CharacterReader r) {
            String name = r.consumeToAnySorted(attributeNameCharsSorted); // spec deviate - consume and emit nulls in one hit vs stepping
            t.tagPending.appendAttributeName(name);

            char c = r.consume();
            switch (c) {
                case '\t':
                case '\n':
                case '\r':
                case '\f':
                case ' ':
                    t.transition(AfterAttributeName);
                    break;
                case '/':
                    t.transition(SelfClosingStartTag);
                    break;
                case '=':
                    t.transition(BeforeAttributeValue);
                    break;
                case '>':
                    t.emitTagPending();
                    t.transition(Data);
                    break;
                case eof:
                    t.eofError(this);
                    t.transition(Data);
                    break;
                case '""':
                case '\'':
                case '<':
                    t.error(this);
                    t.tagPending.appendAttributeName(c);
                    break;
                default: // buffer underrun
                    t.tagPending.appendAttributeName(c);
            }
        }
    },
    AfterAttributeName {
        void read(Tokeniser t, CharacterReader r) {
            char c = r.consume();
            switch (c) {
                case '\t':
                case '\n':
                case '\r':
                case '\f':
                case ' ':
                    // ignore
                    break;
                case '/':
                    t.transition(SelfClosingStartTag);
                    break;
                case '=':
                    t.transition(BeforeAttributeValue);
                    break;
                case '>':
                    t.emitTagPending();
                    t.transition(Data);
                    break;
                case nullChar:
                    t.error(this);
                    t.tagPending.appendAttributeName(replacementChar);
                    t.transition(AttributeName);
                    break;
                case eof:
                    t.eofError(this);
                    t.transition(Data);
                    break;
                case '""':
                case '\'':
                case '<':
                    t.error(this);
                    t.tagPending.newAttribute();
                    t.tagPending.appendAttributeName(c);
                    t.transition(AttributeName);
                    break;
                default: // A-Z, anything else
                    t.tagPending.newAttribute();
                    r.unconsume();
                    t.transition(AttributeName);
            }
        }
    },
    BeforeAttributeValue {
        void read(Tokeniser t, CharacterReader r) {
            char c = r.consume();
            switch (c) {
                case '\t':
                case '\n':
                case '\r':
                case '\f':
                case ' ':
                    // ignore
                    break;
                case '""':
                    t.transition(AttributeValue_doubleQuoted);
                    break;
                case '&':
                    r.unconsume();
                    t.transition(AttributeValue_unquoted);
                    break;
                case '\'':
                    t.transition(AttributeValue_singleQuoted);
                    break;
                case nullChar:
                    t.error(this);
                    t.tagPending.appendAttributeValue(replacementChar);
                    t.transition(AttributeValue_unquoted);
                    break;
                case eof:
                    t.eofError(this);
                    t.emitTagPending();
                    t.transition(Data);
                    break;
                case '>':
                    t.error(this);
                    t.emitTagPending();
                    t.transition(Data);
                    break;
                case '<':
                case '=':
                case '`':
                    t.error(this);
                    t.tagPending.appendAttributeValue(c);
                    t.transition(AttributeValue_unquoted);
                    break;
                default:
                    r.unconsume();
                    t.transition(AttributeValue_unquoted);
            }
        }
    },
    AttributeValue_doubleQuoted {
        void read(Tokeniser t, CharacterReader r) {
            String value = r.consumeAttributeQuoted(false);
            if (value.length() > 0)
                t.tagPending.appendAttributeValue(value);
            else
                t.tagPending.setEmptyAttributeValue();

            char c = r.consume();
            switch (c) {
                case '""':
                    t.transition(AfterAttributeValue_quoted);
                    break;
                case '&':
                    int[] ref = t.consumeCharacterReference('""', true);
                    if (ref != null)
                        t.tagPending.appendAttributeValue(ref);
                    else
                        t.tagPending.appendAttributeValue('&');
                    break;
                case nullChar:
                    t.error(this);
                    t.tagPending.appendAttributeValue(replacementChar);
                    break;
                case eof:
                    t.eofError(this);
                    t.transition(Data);
                    break;
                default: // hit end of buffer in first read, still in attribute
                    t.tagPending.appendAttributeValue(c);
            }
        }
    },
    AttributeValue_singleQuoted {
        void read(Tokeniser t, CharacterReader r) {
            String value = r.consumeAttributeQuoted(true);
            if (value.length() > 0)
                t.tagPending.appendAttributeValue(value);
            else
                t.tagPending.setEmptyAttributeValue();

            char c = r.consume();
            switch (c) {
                case '\'':
                    t.transition(AfterAttributeValue_quoted);
                    break;
                case '&':
                    int[] ref = t.consumeCharacterReference('\'', true);
                    if (ref != null)
                        t.tagPending.appendAttributeValue(ref);
                    else
                        t.tagPending.appendAttributeValue('&');
                    break;
                case nullChar:
                    t.error(this);
                    t.tagPending.appendAttributeValue(replacementChar);
                    break;
                case eof:
                    t.eofError(this);
                    t.transition(Data);
                    break;
                default: // hit end of buffer in first read, still in attribute
                    t.tagPending.appendAttributeValue(c);
            }
        }
    },
    AttributeValue_unquoted {
        void read(Tokeniser t, CharacterReader r) {
            String value = r.consumeToAnySorted(attributeValueUnquoted);
            if (value.length() > 0)
                t.tagPending.appendAttributeValue(value);

            char c = r.consume();
            switch (c) {
                case '\t':
                case '\n':
                case '\r':
                case '\f':
                case ' ':
                    t.transition(BeforeAttributeName);
                    break;
                case '&':
                    int[] ref = t.consumeCharacterReference('>', true);
                    if (ref != null)
                        t.tagPending.appendAttributeValue(ref);
                    else
                        t.tagPending.appendAttributeValue('&');
                    break;
                case '>':
                    t.emitTagPending();
                    t.transition(Data);
                    break;
                case nullChar:
                    t.error(this);
                    t.tagPending.appendAttributeValue(replacementChar);
                    break;
                case eof:
                    t.eofError(this);
                    t.transition(Data);
                    break;
                case '""':
                case '\'':
                case '<':
                case '=':
                case '`':
                    t.error(this);
                    t.tagPending.appendAttributeValue(c);
                    break;
                default: // hit end of buffer in first read, still in attribute
                    t.tagPending.appendAttributeValue(c);
            }

        }
    },
    // CharacterReferenceInAttributeValue state handled inline
    AfterAttributeValue_quoted {
        void read(Tokeniser t, CharacterReader r) {
            char c = r.consume();
            switch (c) {
                case '\t':
                case '\n':
                case '\r':
                case '\f':
                case ' ':
                    t.transition(BeforeAttributeName);
                    break;
                case '/':
                    t.transition(SelfClosingStartTag);
                    break;
                case '>':
                    t.emitTagPending();
                    t.transition(Data);
                    break;
                case eof:
                    t.eofError(this);
                    t.transition(Data);
                    break;
                default:
                    r.unconsume();
                    t.error(this);
                    t.transition(BeforeAttributeName);
            }

        }
    },
    SelfClosingStartTag {
        void read(Tokeniser t, CharacterReader r) {
            char c = r.consume();
            switch (c) {
                case '>':
                    t.tagPending.selfClosing = true;
                    t.emitTagPending();
                    t.transition(Data);
                    break;
                case eof:
                    t.eofError(this);
                    t.transition(Data);
                    break;
                default:
                    r.unconsume();
                    t.error(this);
                    t.transition(BeforeAttributeName);
            }
        }
    },
    BogusComment {
        void read(Tokeniser t, CharacterReader r) {
            // todo: handle bogus comment starting from eof. when does that trigger?
            t.commentPending.append(r.consumeTo('>'));
            // todo: replace nullChar with replaceChar
            char next = r.current();
            if (next == '>' || next == eof) {
                r.consume();
                t.emitCommentPending();
                t.transition(Data);
            }
        }
    },
    MarkupDeclarationOpen {
        void read(Tokeniser t, CharacterReader r) {
            if (r.matchConsume(""--"")) {
                t.createCommentPending();
                t.transition(CommentStart);
            } else if (r.matchConsumeIgnoreCase(""DOCTYPE"")) {
                t.transition(Doctype);
            } else if (r.matchConsume(""[CDATA["")) {
                // todo: should actually check current namespace, and only non-html allows cdata. until namespace
                // is implemented properly, keep handling as cdata
                //} else if (!t.currentNodeInHtmlNS() && r.matchConsume(""[CDATA["")) {
                t.createTempBuffer();
                t.transition(CdataSection);
            } else {
                t.error(this);
                t.createBogusCommentPending();
                t.transition(BogusComment);
            }
        }
    },
    CommentStart {
        void read(Tokeniser t, CharacterReader r) {
            char c = r.consume();
            switch (c) {
                case '-':
                    t.transition(CommentStartDash);
                    break;
                case nullChar:
                    t.error(this);
                    t.commentPending.append(replacementChar);
                    t.transition(Comment);
                    break;
                case '>':
                    t.error(this);
                    t.emitCommentPending();
                    t.transition(Data);
                    break;
                case eof:
                    t.eofError(this);
                    t.emitCommentPending();
                    t.transition(Data);
                    break;
                default:
                    r.unconsume();
                    t.transition(Comment);
            }
        }
    },
    CommentStartDash {
        void read(Tokeniser t, CharacterReader r) {
            char c = r.consume();
            switch (c) {
                case '-':
                    t.transition(CommentEnd);
                    break;
                case nullChar:
                    t.error(this);
                    t.commentPending.append(replacementChar);
                    t.transition(Comment);
                    break;
                case '>':
                    t.error(this);
                    t.emitCommentPending();
                    t.transition(Data);
                    break;
                case eof:
                    t.eofError(this);
                    t.emitCommentPending();
                    t.transition(Data);
                    break;
                default:
                    t.commentPending.append(c);
                    t.transition(Comment);
            }
        }
    },
    Comment {
        void read(Tokeniser t, CharacterReader r) {
            char c = r.current();
            switch (c) {
                case '-':
                    t.advanceTransition(CommentEndDash);
                    break;
                case nullChar:
                    t.error(this);
                    r.advance();
                    t.commentPending.append(replacementChar);
                    break;
                case eof:
                    t.eofError(this);
                    t.emitCommentPending();
                    t.transition(Data);
                    break;
                default:
                    t.commentPending.append(r.consumeToAny('-', nullChar));
            }
        }
    },
    CommentEndDash {
        void read(Tokeniser t, CharacterReader r) {
            char c = r.consume();
            switch (c) {
                case '-':
                    t.transition(CommentEnd);
                    break;
                case nullChar:
                    t.error(this);
                    t.commentPending.append('-').append(replacementChar);
                    t.transition(Comment);
                    break;
                case eof:
                    t.eofError(this);
                    t.emitCommentPending();
                    t.transition(Data);
                    break;
                default:
                    t.commentPending.append('-').append(c);
                    t.transition(Comment);
            }
        }
    },
    CommentEnd {
        void read(Tokeniser t, CharacterReader r) {
            char c = r.consume();
            switch (c) {
                case '>':
                    t.emitCommentPending();
                    t.transition(Data);
                    break;
                case nullChar:
                    t.error(this);
                    t.commentPending.append(""--"").append(replacementChar);
                    t.transition(Comment);
                    break;
                case '!':
                    t.transition(CommentEndBang);
                    break;
                case '-':
                    t.commentPending.append('-');
                    break;
                case eof:
                    t.eofError(this);
                    t.emitCommentPending();
                    t.transition(Data);
                    break;
                default:
                    t.commentPending.append(""--"").append(c);
                    t.transition(Comment);
            }
        }
    },
    CommentEndBang {
        void read(Tokeniser t, CharacterReader r) {
            char c = r.consume();
            switch (c) {
                case '-':
                    t.commentPending.append(""--!"");
                    t.transition(CommentEndDash);
                    break;
                case '>':
                    t.emitCommentPending();
                    t.transition(Data);
                    break;
                case nullChar:
                    t.error(this);
                    t.commentPending.append(""--!"").append(replacementChar);
                    t.transition(Comment);
                    break;
                case eof:
                    t.eofError(this);
                    t.emitCommentPending();
                    t.transition(Data);
                    break;
                default:
                    t.commentPending.append(""--!"").append(c);
                    t.transition(Comment);
            }
        }
    },
    Doctype {
        void read(Tokeniser t, CharacterReader r) {
            char c = r.consume();
            switch (c) {
                case '\t':
                case '\n':
                case '\r':
                case '\f':
                case ' ':
                    t.transition(BeforeDoctypeName);
                    break;
                case eof:
                    t.eofError(this);
                    // note: fall through to > case
                case '>': // catch invalid <!DOCTYPE>
                    t.error(this);
                    t.createDoctypePending();
                    t.doctypePending.forceQuirks = true;
                    t.emitDoctypePending();
                    t.transition(Data);
                    break;
                default:
                    t.error(this);
                    t.transition(BeforeDoctypeName);
            }
        }
    },
    BeforeDoctypeName {
        void read(Tokeniser t, CharacterReader r) {
            if (r.matchesAsciiAlpha()) {
                t.createDoctypePending();
                t.transition(DoctypeName);
                return;
            }
            char c = r.consume();
            switch (c) {
                case '\t':
                case '\n':
                case '\r':
                case '\f':
                case ' ':
                    break; // ignore whitespace
                case nullChar:
                    t.error(this);
                    t.createDoctypePending();
                    t.doctypePending.name.append(replacementChar);
                    t.transition(DoctypeName);
                    break;
                case eof:
                    t.eofError(this);
                    t.createDoctypePending();
                    t.doctypePending.forceQuirks = true;
                    t.emitDoctypePending();
                    t.transition(Data);
                    break;
                default:
                    t.createDoctypePending();
                    t.doctypePending.name.append(c);
                    t.transition(DoctypeName);
            }
        }
    },
    DoctypeName {
        void read(Tokeniser t, CharacterReader r) {
            if (r.matchesLetter()) {
                String name = r.consumeLetterSequence();
                t.doctypePending.name.append(name);
                return;
            }
            char c = r.consume();
            switch (c) {
                case '>':
                    t.emitDoctypePending();
                    t.transition(Data);
                    break;
                case '\t':
                case '\n':
                case '\r':
                case '\f':
                case ' ':
                    t.transition(AfterDoctypeName);
                    break;
                case nullChar:
                    t.error(this);
                    t.doctypePending.name.append(replacementChar);
                    break;
                case eof:
                    t.eofError(this);
                    t.doctypePending.forceQuirks = true;
                    t.emitDoctypePending();
                    t.transition(Data);
                    break;
                default:
                    t.doctypePending.name.append(c);
            }
        }
    },
    AfterDoctypeName {
        void read(Tokeniser t, CharacterReader r) {
            if (r.isEmpty()) {
                t.eofError(this);
                t.doctypePending.forceQuirks = true;
                t.emitDoctypePending();
                t.transition(Data);
                return;
            }
            if (r.matchesAny('\t', '\n', '\r', '\f', ' '))
                r.advance(); // ignore whitespace
            else if (r.matches('>')) {
                t.emitDoctypePending();
                t.advanceTransition(Data);
            } else if (r.matchConsumeIgnoreCase(DocumentType.PUBLIC_KEY)) {
                t.doctypePending.pubSysKey = DocumentType.PUBLIC_KEY;
                t.transition(AfterDoctypePublicKeyword);
            } else if (r.matchConsumeIgnoreCase(DocumentType.SYSTEM_KEY)) {
                t.doctypePending.pubSysKey = DocumentType.SYSTEM_KEY;
                t.transition(AfterDoctypeSystemKeyword);
            } else {
                t.error(this);
                t.doctypePending.forceQuirks = true;
                t.advanceTransition(BogusDoctype);
            }

        }
    },
    AfterDoctypePublicKeyword {
        void read(Tokeniser t, CharacterReader r) {
            char c = r.consume();
            switch (c) {
                case '\t':
                case '\n':
                case '\r':
                case '\f':
                case ' ':
                    t.transition(BeforeDoctypePublicIdentifier);
                    break;
                case '""':
                    t.error(this);
                    // set public id to empty string
                    t.transition(DoctypePublicIdentifier_doubleQuoted);
                    break;
                case '\'':
                    t.error(this);
                    // set public id to empty string
                    t.transition(DoctypePublicIdentifier_singleQuoted);
                    break;
                case '>':
                    t.error(this);
                    t.doctypePending.forceQuirks = true;
                    t.emitDoctypePending();
                    t.transition(Data);
                    break;
                case eof:
                    t.eofError(this);
                    t.doctypePending.forceQuirks = true;
                    t.emitDoctypePending();
                    t.transition(Data);
                    break;
                default:
                    t.error(this);
                    t.doctypePending.forceQuirks = true;
                    t.transition(BogusDoctype);
            }
        }
    },
    BeforeDoctypePublicIdentifier {
        void read(Tokeniser t, CharacterReader r) {
            char c = r.consume();
            switch (c) {
                case '\t':
                case '\n':
                case '\r':
                case '\f':
                case ' ':
                    break;
                case '""':
                    // set public id to empty string
                    t.transition(DoctypePublicIdentifier_doubleQuoted);
                    break;
                case '\'':
                    // set public id to empty string
                    t.transition(DoctypePublicIdentifier_singleQuoted);
                    break;
                case '>':
                    t.error(this);
                    t.doctypePending.forceQuirks = true;
                    t.emitDoctypePending();
                    t.transition(Data);
                    break;
                case eof:
                    t.eofError(this);
                    t.doctypePending.forceQuirks = true;
                    t.emitDoctypePending();
                    t.transition(Data);
                    break;
                default:
                    t.error(this);
                    t.doctypePending.forceQuirks = true;
                    t.transition(BogusDoctype);
            }
        }
    },
    DoctypePublicIdentifier_doubleQuoted {
        void read(Tokeniser t, CharacterReader r) {
            char c = r.consume();
            switch (c) {
                case '""':
                    t.transition(AfterDoctypePublicIdentifier);
                    break;
                case nullChar:
                    t.error(this);
                    t.doctypePending.publicIdentifier.append(replacementChar);
                    break;
                case '>':
                    t.error(this);
                    t.doctypePending.forceQuirks = true;
                    t.emitDoctypePending();
                    t.transition(Data);
                    break;
                case eof:
                    t.eofError(this);
                    t.doctypePending.forceQuirks = true;
                    t.emitDoctypePending();
                    t.transition(Data);
                    break;
                default:
                    t.doctypePending.publicIdentifier.append(c);
            }
        }
    },
    DoctypePublicIdentifier_singleQuoted {
        void read(Tokeniser t, CharacterReader r) {
            char c = r.consume();
            switch (c) {
                case '\'':
                    t.transition(AfterDoctypePublicIdentifier);
                    break;
                case nullChar:
                    t.error(this);
                    t.doctypePending.publicIdentifier.append(replacementChar);
                    break;
                case '>':
                    t.error(this);
                    t.doctypePending.forceQuirks = true;
                    t.emitDoctypePending();
                    t.transition(Data);
                    break;
                case eof:
                    t.eofError(this);
                    t.doctypePending.forceQuirks = true;
                    t.emitDoctypePending();
                    t.transition(Data);
                    break;
                default:
                    t.doctypePending.publicIdentifier.append(c);
            }
        }
    },
    AfterDoctypePublicIdentifier {
        void read(Tokeniser t, CharacterReader r) {
            char c = r.consume();
            switch (c) {
                case '\t':
                case '\n':
                case '\r':
                case '\f':
                case ' ':
                    t.transition(BetweenDoctypePublicAndSystemIdentifiers);
                    break;
                case '>':
                    t.emitDoctypePending();
                    t.transition(Data);
                    break;
                case '""':
                    t.error(this);
                    // system id empty
                    t.transition(DoctypeSystemIdentifier_doubleQuoted);
                    break;
                case '\'':
                    t.error(this);
                    // system id empty
                    t.transition(DoctypeSystemIdentifier_singleQuoted);
                    break;
                case eof:
                    t.eofError(this);
                    t.doctypePending.forceQuirks = true;
                    t.emitDoctypePending();
                    t.transition(Data);
                    break;
                default:
                    t.error(this);
                    t.doctypePending.forceQuirks = true;
                    t.transition(BogusDoctype);
            }
        }
    },
    BetweenDoctypePublicAndSystemIdentifiers {
        void read(Tokeniser t, CharacterReader r) {
            char c = r.consume();
            switch (c) {
                case '\t':
                case '\n':
                case '\r':
                case '\f':
                case ' ':
                    break;
                case '>':
                    t.emitDoctypePending();
                    t.transition(Data);
                    break;
                case '""':
                    t.error(this);
                    // system id empty
                    t.transition(DoctypeSystemIdentifier_doubleQuoted);
                    break;
                case '\'':
                    t.error(this);
                    // system id empty
                    t.transition(DoctypeSystemIdentifier_singleQuoted);
                    break;
                case eof:
                    t.eofError(this);
                    t.doctypePending.forceQuirks = true;
                    t.emitDoctypePending();
                    t.transition(Data);
                    break;
                default:
                    t.error(this);
                    t.doctypePending.forceQuirks = true;
                    t.transition(BogusDoctype);
            }
        }
    },
    AfterDoctypeSystemKeyword {
        void read(Tokeniser t, CharacterReader r) {
            char c = r.consume();
            switch (c) {
                case '\t':
                case '\n':
                case '\r':
                case '\f':
                case ' ':
                    t.transition(BeforeDoctypeSystemIdentifier);
                    break;
                case '>':
                    t.error(this);
                    t.doctypePending.forceQuirks = true;
                    t.emitDoctypePending();
                    t.transition(Data);
                    break;
                case '""':
                    t.error(this);
                    // system id empty
                    t.transition(DoctypeSystemIdentifier_doubleQuoted);
                    break;
                case '\'':
                    t.error(this);
                    // system id empty
                    t.transition(DoctypeSystemIdentifier_singleQuoted);
                    break;
                case eof:
                    t.eofError(this);
                    t.doctypePending.forceQuirks = true;
                    t.emitDoctypePending();
                    t.transition(Data);
                    break;
                default:
                    t.error(this);
                    t.doctypePending.forceQuirks = true;
                    t.emitDoctypePending();
            }
        }
    },
    BeforeDoctypeSystemIdentifier {
        void read(Tokeniser t, CharacterReader r) {
            char c = r.consume();
            switch (c) {
                case '\t':
                case '\n':
                case '\r':
                case '\f':
                case ' ':
                    break;
                case '""':
                    // set system id to empty string
                    t.transition(DoctypeSystemIdentifier_doubleQuoted);
                    break;
                case '\'':
                    // set public id to empty string
                    t.transition(DoctypeSystemIdentifier_singleQuoted);
                    break;
                case '>':
                    t.error(this);
                    t.doctypePending.forceQuirks = true;
                    t.emitDoctypePending();
                    t.transition(Data);
                    break;
                case eof:
                    t.eofError(this);
                    t.doctypePending.forceQuirks = true;
                    t.emitDoctypePending();
                    t.transition(Data);
                    break;
                default:
                    t.error(this);
                    t.doctypePending.forceQuirks = true;
                    t.transition(BogusDoctype);
            }
        }
    },
    DoctypeSystemIdentifier_doubleQuoted {
        void read(Tokeniser t, CharacterReader r) {
            char c = r.consume();
            switch (c) {
                case '""':
                    t.transition(AfterDoctypeSystemIdentifier);
                    break;
                case nullChar:
                    t.error(this);
                    t.doctypePending.systemIdentifier.append(replacementChar);
                    break;
                case '>':
                    t.error(this);
                    t.doctypePending.forceQuirks = true;
                    t.emitDoctypePending();
                    t.transition(Data);
                    break;
                case eof:
                    t.eofError(this);
                    t.doctypePending.forceQuirks = true;
                    t.emitDoctypePending();
                    t.transition(Data);
                    break;
                default:
                    t.doctypePending.systemIdentifier.append(c);
            }
        }
    },
    DoctypeSystemIdentifier_singleQuoted {
        void read(Tokeniser t, CharacterReader r) {
            char c = r.consume();
            switch (c) {
                case '\'':
                    t.transition(AfterDoctypeSystemIdentifier);
                    break;
                case nullChar:
                    t.error(this);
                    t.doctypePending.systemIdentifier.append(replacementChar);
                    break;
                case '>':
                    t.error(this);
                    t.doctypePending.forceQuirks = true;
                    t.emitDoctypePending();
                    t.transition(Data);
                    break;
                case eof:
                    t.eofError(this);
                    t.doctypePending.forceQuirks = true;
                    t.emitDoctypePending();
                    t.transition(Data);
                    break;
                default:
                    t.doctypePending.systemIdentifier.append(c);
            }
        }
    },
    AfterDoctypeSystemIdentifier {
        void read(Tokeniser t, CharacterReader r) {
            char c = r.consume();
            switch (c) {
                case '\t':
                case '\n':
                case '\r':
                case '\f':
                case ' ':
                    break;
                case '>':
                    t.emitDoctypePending();
                    t.transition(Data);
                    break;
                case eof:
                    t.eofError(this);
                    t.doctypePending.forceQuirks = true;
                    t.emitDoctypePending();
                    t.transition(Data);
                    break;
                default:
                    t.error(this);
                    t.transition(BogusDoctype);
                    // NOT force quirks
            }
        }
    },
    BogusDoctype {
        void read(Tokeniser t, CharacterReader r) {
            char c = r.consume();
            switch (c) {
                case '>':
                    t.emitDoctypePending();
                    t.transition(Data);
                    break;
                case eof:
                    t.emitDoctypePending();
                    t.transition(Data);
                    break;
                default:
                    // ignore char
                    break;
            }
        }
    },
    CdataSection {
        void read(Tokeniser t, CharacterReader r) {
            String data = r.consumeTo(""]]>"");
            t.dataBuffer.append(data);
            if (r.matchConsume(""]]>"") || r.isEmpty()) {
                t.emit(new Token.CData(t.dataBuffer.toString()));
                t.transition(Data);
            }// otherwise, buffer underrun, stay in data section
        }
    };


    abstract void read(Tokeniser t, CharacterReader r);

    static final char nullChar = '\u0000';
    // char searches. must be sorted, used in inSorted. MUST update TokenisetStateTest if more arrays are added.
    static final char[] attributeNameCharsSorted = new char[]{'\t', '\n', '\f', '\r', ' ', '""', '\'', '/', '<', '=', '>'};
    static final char[] attributeValueUnquoted = new char[]{nullChar, '\t', '\n', '\f', '\r', ' ', '""', '&', '\'', '<', '=', '>', '`'};

    private static final char replacementChar = Tokeniser.replacementChar;
    private static final String replacementStr = String.valueOf(Tokeniser.replacementChar);
    private static final char eof = CharacterReader.EOF;

    /**
     * Handles RawtextEndTagName, ScriptDataEndTagName, and ScriptDataEscapedEndTagName. Same body impl, just
     * different else exit transitions.
     */
    private static void handleDataEndTag(Tokeniser t, CharacterReader r, TokeniserState elseTransition) {
        if (r.matchesLetter()) {
            String name = r.consumeLetterSequence();
            t.tagPending.appendTagName(name);
            t.dataBuffer.append(name);
            return;
        }

        boolean needsExitTransition = false;
        if (t.isAppropriateEndTagToken() && !r.isEmpty()) {
            char c = r.consume();
            switch (c) {
                case '\t':
                case '\n':
                case '\r':
                case '\f':
                case ' ':
                    t.transition(BeforeAttributeName);
                    break;
                case '/':
                    t.transition(SelfClosingStartTag);
                    break;
                case '>':
                    t.emitTagPending();
                    t.transition(Data);
                    break;
                default:
                    t.dataBuffer.append(c);
                    needsExitTransition = true;
            }
        } else {
            needsExitTransition = true;
        }

        if (needsExitTransition) {
            t.emit(""</"");
            t.emit(t.dataBuffer);
            t.transition(elseTransition);
        }
    }

    private static void readRawData(Tokeniser t, CharacterReader r, TokeniserState current, TokeniserState advance) {
        switch (r.current()) {
            case '<':
                t.advanceTransition(advance);
                break;
            case nullChar:
                t.error(current);
                r.advance();
                t.emit(replacementChar);
                break;
            case eof:
                t.emit(new Token.EOF());
                break;
            default:
                String data = r.consumeRawData();
                t.emit(data);
                break;
        }
    }

    private static void readCharRef(Tokeniser t, TokeniserState advance) {
        int[] c = t.consumeCharacterReference(null, false);
        if (c == null)
            t.emit('&');
        else
            t.emit(c);
        t.transition(advance);
    }

    private static void readEndTag(Tokeniser t, CharacterReader r, TokeniserState a, TokeniserState b) {
        if (r.matchesAsciiAlpha()) {
            t.createTagPending(false);
            t.transition(a);
        } else {
            t.emit(""</"");
            t.transition(b);
        }
    }

    private static void handleDataDoubleEscapeTag(Tokeniser t, CharacterReader r, TokeniserState primary, TokeniserState fallback) {
        if (r.matchesLetter()) {
            String name = r.consumeLetterSequence();
            t.dataBuffer.append(name);
            t.emit(name);
            return;
        }

        char c = r.consume();
        switch (c) {
            case '\t':
            case '\n':
            case '\r':
            case '\f':
            case ' ':
            case '/':
            case '>':
                if (t.dataBuffer.toString().equals(""script""))
                    t.transition(primary);
                else
                    t.transition(fallback);
                t.emit(c);
                break;
            default:
                r.unconsume();
                t.transition(fallback);
        }
    }
}
"
jhy/jsoup,src/main/java/org/jsoup/examples/ListLinks.java,"package org.jsoup.examples;

import org.jsoup.Jsoup;
import org.jsoup.helper.Validate;
import org.jsoup.nodes.Document;
import org.jsoup.nodes.Element;
import org.jsoup.select.Elements;

import java.io.IOException;

/**
 * Example program to list links from a URL.
 */
public class ListLinks {
    public static void main(String[] args) throws IOException {
        Validate.isTrue(args.length == 1, ""usage: supply url to fetch"");
        String url = args[0];
        print(""Fetching %s..."", url);

        Document doc = Jsoup.connect(url).get();
        Elements links = doc.select(""a[href]"");
        Elements media = doc.select(""[src]"");
        Elements imports = doc.select(""link[href]"");

        print(""\nMedia: (%d)"", media.size());
        for (Element src : media) {
            if (src.normalName().equals(""img""))
                print("" * %s: <%s> %sx%s (%s)"",
                        src.tagName(), src.attr(""abs:src""), src.attr(""width""), src.attr(""height""),
                        trim(src.attr(""alt""), 20));
            else
                print("" * %s: <%s>"", src.tagName(), src.attr(""abs:src""));
        }

        print(""\nImports: (%d)"", imports.size());
        for (Element link : imports) {
            print("" * %s <%s> (%s)"", link.tagName(),link.attr(""abs:href""), link.attr(""rel""));
        }

        print(""\nLinks: (%d)"", links.size());
        for (Element link : links) {
            print("" * a: <%s>  (%s)"", link.attr(""abs:href""), trim(link.text(), 35));
        }
    }

    private static void print(String msg, Object... args) {
        System.out.println(String.format(msg, args));
    }

    private static String trim(String s, int width) {
        if (s.length() > width)
            return s.substring(0, width-1) + ""."";
        else
            return s;
    }
}
"
jhy/jsoup,src/main/java/org/jsoup/nodes/Attribute.java,"package org.jsoup.nodes;

import org.jsoup.SerializationException;
import org.jsoup.helper.Validate;
import org.jsoup.internal.Normalizer;
import org.jsoup.internal.StringUtil;
import org.jsoup.nodes.Document.OutputSettings.Syntax;

import javax.annotation.Nullable;
import java.io.IOException;
import java.util.Arrays;
import java.util.Map;
import java.util.regex.Pattern;

/**
 A single key + value attribute. (Only used for presentation.)
 */
public class Attribute implements Map.Entry<String, String>, Cloneable  {
    private static final String[] booleanAttributes = {
            ""allowfullscreen"", ""async"", ""autofocus"", ""checked"", ""compact"", ""declare"", ""default"", ""defer"", ""disabled"",
            ""formnovalidate"", ""hidden"", ""inert"", ""ismap"", ""itemscope"", ""multiple"", ""muted"", ""nohref"", ""noresize"",
            ""noshade"", ""novalidate"", ""nowrap"", ""open"", ""readonly"", ""required"", ""reversed"", ""seamless"", ""selected"",
            ""sortable"", ""truespeed"", ""typemustmatch""
    };

    private String key;
    @Nullable private String val;
    @Nullable Attributes parent; // used to update the holding Attributes when the key / value is changed via this interface

    /**
     * Create a new attribute from unencoded (raw) key and value.
     * @param key attribute key; case is preserved.
     * @param value attribute value (may be null)
     * @see #createFromEncoded
     */
    public Attribute(String key, @Nullable String value) {
        this(key, value, null);
    }

    /**
     * Create a new attribute from unencoded (raw) key and value.
     * @param key attribute key; case is preserved.
     * @param val attribute value (may be null)
     * @param parent the containing Attributes (this Attribute is not automatically added to said Attributes)
     * @see #createFromEncoded*/
    public Attribute(String key, @Nullable String val, @Nullable Attributes parent) {
        Validate.notNull(key);
        key = key.trim();
        Validate.notEmpty(key); // trimming could potentially make empty, so validate here
        this.key = key;
        this.val = val;
        this.parent = parent;
    }

    /**
     Get the attribute key.
     @return the attribute key
     */
    @Override
    public String getKey() {
        return key;
    }

    /**
     Set the attribute key; case is preserved.
     @param key the new key; must not be null
     */
    public void setKey(String key) {
        Validate.notNull(key);
        key = key.trim();
        Validate.notEmpty(key); // trimming could potentially make empty, so validate here
        if (parent != null) {
            int i = parent.indexOfKey(this.key);
            if (i != Attributes.NotFound)
                parent.keys[i] = key;
        }
        this.key = key;
    }

    /**
     Get the attribute value. Will return an empty string if the value is not set.
     @return the attribute value
     */
    @Override
    public String getValue() {
        return Attributes.checkNotNull(val);
    }

    /**
     * Check if this Attribute has a value. Set boolean attributes have no value.
     * @return if this is a boolean attribute / attribute without a value
     */
    public boolean hasDeclaredValue() {
        return val != null;
    }

    /**
     Set the attribute value.
     @param val the new attribute value; may be null (to set an enabled boolean attribute)
     @return the previous value (if was null; an empty string)
     */
    public String setValue(@Nullable String val) {
        String oldVal = this.val;
        if (parent != null) {
            int i = parent.indexOfKey(this.key);
            if (i != Attributes.NotFound) {
                oldVal = parent.get(this.key); // trust the container more
                parent.vals[i] = val;
            }
        }
        this.val = val;
        return Attributes.checkNotNull(oldVal);
    }

    /**
     Get the HTML representation of this attribute; e.g. {@code href=""index.html""}.
     @return HTML
     */
    public String html() {
        StringBuilder sb = StringUtil.borrowBuilder();
        
        try {
        	html(sb, (new Document("""")).outputSettings());
        } catch(IOException exception) {
        	throw new SerializationException(exception);
        }
        return StringUtil.releaseBuilder(sb);
    }

    protected void html(Appendable accum, Document.OutputSettings out) throws IOException {
        html(key, val, accum, out);
    }

    protected static void html(String key, @Nullable String val, Appendable accum, Document.OutputSettings out) throws IOException {
        key = getValidKey(key, out.syntax());
        if (key == null) return; // can't write it :(
        htmlNoValidate(key, val, accum, out);
    }

    static void htmlNoValidate(String key, @Nullable String val, Appendable accum, Document.OutputSettings out) throws IOException {
        // structured like this so that Attributes can check we can write first, so it can add whitespace correctly
        accum.append(key);
        if (!shouldCollapseAttribute(key, val, out)) {
            accum.append(""=\"""");
            Entities.escape(accum, Attributes.checkNotNull(val) , out, true, false, false, false);
            accum.append('""');
        }
    }

    private static final Pattern xmlKeyValid = Pattern.compile(""[a-zA-Z_:][-a-zA-Z0-9_:.]*"");
    private static final Pattern xmlKeyReplace = Pattern.compile(""[^-a-zA-Z0-9_:.]"");
    private static final Pattern htmlKeyValid = Pattern.compile(""[^\\x00-\\x1f\\x7f-\\x9f \""'/=]+"");
    private static final Pattern htmlKeyReplace = Pattern.compile(""[\\x00-\\x1f\\x7f-\\x9f \""'/=]"");

    @Nullable public static String getValidKey(String key, Syntax syntax) {
        // we consider HTML attributes to always be valid. XML checks key validity
        if (syntax == Syntax.xml && !xmlKeyValid.matcher(key).matches()) {
            key = xmlKeyReplace.matcher(key).replaceAll("""");
            return xmlKeyValid.matcher(key).matches() ? key : null; // null if could not be coerced
        }
        else if (syntax == Syntax.html && !htmlKeyValid.matcher(key).matches()) {
            key = htmlKeyReplace.matcher(key).replaceAll("""");
            return htmlKeyValid.matcher(key).matches() ? key : null; // null if could not be coerced
        }
        return key;
    }

    /**
     Get the string representation of this attribute, implemented as {@link #html()}.
     @return string
     */
    @Override
    public String toString() {
        return html();
    }

    /**
     * Create a new Attribute from an unencoded key and a HTML attribute encoded value.
     * @param unencodedKey assumes the key is not encoded, as can be only run of simple \w chars.
     * @param encodedValue HTML attribute encoded value
     * @return attribute
     */
    public static Attribute createFromEncoded(String unencodedKey, String encodedValue) {
        String value = Entities.unescape(encodedValue, true);
        return new Attribute(unencodedKey, value, null); // parent will get set when Put
    }

    protected boolean isDataAttribute() {
        return isDataAttribute(key);
    }

    protected static boolean isDataAttribute(String key) {
        return key.startsWith(Attributes.dataPrefix) && key.length() > Attributes.dataPrefix.length();
    }

    /**
     * Collapsible if it's a boolean attribute and value is empty or same as name
     * 
     * @param out output settings
     * @return  Returns whether collapsible or not
     */
    protected final boolean shouldCollapseAttribute(Document.OutputSettings out) {
        return shouldCollapseAttribute(key, val, out);
    }

    // collapse unknown foo=null, known checked=null, checked="""", checked=checked; write out others
    protected static boolean shouldCollapseAttribute(final String key, @Nullable final String val, final Document.OutputSettings out) {
        return (
            out.syntax() == Syntax.html &&
                (val == null || (val.isEmpty() || val.equalsIgnoreCase(key)) && Attribute.isBooleanAttribute(key)));
    }

    /**
     * Checks if this attribute name is defined as a boolean attribute in HTML5
     */
    public static boolean isBooleanAttribute(final String key) {
        return Arrays.binarySearch(booleanAttributes, Normalizer.lowerCase(key)) >= 0;
    }

    @Override
    public boolean equals(@Nullable Object o) { // note parent not considered
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Attribute attribute = (Attribute) o;
        if (key != null ? !key.equals(attribute.key) : attribute.key != null) return false;
        return val != null ? val.equals(attribute.val) : attribute.val == null;
    }

    @Override
    public int hashCode() { // note parent not considered
        int result = key != null ? key.hashCode() : 0;
        result = 31 * result + (val != null ? val.hashCode() : 0);
        return result;
    }

    @Override
    public Attribute clone() {
        try {
            return (Attribute) super.clone();
        } catch (CloneNotSupportedException e) {
            throw new RuntimeException(e);
        }
    }
}
"
jhy/jsoup,src/test/java/org/jsoup/helper/HttpConnectionTest.java,"package org.jsoup.helper;

import org.jsoup.Connection;
import org.jsoup.Jsoup;
import org.jsoup.MultiLocaleExtension.MultiLocaleTest;
import org.jsoup.integration.ParseTest;
import org.junit.jupiter.api.Test;

import java.io.IOException;
import java.net.MalformedURLException;
import java.net.URL;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Locale;
import java.util.Map;

import static org.junit.jupiter.api.Assertions.*;

public class HttpConnectionTest {
    /* most actual network http connection tests are in integration */

    @Test public void canCreateEmptyConnection() {
        HttpConnection con = new HttpConnection();
        assertEquals(Connection.Method.GET, con.request().method());
        assertThrows(IllegalArgumentException.class, () -> {
            URL url = con.request().url();
        });
    }

    @Test public void throwsExceptionOnResponseWithoutExecute() {
        assertThrows(IllegalArgumentException.class, () -> {
            Connection con = HttpConnection.connect(""http://example.com"");
            con.response();
        });
    }

    @Test public void throwsExceptionOnParseWithoutExecute() {
        assertThrows(IllegalArgumentException.class, () -> {
            Connection con = HttpConnection.connect(""http://example.com"");
            con.response().parse();
        });
    }

    @Test public void throwsExceptionOnBodyWithoutExecute() {
        assertThrows(IllegalArgumentException.class, () -> {
            Connection con = HttpConnection.connect(""http://example.com"");
            con.response().body();
        });
    }

    @Test public void throwsExceptionOnBodyAsBytesWithoutExecute() {
        assertThrows(IllegalArgumentException.class, () -> {
            Connection con = HttpConnection.connect(""http://example.com"");
            con.response().bodyAsBytes();
        });
    }

    @MultiLocaleTest
    public void caseInsensitiveHeaders(Locale locale) {
        Locale.setDefault(locale);

        Connection.Response res = new HttpConnection.Response();
        res.header(""Accept-Encoding"", ""gzip"");
        res.header(""content-type"", ""text/html"");
        res.header(""refErrer"", ""http://example.com"");

        assertTrue(res.hasHeader(""Accept-Encoding""));
        assertTrue(res.hasHeader(""accept-encoding""));
        assertTrue(res.hasHeader(""accept-Encoding""));
        assertTrue(res.hasHeader(""ACCEPT-ENCODING""));

        assertEquals(""gzip"", res.header(""accept-Encoding""));
        assertEquals(""gzip"", res.header(""ACCEPT-ENCODING""));
        assertEquals(""text/html"", res.header(""Content-Type""));
        assertEquals(""http://example.com"", res.header(""Referrer""));

        res.removeHeader(""Content-Type"");
        assertFalse(res.hasHeader(""content-type""));

        res.removeHeader(""ACCEPT-ENCODING"");
        assertFalse(res.hasHeader(""Accept-Encoding""));

        res.header(""ACCEPT-ENCODING"", ""deflate"");
        assertEquals(""deflate"", res.header(""Accept-Encoding""));
        assertEquals(""deflate"", res.header(""accept-Encoding""));
    }

    @Test public void headers() {
        Connection con = HttpConnection.connect(""http://example.com"");
        Map<String, String> headers = new HashMap<>();
        headers.put(""content-type"", ""text/html"");
        headers.put(""Connection"", ""keep-alive"");
        headers.put(""Host"", ""http://example.com"");
        con.headers(headers);
        assertEquals(""text/html"", con.request().header(""content-type""));
        assertEquals(""keep-alive"", con.request().header(""Connection""));
        assertEquals(""http://example.com"", con.request().header(""Host""));
    }

    @Test public void sameHeadersCombineWithComma() {
        Map<String, List<String>> headers = new HashMap<>();
        List<String> values = new ArrayList<>();
        values.add(""no-cache"");
        values.add(""no-store"");
        headers.put(""Cache-Control"", values);
        HttpConnection.Response res = new HttpConnection.Response();
        res.processResponseHeaders(headers);
        assertEquals(""no-cache, no-store"", res.header(""Cache-Control""));
    }

    @Test public void multipleHeaders() {
        Connection.Request req = new HttpConnection.Request();
        req.addHeader(""Accept"", ""Something"");
        req.addHeader(""Accept"", ""Everything"");
        req.addHeader(""Foo"", ""Bar"");

        assertTrue(req.hasHeader(""Accept""));
        assertTrue(req.hasHeader(""ACCEpt""));
        assertEquals(""Something, Everything"", req.header(""accept""));
        assertTrue(req.hasHeader(""fOO""));
        assertEquals(""Bar"", req.header(""foo""));

        List<String> accept = req.headers(""accept"");
        assertEquals(2, accept.size());
        assertEquals(""Something"", accept.get(0));
        assertEquals(""Everything"", accept.get(1));

        Map<String, List<String>> headers = req.multiHeaders();
        assertEquals(accept, headers.get(""Accept""));
        assertEquals(""Bar"", headers.get(""Foo"").get(0));

        assertTrue(req.hasHeader(""Accept""));
        assertTrue(req.hasHeaderWithValue(""accept"", ""Something""));
        assertTrue(req.hasHeaderWithValue(""accept"", ""Everything""));
        assertFalse(req.hasHeaderWithValue(""accept"", ""Something for nothing""));

        req.removeHeader(""accept"");
        headers = req.multiHeaders();
        assertEquals(""Bar"", headers.get(""Foo"").get(0));
        assertFalse(req.hasHeader(""Accept""));
        assertNull(headers.get(""Accept""));
    }

    @Test public void ignoresEmptySetCookies() {
        // prep http response header map
        Map<String, List<String>> headers = new HashMap<>();
        headers.put(""Set-Cookie"", Collections.emptyList());
        HttpConnection.Response res = new HttpConnection.Response();
        res.processResponseHeaders(headers);
        assertEquals(0, res.cookies().size());
    }

    @Test public void ignoresEmptyCookieNameAndVals() {
        // prep http response header map
        Map<String, List<String>> headers = new HashMap<>();
        List<String> cookieStrings = new ArrayList<>();
        cookieStrings.add(null);
        cookieStrings.add("""");
        cookieStrings.add(""one"");
        cookieStrings.add(""two="");
        cookieStrings.add(""three=;"");
        cookieStrings.add(""four=data; Domain=.example.com; Path=/"");

        headers.put(""Set-Cookie"", cookieStrings);
        HttpConnection.Response res = new HttpConnection.Response();
        res.processResponseHeaders(headers);
        assertEquals(4, res.cookies().size());
        assertEquals("""", res.cookie(""one""));
        assertEquals("""", res.cookie(""two""));
        assertEquals("""", res.cookie(""three""));
        assertEquals(""data"", res.cookie(""four""));
    }

    @Test public void connectWithUrl() throws MalformedURLException {
        Connection con = HttpConnection.connect(new URL(""http://example.com""));
        assertEquals(""http://example.com"", con.request().url().toExternalForm());
    }

    @Test public void throwsOnMalformedUrl() {
        assertThrows(IllegalArgumentException.class, () -> HttpConnection.connect(""bzzt""));
    }

    @Test public void userAgent() {
        Connection con = HttpConnection.connect(""http://example.com/"");
        assertEquals(HttpConnection.DEFAULT_UA, con.request().header(""User-Agent""));
        con.userAgent(""Mozilla"");
        assertEquals(""Mozilla"", con.request().header(""User-Agent""));
    }

    @Test public void timeout() {
        Connection con = HttpConnection.connect(""http://example.com/"");
        assertEquals(30 * 1000, con.request().timeout());
        con.timeout(1000);
        assertEquals(1000, con.request().timeout());
    }

    @Test public void referrer() {
        Connection con = HttpConnection.connect(""http://example.com/"");
        con.referrer(""http://foo.com"");
        assertEquals(""http://foo.com"", con.request().header(""Referer""));
    }

    @Test public void method() {
        Connection con = HttpConnection.connect(""http://example.com/"");
        assertEquals(Connection.Method.GET, con.request().method());
        con.method(Connection.Method.POST);
        assertEquals(Connection.Method.POST, con.request().method());
    }

    @Test public void throwsOnOddData() {
        assertThrows(IllegalArgumentException.class, () -> {
            Connection con = HttpConnection.connect(""http://example.com/"");
            con.data(""Name"", ""val"", ""what"");
        });
    }

    @Test public void data() {
        Connection con = HttpConnection.connect(""http://example.com/"");
        con.data(""Name"", ""Val"", ""Foo"", ""bar"");
        Collection<Connection.KeyVal> values = con.request().data();
        Object[] data =  values.toArray();
        Connection.KeyVal one = (Connection.KeyVal) data[0];
        Connection.KeyVal two = (Connection.KeyVal) data[1];
        assertEquals(""Name"", one.key());
        assertEquals(""Val"", one.value());
        assertEquals(""Foo"", two.key());
        assertEquals(""bar"", two.value());
    }

    @Test public void cookie() {
        Connection con = HttpConnection.connect(""http://example.com/"");
        con.cookie(""Name"", ""Val"");
        assertEquals(""Val"", con.request().cookie(""Name""));
    }

    @Test public void inputStream() {
        Connection.KeyVal kv = HttpConnection.KeyVal.create(""file"", ""thumb.jpg"", ParseTest.inputStreamFrom(""Check""));
        assertEquals(""file"", kv.key());
        assertEquals(""thumb.jpg"", kv.value());
        assertTrue(kv.hasInputStream());

        kv = HttpConnection.KeyVal.create(""one"", ""two"");
        assertEquals(""one"", kv.key());
        assertEquals(""two"", kv.value());
        assertFalse(kv.hasInputStream());
    }

    @Test public void requestBody() {
        Connection con = HttpConnection.connect(""http://example.com/"");
        con.requestBody(""foo"");
        assertEquals(""foo"", con.request().requestBody());
    }

    @Test public void encodeUrl() throws MalformedURLException {
        URL url1 = new URL(""http://test.com/?q=white space"");
        URL url2 = HttpConnection.encodeUrl(url1);
        assertEquals(""http://test.com/?q=white%20space"", url2.toExternalForm());
    }

    @Test public void noUrlThrowsValidationError() throws IOException {
        HttpConnection con = new HttpConnection();
        boolean threw = false;
        try {
            con.execute();
        } catch (IllegalArgumentException e) {
            threw = true;
            assertEquals(""URL not set. Make sure to call #url(...) before executing the request."", e.getMessage());
        }
        assertTrue(threw);
    }

    @Test public void handlesHeaderEncodingOnRequest() {
        Connection.Request req = new HttpConnection.Request();
        req.addHeader(""xxx"", ""√©"");
    }

    @Test public void supportsInternationalDomainNames() throws MalformedURLException {
        String idn = ""https://www.ÊµãËØï.ÊµãËØï/foo.html?bar"";
        String puny = ""https://www.xn--0zwm56d.xn--0zwm56d/foo.html?bar"";

        Connection con = Jsoup.connect(idn);
        assertEquals(puny, con.request().url().toExternalForm());

        HttpConnection.Request req = new HttpConnection.Request();
        req.url(new URL(idn));
        assertEquals(puny, req.url().toExternalForm());
    }

    @Test public void validationErrorsOnExecute() throws IOException {
        Connection con = new HttpConnection();
        boolean urlThrew = false;
        try {
            con.execute();
        } catch (IllegalArgumentException e) {
            urlThrew = e.getMessage().contains(""URL"");
        }
        assertTrue(urlThrew);
    }

    @Test void testMalformedException() {
        boolean threw = false;
        try {
            Jsoup.connect(""jsoup.org/test"");
        } catch (IllegalArgumentException e) {
            threw = true;
            assertEquals(""The supplied URL, 'jsoup.org/test', is malformed. Make sure it is an absolute URL, and starts with 'http://' or 'https://'. See https://jsoup.org/cookbook/extracting-data/working-with-urls"", e.getMessage());
        }
        assertTrue(threw);
    }
}
"
jhy/jsoup,src/main/java/org/jsoup/select/Collector.java,"package org.jsoup.select;

import org.jsoup.nodes.Element;
import org.jsoup.nodes.Node;

import javax.annotation.Nullable;

import static org.jsoup.select.NodeFilter.FilterResult.CONTINUE;
import static org.jsoup.select.NodeFilter.FilterResult.STOP;

/**
 * Collects a list of elements that match the supplied criteria.
 *
 * @author Jonathan Hedley
 */
public class Collector {

    private Collector() {}

    /**
     Build a list of elements, by visiting root and every descendant of root, and testing it against the evaluator.
     @param eval Evaluator to test elements against
     @param root root of tree to descend
     @return list of matches; empty if none
     */
    public static Elements collect (Evaluator eval, Element root) {
        Elements elements = new Elements();
        NodeTraversor.traverse(new Accumulator(root, elements, eval), root);
        return elements;
    }

    private static class Accumulator implements NodeVisitor {
        private final Element root;
        private final Elements elements;
        private final Evaluator eval;

        Accumulator(Element root, Elements elements, Evaluator eval) {
            this.root = root;
            this.elements = elements;
            this.eval = eval;
        }

        public void head(Node node, int depth) {
            if (node instanceof Element) {
                Element el = (Element) node;
                if (eval.matches(root, el))
                    elements.add(el);
            }
        }

        public void tail(Node node, int depth) {
            // void
        }
    }

    /**
     Finds the first Element that matches the Evaluator that descends from the root, and stops the query once that first
     match is found.
     @param eval Evaluator to test elements against
     @param root root of tree to descend
     @return the first match; {@code null} if none
     */
    public static @Nullable Element findFirst(Evaluator eval, Element root) {
        FirstFinder finder = new FirstFinder(eval);
        return finder.find(root, root);
    }

    static class FirstFinder implements NodeFilter {
        private @Nullable Element evalRoot = null;
        private @Nullable Element match = null;
        private final Evaluator eval;

        FirstFinder(Evaluator eval) {
            this.eval = eval;
        }

        @Nullable Element find(Element root, Element start) {
            evalRoot = root;
            match = null;
            NodeTraversor.filter(this, start);
            return match;
        }

        @Override
        public FilterResult head(Node node, int depth) {
            if (node instanceof Element) {
                Element el = (Element) node;
                if (eval.matches(evalRoot, el)) {
                    match = el;
                    return STOP;
                }
            }
            return CONTINUE;
        }

        @Override
        public FilterResult tail(Node node, int depth) {
            return CONTINUE;
        }
    }

}
"
jhy/jsoup,src/test/java/org/jsoup/parser/XmlTreeBuilderTest.java,"package org.jsoup.parser;

import org.jsoup.Jsoup;
import org.jsoup.TextUtil;
import org.jsoup.internal.StringUtil;
import org.jsoup.nodes.*;
import org.jsoup.select.Elements;
import org.junit.jupiter.api.Disabled;
import org.junit.jupiter.api.Test;

import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.net.URISyntaxException;
import java.nio.charset.StandardCharsets;
import java.util.List;

import static org.jsoup.nodes.Document.OutputSettings.Syntax;
import static org.junit.jupiter.api.Assertions.*;

/**
 * Tests XmlTreeBuilder.
 *
 * @author Jonathan Hedley
 */
public class XmlTreeBuilderTest {
    @Test
    public void testSimpleXmlParse() {
        String xml = ""<doc id=2 href='/bar'>Foo <br /><link>One</link><link>Two</link></doc>"";
        XmlTreeBuilder tb = new XmlTreeBuilder();
        Document doc = tb.parse(xml, ""http://foo.com/"");
        assertEquals(""<doc id=\""2\"" href=\""/bar\"">Foo <br /><link>One</link><link>Two</link></doc>"",
                TextUtil.stripNewlines(doc.html()));
        assertEquals(doc.getElementById(""2"").absUrl(""href""), ""http://foo.com/bar"");
    }

    @Test
    public void testPopToClose() {
        // test: </val> closes Two, </bar> ignored
        String xml = ""<doc><val>One<val>Two</val></bar>Three</doc>"";
        XmlTreeBuilder tb = new XmlTreeBuilder();
        Document doc = tb.parse(xml, ""http://foo.com/"");
        assertEquals(""<doc><val>One<val>Two</val>Three</val></doc>"",
                TextUtil.stripNewlines(doc.html()));
    }

    @Test
    public void testCommentAndDocType() {
        String xml = ""<!DOCTYPE HTML><!-- a comment -->One <qux />Two"";
        XmlTreeBuilder tb = new XmlTreeBuilder();
        Document doc = tb.parse(xml, ""http://foo.com/"");
        assertEquals(""<!DOCTYPE HTML><!-- a comment -->One <qux />Two"",
                TextUtil.stripNewlines(doc.html()));
    }

    @Test
    public void testSupplyParserToJsoupClass() {
        String xml = ""<doc><val>One<val>Two</val></bar>Three</doc>"";
        Document doc = Jsoup.parse(xml, ""http://foo.com/"", Parser.xmlParser());
        assertEquals(""<doc><val>One<val>Two</val>Three</val></doc>"",
                TextUtil.stripNewlines(doc.html()));
    }

    @Disabled
    @Test
    public void testSupplyParserToConnection() throws IOException {
        String xmlUrl = ""http://direct.infohound.net/tools/jsoup-xml-test.xml"";

        // parse with both xml and html parser, ensure different
        Document xmlDoc = Jsoup.connect(xmlUrl).parser(Parser.xmlParser()).get();
        Document htmlDoc = Jsoup.connect(xmlUrl).parser(Parser.htmlParser()).get();
        Document autoXmlDoc = Jsoup.connect(xmlUrl).get(); // check connection auto detects xml, uses xml parser

        assertEquals(""<doc><val>One<val>Two</val>Three</val></doc>"",
                TextUtil.stripNewlines(xmlDoc.html()));
        assertNotEquals(htmlDoc, xmlDoc);
        assertEquals(xmlDoc, autoXmlDoc);
        assertEquals(1, htmlDoc.select(""head"").size()); // html parser normalises
        assertEquals(0, xmlDoc.select(""head"").size()); // xml parser does not
        assertEquals(0, autoXmlDoc.select(""head"").size()); // xml parser does not
    }

    @Test
    public void testSupplyParserToDataStream() throws IOException, URISyntaxException {
        File xmlFile = new File(XmlTreeBuilder.class.getResource(""/htmltests/xml-test.xml"").toURI());
        InputStream inStream = new FileInputStream(xmlFile);
        Document doc = Jsoup.parse(inStream, null, ""http://foo.com"", Parser.xmlParser());
        assertEquals(""<doc><val>One<val>Two</val>Three</val></doc>"",
                TextUtil.stripNewlines(doc.html()));
    }

    @Test
    public void testDoesNotForceSelfClosingKnownTags() {
        // html will force ""<br>one</br>"" to logically ""<br />One<br />"". XML should be stay ""<br>one</br> -- don't recognise tag.
        Document htmlDoc = Jsoup.parse(""<br>one</br>"");
        assertEquals(""<br>one<br>"", htmlDoc.body().html());

        Document xmlDoc = Jsoup.parse(""<br>one</br>"", """", Parser.xmlParser());
        assertEquals(""<br>one</br>"", xmlDoc.html());
    }

    @Test public void handlesXmlDeclarationAsDeclaration() {
        String html = ""<?xml encoding='UTF-8' ?><body>One</body><!-- comment -->"";
        Document doc = Jsoup.parse(html, """", Parser.xmlParser());
        assertEquals(""<?xml encoding=\""UTF-8\""?><body>One</body><!-- comment -->"",doc.outerHtml());
        assertEquals(""#declaration"", doc.childNode(0).nodeName());
        assertEquals(""#comment"", doc.childNode(2).nodeName());
    }

    @Test public void xmlFragment() {
        String xml = ""<one src='/foo/' />Two<three><four /></three>"";
        List<Node> nodes = Parser.parseXmlFragment(xml, ""http://example.com/"");
        assertEquals(3, nodes.size());

        assertEquals(""http://example.com/foo/"", nodes.get(0).absUrl(""src""));
        assertEquals(""one"", nodes.get(0).nodeName());
        assertEquals(""Two"", ((TextNode)nodes.get(1)).text());
    }

    @Test public void xmlParseDefaultsToHtmlOutputSyntax() {
        Document doc = Jsoup.parse(""x"", """", Parser.xmlParser());
        assertEquals(Syntax.xml, doc.outputSettings().syntax());
    }

    @Test
    public void testDoesHandleEOFInTag() {
        String html = ""<img src=asdf onerror=\""alert(1)\"" x="";
        Document xmlDoc = Jsoup.parse(html, """", Parser.xmlParser());
        assertEquals(""<img src=\""asdf\"" onerror=\""alert(1)\"" x=\""\"" />"", xmlDoc.html());
    }

    @Test
    public void testDetectCharsetEncodingDeclaration() throws IOException, URISyntaxException {
        File xmlFile = new File(XmlTreeBuilder.class.getResource(""/htmltests/xml-charset.xml"").toURI());
        InputStream inStream = new FileInputStream(xmlFile);
        Document doc = Jsoup.parse(inStream, null, ""http://example.com/"", Parser.xmlParser());
        assertEquals(""ISO-8859-1"", doc.charset().name());
        assertEquals(""<?xml version=\""1.0\"" encoding=\""ISO-8859-1\""?><data>√§√∂√•√©√º</data>"",
            TextUtil.stripNewlines(doc.html()));
    }

    @Test
    public void testParseDeclarationAttributes() {
        String xml = ""<?xml version='1' encoding='UTF-8' something='else'?><val>One</val>"";
        Document doc = Jsoup.parse(xml, """", Parser.xmlParser());
        XmlDeclaration decl = (XmlDeclaration) doc.childNode(0);
        assertEquals(""1"", decl.attr(""version""));
        assertEquals(""UTF-8"", decl.attr(""encoding""));
        assertEquals(""else"", decl.attr(""something""));
        assertEquals(""version=\""1\"" encoding=\""UTF-8\"" something=\""else\"""", decl.getWholeDeclaration());
        assertEquals(""<?xml version=\""1\"" encoding=\""UTF-8\"" something=\""else\""?>"", decl.outerHtml());
    }

    @Test
    public void testParseDeclarationWithoutAttributes() {
        String xml = ""<?xml version=\""1.0\"" encoding=\""utf-8\""?>\n<?myProcessingInstruction My Processing instruction.?>"";
        Document doc = Jsoup.parse(xml, """", Parser.xmlParser());
        XmlDeclaration decl = (XmlDeclaration) doc.childNode(2);
        assertEquals(""myProcessingInstruction"", decl.name());
        assertTrue(decl.hasAttr(""My""));
        assertEquals(""<?myProcessingInstruction My Processing instruction.?>"", decl.outerHtml());
    }

    @Test
    public void caseSensitiveDeclaration() {
        String xml = ""<?XML version='1' encoding='UTF-8' something='else'?>"";
        Document doc = Jsoup.parse(xml, """", Parser.xmlParser());
        assertEquals(""<?XML version=\""1\"" encoding=\""UTF-8\"" something=\""else\""?>"", doc.outerHtml());
    }

    @Test
    public void testCreatesValidProlog() {
        Document document = Document.createShell("""");
        document.outputSettings().syntax(Syntax.xml);
        document.charset(StandardCharsets.UTF_8);
        assertEquals(""<?xml version=\""1.0\"" encoding=\""UTF-8\""?>\n"" +
            ""<html>\n"" +
            "" <head></head>\n"" +
            "" <body></body>\n"" +
            ""</html>"", document.outerHtml());
    }

    @Test
    public void preservesCaseByDefault() {
        String xml = ""<CHECK>One</CHECK><TEST ID=1>Check</TEST>"";
        Document doc = Jsoup.parse(xml, """", Parser.xmlParser());
        assertEquals(""<CHECK>One</CHECK><TEST ID=\""1\"">Check</TEST>"", TextUtil.stripNewlines(doc.html()));
    }

    @Test
    public void appendPreservesCaseByDefault() {
        String xml = ""<One>One</One>"";
        Document doc = Jsoup.parse(xml, """", Parser.xmlParser());
        Elements one = doc.select(""One"");
        one.append(""<Two ID=2>Two</Two>"");
        assertEquals(""<One>One<Two ID=\""2\"">Two</Two></One>"", TextUtil.stripNewlines(doc.html()));
    }

    @Test
    public void disablesPrettyPrintingByDefault() {
        String xml = ""\n\n<div><one>One</one><one>\n Two</one>\n</div>\n "";
        Document doc = Jsoup.parse(xml, """", Parser.xmlParser());
        assertEquals(xml, doc.html());
    }

    @Test
    public void canNormalizeCase() {
        String xml = ""<TEST ID=1>Check</TEST>"";
        Document doc = Jsoup.parse(xml, """", Parser.xmlParser().settings(ParseSettings.htmlDefault));
        assertEquals(""<test id=\""1\"">Check</test>"", TextUtil.stripNewlines(doc.html()));
    }

    @Test public void normalizesDiscordantTags() {
        Parser parser = Parser.xmlParser().settings(ParseSettings.htmlDefault);
        Document document = Jsoup.parse(""<div>test</DIV><p></p>"", """", parser);
        assertEquals(""<div>test</div><p></p>"", document.html());
        // was failing -> toString() = ""<div>\n test\n <p></p>\n</div>""
    }

    @Test public void roundTripsCdata() {
        String xml = ""<div id=1><![CDATA[\n<html>\n <foo><&amp;]]></div>"";
        Document doc = Jsoup.parse(xml, """", Parser.xmlParser());

        Element div = doc.getElementById(""1"");
        assertEquals(""<html>\n <foo><&amp;"", div.text());
        assertEquals(0, div.children().size());
        assertEquals(1, div.childNodeSize()); // no elements, one text node

        assertEquals(""<div id=\""1\""><![CDATA[\n<html>\n <foo><&amp;]]></div>"", div.outerHtml());

        CDataNode cdata = (CDataNode) div.textNodes().get(0);
        assertEquals(""\n<html>\n <foo><&amp;"", cdata.text());
    }

    @Test public void cdataPreservesWhiteSpace() {
        String xml = ""<script type=\""text/javascript\"">//<![CDATA[\n\n  foo();\n//]]></script>"";
        Document doc = Jsoup.parse(xml, """", Parser.xmlParser());
        assertEquals(xml, doc.outerHtml());

        assertEquals(""//\n\n  foo();\n//"", doc.selectFirst(""script"").text());
    }

    @Test
    public void handlesDodgyXmlDecl() {
        String xml = ""<?xml version='1.0'><val>One</val>"";
        Document doc = Jsoup.parse(xml, """", Parser.xmlParser());
        assertEquals(""One"", doc.select(""val"").text());
    }

    @Test
    public void handlesLTinScript() {
        // https://github.com/jhy/jsoup/issues/1139
        String html = ""<script> var a=\""<?\""; var b=\""?>\""; </script>"";
        Document doc = Jsoup.parse(html, """", Parser.xmlParser());
        assertEquals(""<script> var a=\""<!--?\""; var b=\""?-->\""; </script>"", doc.html()); // converted from pseudo xmldecl to comment
    }

    @Test public void dropsDuplicateAttributes() {
        // case sensitive, so should drop Four and Five
        String html = ""<p One=One ONE=Two one=Three One=Four ONE=Five two=Six two=Seven Two=Eight>Text</p>"";
        Parser parser = Parser.xmlParser().setTrackErrors(10);
        Document doc = parser.parseInput(html, """");

        assertEquals(""<p One=\""One\"" ONE=\""Two\"" one=\""Three\"" two=\""Six\"" Two=\""Eight\"">Text</p>"", doc.selectFirst(""p"").outerHtml());
    }

    @Test public void readerClosedAfterParse() {
        Document doc = Jsoup.parse(""Hello"", """", Parser.xmlParser());
        TreeBuilder treeBuilder = doc.parser().getTreeBuilder();
        assertNull(treeBuilder.reader);
        assertNull(treeBuilder.tokeniser);
    }

    @Test public void xmlParserEnablesXmlOutputAndEscapes() {
        // Test that when using the XML parser, the output mode and escape mode default to XHTML entities
        // https://github.com/jhy/jsoup/issues/1420
        Document doc = Jsoup.parse(""<p one='&lt;two&gt;&copy'>Three</p>"", """", Parser.xmlParser());
        assertEquals(doc.outputSettings().syntax(), Syntax.xml);
        assertEquals(doc.outputSettings().escapeMode(), Entities.EscapeMode.xhtml);
        assertEquals(""<p one=\""&lt;two>¬©\"">Three</p>"", doc.html()); // only the < should be escaped
    }

    @Test public void xmlSyntaxEscapesLtInAttributes() {
        // Regardless of the entity escape mode, make sure < is escaped in attributes when in XML
        Document doc = Jsoup.parse(""<p one='&lt;two&gt;&copy'>Three</p>"", """", Parser.xmlParser());
        doc.outputSettings().escapeMode(Entities.EscapeMode.extended);
        doc.outputSettings().charset(""ascii""); // to make sure &copy; is output
        assertEquals(doc.outputSettings().syntax(), Syntax.xml);
        assertEquals(""<p one=\""&lt;two>&copy;\"">Three</p>"", doc.html());
    }

    @Test void xmlOutputCorrectsInvalidAttributeNames() {
        String xml = ""<body style=\""color: red\"" \"" name\""><div =\""\""></div></body>"";
        Document doc = Jsoup.parse(xml, Parser.xmlParser());
        assertEquals(Syntax.xml, doc.outputSettings().syntax());

        String out = doc.html();
        assertEquals(""<body style=\""color: red\"" name=\""\""><div></div></body>"", out);
    }

    @Test void customTagsAreFlyweights() {
        String xml = ""<foo>Foo</foo><foo>Foo</foo><FOO>FOO</FOO><FOO>FOO</FOO>"";
        Document doc = Jsoup.parse(xml, Parser.xmlParser());
        Elements els = doc.children();

        Tag t1 = els.get(0).tag();
        Tag t2 = els.get(1).tag();
        Tag t3 = els.get(2).tag();
        Tag t4 = els.get(3).tag();
        assertEquals(""foo"", t1.getName());
        assertEquals(""FOO"", t3.getName());
        assertSame(t1, t2);
        assertSame(t3, t4);

    }
}
"
jhy/jsoup,src/test/java/org/jsoup/helper/ValidateTest.java,"package org.jsoup.helper;

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

import static org.junit.jupiter.api.Assertions.*;

public class ValidateTest {
    @Test
    public void testNotNull() {
        Validate.notNull(""foo"");
        boolean threw = false;
        try {
            Validate.notNull(null);
        } catch (IllegalArgumentException e) {
            threw = true;
        }
        Assertions.assertTrue(threw);
    }

    @Test void stacktraceFiltersOutValidateClass() {
        boolean threw = false;
        try {
            Validate.notNull(null);
        } catch (ValidationException e) {
            threw = true;
            assertEquals(""Object must not be null"", e.getMessage());
            StackTraceElement[] stackTrace = e.getStackTrace();
            for (StackTraceElement trace : stackTrace) {
                assertNotEquals(trace.getClassName(), Validate.class.getName());
            }
            assertTrue(stackTrace.length >= 1);
        }
        Assertions.assertTrue(threw);
    }

    @Test void nonnullParam() {
        boolean threw = true;
        try {
            Validate.notNullParam(null, ""foo"");
        } catch (ValidationException e) {
            assertEquals(""The parameter 'foo' must not be null."", e.getMessage());
        }
        assertTrue(threw);
    }
}
"
jhy/jsoup,src/main/java/org/jsoup/select/QueryParser.java,"package org.jsoup.select;

import org.jsoup.internal.StringUtil;
import org.jsoup.helper.Validate;
import org.jsoup.parser.TokenQueue;

import java.util.ArrayList;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import static org.jsoup.internal.Normalizer.normalize;

/**
 * Parses a CSS selector into an Evaluator tree.
 */
public class QueryParser {
    private final static String[] combinators = {"","", "">"", ""+"", ""~"", "" ""};
    private static final String[] AttributeEvals = new String[]{""="", ""!="", ""^="", ""$="", ""*="", ""~=""};

    private final TokenQueue tq;
    private final String query;
    private final List<Evaluator> evals = new ArrayList<>();

    /**
     * Create a new QueryParser.
     * @param query CSS query
     */
    private QueryParser(String query) {
        Validate.notEmpty(query);
        query = query.trim();
        this.query = query;
        this.tq = new TokenQueue(query);
    }

    /**
     * Parse a CSS query into an Evaluator.
     * @param query CSS query
     * @return Evaluator
     * @see Selector selector query syntax
     */
    public static Evaluator parse(String query) {
        try {
            QueryParser p = new QueryParser(query);
            return p.parse();
        } catch (IllegalArgumentException e) {
            throw new Selector.SelectorParseException(e.getMessage());
        }
    }

    /**
     * Parse the query
     * @return Evaluator
     */
    Evaluator parse() {
        tq.consumeWhitespace();

        if (tq.matchesAny(combinators)) { // if starts with a combinator, use root as elements
            evals.add(new StructuralEvaluator.Root());
            combinator(tq.consume());
        } else {
            findElements();
        }

        while (!tq.isEmpty()) {
            // hierarchy and extras
            boolean seenWhite = tq.consumeWhitespace();

            if (tq.matchesAny(combinators)) {
                combinator(tq.consume());
            } else if (seenWhite) {
                combinator(' ');
            } else { // E.class, E#id, E[attr] etc. AND
                findElements(); // take next el, #. etc off queue
            }
        }

        if (evals.size() == 1)
            return evals.get(0);

        return new CombiningEvaluator.And(evals);
    }

    private void combinator(char combinator) {
        tq.consumeWhitespace();
        String subQuery = consumeSubQuery(); // support multi > childs

        Evaluator rootEval; // the new topmost evaluator
        Evaluator currentEval; // the evaluator the new eval will be combined to. could be root, or rightmost or.
        Evaluator newEval = parse(subQuery); // the evaluator to add into target evaluator
        boolean replaceRightMost = false;

        if (evals.size() == 1) {
            rootEval = currentEval = evals.get(0);
            // make sure OR (,) has precedence:
            if (rootEval instanceof CombiningEvaluator.Or && combinator != ',') {
                currentEval = ((CombiningEvaluator.Or) currentEval).rightMostEvaluator();
                assert currentEval != null; // rightMost signature can return null (if none set), but always will have one by this point
                replaceRightMost = true;
            }
        }
        else {
            rootEval = currentEval = new CombiningEvaluator.And(evals);
        }
        evals.clear();

        // for most combinators: change the current eval into an AND of the current eval and the new eval
        switch (combinator) {
            case '>':
                currentEval = new CombiningEvaluator.And(new StructuralEvaluator.ImmediateParent(currentEval), newEval);
                break;
            case ' ':
                currentEval = new CombiningEvaluator.And(new StructuralEvaluator.Parent(currentEval), newEval);
                break;
            case '+':
                currentEval = new CombiningEvaluator.And(new StructuralEvaluator.ImmediatePreviousSibling(currentEval), newEval);
                break;
            case '~':
                currentEval = new CombiningEvaluator.And(new StructuralEvaluator.PreviousSibling(currentEval), newEval);
                break;
            case ',':
                CombiningEvaluator.Or or;
                if (currentEval instanceof CombiningEvaluator.Or) {
                    or = (CombiningEvaluator.Or) currentEval;
                } else {
                    or = new CombiningEvaluator.Or();
                    or.add(currentEval);
                }
                or.add(newEval);
                currentEval = or;
                break;
            default:
                throw new Selector.SelectorParseException(""Unknown combinator '%s'"", combinator);
        }

        if (replaceRightMost)
            ((CombiningEvaluator.Or) rootEval).replaceRightMostEvaluator(currentEval);
        else rootEval = currentEval;
        evals.add(rootEval);
    }

    private String consumeSubQuery() {
        StringBuilder sq = StringUtil.borrowBuilder();
        while (!tq.isEmpty()) {
            if (tq.matches(""(""))
                sq.append(""("").append(tq.chompBalanced('(', ')')).append("")"");
            else if (tq.matches(""[""))
                sq.append(""["").append(tq.chompBalanced('[', ']')).append(""]"");
            else if (tq.matchesAny(combinators))
                if (sq.length() > 0)
                    break;
                else
                    tq.consume();
            else
                sq.append(tq.consume());
        }
        return StringUtil.releaseBuilder(sq);
    }

    private void findElements() {
        if (tq.matchChomp(""#""))
            byId();
        else if (tq.matchChomp("".""))
            byClass();
        else if (tq.matchesWord() || tq.matches(""*|""))
            byTag();
        else if (tq.matches(""[""))
            byAttribute();
        else if (tq.matchChomp(""*""))
            allElements();
        else if (tq.matchChomp("":lt(""))
            indexLessThan();
        else if (tq.matchChomp("":gt(""))
            indexGreaterThan();
        else if (tq.matchChomp("":eq(""))
            indexEquals();
        else if (tq.matches("":has(""))
            has();
        else if (tq.matches("":contains(""))
            contains(false);
        else if (tq.matches("":containsOwn(""))
            contains(true);
        else if (tq.matches("":containsWholeText(""))
            containsWholeText(false);
        else if (tq.matches("":containsWholeOwnText(""))
            containsWholeText(true);
        else if (tq.matches("":containsData(""))
            containsData();
        else if (tq.matches("":matches(""))
            matches(false);
        else if (tq.matches("":matchesOwn(""))
            matches(true);
        else if (tq.matches("":matchesWholeText(""))
            matchesWholeText(false);
        else if (tq.matches("":matchesWholeOwnText(""))
            matchesWholeText(true);
        else if (tq.matches("":not(""))
            not();
		else if (tq.matchChomp("":nth-child(""))
        	cssNthChild(false, false);
        else if (tq.matchChomp("":nth-last-child(""))
        	cssNthChild(true, false);
        else if (tq.matchChomp("":nth-of-type(""))
        	cssNthChild(false, true);
        else if (tq.matchChomp("":nth-last-of-type(""))
        	cssNthChild(true, true);
        else if (tq.matchChomp("":first-child""))
        	evals.add(new Evaluator.IsFirstChild());
        else if (tq.matchChomp("":last-child""))
        	evals.add(new Evaluator.IsLastChild());
        else if (tq.matchChomp("":first-of-type""))
        	evals.add(new Evaluator.IsFirstOfType());
        else if (tq.matchChomp("":last-of-type""))
        	evals.add(new Evaluator.IsLastOfType());
        else if (tq.matchChomp("":only-child""))
        	evals.add(new Evaluator.IsOnlyChild());
        else if (tq.matchChomp("":only-of-type""))
        	evals.add(new Evaluator.IsOnlyOfType());
        else if (tq.matchChomp("":empty""))
        	evals.add(new Evaluator.IsEmpty());
        else if (tq.matchChomp("":root""))
        	evals.add(new Evaluator.IsRoot());
        else if (tq.matchChomp("":matchText""))
            evals.add(new Evaluator.MatchText());
		else // unhandled
            throw new Selector.SelectorParseException(""Could not parse query '%s': unexpected token at '%s'"", query, tq.remainder());

    }

    private void byId() {
        String id = tq.consumeCssIdentifier();
        Validate.notEmpty(id);
        evals.add(new Evaluator.Id(id));
    }

    private void byClass() {
        String className = tq.consumeCssIdentifier();
        Validate.notEmpty(className);
        evals.add(new Evaluator.Class(className.trim()));
    }

    private void byTag() {
        // todo - these aren't dealing perfectly with case sensitivity. For case sensitive parsers, we should also make
        // the tag in the selector case-sensitive (and also attribute names). But for now, normalize (lower-case) for
        // consistency - both the selector and the element tag
        String tagName = normalize(tq.consumeElementSelector());
        Validate.notEmpty(tagName);

        // namespaces: wildcard match equals(tagName) or ending in "":""+tagName
        if (tagName.startsWith(""*|"")) {
            String plainTag = tagName.substring(2); // strip *|
            evals.add(new CombiningEvaluator.Or(
                new Evaluator.Tag(plainTag),
                new Evaluator.TagEndsWith(tagName.replace(""*|"", "":"")))
            );
        } else {
            // namespaces: if element name is ""abc:def"", selector must be ""abc|def"", so flip:
            if (tagName.contains(""|""))
                tagName = tagName.replace(""|"", "":"");

            evals.add(new Evaluator.Tag(tagName));
        }
    }

    private void byAttribute() {
        TokenQueue cq = new TokenQueue(tq.chompBalanced('[', ']')); // content queue
        String key = cq.consumeToAny(AttributeEvals); // eq, not, start, end, contain, match, (no val)
        Validate.notEmpty(key);
        cq.consumeWhitespace();

        if (cq.isEmpty()) {
            if (key.startsWith(""^""))
                evals.add(new Evaluator.AttributeStarting(key.substring(1)));
            else
                evals.add(new Evaluator.Attribute(key));
        } else {
            if (cq.matchChomp(""=""))
                evals.add(new Evaluator.AttributeWithValue(key, cq.remainder()));

            else if (cq.matchChomp(""!=""))
                evals.add(new Evaluator.AttributeWithValueNot(key, cq.remainder()));

            else if (cq.matchChomp(""^=""))
                evals.add(new Evaluator.AttributeWithValueStarting(key, cq.remainder()));

            else if (cq.matchChomp(""$=""))
                evals.add(new Evaluator.AttributeWithValueEnding(key, cq.remainder()));

            else if (cq.matchChomp(""*=""))
                evals.add(new Evaluator.AttributeWithValueContaining(key, cq.remainder()));

            else if (cq.matchChomp(""~=""))
                evals.add(new Evaluator.AttributeWithValueMatching(key, Pattern.compile(cq.remainder())));
            else
                throw new Selector.SelectorParseException(""Could not parse attribute query '%s': unexpected token at '%s'"", query, cq.remainder());
        }
    }

    private void allElements() {
        evals.add(new Evaluator.AllElements());
    }

    // pseudo selectors :lt, :gt, :eq
    private void indexLessThan() {
        evals.add(new Evaluator.IndexLessThan(consumeIndex()));
    }

    private void indexGreaterThan() {
        evals.add(new Evaluator.IndexGreaterThan(consumeIndex()));
    }

    private void indexEquals() {
        evals.add(new Evaluator.IndexEquals(consumeIndex()));
    }
    
    //pseudo selectors :first-child, :last-child, :nth-child, ...
    private static final Pattern NTH_AB = Pattern.compile(""(([+-])?(\\d+)?)n(\\s*([+-])?\\s*\\d+)?"", Pattern.CASE_INSENSITIVE);
    private static final Pattern NTH_B  = Pattern.compile(""([+-])?(\\d+)"");

	private void cssNthChild(boolean backwards, boolean ofType) {
		String argS = normalize(tq.chompTo("")""));
		Matcher mAB = NTH_AB.matcher(argS);
		Matcher mB = NTH_B.matcher(argS);
		final int a, b;
		if (""odd"".equals(argS)) {
			a = 2;
			b = 1;
		} else if (""even"".equals(argS)) {
			a = 2;
			b = 0;
		} else if (mAB.matches()) {
			a = mAB.group(3) != null ? Integer.parseInt(mAB.group(1).replaceFirst(""^\\+"", """")) : 1;
			b = mAB.group(4) != null ? Integer.parseInt(mAB.group(4).replaceFirst(""^\\+"", """")) : 0;
		} else if (mB.matches()) {
			a = 0;
			b = Integer.parseInt(mB.group().replaceFirst(""^\\+"", """"));
		} else {
			throw new Selector.SelectorParseException(""Could not parse nth-index '%s': unexpected format"", argS);
		}
		if (ofType)
			if (backwards)
				evals.add(new Evaluator.IsNthLastOfType(a, b));
			else
				evals.add(new Evaluator.IsNthOfType(a, b));
		else {
			if (backwards)
				evals.add(new Evaluator.IsNthLastChild(a, b));
			else
				evals.add(new Evaluator.IsNthChild(a, b));
		}
	}

    private int consumeIndex() {
        String indexS = tq.chompTo("")"").trim();
        Validate.isTrue(StringUtil.isNumeric(indexS), ""Index must be numeric"");
        return Integer.parseInt(indexS);
    }

    // pseudo selector :has(el)
    private void has() {
        tq.consume("":has"");
        String subQuery = tq.chompBalanced('(', ')');
        Validate.notEmpty(subQuery, "":has(selector) sub-select must not be empty"");
        evals.add(new StructuralEvaluator.Has(parse(subQuery)));
    }

    // pseudo selector :contains(text), containsOwn(text)
    private void contains(boolean own) {
        String query = own ? "":containsOwn"" : "":contains"";
        tq.consume(query);
        String searchText = TokenQueue.unescape(tq.chompBalanced('(', ')'));
        Validate.notEmpty(searchText, query + ""(text) query must not be empty"");
        evals.add(own
            ? new Evaluator.ContainsOwnText(searchText)
            : new Evaluator.ContainsText(searchText));
    }

    private void containsWholeText(boolean own) {
        String query = own ? "":containsWholeOwnText"" : "":containsWholeText"";
        tq.consume(query);
        String searchText = TokenQueue.unescape(tq.chompBalanced('(', ')'));
        Validate.notEmpty(searchText, query + ""(text) query must not be empty"");
        evals.add(own
            ? new Evaluator.ContainsWholeOwnText(searchText)
            : new Evaluator.ContainsWholeText(searchText));
    }

    // pseudo selector :containsData(data)
    private void containsData() {
        tq.consume("":containsData"");
        String searchText = TokenQueue.unescape(tq.chompBalanced('(', ')'));
        Validate.notEmpty(searchText, "":containsData(text) query must not be empty"");
        evals.add(new Evaluator.ContainsData(searchText));
    }

    // :matches(regex), matchesOwn(regex)
    private void matches(boolean own) {
        String query = own ? "":matchesOwn"" : "":matches"";
        tq.consume(query);
        String regex = tq.chompBalanced('(', ')'); // don't unescape, as regex bits will be escaped
        Validate.notEmpty(regex, query + ""(regex) query must not be empty"");

        evals.add(own
            ? new Evaluator.MatchesOwn(Pattern.compile(regex))
            : new Evaluator.Matches(Pattern.compile(regex)));
    }

    // :matches(regex), matchesOwn(regex)
    private void matchesWholeText(boolean own) {
        String query = own ? "":matchesWholeOwnText"" : "":matchesWholeText"";
        tq.consume(query);
        String regex = tq.chompBalanced('(', ')'); // don't unescape, as regex bits will be escaped
        Validate.notEmpty(regex, query + ""(regex) query must not be empty"");

        evals.add(own
            ? new Evaluator.MatchesWholeOwnText(Pattern.compile(regex))
            : new Evaluator.MatchesWholeText(Pattern.compile(regex)));
    }

    // :not(selector)
    private void not() {
        tq.consume("":not"");
        String subQuery = tq.chompBalanced('(', ')');
        Validate.notEmpty(subQuery, "":not(selector) subselect must not be empty"");

        evals.add(new StructuralEvaluator.Not(parse(subQuery)));
    }

    @Override
    public String toString() {
        return query;
    }


}
"
jhy/jsoup,src/test/java/org/jsoup/nodes/AttributesTest.java,"package org.jsoup.nodes;

import org.jsoup.Jsoup;
import org.junit.jupiter.api.Test;

import java.util.Iterator;
import java.util.List;
import java.util.Map;

import static org.junit.jupiter.api.Assertions.*;

/**
 * Tests for Attributes.
 *
 * @author Jonathan Hedley
 */
public class AttributesTest {

    @Test
    public void html() {
        Attributes a = new Attributes();
        a.put(""Tot"", ""a&p"");
        a.put(""Hello"", ""There"");
        a.put(""data-name"", ""Jsoup"");

        assertEquals(3, a.size());
        assertTrue(a.hasKey(""Tot""));
        assertTrue(a.hasKey(""Hello""));
        assertTrue(a.hasKey(""data-name""));
        assertFalse(a.hasKey(""tot""));
        assertTrue(a.hasKeyIgnoreCase(""tot""));
        assertEquals(""There"", a.getIgnoreCase(""hEllo""));

        Map<String, String> dataset = a.dataset();
        assertEquals(1, dataset.size());
        assertEquals(""Jsoup"", dataset.get(""name""));
        assertEquals("""", a.get(""tot""));
        assertEquals(""a&p"", a.get(""Tot""));
        assertEquals(""a&p"", a.getIgnoreCase(""tot""));

        assertEquals("" Tot=\""a&amp;p\"" Hello=\""There\"" data-name=\""Jsoup\"""", a.html());
        assertEquals(a.html(), a.toString());
    }

    @Test
    public void testIteratorRemovable() {
        Attributes a = new Attributes();
        a.put(""Tot"", ""a&p"");
        a.put(""Hello"", ""There"");
        a.put(""data-name"", ""Jsoup"");
        assertTrue(a.hasKey(""Tot""));

        Iterator<Attribute> iterator = a.iterator();
        Attribute attr = iterator.next();
        assertEquals(""Tot"", attr.getKey());
        iterator.remove();
        assertEquals(2, a.size());
        attr = iterator.next();
        assertEquals(""Hello"", attr.getKey());
        assertEquals(""There"", attr.getValue());

        // make sure that's flowing to the underlying attributes object
        assertEquals(2, a.size());
        assertEquals(""There"", a.get(""Hello""));
        assertFalse(a.hasKey(""Tot""));
    }

    @Test
    public void testIteratorUpdateable() {
        Attributes a = new Attributes();
        a.put(""Tot"", ""a&p"");
        a.put(""Hello"", ""There"");

        assertFalse(a.hasKey(""Foo""));
        Iterator<Attribute> iterator = a.iterator();
        Attribute attr = iterator.next();
        attr.setKey(""Foo"");
        attr = iterator.next();
        attr.setKey(""Bar"");
        attr.setValue(""Qux"");

        assertEquals(""a&p"", a.get(""Foo""));
        assertEquals(""Qux"", a.get(""Bar""));
        assertFalse(a.hasKey(""Tot""));
        assertFalse(a.hasKey(""Hello""));
    }

    @Test public void testIteratorHasNext() {
        Attributes a = new Attributes();
        a.put(""Tot"", ""1"");
        a.put(""Hello"", ""2"");
        a.put(""data-name"", ""3"");

        int seen = 0;
        for (Attribute attribute : a) {
            seen++;
            assertEquals(String.valueOf(seen), attribute.getValue());
        }
        assertEquals(3, seen);
    }

    @Test
    public void testIterator() {
        Attributes a = new Attributes();
        String[][] datas = {{""Tot"", ""raul""},
            {""Hello"", ""pismuth""},
            {""data-name"", ""Jsoup""}};
        for (String[] atts : datas) {
            a.put(atts[0], atts[1]);
        }

        Iterator<Attribute> iterator = a.iterator();
        assertTrue(iterator.hasNext());
        int i = 0;
        for (Attribute attribute : a) {
            assertEquals(datas[i][0], attribute.getKey());
            assertEquals(datas[i][1], attribute.getValue());
            i++;
        }
        assertEquals(datas.length, i);
    }

    @Test
    public void testIteratorSkipsInternal() {
        Attributes a = new Attributes();
        a.put(""One"", ""One"");
        a.put(Attributes.internalKey(""baseUri""), ""example.com"");
        a.put(""Two"", ""Two"");
        a.put(Attributes.internalKey(""another""), ""example.com"");

        Iterator<Attribute> it = a.iterator();
        assertTrue(it.hasNext());
        assertEquals(""One"", it.next().getKey());
        assertTrue(it.hasNext());
        assertEquals(""Two"", it.next().getKey());
        assertFalse(it.hasNext());

        int seen = 0;
        for (Attribute attribute : a) {
            seen++;
        }
        assertEquals(2, seen);
    }

    @Test
    public void testListSkipsInternal() {
        Attributes a = new Attributes();
        a.put(""One"", ""One"");
        a.put(Attributes.internalKey(""baseUri""), ""example.com"");
        a.put(""Two"", ""Two"");
        a.put(Attributes.internalKey(""another""), ""example.com"");

        List<Attribute> attributes = a.asList();
        assertEquals(2, attributes.size());
        assertEquals(""One"", attributes.get(0).getKey());
        assertEquals(""Two"", attributes.get(1). getKey());
    }

    @Test public void htmlSkipsInternals() {
        Attributes a = new Attributes();
        a.put(""One"", ""One"");
        a.put(Attributes.internalKey(""baseUri""), ""example.com"");
        a.put(""Two"", ""Two"");
        a.put(Attributes.internalKey(""another""), ""example.com"");

        assertEquals("" One=\""One\"" Two=\""Two\"""", a.html());
    }

    @Test
    public void testIteratorEmpty() {
        Attributes a = new Attributes();

        Iterator<Attribute> iterator = a.iterator();
        assertFalse(iterator.hasNext());
    }

    @Test
    public void removeCaseSensitive() {
        Attributes a = new Attributes();
        a.put(""Tot"", ""a&p"");
        a.put(""tot"", ""one"");
        a.put(""Hello"", ""There"");
        a.put(""hello"", ""There"");
        a.put(""data-name"", ""Jsoup"");

        assertEquals(5, a.size());
        a.remove(""Tot"");
        a.remove(""Hello"");
        assertEquals(3, a.size());
        assertTrue(a.hasKey(""tot""));
        assertFalse(a.hasKey(""Tot""));
    }

    @Test
    public void testSetKeyConsistency() {
        Attributes a = new Attributes();
        a.put(""a"", ""a"");
        for(Attribute at : a) {
            at.setKey(""b"");
        }
        assertFalse(a.hasKey(""a""), ""Attribute 'a' not correctly removed"");
        assertTrue(a.hasKey(""b""), ""Attribute 'b' not present after renaming"");
    }

    @Test
    public void testBoolean() {
        Attributes ats = new Attributes();
        ats.put(""a"", ""a"");
        ats.put(""B"", ""b"");
        ats.put(""c"", null);

        assertTrue(ats.hasDeclaredValueForKey(""a""));
        assertFalse(ats.hasDeclaredValueForKey(""A""));
        assertTrue(ats.hasDeclaredValueForKeyIgnoreCase(""A""));

        assertFalse(ats.hasDeclaredValueForKey(""c""));
        assertFalse(ats.hasDeclaredValueForKey(""C""));
        assertFalse(ats.hasDeclaredValueForKeyIgnoreCase(""C""));
    }

    @Test public void testSizeWhenHasInternal() {
        Attributes a = new Attributes();
        a.put(""One"", ""One"");
        a.put(""Two"", ""Two"");
        assertEquals(2, a.size());

        a.put(Attributes.internalKey(""baseUri""), ""example.com"");
        a.put(Attributes.internalKey(""another""), ""example.com"");
        a.put(Attributes.internalKey(""last""), ""example.com"");
        a.remove(Attributes.internalKey(""last""));

        assertEquals(4, a.size());
        assertEquals(2, a.asList().size()); // excluded from lists
    }

    @Test public void testBooleans() {
        // want unknown=null, and known like async=null, async="""", and async=async to collapse
        String html = ""<a foo bar=\""\"" async=async qux=qux defer=deferring ismap inert=\""\"">"";
        Element el = Jsoup.parse(html).selectFirst(""a"");
        assertEquals("" foo bar=\""\"" async qux=\""qux\"" defer=\""deferring\"" ismap inert"", el.attributes().html());

    }

    @Test public void booleanNullAttributesConsistent() {
        Attributes attributes = new Attributes();
        attributes.put(""key"", null);
        Attribute attribute = attributes.iterator().next();

        assertEquals(""key"", attribute.html());
        assertEquals("" key"", attributes.html());
    }

    @Test public void booleanEmptyString() {
        Attributes attributes = new Attributes();
        attributes.put(""checked"", """");
        Attribute attribute = attributes.iterator().next();

        assertEquals(""checked"", attribute.html());
        assertEquals("" checked"", attributes.html());
    }

    @Test public void booleanCaseInsensitive() {
        Attributes attributes = new Attributes();
        attributes.put(""checked"", ""CHECKED"");
        Attribute attribute = attributes.iterator().next();

        assertEquals(""checked"", attribute.html());
        assertEquals("" checked"", attributes.html());
    }

    @Test public void equalsIsOrderInsensitive() {
        Attributes one = new Attributes()
            .add(""Key1"", ""Val1"")
            .add(""Key2"", ""Val2"")
            .add(""Key3"", null);

        Attributes two = new Attributes()
            .add(""Key1"", ""Val1"")
            .add(""Key2"", ""Val2"")
            .add(""Key3"", null);

        Attributes three = new Attributes()
            .add(""Key2"", ""Val2"")
            .add(""Key3"", null)
            .add(""Key1"", ""Val1"");

        Attributes four = new Attributes()
            .add(""Key1"", ""Val1"")
            .add(""Key2"", ""Val2"")
            .add(""Key3"", null)
            .add(""Key4"", ""Val4"");

        assertEquals(one, one.clone());
        assertEquals(one, two);
        assertEquals(two, two);
        assertEquals(one, three);
        assertEquals(two, three);
        assertEquals(three, three);
        assertEquals(three, three.clone());
        assertEquals(four, four);
        assertEquals(four, four.clone());
        assertNotEquals(one, four);
    }

    @Test void cloneAttributes() {
        Attributes one = new Attributes()
            .add(""Key1"", ""Val1"")
            .add(""Key2"", ""Val2"")
            .add(""Key3"", null);
        Attributes two = one.clone();
        assertEquals(3, two.size());
        assertEquals(""Val2"", two.get(""Key2""));
        assertEquals(one, two);

        two.add(""Key4"", ""Val4"");
        assertEquals(4, two.size());
        assertEquals(3, one.size());
        assertNotEquals(one, two);

    }
}
"
jhy/jsoup,src/test/java/org/jsoup/select/CssTest.java,"package org.jsoup.select;

import org.jsoup.Jsoup;
import org.jsoup.nodes.Document;
import org.jsoup.parser.Tag;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;

import static org.junit.jupiter.api.Assertions.*;


public class CssTest {

	private Document html = null;
	private static String htmlString;

	@BeforeAll
	public static void initClass() {
		StringBuilder sb = new StringBuilder(""<html><head></head><body>"");

		sb.append(""<div id='pseudo'>"");
		for (int i = 1; i <= 10; i++) {
			sb.append(String.format(""<p>%d</p>"",i));
		}
		sb.append(""</div>"");

		sb.append(""<div id='type'>"");
		for (int i = 1; i <= 10; i++) {
			sb.append(String.format(""<p>%d</p>"",i));
			sb.append(String.format(""<span>%d</span>"",i));
			sb.append(String.format(""<em>%d</em>"",i));
            sb.append(String.format(""<svg>%d</svg>"",i));
		}
		sb.append(""</div>"");

		sb.append(""<span id='onlySpan'><br /></span>"");
		sb.append(""<p class='empty'><!-- Comment only is still empty! --></p>"");

		sb.append(""<div id='only'>"");
		sb.append(""Some text before the <em>only</em> child in this div"");
		sb.append(""</div>"");

		sb.append(""</body></html>"");
		htmlString = sb.toString();
	}

	@BeforeEach
	public void init() {
		html  = Jsoup.parse(htmlString);
	}

	@Test
	public void firstChild() {
		check(html.select(""#pseudo :first-child""), ""1"");
		check(html.select(""html:first-child""));
	}

	@Test
	public void lastChild() {
		check(html.select(""#pseudo :last-child""), ""10"");
		check(html.select(""html:last-child""));
	}

	@Test
	public void nthChild_simple() {
		for(int i = 1; i <=10; i++) {
			check(html.select(String.format(""#pseudo :nth-child(%d)"", i)), String.valueOf(i));
		}
	}

    @Test
    public void nthOfType_unknownTag() {
        for(int i = 1; i <=10; i++) {
            check(html.select(String.format(""#type svg:nth-of-type(%d)"", i)), String.valueOf(i));
        }
    }

	@Test
	public void nthLastChild_simple() {
		for(int i = 1; i <=10; i++) {
			check(html.select(String.format(""#pseudo :nth-last-child(%d)"", i)), String.valueOf(11-i));
		}
	}

	@Test
	public void nthOfType_simple() {
		for(int i = 1; i <=10; i++) {
			check(html.select(String.format(""#type p:nth-of-type(%d)"", i)), String.valueOf(i));
		}
	}

	@Test
	public void nthLastOfType_simple() {
		for(int i = 1; i <=10; i++) {
			check(html.select(String.format(""#type :nth-last-of-type(%d)"", i)), String.valueOf(11-i),String.valueOf(11-i),String.valueOf(11-i),String.valueOf(11-i));
		}
	}

	@Test
	public void nthChild_advanced() {
		check(html.select(""#pseudo :nth-child(-5)""));
		check(html.select(""#pseudo :nth-child(odd)""), ""1"", ""3"", ""5"", ""7"", ""9"");
		check(html.select(""#pseudo :nth-child(2n-1)""), ""1"", ""3"", ""5"", ""7"", ""9"");
		check(html.select(""#pseudo :nth-child(2n+1)""), ""1"", ""3"", ""5"", ""7"", ""9"");
		check(html.select(""#pseudo :nth-child(2n+3)""), ""3"", ""5"", ""7"", ""9"");
		check(html.select(""#pseudo :nth-child(even)""), ""2"", ""4"", ""6"", ""8"", ""10"");
		check(html.select(""#pseudo :nth-child(2n)""), ""2"", ""4"", ""6"", ""8"", ""10"");
		check(html.select(""#pseudo :nth-child(3n-1)""), ""2"", ""5"", ""8"");
		check(html.select(""#pseudo :nth-child(-2n+5)""), ""1"", ""3"", ""5"");
		check(html.select(""#pseudo :nth-child(+5)""), ""5"");
	}

	@Test
	public void nthOfType_advanced() {
		check(html.select(""#type :nth-of-type(-5)""));
		check(html.select(""#type p:nth-of-type(odd)""), ""1"", ""3"", ""5"", ""7"", ""9"");
		check(html.select(""#type em:nth-of-type(2n-1)""), ""1"", ""3"", ""5"", ""7"", ""9"");
		check(html.select(""#type p:nth-of-type(2n+1)""), ""1"", ""3"", ""5"", ""7"", ""9"");
		check(html.select(""#type span:nth-of-type(2n+3)""), ""3"", ""5"", ""7"", ""9"");
		check(html.select(""#type p:nth-of-type(even)""), ""2"", ""4"", ""6"", ""8"", ""10"");
		check(html.select(""#type p:nth-of-type(2n)""), ""2"", ""4"", ""6"", ""8"", ""10"");
		check(html.select(""#type p:nth-of-type(3n-1)""), ""2"", ""5"", ""8"");
		check(html.select(""#type p:nth-of-type(-2n+5)""), ""1"", ""3"", ""5"");
		check(html.select(""#type :nth-of-type(+5)""), ""5"", ""5"", ""5"", ""5"");
	}


	@Test
	public void nthLastChild_advanced() {
		check(html.select(""#pseudo :nth-last-child(-5)""));
		check(html.select(""#pseudo :nth-last-child(odd)""), ""2"", ""4"", ""6"", ""8"", ""10"");
		check(html.select(""#pseudo :nth-last-child(2n-1)""), ""2"", ""4"", ""6"", ""8"", ""10"");
		check(html.select(""#pseudo :nth-last-child(2n+1)""), ""2"", ""4"", ""6"", ""8"", ""10"");
		check(html.select(""#pseudo :nth-last-child(2n+3)""), ""2"", ""4"", ""6"", ""8"");
		check(html.select(""#pseudo :nth-last-child(even)""), ""1"", ""3"", ""5"", ""7"", ""9"");
		check(html.select(""#pseudo :nth-last-child(2n)""), ""1"", ""3"", ""5"", ""7"", ""9"");
		check(html.select(""#pseudo :nth-last-child(3n-1)""), ""3"", ""6"", ""9"");

		check(html.select(""#pseudo :nth-last-child(-2n+5)""), ""6"", ""8"", ""10"");
		check(html.select(""#pseudo :nth-last-child(+5)""), ""6"");
	}

	@Test
	public void nthLastOfType_advanced() {
		check(html.select(""#type :nth-last-of-type(-5)""));
		check(html.select(""#type p:nth-last-of-type(odd)""), ""2"", ""4"", ""6"", ""8"", ""10"");
		check(html.select(""#type em:nth-last-of-type(2n-1)""), ""2"", ""4"", ""6"", ""8"", ""10"");
		check(html.select(""#type p:nth-last-of-type(2n+1)""), ""2"", ""4"", ""6"", ""8"", ""10"");
		check(html.select(""#type span:nth-last-of-type(2n+3)""), ""2"", ""4"", ""6"", ""8"");
		check(html.select(""#type p:nth-last-of-type(even)""), ""1"", ""3"", ""5"", ""7"", ""9"");
		check(html.select(""#type p:nth-last-of-type(2n)""), ""1"", ""3"", ""5"", ""7"", ""9"");
		check(html.select(""#type p:nth-last-of-type(3n-1)""), ""3"", ""6"", ""9"");

		check(html.select(""#type span:nth-last-of-type(-2n+5)""), ""6"", ""8"", ""10"");
		check(html.select(""#type :nth-last-of-type(+5)""), ""6"", ""6"", ""6"", ""6"");
	}

	@Test
	public void firstOfType() {
		check(html.select(""div:not(#only) :first-of-type""), ""1"", ""1"", ""1"", ""1"", ""1"");
	}

	@Test
	public void lastOfType() {
		check(html.select(""div:not(#only) :last-of-type""), ""10"", ""10"", ""10"", ""10"", ""10"");
	}

	@Test
	public void empty() {
		final Elements sel = html.select("":empty"");
		assertEquals(3, sel.size());
		assertEquals(""head"", sel.get(0).tagName());
		assertEquals(""br"", sel.get(1).tagName());
		assertEquals(""p"", sel.get(2).tagName());
	}

	@Test
	public void onlyChild() {
		final Elements sel = html.select(""span :only-child"");
		assertEquals(1, sel.size());
		assertEquals(""br"", sel.get(0).tagName());

		check(html.select(""#only :only-child""), ""only"");
	}

	@Test
	public void onlyOfType() {
		final Elements sel = html.select("":only-of-type"");
		assertEquals(6, sel.size());
		assertEquals(""head"", sel.get(0).tagName());
		assertEquals(""body"", sel.get(1).tagName());
		assertEquals(""span"", sel.get(2).tagName());
		assertEquals(""br"", sel.get(3).tagName());
		assertEquals(""p"", sel.get(4).tagName());
		assertTrue(sel.get(4).hasClass(""empty""));
		assertEquals(""em"", sel.get(5).tagName());
	}

	protected void check(Elements result, String...expectedContent ) {
		assertEquals(expectedContent.length, result.size(), ""Number of elements"");
		for (int i = 0; i < expectedContent.length; i++) {
			assertNotNull(result.get(i));
			assertEquals(expectedContent[i], result.get(i).ownText(), ""Expected element"");
		}
	}

	@Test
	public void root() {
		Elements sel = html.select("":root"");
		assertEquals(1, sel.size());
		assertNotNull(sel.get(0));
		assertEquals(Tag.valueOf(""html""), sel.get(0).tag());

		Elements sel2 = html.select(""body"").select("":root"");
		assertEquals(1, sel2.size());
		assertNotNull(sel2.get(0));
		assertEquals(Tag.valueOf(""body""), sel2.get(0).tag());
	}

}
"
jhy/jsoup,src/main/java/org/jsoup/internal/ReturnsAreNonnullByDefault.java,"package org.jsoup.internal;

import javax.annotation.Nonnull;
import javax.annotation.meta.TypeQualifierDefault;
import java.lang.annotation.Documented;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;

@Documented
@Nonnull
@TypeQualifierDefault(ElementType.METHOD)
@Retention(value = RetentionPolicy.RUNTIME)

/**
 Indicates return types are not nullable, unless otherwise specified by @Nullable.
 @see javax.annotation.ParametersAreNonnullByDefault
 */
public @interface ReturnsAreNonnullByDefault {
}
"
jhy/jsoup,src/main/java/org/jsoup/SerializationException.java,"package org.jsoup;

/**
 * A SerializationException is raised whenever serialization of a DOM element fails. This exception usually wraps an
 * {@link java.io.IOException} that may be thrown due to an inaccessible output stream.
 */
public final class SerializationException extends RuntimeException {
	/**
	 * Creates and initializes a new serialization exception with no error message and cause.
	 */
	public SerializationException() {
		super();
	}

	/**
	 * Creates and initializes a new serialization exception with the given error message and no cause.
	 * 
	 * @param message
	 *            the error message of the new serialization exception (may be <code>null</code>).
	 */
	public SerializationException(String message) {
		super(message);
	}

	/**
	 * Creates and initializes a new serialization exception with the specified cause and an error message of
     * <code>(cause==null ? null : cause.toString())</code> (which typically contains the class and error message of
     * <code>cause</code>).
	 * 
	 * @param cause
	 *            the cause of the new serialization exception (may be <code>null</code>).
	 */
	public SerializationException(Throwable cause) {
		super(cause);
	}

	/**
	 * Creates and initializes a new serialization exception with the given error message and cause.
	 * 
	 * @param message
	 *            the error message of the new serialization exception.
	 * @param cause
	 *            the cause of the new serialization exception.
	 */
	public SerializationException(String message, Throwable cause) {
		super(message, cause);
	}
}
"
jhy/jsoup,src/test/java/org/jsoup/parser/ParserSettingsTest.java,"package org.jsoup.parser;

import org.jsoup.MultiLocaleExtension.MultiLocaleTest;
import org.jsoup.nodes.Attributes;

import java.util.Locale;

import static org.junit.jupiter.api.Assertions.assertEquals;

public class ParserSettingsTest {
    @MultiLocaleTest
    public void caseSupport(Locale locale) {
        Locale.setDefault(locale);

        ParseSettings bothOn = new ParseSettings(true, true);
        ParseSettings bothOff = new ParseSettings(false, false);
        ParseSettings tagOn = new ParseSettings(true, false);
        ParseSettings attrOn = new ParseSettings(false, true);

        assertEquals(""IMG"", bothOn.normalizeTag(""IMG""));
        assertEquals(""ID"", bothOn.normalizeAttribute(""ID""));

        assertEquals(""img"", bothOff.normalizeTag(""IMG""));
        assertEquals(""id"", bothOff.normalizeAttribute(""ID""));

        assertEquals(""IMG"", tagOn.normalizeTag(""IMG""));
        assertEquals(""id"", tagOn.normalizeAttribute(""ID""));

        assertEquals(""img"", attrOn.normalizeTag(""IMG""));
        assertEquals(""ID"", attrOn.normalizeAttribute(""ID""));
    }

    @MultiLocaleTest
    public void attributeCaseNormalization(Locale locale) {
        Locale.setDefault(locale);

        ParseSettings parseSettings = new ParseSettings(false, false);
        String normalizedAttribute = parseSettings.normalizeAttribute(""HIDDEN"");

        assertEquals(""hidden"", normalizedAttribute);
    }

    @MultiLocaleTest
    public void attributesCaseNormalization(Locale locale) {
        Locale.setDefault(locale);

        ParseSettings parseSettings = new ParseSettings(false, false);
        Attributes attributes = new Attributes();
        attributes.put(""ITEM"", ""1"");

        Attributes normalizedAttributes = parseSettings.normalizeAttributes(attributes);

        assertEquals(""item"", normalizedAttributes.asList().get(0).getKey());
    }
}
"
jhy/jsoup,src/test/java/org/jsoup/nodes/BuildEntities.java,"package org.jsoup.nodes;

import com.google.gson.Gson;
import com.google.gson.reflect.TypeToken;
import org.jsoup.Connection;
import org.jsoup.Jsoup;
import org.jsoup.integration.UrlConnectTest;

import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.nio.file.Files;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.Map;

/**
 * Fetches HTML entity names from w3.org json, and outputs data files for optimized used in Entities.
 * I refuse to believe that entity names like ""NotNestedLessLess"" are valuable or useful for HTML authors. Implemented
 * only to be complete.
 */
class BuildEntities {
    public static void main(String[] args) throws IOException {
        String url = ""https://www.w3.org/TR/2012/WD-html5-20121025/entities.json"";
        Connection.Response res = Jsoup.connect(url)
            .ignoreContentType(true)
            .userAgent(UrlConnectTest.browserUa)
            .execute();

        Gson gson = new Gson();
        Map<String, CharacterRef> input = gson.fromJson(res.body(),
            new TypeToken<Map<String, CharacterRef>>() {
            }.getType());


        // build name sorted base and full character lists:
        ArrayList<CharacterRef> base = new ArrayList<>();
        ArrayList<CharacterRef> full = new ArrayList<>();

        for (Map.Entry<String, CharacterRef> entry : input.entrySet()) {
            String name = entry.getKey().substring(1); // name is like &acute or &acute; , trim &
            CharacterRef ref = entry.getValue();
            if (name.endsWith("";"")) {
                name = name.substring(0, name.length() - 1);
                full.add(ref);
            } else {
                base.add(ref);
            }
            ref.name = name;
        }
        base.sort(byName);
        full.sort(byName);

        // now determine code point order
        ArrayList<CharacterRef> baseByCode = new ArrayList<>(base);
        ArrayList<CharacterRef> fullByCode = new ArrayList<>(full);
        baseByCode.sort(byCode);
        fullByCode.sort(byCode);

        // and update their codepoint index.
        @SuppressWarnings(""unchecked"") ArrayList<CharacterRef>[] codelists = new ArrayList[]{baseByCode, fullByCode};
        for (ArrayList<CharacterRef> codelist : codelists) {
            for (int i = 0; i < codelist.size(); i++) {
                codelist.get(i).codeIndex = i;
            }
        }

        // now write them
        persist(""entities-full"", full);
        persist(""entities-base"", base);

        System.out.println(""Full size: "" + full.size() + "", base size: "" + base.size());
    }

    private static void persist(String name, ArrayList<CharacterRef> refs) throws IOException {
        File file = Files.createTempFile(name, "".txt"").toFile();
        FileWriter writer = new FileWriter(file, false);
        writer.append(""static final String points = \"""");
        for (CharacterRef ref : refs) {
            writer.append(ref.toString()).append('&');
        }
        writer.append(""\"";\n"");
        writer.close();

        System.out.println(""Wrote "" + name + "" to "" + file.getAbsolutePath());
    }


    private static class CharacterRef {
        int[] codepoints;
        String name;
        int codeIndex;

        @Override
        public String toString() {
            return name
                + ""=""
                + d(codepoints[0])
                + (codepoints.length > 1 ? "","" + d(codepoints[1]) : """")
                + "";"" + d(codeIndex);
        }
    }

    private static String d(int d) {
        return Integer.toString(d, Entities.codepointRadix);
    }

    private static class ByName implements Comparator<CharacterRef> {
        public int compare(CharacterRef o1, CharacterRef o2) {
            return o1.name.compareTo(o2.name);
        }
    }

    private static class ByCode implements Comparator<CharacterRef> {
        public int compare(CharacterRef o1, CharacterRef o2) {
            int[] c1 = o1.codepoints;
            int[] c2 = o2.codepoints;
            int first = c1[0] - c2[0];
            if (first != 0)
                return first;
            if (c1.length == 1 && c2.length == 1) { // for the same code, use the shorter name
                int len = o2.name.length() - o1.name.length();
                if (len != 0)
                    return len;
                return o1.name.compareTo(o2.name);
            }
            if (c1.length == 2 && c2.length == 2)
                return c1[1] - c2[1];
            else
                return c2.length - c1.length; // pushes multi down the list so hits on singles first (don't support multi lookup by codepoint yet)
        }
    }

    private static ByName byName = new ByName();
    private static ByCode byCode = new ByCode();
}
"
jhy/jsoup,src/main/java/org/jsoup/parser/package-info.java,"/**
 Contains the HTML parser, tag specifications, and HTML tokeniser.
 */
@NonnullByDefault
package org.jsoup.parser;

import org.jsoup.internal.NonnullByDefault;
"
jhy/jsoup,src/main/java/org/jsoup/parser/Token.java,"package org.jsoup.parser;

import org.jsoup.helper.Validate;
import org.jsoup.nodes.Attributes;

import javax.annotation.Nullable;

/**
 * Parse tokens for the Tokeniser.
 */
abstract class Token {
    TokenType type;
    static final int Unset = -1;
    private int startPos, endPos = Unset; // position in CharacterReader this token was read from

    private Token() {
    }
    
    String tokenType() {
        return this.getClass().getSimpleName();
    }

    /**
     * Reset the data represent by this token, for reuse. Prevents the need to create transfer objects for every
     * piece of data, which immediately get GCed.
     */
    Token reset() {
        startPos = Unset;
        endPos = Unset;
        return this;
    }

    int startPos() {
        return startPos;
    }

    void startPos(int pos) {
        startPos = pos;
    }

    int endPos() {
        return endPos;
    }

    void endPos(int pos) {
        endPos = pos;
    }

    static void reset(StringBuilder sb) {
        if (sb != null) {
            sb.delete(0, sb.length());
        }
    }

    static final class Doctype extends Token {
        final StringBuilder name = new StringBuilder();
        String pubSysKey = null;
        final StringBuilder publicIdentifier = new StringBuilder();
        final StringBuilder systemIdentifier = new StringBuilder();
        boolean forceQuirks = false;

        Doctype() {
            type = TokenType.Doctype;
        }

        @Override
        Token reset() {
            super.reset();
            reset(name);
            pubSysKey = null;
            reset(publicIdentifier);
            reset(systemIdentifier);
            forceQuirks = false;
            return this;
        }

        String getName() {
            return name.toString();
        }

        String getPubSysKey() {
            return pubSysKey;
        }

        String getPublicIdentifier() {
            return publicIdentifier.toString();
        }

        public String getSystemIdentifier() {
            return systemIdentifier.toString();
        }

        public boolean isForceQuirks() {
            return forceQuirks;
        }

        @Override
        public String toString() {
            return ""<!doctype "" + getName() + "">"";
        }
    }

    static abstract class Tag extends Token {
        @Nullable protected String tagName;
        @Nullable protected String normalName; // lc version of tag name, for case insensitive tree build

        private final StringBuilder attrName = new StringBuilder(); // try to get attr names and vals in one shot, vs Builder
        @Nullable private String attrNameS;
        private boolean hasAttrName = false;

        private final StringBuilder attrValue = new StringBuilder();
        @Nullable private String attrValueS;
        private boolean hasAttrValue = false;
        private boolean hasEmptyAttrValue = false; // distinguish boolean attribute from empty string value

        boolean selfClosing = false;
        @Nullable Attributes attributes; // start tags get attributes on construction. End tags get attributes on first new attribute (but only for parser convenience, not used).

        @Override
        Tag reset() {
            super.reset();
            tagName = null;
            normalName = null;
            reset(attrName);
            attrNameS = null;
            hasAttrName = false;
            reset(attrValue);
            attrValueS = null;
            hasEmptyAttrValue = false;
            hasAttrValue = false;
            selfClosing = false;
            attributes = null;
            return this;
        }

        /* Limits runaway crafted HTML from spewing attributes and getting a little sluggish in ensureCapacity.
        Real-world HTML will P99 around 8 attributes, so plenty of headroom. Implemented here and not in the Attributes
        object so that API users can add more if ever required. */
        private static final int MaxAttributes = 512;

        final void newAttribute() {
            if (attributes == null)
                attributes = new Attributes();

            if (hasAttrName && attributes.size() < MaxAttributes) {
                // the tokeniser has skipped whitespace control chars, but trimming could collapse to empty for other control codes, so verify here
                String name = attrName.length() > 0 ? attrName.toString() : attrNameS;
                name = name.trim();
                if (name.length() > 0) {
                    String value;
                    if (hasAttrValue)
                        value = attrValue.length() > 0 ? attrValue.toString() : attrValueS;
                    else if (hasEmptyAttrValue)
                        value = """";
                    else
                        value = null;
                    // note that we add, not put. So that the first is kept, and rest are deduped, once in a context where case sensitivity is known (the appropriate tree builder).
                    attributes.add(name, value);
                }
            }
            reset(attrName);
            attrNameS = null;
            hasAttrName = false;

            reset(attrValue);
            attrValueS = null;
            hasAttrValue = false;
            hasEmptyAttrValue = false;
        }

        final boolean hasAttributes() {
            return attributes != null;
        }

        final boolean hasAttribute(String key) {
            return attributes != null && attributes.hasKey(key);
        }

        final void finaliseTag() {
            // finalises for emit
            if (hasAttrName) {
                newAttribute();
            }
        }

        /** Preserves case */
        final String name() { // preserves case, for input into Tag.valueOf (which may drop case)
            Validate.isFalse(tagName == null || tagName.length() == 0);
            return tagName;
        }

        /** Lower case */
        final String normalName() { // lower case, used in tree building for working out where in tree it should go
            return normalName;
        }

        final String toStringName() {
            return tagName != null ? tagName : ""[unset]"";
        }

        final Tag name(String name) {
            tagName = name;
            normalName = ParseSettings.normalName(tagName);
            return this;
        }

        final boolean isSelfClosing() {
            return selfClosing;
        }

        // these appenders are rarely hit in not null state-- caused by null chars.
        final void appendTagName(String append) {
            // might have null chars - need to replace with null replacement character
            append = append.replace(TokeniserState.nullChar, Tokeniser.replacementChar);
            tagName = tagName == null ? append : tagName.concat(append);
            normalName = ParseSettings.normalName(tagName);
        }

        final void appendTagName(char append) {
            appendTagName(String.valueOf(append));
        }

        final void appendAttributeName(String append) {
            // might have null chars because we eat in one pass - need to replace with null replacement character
            append = append.replace(TokeniserState.nullChar, Tokeniser.replacementChar);

            ensureAttrName();
            if (attrName.length() == 0) {
                attrNameS = append;
            } else {
                attrName.append(append);
            }
        }

        final void appendAttributeName(char append) {
            ensureAttrName();
            attrName.append(append);
        }

        final void appendAttributeValue(String append) {
            ensureAttrValue();
            if (attrValue.length() == 0) {
                attrValueS = append;
            } else {
                attrValue.append(append);
            }
        }

        final void appendAttributeValue(char append) {
            ensureAttrValue();
            attrValue.append(append);
        }

        final void appendAttributeValue(char[] append) {
            ensureAttrValue();
            attrValue.append(append);
        }

        final void appendAttributeValue(int[] appendCodepoints) {
            ensureAttrValue();
            for (int codepoint : appendCodepoints) {
                attrValue.appendCodePoint(codepoint);
            }
        }
        
        final void setEmptyAttributeValue() {
            hasEmptyAttrValue = true;
        }

        private void ensureAttrName() {
            hasAttrName = true;
            // if on second hit, we'll need to move to the builder
            if (attrNameS != null) {
                attrName.append(attrNameS);
                attrNameS = null;
            }
        }

        private void ensureAttrValue() {
            hasAttrValue = true;
            // if on second hit, we'll need to move to the builder
            if (attrValueS != null) {
                attrValue.append(attrValueS);
                attrValueS = null;
            }
        }

        @Override
        abstract public String toString();
    }

    final static class StartTag extends Tag {
        StartTag() {
            super();
            type = TokenType.StartTag;
        }

        @Override
        Tag reset() {
            super.reset();
            attributes = null;
            return this;
        }

        StartTag nameAttr(String name, Attributes attributes) {
            this.tagName = name;
            this.attributes = attributes;
            normalName = ParseSettings.normalName(tagName);
            return this;
        }

        @Override
        public String toString() {
            if (hasAttributes() && attributes.size() > 0)
                return ""<"" + toStringName() + "" "" + attributes.toString() + "">"";
            else
                return ""<"" + toStringName() + "">"";
        }
    }

    final static class EndTag extends Tag{
        EndTag() {
            super();
            type = TokenType.EndTag;
        }

        @Override
        public String toString() {
            return ""</"" + toStringName() + "">"";
        }
    }

    final static class Comment extends Token {
        private final StringBuilder data = new StringBuilder();
        private String dataS; // try to get in one shot
        boolean bogus = false;

        @Override
        Token reset() {
            super.reset();
            reset(data);
            dataS = null;
            bogus = false;
            return this;
        }

        Comment() {
            type = TokenType.Comment;
        }

        String getData() {
            return dataS != null ? dataS : data.toString();
        }

        final Comment append(String append) {
            ensureData();
            if (data.length() == 0) {
                dataS = append;
            } else {
                data.append(append);
            }
            return this;
        }

        final Comment append(char append) {
            ensureData();
            data.append(append);
            return this;
        }

        private void ensureData() {
            // if on second hit, we'll need to move to the builder
            if (dataS != null) {
                data.append(dataS);
                dataS = null;
            }
        }

        @Override
        public String toString() {
            return ""<!--"" + getData() + ""-->"";
        }
    }

    static class Character extends Token {
        private String data;

        Character() {
            super();
            type = TokenType.Character;
        }

        @Override
        Token reset() {
            super.reset();
            data = null;
            return this;
        }

        Character data(String data) {
            this.data = data;
            return this;
        }

        String getData() {
            return data;
        }

        @Override
        public String toString() {
            return getData();
        }
    }

    final static class CData extends Character {
        CData(String data) {
            super();
            this.data(data);
        }

        @Override
        public String toString() {
            return ""<![CDATA["" + getData() + ""]]>"";
        }

    }

    final static class EOF extends Token {
        EOF() {
            type = Token.TokenType.EOF;
        }

        @Override
        Token reset() {
            super.reset();
            return this;
        }

        @Override
        public String toString() {
            return """";
        }
    }

    final boolean isDoctype() {
        return type == TokenType.Doctype;
    }

    final Doctype asDoctype() {
        return (Doctype) this;
    }

    final boolean isStartTag() {
        return type == TokenType.StartTag;
    }

    final StartTag asStartTag() {
        return (StartTag) this;
    }

    final boolean isEndTag() {
        return type == TokenType.EndTag;
    }

    final EndTag asEndTag() {
        return (EndTag) this;
    }

    final boolean isComment() {
        return type == TokenType.Comment;
    }

    final Comment asComment() {
        return (Comment) this;
    }

    final boolean isCharacter() {
        return type == TokenType.Character;
    }

    final boolean isCData() {
        return this instanceof CData;
    }

    final Character asCharacter() {
        return (Character) this;
    }

    final boolean isEOF() {
        return type == TokenType.EOF;
    }

    public enum TokenType {
        Doctype,
        StartTag,
        EndTag,
        Comment,
        Character, // note no CData - treated in builder as an extension of Character
        EOF
    }
}
"
jhy/jsoup,src/main/java/org/jsoup/examples/HtmlToPlainText.java,"package org.jsoup.examples;

import org.jsoup.Jsoup;
import org.jsoup.internal.StringUtil;
import org.jsoup.helper.Validate;
import org.jsoup.nodes.Document;
import org.jsoup.nodes.Element;
import org.jsoup.nodes.Node;
import org.jsoup.nodes.TextNode;
import org.jsoup.select.Elements;
import org.jsoup.select.NodeTraversor;
import org.jsoup.select.NodeVisitor;

import java.io.IOException;

/**
 * HTML to plain-text. This example program demonstrates the use of jsoup to convert HTML input to lightly-formatted
 * plain-text. That is divergent from the general goal of jsoup's .text() methods, which is to get clean data from a
 * scrape.
 * <p>
 * Note that this is a fairly simplistic formatter -- for real world use you'll want to embrace and extend.
 * </p>
 * <p>
 * To invoke from the command line, assuming you've downloaded the jsoup jar to your current directory:</p>
 * <p><code>java -cp jsoup.jar org.jsoup.examples.HtmlToPlainText url [selector]</code></p>
 * where <i>url</i> is the URL to fetch, and <i>selector</i> is an optional CSS selector.
 * 
 * @author Jonathan Hedley, jonathan@hedley.net
 */
public class HtmlToPlainText {
    private static final String userAgent = ""Mozilla/5.0 (jsoup)"";
    private static final int timeout = 5 * 1000;

    public static void main(String... args) throws IOException {
        Validate.isTrue(args.length == 1 || args.length == 2, ""usage: java -cp jsoup.jar org.jsoup.examples.HtmlToPlainText url [selector]"");
        final String url = args[0];
        final String selector = args.length == 2 ? args[1] : null;

        // fetch the specified URL and parse to a HTML DOM
        Document doc = Jsoup.connect(url).userAgent(userAgent).timeout(timeout).get();

        HtmlToPlainText formatter = new HtmlToPlainText();

        if (selector != null) {
            Elements elements = doc.select(selector); // get each element that matches the CSS selector
            for (Element element : elements) {
                String plainText = formatter.getPlainText(element); // format that element to plain text
                System.out.println(plainText);
            }
        } else { // format the whole doc
            String plainText = formatter.getPlainText(doc);
            System.out.println(plainText);
        }
    }

    /**
     * Format an Element to plain-text
     * @param element the root element to format
     * @return formatted text
     */
    public String getPlainText(Element element) {
        FormattingVisitor formatter = new FormattingVisitor();
        NodeTraversor.traverse(formatter, element); // walk the DOM, and call .head() and .tail() for each node

        return formatter.toString();
    }

    // the formatting rules, implemented in a breadth-first DOM traverse
    private static class FormattingVisitor implements NodeVisitor {
        private static final int maxWidth = 80;
        private int width = 0;
        private StringBuilder accum = new StringBuilder(); // holds the accumulated text

        // hit when the node is first seen
        public void head(Node node, int depth) {
            String name = node.nodeName();
            if (node instanceof TextNode)
                append(((TextNode) node).text()); // TextNodes carry all user-readable text in the DOM.
            else if (name.equals(""li""))
                append(""\n * "");
            else if (name.equals(""dt""))
                append(""  "");
            else if (StringUtil.in(name, ""p"", ""h1"", ""h2"", ""h3"", ""h4"", ""h5"", ""tr""))
                append(""\n"");
        }

        // hit when all of the node's children (if any) have been visited
        public void tail(Node node, int depth) {
            String name = node.nodeName();
            if (StringUtil.in(name, ""br"", ""dd"", ""dt"", ""p"", ""h1"", ""h2"", ""h3"", ""h4"", ""h5""))
                append(""\n"");
            else if (name.equals(""a""))
                append(String.format("" <%s>"", node.absUrl(""href"")));
        }

        // appends text to the string builder with a simple word wrap method
        private void append(String text) {
            if (text.startsWith(""\n""))
                width = 0; // reset counter if starts with a newline. only from formats above, not in natural text
            if (text.equals("" "") &&
                    (accum.length() == 0 || StringUtil.in(accum.substring(accum.length() - 1), "" "", ""\n"")))
                return; // don't accumulate long runs of empty spaces

            if (text.length() + width > maxWidth) { // won't fit, needs to wrap
                String[] words = text.split(""\\s+"");
                for (int i = 0; i < words.length; i++) {
                    String word = words[i];
                    boolean last = i == words.length - 1;
                    if (!last) // insert a space if not the last word
                        word = word + "" "";
                    if (word.length() + width > maxWidth) { // wrap and reset counter
                        accum.append(""\n"").append(word);
                        width = word.length();
                    } else {
                        accum.append(word);
                        width += word.length();
                    }
                }
            } else { // fits as is, without need to wrap text
                accum.append(text);
                width += text.length();
            }
        }

        @Override
        public String toString() {
            return accum.toString();
        }
    }
}
"
jhy/jsoup,src/test/java/org/jsoup/parser/AttributeParseTest.java,"package org.jsoup.parser;

import org.jsoup.Jsoup;
import org.jsoup.nodes.Attribute;
import org.jsoup.nodes.Attributes;
import org.jsoup.nodes.Document;
import org.jsoup.nodes.Element;
import org.jsoup.select.Elements;
import org.junit.jupiter.api.Test;

import java.util.List;

import static org.junit.jupiter.api.Assertions.*;

/**
 Test suite for attribute parser.

 @author Jonathan Hedley, jonathan@hedley.net */
public class AttributeParseTest {

    @Test public void parsesRoughAttributeString() {
        String html = ""<a id=\""123\"" class=\""baz = 'bar'\"" style = 'border: 2px'qux zim foo = 12 mux=18 />"";
        // should be: <id=123>, <class=baz = 'bar'>, <qux=>, <zim=>, <foo=12>, <mux.=18>

        Element el = Jsoup.parse(html).getElementsByTag(""a"").get(0);
        Attributes attr = el.attributes();
        assertEquals(7, attr.size());
        assertEquals(""123"", attr.get(""id""));
        assertEquals(""baz = 'bar'"", attr.get(""class""));
        assertEquals(""border: 2px"", attr.get(""style""));
        assertEquals("""", attr.get(""qux""));
        assertEquals("""", attr.get(""zim""));
        assertEquals(""12"", attr.get(""foo""));
        assertEquals(""18"", attr.get(""mux""));
    }

    @Test public void handlesNewLinesAndReturns() {
        String html = ""<a\r\nfoo='bar\r\nqux'\r\nbar\r\n=\r\ntwo>One</a>"";
        Element el = Jsoup.parse(html).select(""a"").first();
        assertEquals(2, el.attributes().size());
        assertEquals(""bar\r\nqux"", el.attr(""foo"")); // currently preserves newlines in quoted attributes. todo confirm if should.
        assertEquals(""two"", el.attr(""bar""));
    }

    @Test public void parsesEmptyString() {
        String html = ""<a />"";
        Element el = Jsoup.parse(html).getElementsByTag(""a"").get(0);
        Attributes attr = el.attributes();
        assertEquals(0, attr.size());
    }

    @Test public void canStartWithEq() {
        String html = ""<a =empty />"";
        // TODO this is the weirdest thing in the spec - why not consider this an attribute with an empty name, not where name is '='?
        // am I reading it wrong? https://html.spec.whatwg.org/multipage/parsing.html#before-attribute-name-state
        Element el = Jsoup.parse(html).getElementsByTag(""a"").get(0);
        Attributes attr = el.attributes();
        assertEquals(1, attr.size());
        assertTrue(attr.hasKey(""=empty""));
        assertEquals("""", attr.get(""=empty""));
    }

    @Test public void strictAttributeUnescapes() {
        String html = ""<a id=1 href='?foo=bar&mid&lt=true'>One</a> <a id=2 href='?foo=bar&lt;qux&lg=1'>Two</a>"";
        Elements els = Jsoup.parse(html).select(""a"");
        assertEquals(""?foo=bar&mid&lt=true"", els.first().attr(""href""));
        assertEquals(""?foo=bar<qux&lg=1"", els.last().attr(""href""));
    }

    @Test public void moreAttributeUnescapes() {
        String html = ""<a href='&wr_id=123&mid-size=true&ok=&wr'>Check</a>"";
        Elements els = Jsoup.parse(html).select(""a"");
        assertEquals(""&wr_id=123&mid-size=true&ok=&wr"", els.first().attr(""href""));
    }

    @Test public void parsesBooleanAttributes() {
        String html = ""<a normal=\""123\"" boolean empty=\""\""></a>"";
        Element el = Jsoup.parse(html).select(""a"").first();

        assertEquals(""123"", el.attr(""normal""));
        assertEquals("""", el.attr(""boolean""));
        assertEquals("""", el.attr(""empty""));

        List<Attribute> attributes = el.attributes().asList();
        assertEquals(3, attributes.size(), ""There should be 3 attribute present"");

        assertEquals(html, el.outerHtml()); // vets boolean syntax
    }

    @Test public void dropsSlashFromAttributeName() {
        String html = ""<img /onerror='doMyJob'/>"";
        Document doc = Jsoup.parse(html);
        assertFalse(doc.select(""img[onerror]"").isEmpty(), ""SelfClosingStartTag ignores last character"");
        assertEquals(""<img onerror=\""doMyJob\"">"", doc.body().html());

        doc = Jsoup.parse(html, """", Parser.xmlParser());
        assertEquals(""<img onerror=\""doMyJob\"" />"", doc.html());
    }
}
"
jhy/jsoup,src/test/java/org/jsoup/integration/servlets/SlowRider.java,"package org.jsoup.integration.servlets;

import org.jsoup.integration.TestServer;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.io.PrintWriter;

/**
 * Slowly, interminably writes output. For the purposes of testing timeouts and interrupts.
 */
public class SlowRider extends BaseServlet {
    public static final String Url = TestServer.map(SlowRider.class);
    private static final int SleepTime = 2000;
    public static final String MaxTimeParam = ""maxTime"";

    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse res) throws IOException {
        pause(1000);
        res.setContentType(TextHtml);
        res.setStatus(HttpServletResponse.SC_OK);
        PrintWriter w = res.getWriter();

        int maxTime = -1;
        String maxTimeP = req.getParameter(MaxTimeParam);
        if (maxTimeP != null) {
            maxTime = Integer.parseInt(maxTimeP);
        }

        long startTime = System.currentTimeMillis();
        w.println(""<title>Slow Rider</title>"");
        while (true) {
            w.println(""<p>Are you still there?"");
            boolean err = w.checkError(); // flush, and check still ok
            if (err) {
                log(""Remote connection lost"");
                break;
            }
            if (pause(SleepTime)) break;

            if (maxTime > 0 && System.currentTimeMillis() > startTime + maxTime) {
                w.println(""<h1>outatime</h1>"");
                break;
            }
        }
    }

    private static boolean pause(int sleepTime) {
        try {
            Thread.sleep(sleepTime);
        } catch (InterruptedException e) {
            return true;
        }
        return false;
    }

    // allow the servlet to run as a main program, for local test
    public static void main(String[] args) {
        TestServer.start();
        System.out.println(Url);
    }
}
"
jhy/jsoup,src/test/java/org/jsoup/parser/TagTest.java,"package org.jsoup.parser;

import org.jsoup.MultiLocaleExtension.MultiLocaleTest;
import org.junit.jupiter.api.Test;

import java.util.Locale;

import static org.junit.jupiter.api.Assertions.*;

/**
 Tag tests.
 @author Jonathan Hedley, jonathan@hedley.net */
public class TagTest {
    @Test public void isCaseSensitive() {
        Tag p1 = Tag.valueOf(""P"");
        Tag p2 = Tag.valueOf(""p"");
        assertNotEquals(p1, p2);
    }

    @MultiLocaleTest
    public void canBeInsensitive(Locale locale) {
        Locale.setDefault(locale);

        Tag script1 = Tag.valueOf(""script"", ParseSettings.htmlDefault);
        Tag script2 = Tag.valueOf(""SCRIPT"", ParseSettings.htmlDefault);
        assertSame(script1, script2);
    }

    @Test public void trims() {
        Tag p1 = Tag.valueOf(""p"");
        Tag p2 = Tag.valueOf("" p "");
        assertEquals(p1, p2);
    }

    @Test public void equality() {
        Tag p1 = Tag.valueOf(""p"");
        Tag p2 = Tag.valueOf(""p"");
        assertEquals(p1, p2);
        assertSame(p1, p2);
    }

    @Test public void divSemantics() {
        Tag div = Tag.valueOf(""div"");

        assertTrue(div.isBlock());
        assertTrue(div.formatAsBlock());
    }

    @Test public void pSemantics() {
        Tag p = Tag.valueOf(""p"");

        assertTrue(p.isBlock());
        assertFalse(p.formatAsBlock());
    }

    @Test public void imgSemantics() {
        Tag img = Tag.valueOf(""img"");
        assertTrue(img.isInline());
        assertTrue(img.isSelfClosing());
        assertFalse(img.isBlock());
    }

    @Test public void defaultSemantics() {
        Tag foo = Tag.valueOf(""FOO""); // not defined
        Tag foo2 = Tag.valueOf(""FOO"");

        assertEquals(foo, foo2);
        assertTrue(foo.isInline());
        assertTrue(foo.formatAsBlock());
    }

    @Test public void valueOfChecksNotNull() {
        assertThrows(IllegalArgumentException.class, () -> Tag.valueOf(null));
    }

    @Test public void valueOfChecksNotEmpty() {
        assertThrows(IllegalArgumentException.class, () -> Tag.valueOf("" ""));
    }

    @Test public void knownTags() {
        assertTrue(Tag.isKnownTag(""div""));
        assertFalse(Tag.isKnownTag(""explain""));
    }
}
"
jhy/jsoup,src/test/java/org/jsoup/integration/servlets/EchoServlet.java,"package org.jsoup.integration.servlets;

import org.eclipse.jetty.server.Request;
import org.jsoup.helper.DataUtil;
import org.jsoup.internal.StringUtil;
import org.jsoup.integration.TestServer;

import javax.servlet.MultipartConfigElement;
import javax.servlet.ServletException;
import javax.servlet.http.Cookie;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.Part;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.ByteBuffer;
import java.nio.charset.StandardCharsets;
import java.util.Collection;
import java.util.Enumeration;

import static org.jsoup.nodes.Entities.escape;

public class EchoServlet extends BaseServlet {
    public static final String CodeParam = ""code"";
    public static final String Url = TestServer.map(EchoServlet.class);
    private static final int DefaultCode = HttpServletResponse.SC_OK;

    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse res) throws ServletException, IOException {
        doIt(req, res);
    }

    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse res) throws ServletException, IOException {
        doIt(req, res);
    }

    @Override
    protected void doPut(HttpServletRequest req, HttpServletResponse res) throws ServletException, IOException {
        doIt(req, res);
    }

    private void doIt(HttpServletRequest req, HttpServletResponse res) throws IOException, ServletException {
        int intCode = DefaultCode;
        String code = req.getHeader(CodeParam);
        if (code != null)
            intCode = Integer.parseInt(code);

        boolean isMulti = maybeEnableMultipart(req);

        res.setContentType(TextHtml);
        res.setStatus(intCode);
        // no-cache headers for test
        res.addHeader(""Cache-Control"", ""no-cache"");
        res.addHeader(""Cache-Control"", ""no-store"");

        PrintWriter w = res.getWriter();

        w.write(""<title>Webserver Environment Variables</title>\n"" +
            ""    <style type=\""text/css\"">\n"" +
            ""      body, td, th {font: 10pt Verdana, Arial, sans-serif; text-align: left}\n"" +
            ""      th {font-weight: bold}        \n"" +
            ""    </style>\n"" +
            ""    <body>\n"" +
            ""    <table border=\""0\"">"");

        // some get items
        write(w, ""Method"", req.getMethod());
        write(w, ""Request URI"", req.getRequestURI());
        write(w, ""Query String"", req.getQueryString());

        // request headers (why is it an enumeration?)
        Enumeration<String> headerNames = req.getHeaderNames();
        while (headerNames.hasMoreElements()) {
            String header = headerNames.nextElement();
            Enumeration<String> headers = req.getHeaders(header);
            while (headers.hasMoreElements()) {
                write(w, header, headers.nextElement());
            }
        }

        // cookies
        final Cookie[] cookies = req.getCookies();
        if (cookies != null) {
            for (Cookie cookie : cookies) {
                EchoServlet.write(w, ""Cookie: "" + cookie.getName(), cookie.getValue());
            }
        }

        // the request params
        Enumeration<String> parameterNames = req.getParameterNames();
        while (parameterNames.hasMoreElements()) {
            String name = parameterNames.nextElement();
            String[] values = req.getParameterValues(name);
            write(w, name, StringUtil.join(values, "", ""));
        }

        // post body
        ByteBuffer byteBuffer = DataUtil.readToByteBuffer(req.getInputStream(), 0);
        String postData = new String(byteBuffer.array(), StandardCharsets.UTF_8);
        if (!StringUtil.isBlank(postData)) {
            write(w, ""Post Data"", postData);
        }

        // file uploads
        if (isMulti) {
            Collection<Part> parts = req.getParts();
            write(w, ""Parts"", String.valueOf(parts.size()));

            for (Part part : parts) {
                String name = part.getName();
                write(w, ""Part "" + name + "" ContentType"", part.getContentType());
                write(w, ""Part "" + name + "" Name"", name);
                write(w, ""Part "" + name + "" Filename"", part.getSubmittedFileName());
                write(w, ""Part "" + name + "" Size"", String.valueOf(part.getSize()));
                part.delete();
            }
        }

        w.println(""</table>"");
    }

    static void write(PrintWriter w, String key, String val) {
        w.println(""<tr><th>"" + escape(key) + ""</th><td>"" + escape(val) + ""</td></tr>"");
    }

    // allow the servlet to run as a main program, for local test
    public static void main(String[] args) {
        TestServer.start();
        System.out.println(Url);
    }

    private static boolean maybeEnableMultipart(HttpServletRequest req) {
        boolean isMulti = req.getContentType() != null
            && req.getContentType().startsWith(""multipart/form-data"");

        if (isMulti) {
            req.setAttribute(Request.MULTIPART_CONFIG_ELEMENT, new MultipartConfigElement(
                System.getProperty(""java.io.tmpdir"")));
        }
        return isMulti;
    }
}
"
jhy/jsoup,src/main/java/org/jsoup/nodes/Range.java,"package org.jsoup.nodes;

import org.jsoup.helper.Validate;

/**
 A Range object tracks the character positions in the original input source where a Node starts or ends. If you want to
 track these positions, tracking must be enabled in the Parser with
 {@link org.jsoup.parser.Parser#setTrackPosition(boolean)}.
 @see Node#sourceRange()
 @since 1.15.2
 */
public class Range {
    private final Position start, end;

    private static final String RangeKey = Attributes.internalKey(""jsoup.sourceRange"");
    private static final String EndRangeKey = Attributes.internalKey(""jsoup.endSourceRange"");
    private static final Position UntrackedPos = new Position(-1, -1, -1);
    private static final Range Untracked = new Range(UntrackedPos, UntrackedPos);

    /**
     Creates a new Range with start and end Positions. Called by TreeBuilder when position tracking is on.
     * @param start the start position
     * @param end the end position
     */
    public Range(Position start, Position end) {
        this.start = start;
        this.end = end;
    }

    /**
     Get the start position of this node.
     * @return the start position
     */
    public Position start() {
        return start;
    }

    /**
     Get the end position of this node.
     * @return the end position
     */
    public Position end() {
        return end;
    }

    /**
     Test if this source range was tracked during parsing.
     * @return true if this was tracked during parsing, false otherwise (and all fields will be {@code -1}).
     */
    public boolean isTracked() {
        return this != Untracked;
    }

    /**
     Retrieves the source range for a given Node.
     * @param node the node to retrieve the position for
     * @param start if this is the starting range. {@code false} for Element end tags.
     * @return the Range, or the Untracked (-1) position if tracking is disabled.
     */
    static Range of(Node node, boolean start) {
        final String key = start ? RangeKey : EndRangeKey;
        if (!node.hasAttr(key))
            return Untracked;
        else
            return (Range) Validate.ensureNotNull(node.attributes().getUserData(key));
    }

    /**
     Internal jsoup method, called by the TreeBuilder. Tracks a Range for a Node.
     * @param node the node to associate this position to
     * @param start if this is the starting range. {@code false} for Element end tags.
     */
    public void track(Node node, boolean start) {
        node.attributes().putUserData(start ? RangeKey : EndRangeKey, this);
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;

        Range range = (Range) o;

        if (!start.equals(range.start)) return false;
        return end.equals(range.end);
    }

    @Override
    public int hashCode() {
        int result = start.hashCode();
        result = 31 * result + end.hashCode();
        return result;
    }

    /**
     Gets a String presentation of this Range, in the format {@code line,column:pos-line,column:pos}.
     * @return a String
     */
    @Override
    public String toString() {
        return start + ""-"" + end;
    }

    /**
     A Position object tracks the character position in the original input source where a Node starts or ends. If you want to
     track these positions, tracking must be enabled in the Parser with
     {@link org.jsoup.parser.Parser#setTrackPosition(boolean)}.
     @see Node#sourceRange()
     */
    public static class Position {
        private final int pos, lineNumber, columnNumber;

        /**
         Create a new Position object. Called by the TreeBuilder if source position tracking is on.
         * @param pos position index
         * @param lineNumber line number
         * @param columnNumber column number
         */
        public Position(int pos, int lineNumber, int columnNumber) {
            this.pos = pos;
            this.lineNumber = lineNumber;
            this.columnNumber = columnNumber;
        }

        /**
         Gets the position index (0-based) of the original input source that this Position was read at. This tracks the
         total number of characters read into the source at this position, regardless of the number of preceeding lines.
         * @return the position, or {@code -1} if untracked.
         */
        public int pos() {
            return pos;
        }

        /**
         Gets the line number (1-based) of the original input source that this Position was read at.
         * @return the line number, or {@code -1} if untracked.
         */
        public int lineNumber() {
            return lineNumber;
        }

        /**
         Gets the cursor number (1-based) of the original input source that this Position was read at. The cursor number
         resets to 1 on every new line.
         * @return the cursor number, or {@code -1} if untracked.
         */
        public int columnNumber() {
            return columnNumber;
        }

        /**
         Test if this position was tracked during parsing.
         * @return true if this was tracked during parsing, false otherwise (and all fields will be {@code -1}).
         */
        public boolean isTracked() {
            return this != UntrackedPos;
        }

        /**
         Gets a String presentation of this Position, in the format {@code line,column:pos}.
         * @return a String
         */
        @Override
        public String toString() {
            return lineNumber + "","" + columnNumber + "":"" + pos;
        }

        @Override
        public boolean equals(Object o) {
            if (this == o) return true;
            if (o == null || getClass() != o.getClass()) return false;
            Position position = (Position) o;
            if (pos != position.pos) return false;
            if (lineNumber != position.lineNumber) return false;
            return columnNumber == position.columnNumber;
        }

        @Override
        public int hashCode() {
            int result = pos;
            result = 31 * result + lineNumber;
            result = 31 * result + columnNumber;
            return result;
        }

    }
}
"
jhy/jsoup,src/main/java/org/jsoup/nodes/package-info.java,"/**
 HTML document structure nodes.
 */
@NonnullByDefault
package org.jsoup.nodes;

import org.jsoup.internal.NonnullByDefault;
"
jhy/jsoup,src/test/java/org/jsoup/select/ElementsTest.java,"package org.jsoup.select;

import org.jsoup.Jsoup;
import org.jsoup.TextUtil;
import org.jsoup.nodes.Comment;
import org.jsoup.nodes.DataNode;
import org.jsoup.nodes.Document;
import org.jsoup.nodes.Element;
import org.jsoup.nodes.FormElement;
import org.jsoup.nodes.Node;
import org.jsoup.nodes.TextNode;
import org.junit.jupiter.api.Test;

import java.util.List;

import static org.junit.jupiter.api.Assertions.*;

/**
 Tests for ElementList.

 @author Jonathan Hedley, jonathan@hedley.net */
public class ElementsTest {
    @Test public void filter() {
        String h = ""<p>Excl</p><div class=headline><p>Hello</p><p>There</p></div><div class=headline><h1>Headline</h1></div>"";
        Document doc = Jsoup.parse(h);
        Elements els = doc.select("".headline"").select(""p"");
        assertEquals(2, els.size());
        assertEquals(""Hello"", els.get(0).text());
        assertEquals(""There"", els.get(1).text());
    }

    @Test public void attributes() {
        String h = ""<p title=foo><p title=bar><p class=foo><p class=bar>"";
        Document doc = Jsoup.parse(h);
        Elements withTitle = doc.select(""p[title]"");
        assertEquals(2, withTitle.size());
        assertTrue(withTitle.hasAttr(""title""));
        assertFalse(withTitle.hasAttr(""class""));
        assertEquals(""foo"", withTitle.attr(""title""));

        withTitle.removeAttr(""title"");
        assertEquals(2, withTitle.size()); // existing Elements are not reevaluated
        assertEquals(0, doc.select(""p[title]"").size());

        Elements ps = doc.select(""p"").attr(""style"", ""classy"");
        assertEquals(4, ps.size());
        assertEquals(""classy"", ps.last().attr(""style""));
        assertEquals(""bar"", ps.last().attr(""class""));
    }

    @Test public void hasAttr() {
        Document doc = Jsoup.parse(""<p title=foo><p title=bar><p class=foo><p class=bar>"");
        Elements ps = doc.select(""p"");
        assertTrue(ps.hasAttr(""class""));
        assertFalse(ps.hasAttr(""style""));
    }

    @Test public void hasAbsAttr() {
        Document doc = Jsoup.parse(""<a id=1 href='/foo'>One</a> <a id=2 href='https://jsoup.org'>Two</a>"");
        Elements one = doc.select(""#1"");
        Elements two = doc.select(""#2"");
        Elements both = doc.select(""a"");
        assertFalse(one.hasAttr(""abs:href""));
        assertTrue(two.hasAttr(""abs:href""));
        assertTrue(both.hasAttr(""abs:href"")); // hits on #2
    }

    @Test public void attr() {
        Document doc = Jsoup.parse(""<p title=foo><p title=bar><p class=foo><p class=bar>"");
        String classVal = doc.select(""p"").attr(""class"");
        assertEquals(""foo"", classVal);
    }

    @Test public void absAttr() {
        Document doc = Jsoup.parse(""<a id=1 href='/foo'>One</a> <a id=2 href='https://jsoup.org'>Two</a>"");
        Elements one = doc.select(""#1"");
        Elements two = doc.select(""#2"");
        Elements both = doc.select(""a"");

        assertEquals("""", one.attr(""abs:href""));
        assertEquals(""https://jsoup.org"", two.attr(""abs:href""));
        assertEquals(""https://jsoup.org"", both.attr(""abs:href""));
    }

    @Test public void classes() {
        Document doc = Jsoup.parse(""<div><p class='mellow yellow'></p><p class='red green'></p>"");

        Elements els = doc.select(""p"");
        assertTrue(els.hasClass(""red""));
        assertFalse(els.hasClass(""blue""));
        els.addClass(""blue"");
        els.removeClass(""yellow"");
        els.toggleClass(""mellow"");

        assertEquals(""blue"", els.get(0).className());
        assertEquals(""red green blue mellow"", els.get(1).className());
    }

    @Test public void hasClassCaseInsensitive() {
        Elements els = Jsoup.parse(""<p Class=One>One <p class=Two>Two <p CLASS=THREE>THREE"").select(""p"");
        Element one = els.get(0);
        Element two = els.get(1);
        Element thr = els.get(2);

        assertTrue(one.hasClass(""One""));
        assertTrue(one.hasClass(""ONE""));

        assertTrue(two.hasClass(""TWO""));
        assertTrue(two.hasClass(""Two""));

        assertTrue(thr.hasClass(""ThreE""));
        assertTrue(thr.hasClass(""three""));
    }

    @Test public void text() {
        String h = ""<div><p>Hello<p>there<p>world</div>"";
        Document doc = Jsoup.parse(h);
        assertEquals(""Hello there world"", doc.select(""div > *"").text());
    }

    @Test public void hasText() {
        Document doc = Jsoup.parse(""<div><p>Hello</p></div><div><p></p></div>"");
        Elements divs = doc.select(""div"");
        assertTrue(divs.hasText());
        assertFalse(doc.select(""div + div"").hasText());
    }

    @Test public void html() {
        Document doc = Jsoup.parse(""<div><p>Hello</p></div><div><p>There</p></div>"");
        Elements divs = doc.select(""div"");
        assertEquals(""<p>Hello</p>\n<p>There</p>"", divs.html());
    }

    @Test public void outerHtml() {
        Document doc = Jsoup.parse(""<div><p>Hello</p></div><div><p>There</p></div>"");
        Elements divs = doc.select(""div"");
        assertEquals(""<div><p>Hello</p></div><div><p>There</p></div>"", TextUtil.stripNewlines(divs.outerHtml()));
    }

    @Test public void setHtml() {
        Document doc = Jsoup.parse(""<p>One</p><p>Two</p><p>Three</p>"");
        Elements ps = doc.select(""p"");

        ps.prepend(""<b>Bold</b>"").append(""<i>Ital</i>"");
        assertEquals(""<p><b>Bold</b>Two<i>Ital</i></p>"", TextUtil.stripNewlines(ps.get(1).outerHtml()));

        ps.html(""<span>Gone</span>"");
        assertEquals(""<p><span>Gone</span></p>"", TextUtil.stripNewlines(ps.get(1).outerHtml()));
    }

    @Test public void val() {
        Document doc = Jsoup.parse(""<input value='one' /><textarea>two</textarea>"");
        Elements els = doc.select(""input, textarea"");
        assertEquals(2, els.size());
        assertEquals(""one"", els.val());
        assertEquals(""two"", els.last().val());

        els.val(""three"");
        assertEquals(""three"", els.first().val());
        assertEquals(""three"", els.last().val());
        assertEquals(""<textarea>three</textarea>"", els.last().outerHtml());
    }

    @Test public void before() {
        Document doc = Jsoup.parse(""<p>This <a>is</a> <a>jsoup</a>.</p>"");
        doc.select(""a"").before(""<span>foo</span>"");
        assertEquals(""<p>This <span>foo</span><a>is</a> <span>foo</span><a>jsoup</a>.</p>"", TextUtil.stripNewlines(doc.body().html()));
    }

    @Test public void after() {
        Document doc = Jsoup.parse(""<p>This <a>is</a> <a>jsoup</a>.</p>"");
        doc.select(""a"").after(""<span>foo</span>"");
        assertEquals(""<p>This <a>is</a><span>foo</span> <a>jsoup</a><span>foo</span>.</p>"", TextUtil.stripNewlines(doc.body().html()));
    }

    @Test public void wrap() {
        String h = ""<p><b>This</b> is <b>jsoup</b></p>"";
        Document doc = Jsoup.parse(h);
        doc.select(""b"").wrap(""<i></i>"");
        assertEquals(""<p><i><b>This</b></i> is <i><b>jsoup</b></i></p>"", doc.body().html());
    }

    @Test public void wrapDiv() {
        String h = ""<p><b>This</b> is <b>jsoup</b>.</p> <p>How do you like it?</p>"";
        Document doc = Jsoup.parse(h);
        doc.select(""p"").wrap(""<div></div>"");
        assertEquals(
            ""<div>\n <p><b>This</b> is <b>jsoup</b>.</p>\n</div>\n<div>\n <p>How do you like it?</p>\n</div>"",
            doc.body().html());
    }

    @Test public void unwrap() {
        String h = ""<div><font>One</font> <font><a href=\""/\"">Two</a></font></div"";
        Document doc = Jsoup.parse(h);
        doc.select(""font"").unwrap();
        assertEquals(""<div>One <a href=\""/\"">Two</a></div>"", TextUtil.stripNewlines(doc.body().html()));
    }

    @Test public void unwrapP() {
        String h = ""<p><a>One</a> Two</p> Three <i>Four</i> <p>Fix <i>Six</i></p>"";
        Document doc = Jsoup.parse(h);
        doc.select(""p"").unwrap();
        assertEquals(""<a>One</a> Two Three <i>Four</i> Fix <i>Six</i>"", TextUtil.stripNewlines(doc.body().html()));
    }

    @Test public void unwrapKeepsSpace() {
        String h = ""<p>One <span>two</span> <span>three</span> four</p>"";
        Document doc = Jsoup.parse(h);
        doc.select(""span"").unwrap();
        assertEquals(""<p>One two three four</p>"", doc.body().html());
    }

    @Test public void empty() {
        Document doc = Jsoup.parse(""<div><p>Hello <b>there</b></p> <p>now!</p></div>"");
        doc.outputSettings().prettyPrint(false);

        doc.select(""p"").empty();
        assertEquals(""<div><p></p> <p></p></div>"", doc.body().html());
    }

    @Test public void remove() {
        Document doc = Jsoup.parse(""<div><p>Hello <b>there</b></p> jsoup <p>now!</p></div>"");
        doc.outputSettings().prettyPrint(false);

        doc.select(""p"").remove();
        assertEquals(""<div> jsoup </div>"", doc.body().html());
    }

    @Test public void eq() {
        String h = ""<p>Hello<p>there<p>world"";
        Document doc = Jsoup.parse(h);
        assertEquals(""there"", doc.select(""p"").eq(1).text());
        assertEquals(""there"", doc.select(""p"").get(1).text());
    }

    @Test public void is() {
        String h = ""<p>Hello<p title=foo>there<p>world"";
        Document doc = Jsoup.parse(h);
        Elements ps = doc.select(""p"");
        assertTrue(ps.is(""[title=foo]""));
        assertFalse(ps.is(""[title=bar]""));
    }

    @Test public void parents() {
        Document doc = Jsoup.parse(""<div><p>Hello</p></div><p>There</p>"");
        Elements parents = doc.select(""p"").parents();

        assertEquals(3, parents.size());
        assertEquals(""div"", parents.get(0).tagName());
        assertEquals(""body"", parents.get(1).tagName());
        assertEquals(""html"", parents.get(2).tagName());
    }

    @Test public void not() {
        Document doc = Jsoup.parse(""<div id=1><p>One</p></div> <div id=2><p><span>Two</span></p></div>"");

        Elements div1 = doc.select(""div"").not("":has(p > span)"");
        assertEquals(1, div1.size());
        assertEquals(""1"", div1.first().id());

        Elements div2 = doc.select(""div"").not(""#1"");
        assertEquals(1, div2.size());
        assertEquals(""2"", div2.first().id());
    }

    @Test public void tagNameSet() {
        Document doc = Jsoup.parse(""<p>Hello <i>there</i> <i>now</i></p>"");
        doc.select(""i"").tagName(""em"");

        assertEquals(""<p>Hello <em>there</em> <em>now</em></p>"", doc.body().html());
    }

    @Test public void traverse() {
        Document doc = Jsoup.parse(""<div><p>Hello</p></div><div>There</div>"");
        final StringBuilder accum = new StringBuilder();
        doc.select(""div"").traverse(new NodeVisitor() {
            @Override
            public void head(Node node, int depth) {
                accum.append(""<"").append(node.nodeName()).append("">"");
            }

            @Override
            public void tail(Node node, int depth) {
                accum.append(""</"").append(node.nodeName()).append("">"");
            }
        });
        assertEquals(""<div><p><#text></#text></p></div><div><#text></#text></div>"", accum.toString());
    }

    @Test public void forms() {
        Document doc = Jsoup.parse(""<form id=1><input name=q></form><div /><form id=2><input name=f></form>"");
        Elements els = doc.select(""form, div"");
        assertEquals(3, els.size());

        List<FormElement> forms = els.forms();
        assertEquals(2, forms.size());
        assertNotNull(forms.get(0));
        assertNotNull(forms.get(1));
        assertEquals(""1"", forms.get(0).id());
        assertEquals(""2"", forms.get(1).id());
    }

    @Test public void comments() {
        Document doc = Jsoup.parse(""<!-- comment1 --><p><!-- comment2 --><p class=two><!-- comment3 -->"");
        List<Comment> comments = doc.select(""p"").comments();
        assertEquals(2, comments.size());
        assertEquals("" comment2 "", comments.get(0).getData());
        assertEquals("" comment3 "", comments.get(1).getData());

        List<Comment> comments1 = doc.select(""p.two"").comments();
        assertEquals(1, comments1.size());
        assertEquals("" comment3 "", comments1.get(0).getData());
    }

    @Test public void textNodes() {
        Document doc = Jsoup.parse(""One<p>Two<a>Three</a><p>Four</p>Five"");
        List<TextNode> textNodes = doc.select(""p"").textNodes();
        assertEquals(2, textNodes.size());
        assertEquals(""Two"", textNodes.get(0).text());
        assertEquals(""Four"", textNodes.get(1).text());
    }

    @Test public void dataNodes() {
        Document doc = Jsoup.parse(""<p>One</p><script>Two</script><style>Three</style>"");
        List<DataNode> dataNodes = doc.select(""p, script, style"").dataNodes();
        assertEquals(2, dataNodes.size());
        assertEquals(""Two"", dataNodes.get(0).getWholeData());
        assertEquals(""Three"", dataNodes.get(1).getWholeData());

        doc = Jsoup.parse(""<head><script type=application/json><crux></script><script src=foo>Blah</script>"");
        Elements script = doc.select(""script[type=application/json]"");
        List<DataNode> scriptNode = script.dataNodes();
        assertEquals(1, scriptNode.size());
        DataNode dataNode = scriptNode.get(0);
        assertEquals(""<crux>"", dataNode.getWholeData());

        // check if they're live
        dataNode.setWholeData(""<cromulent>"");
        assertEquals(""<script type=\""application/json\""><cromulent></script>"", script.outerHtml());
    }

    @Test public void nodesEmpty() {
        Document doc = Jsoup.parse(""<p>"");
        assertEquals(0, doc.select(""form"").textNodes().size());
    }

    @Test public void classWithHyphen() {
        Document doc = Jsoup.parse(""<p class='tab-nav'>Check</p>"");
        Elements els = doc.getElementsByClass(""tab-nav"");
        assertEquals(1, els.size());
        assertEquals(""Check"", els.text());
    }

    @Test public void siblings() {
        Document doc = Jsoup.parse(""<div><p>1<p>2<p>3<p>4<p>5<p>6</div><div><p>7<p>8<p>9<p>10<p>11<p>12</div>"");

        Elements els = doc.select(""p:eq(3)""); // gets p4 and p10
        assertEquals(2, els.size());

        Elements next = els.next();
        assertEquals(2, next.size());
        assertEquals(""5"", next.first().text());
        assertEquals(""11"", next.last().text());

        assertEquals(0, els.next(""p:contains(6)"").size());
        final Elements nextF = els.next(""p:contains(5)"");
        assertEquals(1, nextF.size());
        assertEquals(""5"", nextF.first().text());

        Elements nextA = els.nextAll();
        assertEquals(4, nextA.size());
        assertEquals(""5"", nextA.first().text());
        assertEquals(""12"", nextA.last().text());

        Elements nextAF = els.nextAll(""p:contains(6)"");
        assertEquals(1, nextAF.size());
        assertEquals(""6"", nextAF.first().text());

        Elements prev = els.prev();
        assertEquals(2, prev.size());
        assertEquals(""3"", prev.first().text());
        assertEquals(""9"", prev.last().text());

        assertEquals(0, els.prev(""p:contains(1)"").size());
        final Elements prevF = els.prev(""p:contains(3)"");
        assertEquals(1, prevF.size());
        assertEquals(""3"", prevF.first().text());

        Elements prevA = els.prevAll();
        assertEquals(6, prevA.size());
        assertEquals(""3"", prevA.first().text());
        assertEquals(""7"", prevA.last().text());

        Elements prevAF = els.prevAll(""p:contains(1)"");
        assertEquals(1, prevAF.size());
        assertEquals(""1"", prevAF.first().text());
    }

    @Test public void eachText() {
        Document doc = Jsoup.parse(""<div><p>1<p>2<p>3<p>4<p>5<p>6</div><div><p>7<p>8<p>9<p>10<p>11<p>12<p></p></div>"");
        List<String> divText = doc.select(""div"").eachText();
        assertEquals(2, divText.size());
        assertEquals(""1 2 3 4 5 6"", divText.get(0));
        assertEquals(""7 8 9 10 11 12"", divText.get(1));

        List<String> pText = doc.select(""p"").eachText();
        Elements ps = doc.select(""p"");
        assertEquals(13, ps.size());
        assertEquals(12, pText.size()); // not 13, as last doesn't have text
        assertEquals(""1"", pText.get(0));
        assertEquals(""2"", pText.get(1));
        assertEquals(""5"", pText.get(4));
        assertEquals(""7"", pText.get(6));
        assertEquals(""12"", pText.get(11));
    }

    @Test public void eachAttr() {
        Document doc = Jsoup.parse(
            ""<div><a href='/foo'>1</a><a href='http://example.com/bar'>2</a><a href=''>3</a><a>4</a>"",
            ""http://example.com"");

        List<String> hrefAttrs = doc.select(""a"").eachAttr(""href"");
        assertEquals(3, hrefAttrs.size());
        assertEquals(""/foo"", hrefAttrs.get(0));
        assertEquals(""http://example.com/bar"", hrefAttrs.get(1));
        assertEquals("""", hrefAttrs.get(2));
        assertEquals(4, doc.select(""a"").size());

        List<String> absAttrs = doc.select(""a"").eachAttr(""abs:href"");
        assertEquals(3, absAttrs.size());
        assertEquals(3, absAttrs.size());
        assertEquals(""http://example.com/foo"", absAttrs.get(0));
        assertEquals(""http://example.com/bar"", absAttrs.get(1));
        assertEquals(""http://example.com"", absAttrs.get(2));
    }
}
"
jhy/jsoup,src/test/java/org/jsoup/integration/TestServer.java,"package org.jsoup.integration;

import org.eclipse.jetty.server.Server;
import org.eclipse.jetty.server.ServerConnector;
import org.eclipse.jetty.servlet.ServletHandler;
import org.jsoup.integration.servlets.BaseServlet;

import java.net.InetSocketAddress;

public class TestServer {
    private static final Server jetty = new Server(new InetSocketAddress(""localhost"", 0));
    private static final ServletHandler handler = new ServletHandler();

    static {
        jetty.setHandler(handler);
    }

    private TestServer() {
    }

    public static void start() {
        synchronized (jetty) {
            try {
                jetty.start(); // jetty will safely no-op a start on an already running instance
            } catch (Exception e) {
                throw new IllegalStateException(e);
            }
        }
    }

    public static String map(Class<? extends BaseServlet> servletClass) {
        synchronized (jetty) {
            if (!jetty.isStarted())
                start(); // if running out of the test cases

            String path = ""/"" + servletClass.getSimpleName();
            handler.addServletWithMapping(servletClass, path + ""/*"");
            int port = ((ServerConnector) jetty.getConnectors()[0]).getLocalPort();
            return ""http://localhost:"" + port + path;
        }
    }
}
"
jhy/jsoup,src/test/java/org/jsoup/parser/HtmlParserTest.java,"package org.jsoup.parser;

import org.jsoup.Jsoup;
import org.jsoup.TextUtil;
import org.jsoup.integration.ParseTest;
import org.jsoup.internal.StringUtil;
import org.jsoup.nodes.*;
import org.jsoup.safety.Safelist;
import org.jsoup.select.Elements;
import org.junit.jupiter.api.Disabled;
import org.junit.jupiter.api.Test;

import java.io.ByteArrayInputStream;
import java.io.File;
import java.io.IOException;
import java.util.List;

import static org.jsoup.parser.ParseSettings.preserveCase;
import static org.junit.jupiter.api.Assertions.*;

/**
 * Tests for the Parser
 *
 * @author Jonathan Hedley, jonathan@hedley.net
 */
public class HtmlParserTest {

    @Test public void parsesSimpleDocument() {
        String html = ""<html><head><title>First!</title></head><body><p>First post! <img src=\""foo.png\"" /></p></body></html>"";
        Document doc = Jsoup.parse(html);
        // need a better way to verify these:
        Element p = doc.body().child(0);
        assertEquals(""p"", p.tagName());
        Element img = p.child(0);
        assertEquals(""foo.png"", img.attr(""src""));
        assertEquals(""img"", img.tagName());
    }

    @Test public void parsesRoughAttributes() {
        String html = ""<html><head><title>First!</title></head><body><p class=\""foo > bar\"">First post! <img src=\""foo.png\"" /></p></body></html>"";
        Document doc = Jsoup.parse(html);

        // need a better way to verify these:
        Element p = doc.body().child(0);
        assertEquals(""p"", p.tagName());
        assertEquals(""foo > bar"", p.attr(""class""));
    }

    @Test public void dropsDuplicateAttributes() {
        String html = ""<p One=One ONE=Two Two=two one=Three One=Four two=Five>Text</p>"";
        Parser parser = Parser.htmlParser().setTrackErrors(10);
        Document doc = parser.parseInput(html, """");

        Element p = doc.selectFirst(""p"");
        assertEquals(""<p one=\""One\"" two=\""two\"">Text</p>"", p.outerHtml()); // normalized names due to lower casing

        assertEquals(1, parser.getErrors().size());
        assertEquals(""Dropped duplicate attribute(s) in tag [p]"", parser.getErrors().get(0).getErrorMessage());
    }

    @Test public void retainsAttributesOfDifferentCaseIfSensitive() {
        String html = ""<p One=One One=Two one=Three two=Four two=Five Two=Six>Text</p>"";
        Parser parser = Parser.htmlParser().settings(preserveCase);
        Document doc = parser.parseInput(html, """");
        assertEquals(""<p One=\""One\"" one=\""Three\"" two=\""Four\"" Two=\""Six\"">Text</p>"", doc.selectFirst(""p"").outerHtml());
    }

    @Test public void parsesQuiteRoughAttributes() {
        String html = ""<p =a>One<a <p>Something</p>Else"";
        // this (used to; now gets cleaner) gets a <p> with attr '=a' and an <a tag with an attribute named '<p'; and then auto-recreated
        Document doc = Jsoup.parse(html);

        // NOTE: per spec this should be the test case. but impacts too many ppl
        // assertEquals(""<p =a>One<a <p>Something</a></p>\n<a <p>Else</a>"", doc.body().html());

        assertEquals(""<p a>One<a></a></p><p><a>Something</a></p><a>Else</a>"", TextUtil.stripNewlines(doc.body().html()));

        doc = Jsoup.parse(""<p .....>"");
        assertEquals(""<p .....></p>"", doc.body().html());
    }

    @Test public void parsesComments() {
        String html = ""<html><head></head><body><img src=foo><!-- <table><tr><td></table> --><p>Hello</p></body></html>"";
        Document doc = Jsoup.parse(html);

        Element body = doc.body();
        Comment comment = (Comment) body.childNode(1); // comment should not be sub of img, as it's an empty tag
        assertEquals("" <table><tr><td></table> "", comment.getData());
        Element p = body.child(1);
        TextNode text = (TextNode) p.childNode(0);
        assertEquals(""Hello"", text.getWholeText());
    }

    @Test public void parsesUnterminatedComments() {
        String html = ""<p>Hello<!-- <tr><td>"";
        Document doc = Jsoup.parse(html);
        Element p = doc.getElementsByTag(""p"").get(0);
        assertEquals(""Hello"", p.text());
        TextNode text = (TextNode) p.childNode(0);
        assertEquals(""Hello"", text.getWholeText());
        Comment comment = (Comment) p.childNode(1);
        assertEquals("" <tr><td>"", comment.getData());
    }

    @Test void allDashCommentsAreNotParseErrors() {
        // https://github.com/jhy/jsoup/issues/1667
        // <!-----> is not a parse error
        String html = ""<!------>"";
        Parser parser = Parser.htmlParser().setTrackErrors(10);
        Document doc = Jsoup.parse(html, parser);
        Comment comment = (Comment) doc.childNode(0);
        assertEquals(""--"", comment.getData());
        assertEquals(0, parser.getErrors().size());
    }

    @Test public void dropsUnterminatedTag() {
        // jsoup used to parse this to <p>, but whatwg, webkit will drop.
        String h1 = ""<p"";
        Document doc = Jsoup.parse(h1);
        assertEquals(0, doc.getElementsByTag(""p"").size());
        assertEquals("""", doc.text());

        String h2 = ""<div id=1<p id='2'"";
        doc = Jsoup.parse(h2);
        assertEquals("""", doc.text());
    }

    @Test public void dropsUnterminatedAttribute() {
        // jsoup used to parse this to <p id=""foo"">, but whatwg, webkit will drop.
        String h1 = ""<p id=\""foo"";
        Document doc = Jsoup.parse(h1);
        assertEquals("""", doc.text());
    }

    @Test public void parsesUnterminatedTextarea() {
        // don't parse right to end, but break on <p>
        Document doc = Jsoup.parse(""<body><p><textarea>one<p>two"");
        Element t = doc.select(""textarea"").first();
        assertEquals(""one"", t.text());
        assertEquals(""two"", doc.select(""p"").get(1).text());
    }

    @Test public void parsesUnterminatedOption() {
        // bit weird this -- browsers and spec get stuck in select until there's a </select>
        Document doc = Jsoup.parse(""<body><p><select><option>One<option>Two</p><p>Three</p>"");
        Elements options = doc.select(""option"");
        assertEquals(2, options.size());
        assertEquals(""One"", options.first().text());
        assertEquals(""TwoThree"", options.last().text());
    }

    @Test public void testSelectWithOption() {
        Parser parser = Parser.htmlParser();
        parser.setTrackErrors(10);
        Document document = parser.parseInput(""<select><option>Option 1</option></select>"", ""http://jsoup.org"");
        assertEquals(0, parser.getErrors().size());
    }

    @Test public void testSpaceAfterTag() {
        Document doc = Jsoup.parse(""<div > <a name=\""top\""></a ><p id=1 >Hello</p></div>"");
        assertEquals(""<div><a name=\""top\""></a><p id=\""1\"">Hello</p></div>"", TextUtil.stripNewlines(doc.body().html()));
    }

    @Test public void createsDocumentStructure() {
        String html = ""<meta name=keywords /><link rel=stylesheet /><title>jsoup</title><p>Hello world</p>"";
        Document doc = Jsoup.parse(html);
        Element head = doc.head();
        Element body = doc.body();

        assertEquals(1, doc.children().size()); // root node: contains html node
        assertEquals(2, doc.child(0).children().size()); // html node: head and body
        assertEquals(3, head.children().size());
        assertEquals(1, body.children().size());

        assertEquals(""keywords"", head.getElementsByTag(""meta"").get(0).attr(""name""));
        assertEquals(0, body.getElementsByTag(""meta"").size());
        assertEquals(""jsoup"", doc.title());
        assertEquals(""Hello world"", body.text());
        assertEquals(""Hello world"", body.children().get(0).text());
    }

    @Test public void createsStructureFromBodySnippet() {
        // the bar baz stuff naturally goes into the body, but the 'foo' goes into root, and the normalisation routine
        // needs to move into the start of the body
        String html = ""foo <b>bar</b> baz"";
        Document doc = Jsoup.parse(html);
        assertEquals(""foo bar baz"", doc.text());
    }

    @Test public void handlesEscapedData() {
        String html = ""<div title='Surf &amp; Turf'>Reef &amp; Beef</div>"";
        Document doc = Jsoup.parse(html);
        Element div = doc.getElementsByTag(""div"").get(0);

        assertEquals(""Surf & Turf"", div.attr(""title""));
        assertEquals(""Reef & Beef"", div.text());
    }

    @Test public void handlesDataOnlyTags() {
        String t = ""<style>font-family: bold</style>"";
        List<Element> tels = Jsoup.parse(t).getElementsByTag(""style"");
        assertEquals(""font-family: bold"", tels.get(0).data());
        assertEquals("""", tels.get(0).text());

        String s = ""<p>Hello</p><script>obj.insert('<a rel=\""none\"" />');\ni++;</script><p>There</p>"";
        Document doc = Jsoup.parse(s);
        assertEquals(""Hello There"", doc.text());
        assertEquals(""obj.insert('<a rel=\""none\"" />');\ni++;"", doc.data());
    }

    @Test public void handlesTextAfterData() {
        String h = ""<html><body>pre <script>inner</script> aft</body></html>"";
        Document doc = Jsoup.parse(h);
        assertEquals(""<html><head></head><body>pre <script>inner</script> aft</body></html>"", TextUtil.stripNewlines(doc.html()));
    }

    @Test public void handlesTextArea() {
        Document doc = Jsoup.parse(""<textarea>Hello</textarea>"");
        Elements els = doc.select(""textarea"");
        assertEquals(""Hello"", els.text());
        assertEquals(""Hello"", els.val());
    }

    @Test public void preservesSpaceInTextArea() {
        // preserve because the tag is marked as preserve white space
        Document doc = Jsoup.parse(""<textarea>\n\tOne\n\tTwo\n\tThree\n</textarea>"");
        String expect = ""One\n\tTwo\n\tThree""; // the leading and trailing spaces are dropped as a convenience to authors
        Element el = doc.select(""textarea"").first();
        assertEquals(expect, el.text());
        assertEquals(expect, el.val());
        assertEquals(expect, el.html());
        assertEquals(""<textarea>\n\t"" + expect + ""\n</textarea>"", el.outerHtml()); // but preserved in round-trip html
    }

    @Test public void preservesSpaceInScript() {
        // preserve because it's content is a data node
        Document doc = Jsoup.parse(""<script>\nOne\n\tTwo\n\tThree\n</script>"");
        String expect = ""\nOne\n\tTwo\n\tThree\n"";
        Element el = doc.select(""script"").first();
        assertEquals(expect, el.data());
        assertEquals(""One\n\tTwo\n\tThree"", el.html());
        assertEquals(""<script>"" + expect + ""</script>"", el.outerHtml());
    }

    @Test public void doesNotCreateImplicitLists() {
        // old jsoup used to wrap this in <ul>, but that's not to spec
        String h = ""<li>Point one<li>Point two"";
        Document doc = Jsoup.parse(h);
        Elements ol = doc.select(""ul""); // should NOT have created a default ul.
        assertEquals(0, ol.size());
        Elements lis = doc.select(""li"");
        assertEquals(2, lis.size());
        assertEquals(""body"", lis.first().parent().tagName());

        // no fiddling with non-implicit lists
        String h2 = ""<ol><li><p>Point the first<li><p>Point the second"";
        Document doc2 = Jsoup.parse(h2);

        assertEquals(0, doc2.select(""ul"").size());
        assertEquals(1, doc2.select(""ol"").size());
        assertEquals(2, doc2.select(""ol li"").size());
        assertEquals(2, doc2.select(""ol li p"").size());
        assertEquals(1, doc2.select(""ol li"").get(0).children().size()); // one p in first li
    }

    @Test public void discardsNakedTds() {
        // jsoup used to make this into an implicit table; but browsers make it into a text run
        String h = ""<td>Hello<td><p>There<p>now"";
        Document doc = Jsoup.parse(h);
        assertEquals(""Hello<p>There</p><p>now</p>"", TextUtil.stripNewlines(doc.body().html()));
        // <tbody> is introduced if no implicitly creating table, but allows tr to be directly under table
    }

    @Test public void handlesNestedImplicitTable() {
        Document doc = Jsoup.parse(""<table><td>1</td></tr> <td>2</td></tr> <td> <table><td>3</td> <td>4</td></table> <tr><td>5</table>"");
        assertEquals(""<table><tbody><tr><td>1</td></tr><tr><td>2</td></tr><tr><td><table><tbody><tr><td>3</td><td>4</td></tr></tbody></table></td></tr><tr><td>5</td></tr></tbody></table>"", TextUtil.stripNewlines(doc.body().html()));
    }

    @Test public void handlesWhatWgExpensesTableExample() {
        // http://www.whatwg.org/specs/web-apps/current-work/multipage/tabular-data.html#examples-0
        Document doc = Jsoup.parse(""<table> <colgroup> <col> <colgroup> <col> <col> <col> <thead> <tr> <th> <th>2008 <th>2007 <th>2006 <tbody> <tr> <th scope=rowgroup> Research and development <td> $ 1,109 <td> $ 782 <td> $ 712 <tr> <th scope=row> Percentage of net sales <td> 3.4% <td> 3.3% <td> 3.7% <tbody> <tr> <th scope=rowgroup> Selling, general, and administrative <td> $ 3,761 <td> $ 2,963 <td> $ 2,433 <tr> <th scope=row> Percentage of net sales <td> 11.6% <td> 12.3% <td> 12.6% </table>"");
        assertEquals(""<table><colgroup><col></colgroup><colgroup><col><col><col></colgroup><thead><tr><th></th><th>2008</th><th>2007</th><th>2006</th></tr></thead><tbody><tr><th scope=\""rowgroup\"">Research and development</th><td>$ 1,109</td><td>$ 782</td><td>$ 712</td></tr><tr><th scope=\""row\"">Percentage of net sales</th><td>3.4%</td><td>3.3%</td><td>3.7%</td></tr></tbody><tbody><tr><th scope=\""rowgroup\"">Selling, general, and administrative</th><td>$ 3,761</td><td>$ 2,963</td><td>$ 2,433</td></tr><tr><th scope=\""row\"">Percentage of net sales</th><td>11.6%</td><td>12.3%</td><td>12.6%</td></tr></tbody></table>"", TextUtil.stripNewlines(doc.body().html()));
    }

    @Test public void handlesTbodyTable() {
        Document doc = Jsoup.parse(""<html><head></head><body><table><tbody><tr><td>aaa</td><td>bbb</td></tr></tbody></table></body></html>"");
        assertEquals(""<table><tbody><tr><td>aaa</td><td>bbb</td></tr></tbody></table>"", TextUtil.stripNewlines(doc.body().html()));
    }

    @Test public void handlesImplicitCaptionClose() {
        Document doc = Jsoup.parse(""<table><caption>A caption<td>One<td>Two"");
        assertEquals(""<table><caption>A caption</caption><tbody><tr><td>One</td><td>Two</td></tr></tbody></table>"", TextUtil.stripNewlines(doc.body().html()));
    }

    @Test public void noTableDirectInTable() {
        Document doc = Jsoup.parse(""<table> <td>One <td><table><td>Two</table> <table><td>Three"");
        assertEquals(""<table><tbody><tr><td>One</td><td><table><tbody><tr><td>Two</td></tr></tbody></table><table><tbody><tr><td>Three</td></tr></tbody></table></td></tr></tbody></table>"",
            TextUtil.stripNewlines(doc.body().html()));
    }

    @Test public void ignoresDupeEndTrTag() {
        Document doc = Jsoup.parse(""<table><tr><td>One</td><td><table><tr><td>Two</td></tr></tr></table></td><td>Three</td></tr></table>""); // two </tr></tr>, must ignore or will close table
        assertEquals(""<table><tbody><tr><td>One</td><td><table><tbody><tr><td>Two</td></tr></tbody></table></td><td>Three</td></tr></tbody></table>"",
            TextUtil.stripNewlines(doc.body().html()));
    }

    @Test public void handlesBaseTags() {
        // only listen to the first base href
        String h = ""<a href=1>#</a><base href='/2/'><a href='3'>#</a><base href='http://bar'><a href=/4>#</a>"";
        Document doc = Jsoup.parse(h, ""http://foo/"");
        assertEquals(""http://foo/2/"", doc.baseUri()); // gets set once, so doc and descendants have first only

        Elements anchors = doc.getElementsByTag(""a"");
        assertEquals(3, anchors.size());

        assertEquals(""http://foo/2/"", anchors.get(0).baseUri());
        assertEquals(""http://foo/2/"", anchors.get(1).baseUri());
        assertEquals(""http://foo/2/"", anchors.get(2).baseUri());

        assertEquals(""http://foo/2/1"", anchors.get(0).absUrl(""href""));
        assertEquals(""http://foo/2/3"", anchors.get(1).absUrl(""href""));
        assertEquals(""http://foo/4"", anchors.get(2).absUrl(""href""));
    }

    @Test public void handlesProtocolRelativeUrl() {
        String base = ""https://example.com/"";
        String html = ""<img src='//example.net/img.jpg'>"";
        Document doc = Jsoup.parse(html, base);
        Element el = doc.select(""img"").first();
        assertEquals(""https://example.net/img.jpg"", el.absUrl(""src""));
    }

    @Test public void handlesCdata() {
        // todo: as this is html namespace, should actually treat as bogus comment, not cdata. keep as cdata for now
        String h = ""<div id=1><![CDATA[<html>\n <foo><&amp;]]></div>""; // the &amp; in there should remain literal
        Document doc = Jsoup.parse(h);
        Element div = doc.getElementById(""1"");
        assertEquals(""<html>\n <foo><&amp;"", div.text());
        assertEquals(0, div.children().size());
        assertEquals(1, div.childNodeSize()); // no elements, one text node
    }

    @Test public void roundTripsCdata() {
        String h = ""<div id=1><![CDATA[\n<html>\n <foo><&amp;]]></div>"";
        Document doc = Jsoup.parse(h);
        Element div = doc.getElementById(""1"");
        assertEquals(""<html>\n <foo><&amp;"", div.text());
        assertEquals(0, div.children().size());
        assertEquals(1, div.childNodeSize()); // no elements, one text node

        assertEquals(""<div id=\""1\""><![CDATA[\n<html>\n <foo><&amp;]]>\n</div>"", div.outerHtml());

        CDataNode cdata = (CDataNode) div.textNodes().get(0);
        assertEquals(""\n<html>\n <foo><&amp;"", cdata.text());
    }

    @Test public void handlesCdataAcrossBuffer() {
        StringBuilder sb = new StringBuilder();
        while (sb.length() <= CharacterReader.maxBufferLen) {
            sb.append(""A suitable amount of CData.\n"");
        }
        String cdata = sb.toString();
        String h = ""<div><![CDATA["" + cdata + ""]]></div>"";
        Document doc = Jsoup.parse(h);
        Element div = doc.selectFirst(""div"");

        CDataNode node = (CDataNode) div.textNodes().get(0);
        assertEquals(cdata, node.text());
    }

    @Test public void handlesCdataInScript() {
        String html = ""<script type=\""text/javascript\"">//<![CDATA[\n\n  foo();\n//]]></script>"";
        Document doc = Jsoup.parse(html);

        String data = ""//<![CDATA[\n\n  foo();\n//]]>"";
        Element script = doc.selectFirst(""script"");
        assertEquals("""", script.text()); // won't be parsed as cdata because in script data section
        assertEquals(data, script.data());
        assertEquals(html, script.outerHtml());

        DataNode dataNode = (DataNode) script.childNode(0);
        assertEquals(data, dataNode.getWholeData());
        // see - not a cdata node, because in script. contrast with XmlTreeBuilder - will be cdata.
    }

    @Test public void handlesUnclosedCdataAtEOF() {
        // https://github.com/jhy/jsoup/issues/349 would crash, as character reader would try to seek past EOF
        String h = ""<![CDATA[]]"";
        Document doc = Jsoup.parse(h);
        assertEquals(1, doc.body().childNodeSize());
    }

    @Test public void handleCDataInText() {
        String h = ""<p>One <![CDATA[Two <&]]> Three</p>"";
        Document doc = Jsoup.parse(h);
        Element p = doc.selectFirst(""p"");

        List<Node> nodes = p.childNodes();
        assertEquals(""One "", ((TextNode) nodes.get(0)).getWholeText());
        assertEquals(""Two <&"", ((TextNode) nodes.get(1)).getWholeText());
        assertEquals(""Two <&"", ((CDataNode) nodes.get(1)).getWholeText());
        assertEquals("" Three"", ((TextNode) nodes.get(2)).getWholeText());

        assertEquals(h, p.outerHtml());
    }

    @Test public void cdataNodesAreTextNodes() {
        String h = ""<p>One <![CDATA[ Two <& ]]> Three</p>"";
        Document doc = Jsoup.parse(h);
        Element p = doc.selectFirst(""p"");

        List<TextNode> nodes = p.textNodes();
        assertEquals(""One "", nodes.get(0).text());
        assertEquals("" Two <& "", nodes.get(1).text());
        assertEquals("" Three"", nodes.get(2).text());
    }

    @Test public void handlesInvalidStartTags() {
        String h = ""<div>Hello < There <&amp;></div>""; // parse to <div {#text=Hello < There <&>}>
        Document doc = Jsoup.parse(h);
        assertEquals(""Hello < There <&>"", doc.select(""div"").first().text());
    }

    @Test public void handlesUnknownTags() {
        String h = ""<div><foo title=bar>Hello<foo title=qux>there</foo></div>"";
        Document doc = Jsoup.parse(h);
        Elements foos = doc.select(""foo"");
        assertEquals(2, foos.size());
        assertEquals(""bar"", foos.first().attr(""title""));
        assertEquals(""qux"", foos.last().attr(""title""));
        assertEquals(""there"", foos.last().text());
    }

    @Test public void handlesUnknownInlineTags() {
        String h = ""<p><cust>Test</cust></p><p><cust><cust>Test</cust></cust></p>"";
        Document doc = Jsoup.parseBodyFragment(h);
        String out = doc.body().html();
        assertEquals(h, TextUtil.stripNewlines(out));
    }

    @Test public void parsesBodyFragment() {
        String h = ""<!-- comment --><p><a href='foo'>One</a></p>"";
        Document doc = Jsoup.parseBodyFragment(h, ""http://example.com"");
        assertEquals(""<body><!-- comment --><p><a href=\""foo\"">One</a></p></body>"", TextUtil.stripNewlines(doc.body().outerHtml()));
        assertEquals(""http://example.com/foo"", doc.select(""a"").first().absUrl(""href""));
    }

    @Test public void parseBodyIsIndexNoAttributes() {
        // https://github.com/jhy/jsoup/issues/1404
        String expectedHtml = ""<form>\n"" +
            "" <hr><label>This is a searchable index. Enter search keywords: <input name=\""isindex\""></label>\n"" +
            "" <hr>\n"" +
            ""</form>"";
        Document doc = Jsoup.parse(""<isindex>"");
        assertEquals(expectedHtml, doc.body().html());

        doc = Jsoup.parseBodyFragment(""<isindex>"");
        assertEquals(expectedHtml, doc.body().html());

        doc = Jsoup.parseBodyFragment(""<table><input></table>"");
        assertEquals(""<input>\n<table></table>"", doc.body().html());
    }

    @Test public void handlesUnknownNamespaceTags() {
        // note that the first foo:bar should not really be allowed to be self closing, if parsed in html mode.
        String h = ""<foo:bar id='1' /><abc:def id=2>Foo<p>Hello</p></abc:def><foo:bar>There</foo:bar>"";
        Document doc = Jsoup.parse(h);
        assertEquals(""<foo:bar id=\""1\"" /><abc:def id=\""2\"">Foo<p>Hello</p></abc:def><foo:bar>There</foo:bar>"", TextUtil.stripNewlines(doc.body().html()));
    }

    @Test public void handlesKnownEmptyBlocks() {
        // if a known tag, allow self closing outside of spec, but force an end tag. unknown tags can be self closing.
        String h = ""<div id='1' /><script src='/foo' /><div id=2><img /><img></div><a id=3 /><i /><foo /><foo>One</foo> <hr /> hr text <hr> hr text two"";
        Document doc = Jsoup.parse(h);
        assertEquals(""<div id=\""1\""></div><script src=\""/foo\""></script><div id=\""2\""><img><img></div><a id=\""3\""></a><i></i><foo /><foo>One</foo><hr> hr text <hr> hr text two"", TextUtil.stripNewlines(doc.body().html()));
    }

    @Test public void handlesKnownEmptyNoFrames() {
        String h = ""<html><head><noframes /><meta name=foo></head><body>One</body></html>"";
        Document doc = Jsoup.parse(h);
        assertEquals(""<html><head><noframes></noframes><meta name=\""foo\""></head><body>One</body></html>"", TextUtil.stripNewlines(doc.html()));
    }

    @Test public void handlesKnownEmptyStyle() {
        String h = ""<html><head><style /><meta name=foo></head><body>One</body></html>"";
        Document doc = Jsoup.parse(h);
        assertEquals(""<html><head><style></style><meta name=\""foo\""></head><body>One</body></html>"", TextUtil.stripNewlines(doc.html()));
    }

    @Test public void handlesKnownEmptyTitle() {
        String h = ""<html><head><title /><meta name=foo></head><body>One</body></html>"";
        Document doc = Jsoup.parse(h);
        assertEquals(""<html><head><title></title><meta name=\""foo\""></head><body>One</body></html>"", TextUtil.stripNewlines(doc.html()));
    }

    @Test public void handlesKnownEmptyIframe() {
        String h = ""<p>One</p><iframe id=1 /><p>Two"";
        Document doc = Jsoup.parse(h);
        assertEquals(""<html><head></head><body><p>One</p><iframe id=\""1\""></iframe><p>Two</p></body></html>"", TextUtil.stripNewlines(doc.html()));
    }

    @Test public void handlesSolidusAtAttributeEnd() {
        // this test makes sure [<a href=/>link</a>] is parsed as [<a href=""/"">link</a>], not [<a href="""" /><a>link</a>]
        String h = ""<a href=/>link</a>"";
        Document doc = Jsoup.parse(h);
        assertEquals(""<a href=\""/\"">link</a>"", doc.body().html());
    }

    @Test public void handlesMultiClosingBody() {
        String h = ""<body><p>Hello</body><p>there</p></body></body></html><p>now"";
        Document doc = Jsoup.parse(h);
        assertEquals(3, doc.select(""p"").size());
        assertEquals(3, doc.body().children().size());
    }

    @Test public void handlesUnclosedDefinitionLists() {
        // jsoup used to create a <dl>, but that's not to spec
        String h = ""<dt>Foo<dd>Bar<dt>Qux<dd>Zug"";
        Document doc = Jsoup.parse(h);
        assertEquals(0, doc.select(""dl"").size()); // no auto dl
        assertEquals(4, doc.select(""dt, dd"").size());
        Elements dts = doc.select(""dt"");
        assertEquals(2, dts.size());
        assertEquals(""Zug"", dts.get(1).nextElementSibling().text());
    }

    @Test public void handlesBlocksInDefinitions() {
        // per the spec, dt and dd are inline, but in practise are block
        String h = ""<dl><dt><div id=1>Term</div></dt><dd><div id=2>Def</div></dd></dl>"";
        Document doc = Jsoup.parse(h);
        assertEquals(""dt"", doc.select(""#1"").first().parent().tagName());
        assertEquals(""dd"", doc.select(""#2"").first().parent().tagName());
        assertEquals(""<dl><dt><div id=\""1\"">Term</div></dt><dd><div id=\""2\"">Def</div></dd></dl>"", TextUtil.stripNewlines(doc.body().html()));
    }

    @Test public void handlesFrames() {
        String h = ""<html><head><script></script><noscript></noscript></head><frameset><frame src=foo></frame><frame src=foo></frameset></html>"";
        Document doc = Jsoup.parse(h);
        assertEquals(""<html><head><script></script><noscript></noscript></head><frameset><frame src=\""foo\""><frame src=\""foo\""></frameset></html>"",
            TextUtil.stripNewlines(doc.html()));
        // no body auto vivification
    }

    @Test public void ignoresContentAfterFrameset() {
        String h = ""<html><head><title>One</title></head><frameset><frame /><frame /></frameset><table></table></html>"";
        Document doc = Jsoup.parse(h);
        assertEquals(""<html><head><title>One</title></head><frameset><frame><frame></frameset></html>"", TextUtil.stripNewlines(doc.html()));
        // no body, no table. No crash!
    }

    @Test public void handlesJavadocFont() {
        String h = ""<TD BGCOLOR=\""#EEEEFF\"" CLASS=\""NavBarCell1\"">    <A HREF=\""deprecated-list.html\""><FONT CLASS=\""NavBarFont1\""><B>Deprecated</B></FONT></A>&nbsp;</TD>"";
        Document doc = Jsoup.parse(h);
        Element a = doc.select(""a"").first();
        assertEquals(""Deprecated"", a.text());
        assertEquals(""font"", a.child(0).tagName());
        assertEquals(""b"", a.child(0).child(0).tagName());
    }

    @Test public void handlesBaseWithoutHref() {
        String h = ""<head><base target='_blank'></head><body><a href=/foo>Test</a></body>"";
        Document doc = Jsoup.parse(h, ""http://example.com/"");
        Element a = doc.select(""a"").first();
        assertEquals(""/foo"", a.attr(""href""));
        assertEquals(""http://example.com/foo"", a.attr(""abs:href""));
    }

    @Test public void normalisesDocument() {
        String h = ""<!doctype html>One<html>Two<head>Three<link></head>Four<body>Five </body>Six </html>Seven "";
        Document doc = Jsoup.parse(h);
        assertEquals(""<!doctype html><html><head></head><body>OneTwoThree<link>FourFive Six Seven</body></html>"",
            TextUtil.stripNewlines(doc.html()));
    }

    @Test public void normalisesEmptyDocument() {
        Document doc = Jsoup.parse("""");
        assertEquals(""<html><head></head><body></body></html>"", TextUtil.stripNewlines(doc.html()));
    }

    @Test public void normalisesHeadlessBody() {
        Document doc = Jsoup.parse(""<html><body><span class=\""foo\"">bar</span>"");
        assertEquals(""<html><head></head><body><span class=\""foo\"">bar</span></body></html>"",
            TextUtil.stripNewlines(doc.html()));
    }

    @Test public void normalisedBodyAfterContent() {
        Document doc = Jsoup.parse(""<font face=Arial><body class=name><div>One</div></body></font>"");
        assertEquals(""<html><head></head><body class=\""name\""><font face=\""Arial\""><div>One</div></font></body></html>"",
            TextUtil.stripNewlines(doc.html()));
    }

    @Test public void findsCharsetInMalformedMeta() {
        String h = ""<meta http-equiv=Content-Type content=text/html; charset=gb2312>"";
        // example cited for reason of html5's <meta charset> element
        Document doc = Jsoup.parse(h);
        assertEquals(""gb2312"", doc.select(""meta"").attr(""charset""));
    }

    @Test public void testHgroup() {
        // jsoup used to not allow hgroup in h{n}, but that's not in spec, and browsers are OK
        Document doc = Jsoup.parse(""<h1>Hello <h2>There <hgroup><h1>Another<h2>headline</hgroup> <hgroup><h1>More</h1><p>stuff</p></hgroup>"");
        assertEquals(""<h1>Hello</h1><h2>There <hgroup><h1>Another</h1><h2>headline</h2></hgroup><hgroup><h1>More</h1><p>stuff</p></hgroup></h2>"", TextUtil.stripNewlines(doc.body().html()));
    }

    @Test public void testRelaxedTags() {
        Document doc = Jsoup.parse(""<abc_def id=1>Hello</abc_def> <abc-def>There</abc-def>"");
        assertEquals(""<abc_def id=\""1\"">Hello</abc_def> <abc-def>There</abc-def>"", TextUtil.stripNewlines(doc.body().html()));
    }

    @Test public void testHeaderContents() {
        // h* tags (h1 .. h9) in browsers can handle any internal content other than other h*. which is not per any
        // spec, which defines them as containing phrasing content only. so, reality over theory.
        Document doc = Jsoup.parse(""<h1>Hello <div>There</div> now</h1> <h2>More <h3>Content</h3></h2>"");
        assertEquals(""<h1>Hello <div>There</div> now</h1><h2>More</h2><h3>Content</h3>"", TextUtil.stripNewlines(doc.body().html()));
    }

    @Test public void testSpanContents() {
        // like h1 tags, the spec says SPAN is phrasing only, but browsers and publisher treat span as a block tag
        Document doc = Jsoup.parse(""<span>Hello <div>there</div> <span>now</span></span>"");
        assertEquals(""<span>Hello <div>there</div> <span>now</span></span>"", TextUtil.stripNewlines(doc.body().html()));
    }

    @Test public void testNoImagesInNoScriptInHead() {
        // jsoup used to allow, but against spec if parsing with noscript
        Document doc = Jsoup.parse(""<html><head><noscript><img src='foo'></noscript></head><body><p>Hello</p></body></html>"");
        assertEquals(""<html><head><noscript>&lt;img src=\""foo\""&gt;</noscript></head><body><p>Hello</p></body></html>"", TextUtil.stripNewlines(doc.html()));
    }

    @Test public void testUnclosedNoscriptInHead() {
        // Was getting ""EOF"" in html output, because the #anythingElse handler was calling an undefined toString, so used object.toString.
        String[] strings = {""<noscript>"", ""<noscript>One""};
        for (String html : strings) {
            Document doc = Jsoup.parse(html);
            assertEquals(html + ""</noscript>"", TextUtil.stripNewlines(doc.head().html()));
        }
    }

    @Test public void testAFlowContents() {
        // html5 has <a> as either phrasing or block
        Document doc = Jsoup.parse(""<a>Hello <div>there</div> <span>now</span></a>"");
        assertEquals(""<a>Hello <div>there</div> <span>now</span></a>"", TextUtil.stripNewlines(doc.body().html()));
    }

    @Test public void testFontFlowContents() {
        // html5 has no definition of <font>; often used as flow
        Document doc = Jsoup.parse(""<font>Hello <div>there</div> <span>now</span></font>"");
        assertEquals(""<font>Hello <div>there</div> <span>now</span></font>"", TextUtil.stripNewlines(doc.body().html()));
    }

    @Test public void handlesMisnestedTagsBI() {
        // whatwg: <b><i></b></i>
        String h = ""<p>1<b>2<i>3</b>4</i>5</p>"";
        Document doc = Jsoup.parse(h);
        assertEquals(""<p>1<b>2<i>3</i></b><i>4</i>5</p>"", doc.body().html());
        // adoption agency on </b>, reconstruction of formatters on 4.
    }

    @Test public void handlesMisnestedTagsBP() {
        //  whatwg: <b><p></b></p>
        String h = ""<b>1<p>2</b>3</p>"";
        Document doc = Jsoup.parse(h);
        assertEquals(""<b>1</b>\n<p><b>2</b>3</p>"", doc.body().html());
    }

    @Test public void handlesMisnestedAInDivs() {
        String h = ""<a href='#1'><div><div><a href='#2'>child</a></div</div></a>"";
        String w = ""<a href=\""#1\""></a> <div> <a href=\""#1\""></a> <div> <a href=\""#1\""></a><a href=\""#2\"">child</a> </div> </div>"";
        Document doc = Jsoup.parse(h);
        assertEquals(
            StringUtil.normaliseWhitespace(w),
            StringUtil.normaliseWhitespace(doc.body().html()));
    }

    @Test public void handlesUnexpectedMarkupInTables() {
        // whatwg - tests markers in active formatting (if they didn't work, would get in table)
        // also tests foster parenting
        String h = ""<table><b><tr><td>aaa</td></tr>bbb</table>ccc"";
        Document doc = Jsoup.parse(h);
        assertEquals(""<b></b><b>bbb</b><table><tbody><tr><td>aaa</td></tr></tbody></table><b>ccc</b>"", TextUtil.stripNewlines(doc.body().html()));
    }

    @Test public void handlesUnclosedFormattingElements() {
        // whatwg: formatting elements get collected and applied, but excess elements are thrown away
        String h = ""<!DOCTYPE html>\n"" +
            ""<p><b class=x><b class=x><b><b class=x><b class=x><b>X\n"" +
            ""<p>X\n"" +
            ""<p><b><b class=x><b>X\n"" +
            ""<p></b></b></b></b></b></b>X"";
        Document doc = Jsoup.parse(h);
        doc.outputSettings().indentAmount(0);
        String want = ""<!doctype html>\n"" +
            ""<html>\n"" +
            ""<head></head>\n"" +
            ""<body>\n"" +
            ""<p><b class=\""x\""><b class=\""x\""><b><b class=\""x\""><b class=\""x\""><b>X </b></b></b></b></b></b></p>\n"" +
            ""<p><b class=\""x\""><b><b class=\""x\""><b class=\""x\""><b>X </b></b></b></b></b></p>\n"" +
            ""<p><b class=\""x\""><b><b class=\""x\""><b class=\""x\""><b><b><b class=\""x\""><b>X </b></b></b></b></b></b></b></b></p>\n"" +
            ""<p>X</p>\n"" +
            ""</body>\n"" +
            ""</html>"";
        assertEquals(want, doc.html());
    }

    @Test public void handlesUnclosedAnchors() {
        String h = ""<a href='http://example.com/'>Link<p>Error link</a>"";
        Document doc = Jsoup.parse(h);
        String want = ""<a href=\""http://example.com/\"">Link</a>\n<p><a href=\""http://example.com/\"">Error link</a></p>"";
        assertEquals(want, doc.body().html());
    }

    @Test public void reconstructFormattingElements() {
        // tests attributes and multi b
        String h = ""<p><b class=one>One <i>Two <b>Three</p><p>Hello</p>"";
        Document doc = Jsoup.parse(h);
        assertEquals(""<p><b class=\""one\"">One <i>Two <b>Three</b></i></b></p>\n<p><b class=\""one\""><i><b>Hello</b></i></b></p>"", doc.body().html());
    }

    @Test public void reconstructFormattingElementsInTable() {
        // tests that tables get formatting markers -- the <b> applies outside the table and does not leak in,
        // and the <i> inside the table and does not leak out.
        String h = ""<p><b>One</p> <table><tr><td><p><i>Three<p>Four</i></td></tr></table> <p>Five</p>"";
        Document doc = Jsoup.parse(h);
        String want = ""<p><b>One</b></p><b>\n"" +
            "" <table>\n"" +
            ""  <tbody>\n"" +
            ""   <tr>\n"" +
            ""    <td><p><i>Three</i></p><p><i>Four</i></p></td>\n"" +
            ""   </tr>\n"" +
            ""  </tbody>\n"" +
            "" </table> <p>Five</p></b>"";
        assertEquals(want, doc.body().html());
    }

    @Test public void commentBeforeHtml() {
        String h = ""<!-- comment --><!-- comment 2 --><p>One</p>"";
        Document doc = Jsoup.parse(h);
        assertEquals(""<!-- comment --><!-- comment 2 --><html><head></head><body><p>One</p></body></html>"", TextUtil.stripNewlines(doc.html()));
    }

    @Test public void emptyTdTag() {
        String h = ""<table><tr><td>One</td><td id='2' /></tr></table>"";
        Document doc = Jsoup.parse(h);
        assertEquals(""<td>One</td>\n<td id=\""2\""></td>"", doc.select(""tr"").first().html());
    }

    @Test public void handlesSolidusInA() {
        // test for bug #66
        String h = ""<a class=lp href=/lib/14160711/>link text</a>"";
        Document doc = Jsoup.parse(h);
        Element a = doc.select(""a"").first();
        assertEquals(""link text"", a.text());
        assertEquals(""/lib/14160711/"", a.attr(""href""));
    }

    @Test public void handlesSpanInTbody() {
        // test for bug 64
        String h = ""<table><tbody><span class='1'><tr><td>One</td></tr><tr><td>Two</td></tr></span></tbody></table>"";
        Document doc = Jsoup.parse(h);
        assertEquals(doc.select(""span"").first().children().size(), 0); // the span gets closed
        assertEquals(doc.select(""table"").size(), 1); // only one table
    }

    @Test public void handlesUnclosedTitleAtEof() {
        assertEquals(""Data"", Jsoup.parse(""<title>Data"").title());
        assertEquals(""Data<"", Jsoup.parse(""<title>Data<"").title());
        assertEquals(""Data</"", Jsoup.parse(""<title>Data</"").title());
        assertEquals(""Data</t"", Jsoup.parse(""<title>Data</t"").title());
        assertEquals(""Data</ti"", Jsoup.parse(""<title>Data</ti"").title());
        assertEquals(""Data"", Jsoup.parse(""<title>Data</title>"").title());
        assertEquals(""Data"", Jsoup.parse(""<title>Data</title >"").title());
    }

    @Test public void handlesUnclosedTitle() {
        Document one = Jsoup.parse(""<title>One <b>Two <b>Three</TITLE><p>Test</p>""); // has title, so <b> is plain text
        assertEquals(""One <b>Two <b>Three"", one.title());
        assertEquals(""Test"", one.select(""p"").first().text());

        Document two = Jsoup.parse(""<title>One<b>Two <p>Test</p>""); // no title, so <b> causes </title> breakout
        assertEquals(""One"", two.title());
        assertEquals(""<b>Two <p>Test</p></b>"", two.body().html());
    }

    @Test public void handlesUnclosedScriptAtEof() {
        assertEquals(""Data"", Jsoup.parse(""<script>Data"").select(""script"").first().data());
        assertEquals(""Data<"", Jsoup.parse(""<script>Data<"").select(""script"").first().data());
        assertEquals(""Data</sc"", Jsoup.parse(""<script>Data</sc"").select(""script"").first().data());
        assertEquals(""Data</-sc"", Jsoup.parse(""<script>Data</-sc"").select(""script"").first().data());
        assertEquals(""Data</sc-"", Jsoup.parse(""<script>Data</sc-"").select(""script"").first().data());
        assertEquals(""Data</sc--"", Jsoup.parse(""<script>Data</sc--"").select(""script"").first().data());
        assertEquals(""Data"", Jsoup.parse(""<script>Data</script>"").select(""script"").first().data());
        assertEquals(""Data</script"", Jsoup.parse(""<script>Data</script"").select(""script"").first().data());
        assertEquals(""Data"", Jsoup.parse(""<script>Data</script "").select(""script"").first().data());
        assertEquals(""Data"", Jsoup.parse(""<script>Data</script n"").select(""script"").first().data());
        assertEquals(""Data"", Jsoup.parse(""<script>Data</script n="").select(""script"").first().data());
        assertEquals(""Data"", Jsoup.parse(""<script>Data</script n=\"""").select(""script"").first().data());
        assertEquals(""Data"", Jsoup.parse(""<script>Data</script n=\""p"").select(""script"").first().data());
    }

    @Test public void handlesUnclosedRawtextAtEof() {
        assertEquals(""Data"", Jsoup.parse(""<style>Data"").select(""style"").first().data());
        assertEquals(""Data</st"", Jsoup.parse(""<style>Data</st"").select(""style"").first().data());
        assertEquals(""Data"", Jsoup.parse(""<style>Data</style>"").select(""style"").first().data());
        assertEquals(""Data</style"", Jsoup.parse(""<style>Data</style"").select(""style"").first().data());
        assertEquals(""Data</-style"", Jsoup.parse(""<style>Data</-style"").select(""style"").first().data());
        assertEquals(""Data</style-"", Jsoup.parse(""<style>Data</style-"").select(""style"").first().data());
        assertEquals(""Data</style--"", Jsoup.parse(""<style>Data</style--"").select(""style"").first().data());
    }

    @Test public void noImplicitFormForTextAreas() {
        // old jsoup parser would create implicit forms for form children like <textarea>, but no more
        Document doc = Jsoup.parse(""<textarea>One</textarea>"");
        assertEquals(""<textarea>One</textarea>"", doc.body().html());
    }

    @Test public void handlesEscapedScript() {
        Document doc = Jsoup.parse(""<script><!-- one <script>Blah</script> --></script>"");
        assertEquals(""<!-- one <script>Blah</script> -->"", doc.select(""script"").first().data());
    }

    @Test public void handles0CharacterAsText() {
        Document doc = Jsoup.parse(""0<p>0</p>"");
        assertEquals(""0\n<p>0</p>"", doc.body().html());
    }

    @Test public void handlesNullInData() {
        Document doc = Jsoup.parse(""<p id=\u0000>Blah \u0000</p>"");
        assertEquals(""<p id=\""\uFFFD\"">Blah &#x0;</p>"", doc.body().html()); // replaced in attr, NOT replaced in data (but is escaped as control char <0x20)
    }

    @Test public void handlesNullInComments() {
        Document doc = Jsoup.parse(""<body><!-- \u0000 \u0000 -->"");
        assertEquals(""<!-- \uFFFD \uFFFD -->"", doc.body().html());
    }

    @Test public void handlesNewlinesAndWhitespaceInTag() {
        Document doc = Jsoup.parse(""<a \n href=\""one\"" \r\n id=\""two\"" \f >"");
        assertEquals(""<a href=\""one\"" id=\""two\""></a>"", doc.body().html());
    }

    @Test public void handlesWhitespaceInoDocType() {
        String html = ""<!DOCTYPE html\r\n"" +
            ""      PUBLIC \""-//W3C//DTD XHTML 1.0 Transitional//EN\""\r\n"" +
            ""      \""http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\"">"";
        Document doc = Jsoup.parse(html);
        assertEquals(""<!DOCTYPE html PUBLIC \""-//W3C//DTD XHTML 1.0 Transitional//EN\"" \""http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\"">"", doc.childNode(0).outerHtml());
    }

    @Test public void tracksErrorsWhenRequested() {
        String html = ""<p>One</p href='no'>\n<!DOCTYPE html>\n&arrgh;<font />&#33 &amp &#xD800;<br /></div><foo"";
        Parser parser = Parser.htmlParser().setTrackErrors(500);
        Document doc = Jsoup.parse(html, ""http://example.com"", parser);

        List<ParseError> errors = parser.getErrors();
        assertEquals(9, errors.size());
        assertEquals(""<1:21>: Attributes incorrectly present on end tag [/p]"", errors.get(0).toString());
        assertEquals(""<2:16>: Unexpected Doctype token [<!doctype html>] when in state [InBody]"", errors.get(1).toString());
        assertEquals(""<3:2>: Invalid character reference: invalid named reference [arrgh]"", errors.get(2).toString());
        assertEquals(""<3:16>: Tag [font] cannot be self closing; not a void tag"", errors.get(3).toString());
        assertEquals(""<3:20>: Invalid character reference: missing semicolon on [&#33]"", errors.get(4).toString());
        assertEquals(""<3:25>: Invalid character reference: missing semicolon on [&amp]"", errors.get(5).toString());
        assertEquals(""<3:34>: Invalid character reference: character [55296] outside of valid range"", errors.get(6).toString());
        assertEquals(""<3:46>: Unexpected EndTag token [</div>] when in state [InBody]"", errors.get(7).toString());
        assertEquals(""<3:51>: Unexpectedly reached end of file (EOF) in input state [TagName]"", errors.get(8).toString());
    }

    @Test public void tracksLimitedErrorsWhenRequested() {
        String html = ""<p>One</p href='no'>\n<!DOCTYPE html>\n&arrgh;<font /><br /><foo"";
        Parser parser = Parser.htmlParser().setTrackErrors(3);
        Document doc = parser.parseInput(html, ""http://example.com"");

        List<ParseError> errors = parser.getErrors();
        assertEquals(3, errors.size());
        assertEquals(""<1:21>: Attributes incorrectly present on end tag [/p]"", errors.get(0).toString());
        assertEquals(""<2:16>: Unexpected Doctype token [<!doctype html>] when in state [InBody]"", errors.get(1).toString());
        assertEquals(""<3:2>: Invalid character reference: invalid named reference [arrgh]"", errors.get(2).toString());
    }

    @Test public void noErrorsByDefault() {
        String html = ""<p>One</p href='no'>&arrgh;<font /><br /><foo"";
        Parser parser = Parser.htmlParser();
        Document doc = Jsoup.parse(html, ""http://example.com"", parser);

        List<ParseError> errors = parser.getErrors();
        assertEquals(0, errors.size());
    }

    @Test public void optionalPClosersAreNotErrors() {
        String html = ""<body><div><p>One<p>Two</div></body>"";
        Parser parser = Parser.htmlParser().setTrackErrors(128);
        Document doc = Jsoup.parse(html, """", parser);
        ParseErrorList errors = parser.getErrors();
        assertEquals(0, errors.size());
    }

    @Test public void handlesCommentsInTable() {
        String html = ""<table><tr><td>text</td><!-- Comment --></tr></table>"";
        Document node = Jsoup.parseBodyFragment(html);
        assertEquals(""<html><head></head><body><table><tbody><tr><td>text</td><!-- Comment --></tr></tbody></table></body></html>"", TextUtil.stripNewlines(node.outerHtml()));
    }

    @Test public void handlesQuotesInCommentsInScripts() {
        String html = ""<script>\n"" +
            ""  <!--\n"" +
            ""    document.write('</scr' + 'ipt>');\n"" +
            ""  // -->\n"" +
            ""</script>"";
        Document node = Jsoup.parseBodyFragment(html);
        assertEquals(""<script>\n"" +
            ""  <!--\n"" +
            ""    document.write('</scr' + 'ipt>');\n"" +
            ""  // -->\n"" +
            ""</script>"", node.body().html());
    }

    @Test public void handleNullContextInParseFragment() {
        String html = ""<ol><li>One</li></ol><p>Two</p>"";
        List<Node> nodes = Parser.parseFragment(html, null, ""http://example.com/"");
        assertEquals(1, nodes.size()); // returns <html> node (not document) -- no context means doc gets created
        assertEquals(""html"", nodes.get(0).nodeName());
        assertEquals(""<html> <head></head> <body> <ol> <li>One</li> </ol> <p>Two</p> </body> </html>"", StringUtil.normaliseWhitespace(nodes.get(0).outerHtml()));
    }

    @Test public void doesNotFindShortestMatchingEntity() {
        // previous behaviour was to identify a possible entity, then chomp down the string until a match was found.
        // (as defined in html5.) However in practise that lead to spurious matches against the author's intent.
        String html = ""One &clubsuite; &clubsuit;"";
        Document doc = Jsoup.parse(html);
        assertEquals(StringUtil.normaliseWhitespace(""One &amp;clubsuite; ‚ô£""), doc.body().html());
    }

    @Test public void relaxedBaseEntityMatchAndStrictExtendedMatch() {
        // extended entities need a ; at the end to match, base does not
        String html = ""&amp &quot &reg &icy &hopf &icy; &hopf;"";
        Document doc = Jsoup.parse(html);
        doc.outputSettings().escapeMode(Entities.EscapeMode.extended).charset(""ascii""); // modifies output only to clarify test
        assertEquals(""&amp; \"" &reg; &amp;icy &amp;hopf &icy; &hopf;"", doc.body().html());
    }

    @Test public void handlesXmlDeclarationAsBogusComment() {
        String html = ""<?xml encoding='UTF-8' ?><body>One</body>"";
        Document doc = Jsoup.parse(html);
        assertEquals(""<!--?xml encoding='UTF-8' ?--> <html> <head></head> <body> One </body> </html>"", StringUtil.normaliseWhitespace(doc.outerHtml()));
    }

    @Test public void handlesTagsInTextarea() {
        String html = ""<textarea><p>Jsoup</p></textarea>"";
        Document doc = Jsoup.parse(html);
        assertEquals(""<textarea>&lt;p&gt;Jsoup&lt;/p&gt;</textarea>"", doc.body().html());
    }

    // form tests
    @Test public void createsFormElements() {
        String html = ""<body><form><input id=1><input id=2></form></body>"";
        Document doc = Jsoup.parse(html);
        Element el = doc.select(""form"").first();

        assertTrue(el instanceof FormElement, ""Is form element"");
        FormElement form = (FormElement) el;
        Elements controls = form.elements();
        assertEquals(2, controls.size());
        assertEquals(""1"", controls.get(0).id());
        assertEquals(""2"", controls.get(1).id());
    }

    @Test public void associatedFormControlsWithDisjointForms() {
        // form gets closed, isn't parent of controls
        String html = ""<table><tr><form><input type=hidden id=1><td><input type=text id=2></td><tr></table>"";
        Document doc = Jsoup.parse(html);
        Element el = doc.select(""form"").first();

        assertTrue(el instanceof FormElement, ""Is form element"");
        FormElement form = (FormElement) el;
        Elements controls = form.elements();
        assertEquals(2, controls.size());
        assertEquals(""1"", controls.get(0).id());
        assertEquals(""2"", controls.get(1).id());

        assertEquals(""<table><tbody><tr><form></form><input type=\""hidden\"" id=\""1\""><td><input type=\""text\"" id=\""2\""></td></tr><tr></tr></tbody></table>"", TextUtil.stripNewlines(doc.body().html()));
    }

    @Test public void handlesInputInTable() {
        String h = ""<body>\n"" +
            ""<input type=\""hidden\"" name=\""a\"" value=\""\"">\n"" +
            ""<table>\n"" +
            ""<input type=\""hidden\"" name=\""b\"" value=\""\"" />\n"" +
            ""</table>\n"" +
            ""</body>"";
        Document doc = Jsoup.parse(h);
        assertEquals(1, doc.select(""table input"").size());
        assertEquals(2, doc.select(""input"").size());
    }

    @Test public void convertsImageToImg() {
        // image to img, unless in a svg. old html cruft.
        String h = ""<body><image><svg><image /></svg></body>"";
        Document doc = Jsoup.parse(h);
        assertEquals(""<img>\n<svg>\n <image />\n</svg>"", doc.body().html());
    }

    @Test public void handlesInvalidDoctypes() {
        // would previously throw invalid name exception on empty doctype
        Document doc = Jsoup.parse(""<!DOCTYPE>"");
        assertEquals(
            ""<!doctype> <html> <head></head> <body></body> </html>"",
            StringUtil.normaliseWhitespace(doc.outerHtml()));

        doc = Jsoup.parse(""<!DOCTYPE><html><p>Foo</p></html>"");
        assertEquals(
            ""<!doctype> <html> <head></head> <body> <p>Foo</p> </body> </html>"",
            StringUtil.normaliseWhitespace(doc.outerHtml()));

        doc = Jsoup.parse(""<!DOCTYPE \u0000>"");
        assertEquals(
            ""<!doctype ÔøΩ> <html> <head></head> <body></body> </html>"",
            StringUtil.normaliseWhitespace(doc.outerHtml()));
    }

    @Test public void handlesManyChildren() {
        // Arrange
        StringBuilder longBody = new StringBuilder(500000);
        for (int i = 0; i < 25000; i++) {
            longBody.append(i).append(""<br>"");
        }

        // Act
        long start = System.currentTimeMillis();
        Document doc = Parser.parseBodyFragment(longBody.toString(), """");

        // Assert
        assertEquals(50000, doc.body().childNodeSize());
        assertTrue(System.currentTimeMillis() - start < 1000);
    }

    @Test
    public void testInvalidTableContents() throws IOException {
        File in = ParseTest.getFile(""/htmltests/table-invalid-elements.html"");
        Document doc = Jsoup.parse(in, ""UTF-8"");
        doc.outputSettings().prettyPrint(true);
        String rendered = doc.toString();
        int endOfEmail = rendered.indexOf(""Comment"");
        int guarantee = rendered.indexOf(""Why am I here?"");
        assertTrue(endOfEmail > -1, ""Comment not found"");
        assertTrue(guarantee > -1, ""Search text not found"");
        assertTrue(guarantee > endOfEmail, ""Search text did not come after comment"");
    }

    @Test public void testNormalisesIsIndex() {
        Document doc = Jsoup.parse(""<body><isindex action='/submit'></body>"");
        String html = doc.outerHtml();
        assertEquals(""<form action=\""/submit\""> <hr><label>This is a searchable index. Enter search keywords: <input name=\""isindex\""></label> <hr> </form>"",
            StringUtil.normaliseWhitespace(doc.body().html()));
    }

    @Test public void testReinsertionModeForThCelss() {
        String body = ""<body> <table> <tr> <th> <table><tr><td></td></tr></table> <div> <table><tr><td></td></tr></table> </div> <div></div> <div></div> <div></div> </th> </tr> </table> </body>"";
        Document doc = Jsoup.parse(body);
        assertEquals(1, doc.body().children().size());
    }

    @Test public void testUsingSingleQuotesInQueries() {
        String body = ""<body> <div class='main'>hello</div></body>"";
        Document doc = Jsoup.parse(body);
        Elements main = doc.select(""div[class='main']"");
        assertEquals(""hello"", main.text());
    }

    @Test public void testSupportsNonAsciiTags() {
        String body = ""<aÈÄ≤ÊçóÊé®Áßª„Ç∞„É©„Éï>Yes</aÈÄ≤ÊçóÊé®Áßª„Ç∞„É©„Éï><b—Ä—É—Å—Å–∫–∏–π-—Ç—ç–≥>Correct</<b—Ä—É—Å—Å–∫–∏–π-—Ç—ç–≥>"";
        Document doc = Jsoup.parse(body);
        Elements els = doc.select(""aÈÄ≤ÊçóÊé®Áßª„Ç∞„É©„Éï"");
        assertEquals(""Yes"", els.text());
        els = doc.select(""b—Ä—É—Å—Å–∫–∏–π-—Ç—ç–≥"");
        assertEquals(""Correct"", els.text());
    }

    @Test public void testSupportsPartiallyNonAsciiTags() {
        String body = ""<div>Check</div√°>"";
        Document doc = Jsoup.parse(body);
        Elements els = doc.select(""div"");
        assertEquals(""Check"", els.text());
    }

    @Test public void testFragment() {
        // make sure when parsing a body fragment, a script tag at start goes into the body
        String html =
            ""<script type=\""text/javascript\"">console.log('foo');</script>\n"" +
                ""<div id=\""somecontent\"">some content</div>\n"" +
                ""<script type=\""text/javascript\"">console.log('bar');</script>"";

        Document body = Jsoup.parseBodyFragment(html);
        assertEquals(""<script type=\""text/javascript\"">console.log('foo');</script>\n"" +
            ""<div id=\""somecontent\"">\n"" +
            "" some content\n"" +
            ""</div>\n"" +
            ""<script type=\""text/javascript\"">console.log('bar');</script>"", body.body().html());
    }

    @Test public void testHtmlLowerCase() {
        String html = ""<!doctype HTML><DIV ID=1>One</DIV>"";
        Document doc = Jsoup.parse(html);
        assertEquals(""<!doctype html> <html> <head></head> <body> <div id=\""1\""> One </div> </body> </html>"", StringUtil.normaliseWhitespace(doc.outerHtml()));

        Element div = doc.selectFirst(""#1"");
        div.after(""<TaG>One</TaG>"");
        assertEquals(""<tag>One</tag>"", TextUtil.stripNewlines(div.nextElementSibling().outerHtml()));
    }

    @Test public void testHtmlLowerCaseAttributesOfVoidTags() {
        String html = ""<!doctype HTML><IMG ALT=One></DIV>"";
        Document doc = Jsoup.parse(html);
        assertEquals(""<!doctype html> <html> <head></head> <body> <img alt=\""One\""> </body> </html>"", StringUtil.normaliseWhitespace(doc.outerHtml()));
    }

    @Test public void testHtmlLowerCaseAttributesForm() {
        String html = ""<form NAME=one>"";
        Document doc = Jsoup.parse(html);
        assertEquals(""<form name=\""one\""></form>"", StringUtil.normaliseWhitespace(doc.body().html()));
    }

    @Test public void canPreserveTagCase() {
        Parser parser = Parser.htmlParser();
        parser.settings(new ParseSettings(true, false));
        Document doc = parser.parseInput(""<div id=1><SPAN ID=2>"", """");
        assertEquals(""<html> <head></head> <body> <div id=\""1\""> <SPAN id=\""2\""></SPAN> </div> </body> </html>"", StringUtil.normaliseWhitespace(doc.outerHtml()));

        Element div = doc.selectFirst(""#1"");
        div.after(""<TaG ID=one>One</TaG>"");
        assertEquals(""<TaG id=\""one\"">One</TaG>"", TextUtil.stripNewlines(div.nextElementSibling().outerHtml()));
    }

    @Test public void canPreserveAttributeCase() {
        Parser parser = Parser.htmlParser();
        parser.settings(new ParseSettings(false, true));
        Document doc = parser.parseInput(""<div id=1><SPAN ID=2>"", """");
        assertEquals(""<html> <head></head> <body> <div id=\""1\""> <span ID=\""2\""></span> </div> </body> </html>"", StringUtil.normaliseWhitespace(doc.outerHtml()));

        Element div = doc.selectFirst(""#1"");
        div.after(""<TaG ID=one>One</TaG>"");
        assertEquals(""<tag ID=\""one\"">One</tag>"", TextUtil.stripNewlines(div.nextElementSibling().outerHtml()));
    }

    @Test public void canPreserveBothCase() {
        Parser parser = Parser.htmlParser();
        parser.settings(new ParseSettings(true, true));
        Document doc = parser.parseInput(""<div id=1><SPAN ID=2>"", """");
        assertEquals(""<html> <head></head> <body> <div id=\""1\""> <SPAN ID=\""2\""></SPAN> </div> </body> </html>"", StringUtil.normaliseWhitespace(doc.outerHtml()));

        Element div = doc.selectFirst(""#1"");
        div.after(""<TaG ID=one>One</TaG>"");
        assertEquals(""<TaG ID=\""one\"">One</TaG>"", TextUtil.stripNewlines(div.nextElementSibling().outerHtml()));
    }

    @Test public void handlesControlCodeInAttributeName() {
        Document doc = Jsoup.parse(""<p><a \06=foo>One</a><a/\06=bar><a foo\06=bar>Two</a></p>"");
        assertEquals(""<p><a>One</a><a></a><a foo=\""bar\"">Two</a></p>"", doc.body().html());
    }

    @Test public void caseSensitiveParseTree() {
        String html = ""<r><X>A</X><y>B</y></r>"";
        Parser parser = Parser.htmlParser();
        parser.settings(preserveCase);
        Document doc = parser.parseInput(html, """");
        assertEquals(""<r> <X> A </X> <y> B </y> </r>"", StringUtil.normaliseWhitespace(doc.body().html()));
    }

    @Test public void caseInsensitiveParseTree() {
        String html = ""<r><X>A</X><y>B</y></r>"";
        Parser parser = Parser.htmlParser();
        Document doc = parser.parseInput(html, """");
        assertEquals(""<r> <x> A </x> <y> B </y> </r>"", StringUtil.normaliseWhitespace(doc.body().html()));
    }

    @Test public void preservedCaseLinksCantNest() {
        String html = ""<A>ONE <A>Two</A></A>"";
        Document doc = Parser.htmlParser()
            .settings(preserveCase)
            .parseInput(html, """");
        //assertEquals(""<A>ONE </A><A>Two</A>"", StringUtil.normaliseWhitespace(doc.body().html()));
        assertEquals(""<A>ONE </A><A>Two</A>"", doc.body().html());
    }

    @Test public void normalizesDiscordantTags() {
        Document document = Jsoup.parse(""<div>test</DIV><p></p>"");
        assertEquals(""<div>\n test\n</div>\n<p></p>"", document.body().html());
    }

    @Test public void selfClosingVoidIsNotAnError() {
        String html = ""<p>test<br/>test<br/></p>"";
        Parser parser = Parser.htmlParser().setTrackErrors(5);
        parser.parseInput(html, """");
        assertEquals(0, parser.getErrors().size());

        assertTrue(Jsoup.isValid(html, Safelist.basic()));
        String clean = Jsoup.clean(html, Safelist.basic());
        assertEquals(""<p>test<br>test<br></p>"", clean);
    }

    @Test public void selfClosingOnNonvoidIsError() {
        String html = ""<p>test</p>\n\n<div /><div>Two</div>"";
        Parser parser = Parser.htmlParser().setTrackErrors(5);
        parser.parseInput(html, """");
        assertEquals(1, parser.getErrors().size());
        assertEquals(""<3:8>: Tag [div] cannot be self closing; not a void tag"", parser.getErrors().get(0).toString());

        assertFalse(Jsoup.isValid(html, Safelist.relaxed()));
        String clean = Jsoup.clean(html, Safelist.relaxed());
        assertEquals(""<p>test</p> <div></div> <div> Two </div>"", StringUtil.normaliseWhitespace(clean));
    }

    @Test public void testTemplateInsideTable() throws IOException {
        File in = ParseTest.getFile(""/htmltests/table-polymer-template.html"");
        Document doc = Jsoup.parse(in, ""UTF-8"");
        doc.outputSettings().prettyPrint(true);

        Elements templates = doc.body().getElementsByTag(""template"");
        for (Element template : templates) {
            assertTrue(template.childNodes().size() > 1);
        }
    }

    @Test public void testHandlesDeepSpans() {
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < 200; i++) {
            sb.append(""<span>"");
        }

        sb.append(""<p>One</p>"");

        Document doc = Jsoup.parse(sb.toString());
        assertEquals(200, doc.select(""span"").size());
        assertEquals(1, doc.select(""p"").size());
    }

    @Test public void commentAtEnd() {
        Document doc = Jsoup.parse(""<!"");
        assertTrue(doc.childNode(0) instanceof Comment);
    }

    @Test public void preSkipsFirstNewline() {
        Document doc = Jsoup.parse(""<pre>\n\nOne\nTwo\n</pre>"");
        Element pre = doc.selectFirst(""pre"");
        assertEquals(""One\nTwo"", pre.text());
        assertEquals(""\nOne\nTwo\n"", pre.wholeText());
    }

    @Test public void handlesXmlDeclAndCommentsBeforeDoctype() throws IOException {
        File in = ParseTest.getFile(""/htmltests/comments.html"");
        Document doc = Jsoup.parse(in, ""UTF-8"");

        assertEquals(""<!--?xml version=\""1.0\"" encoding=\""utf-8\""?--><!-- so --> <!DOCTYPE html PUBLIC \""-//W3C//DTD XHTML 1.0 Transitional//EN\"" \""http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\""><!-- what --> <html xml:lang=\""en\"" lang=\""en\"" xmlns=\""http://www.w3.org/1999/xhtml\""><!-- now --> <head><!-- then --> <meta http-equiv=\""Content-type\"" content=\""text/html; charset=utf-8\""> <title>A Certain Kind of Test</title> </head> <body> <h1>Hello</h1>h1&gt; (There is a UTF8 hidden BOM at the top of this file.) </body> </html>"",
            StringUtil.normaliseWhitespace(doc.html()));

        assertEquals(""A Certain Kind of Test"", doc.head().select(""title"").text());
    }

    @Test public void fallbackToUtfIfCantEncode() throws IOException {
        // that charset can't be encoded, so make sure we flip to utf

        String in = ""<html><meta charset=\""ISO-2022-CN\""/>One</html>"";
        Document doc = Jsoup.parse(new ByteArrayInputStream(in.getBytes()), null, """");

        assertEquals(""UTF-8"", doc.charset().name());
        assertEquals(""One"", doc.text());

        String html = doc.outerHtml();
        assertEquals(""<html><head><meta charset=\""UTF-8\""></head><body>One</body></html>"", TextUtil.stripNewlines(html));
    }

    @Test public void characterReaderBuffer() throws IOException {
        File in = ParseTest.getFile(""/htmltests/character-reader-buffer.html.gz"");
        Document doc = Jsoup.parse(in, ""UTF-8"");

        String expectedHref = ""http://www.domain.com/path?param_one=value&param_two=value"";

        Elements links = doc.select(""a"");
        assertEquals(2, links.size());
        assertEquals(expectedHref, links.get(0).attr(""href"")); // passes
        assertEquals(expectedHref, links.get(1).attr(""href"")); // fails, ""but was:<...ath?param_one=value&[]_two-value>""
    }

    @Test
    public void selfClosingTextAreaDoesntLeaveDroppings() {
        // https://github.com/jhy/jsoup/issues/1220
        Document doc = Jsoup.parse(""<div><div><textarea/></div></div>"");
        assertFalse(doc.body().html().contains(""&lt;""));
        assertFalse(doc.body().html().contains(""&gt;""));
        assertEquals(""<div><div><textarea></textarea></div></div>"", TextUtil.stripNewlines(doc.body().html()));
    }

    @Test
    public void testNoSpuriousSpace() {
        Document doc = Jsoup.parse(""Just<a>One</a><a>Two</a>"");
        assertEquals(""Just<a>One</a><a>Two</a>"", doc.body().html());
        assertEquals(""JustOneTwo"", doc.body().text());
    }

    @Test
    public void pTagsGetIndented() {
        String html = ""<div><p><a href=one>One</a><p><a href=two>Two</a></p></div>"";
        Document doc = Jsoup.parse(html);
        assertEquals(""<div>\n"" +
            "" <p><a href=\""one\"">One</a></p>\n"" +
            "" <p><a href=\""two\"">Two</a></p>\n"" +
            ""</div>"", doc.body().html());
    }

    @Test
    public void indentRegardlessOfCase() {
        String html = ""<p>1</p><P>2</P>"";
        Document doc = Jsoup.parse(html);
        assertEquals(
            ""<body>\n"" +
            "" <p>1</p>\n"" +
            "" <p>2</p>\n"" +
            ""</body>"", doc.body().outerHtml());

        Document caseDoc = Jsoup.parse(html, """", Parser.htmlParser().settings(preserveCase));
        assertEquals(
            ""<body>\n"" +
            "" <p>1</p>\n"" +
            "" <P>2</P>\n"" +
            ""</body>"", caseDoc.body().outerHtml());
    }

    @Test
    public void testH20() {
        // https://github.com/jhy/jsoup/issues/731
        String html = ""H<sub>2</sub>O"";
        String clean = Jsoup.clean(html, Safelist.basic());
        assertEquals(""H<sub>2</sub>O"", clean);

        Document doc = Jsoup.parse(html);
        assertEquals(""H2O"", doc.text());
    }

    @Test
    public void testUNewlines() {
        // https://github.com/jhy/jsoup/issues/851
        String html = ""t<u>es</u>t <b>on</b> <i>f</i><u>ir</u>e"";
        String clean = Jsoup.clean(html, Safelist.basic());
        assertEquals(""t<u>es</u>t <b>on</b> <i>f</i><u>ir</u>e"", clean);

        Document doc = Jsoup.parse(html);
        assertEquals(""test on fire"", doc.text());
    }

    @Test public void testFarsi() {
        // https://github.com/jhy/jsoup/issues/1227
        String text = ""ŸÜ€åŸÖŸá\u200Cÿ¥ÿ®"";
        Document doc = Jsoup.parse(""<p>"" + text);
        assertEquals(text, doc.text());
    }

    @Test public void testStartOptGroup() {
        // https://github.com/jhy/jsoup/issues/1313
        String html = ""<select>\n"" +
            ""  <optgroup label=\""a\"">\n"" +
            ""  <option>one\n"" +
            ""  <option>two\n"" +
            ""  <option>three\n"" +
            ""  <optgroup label=\""b\"">\n"" +
            ""  <option>four\n"" +
            ""  <option>fix\n"" +
            ""  <option>six\n"" +
            ""</select>"";
        Document doc = Jsoup.parse(html);
        Element select = doc.selectFirst(""select"");
        assertEquals(2, select.childrenSize());

        assertEquals(""<optgroup label=\""a\""> <option>one </option><option>two </option><option>three </option></optgroup><optgroup label=\""b\""> <option>four </option><option>fix </option><option>six </option></optgroup>"", select.html());
    }

    @Test public void readerClosedAfterParse() {
        Document doc = Jsoup.parse(""Hello"");
        TreeBuilder treeBuilder = doc.parser().getTreeBuilder();
        assertNull(treeBuilder.reader);
        assertNull(treeBuilder.tokeniser);
    }

    @Test public void scriptInDataNode() {
        Document doc = Jsoup.parse(""<script>Hello</script><style>There</style>"");
        assertTrue(doc.selectFirst(""script"").childNode(0) instanceof DataNode);
        assertTrue(doc.selectFirst(""style"").childNode(0) instanceof DataNode);

        doc = Jsoup.parse(""<SCRIPT>Hello</SCRIPT><STYLE>There</STYLE>"", """", Parser.htmlParser().settings(preserveCase));
        assertTrue(doc.selectFirst(""script"").childNode(0) instanceof DataNode);
        assertTrue(doc.selectFirst(""style"").childNode(0) instanceof DataNode);
    }

    @Test public void textareaValue() {
        String html = ""<TEXTAREA>YES YES</TEXTAREA>"";
        Document doc = Jsoup.parse(html);
        assertEquals(""YES YES"", doc.selectFirst(""textarea"").val());

        doc = Jsoup.parse(html, """", Parser.htmlParser().settings(preserveCase));
        assertEquals(""YES YES"", doc.selectFirst(""textarea"").val());
    }

    @Test public void preserveWhitespaceInHead() {
        String html = ""\n<!doctype html>\n<html>\n<head>\n<title>Hello</title>\n</head>\n<body>\n<p>One</p>\n</body>\n</html>\n"";
        Document doc = Jsoup.parse(html);
        doc.outputSettings().prettyPrint(false);
        assertEquals(""<!doctype html>\n<html>\n<head>\n<title>Hello</title>\n</head>\n<body>\n<p>One</p>\n</body>\n</html>\n"", doc.outerHtml());
    }

    @Test public void handleContentAfterBody() {
        String html = ""<body>One</body>  <p>Hello!</p></html> <p>There</p>"";
        Document doc = Jsoup.parse(html);
        doc.outputSettings().prettyPrint(false);
        assertEquals(""<html><head></head><body>One<p>Hello!</p><p>There</p></body>  </html> "", doc.outerHtml());
    }

    @Test public void preservesTabs() {
        // testcase to demonstrate tab retention - https://github.com/jhy/jsoup/issues/1240
        String html = ""<pre>One\tTwo</pre><span>\tThree\tFour</span>"";
        Document doc = Jsoup.parse(html);

        Element pre = doc.selectFirst(""pre"");
        Element span = doc.selectFirst(""span"");

        assertEquals(""One\tTwo"", pre.text());
        assertEquals(""Three Four"", span.text()); // normalized, including overall trim
        assertEquals(""\tThree\tFour"", span.wholeText()); // text normalizes, wholeText retains original spaces incl tabs
        assertEquals(""One\tTwo Three Four"", doc.body().text());

        assertEquals(""<pre>One\tTwo</pre><span> Three Four</span>"", doc.body().html()); // html output provides normalized space, incl tab in pre but not in span

        doc.outputSettings().prettyPrint(false);
        assertEquals(html, doc.body().html()); // disabling pretty-printing - round-trips the tab throughout, as no normalization occurs
    }

    @Test void wholeTextTreatsBRasNewline() {
        String html = ""<div>\nOne<br>Two <p>Three<br>Four</div>"";
        Document doc = Jsoup.parse(html);
        Element div = doc.selectFirst(""div"");
        assertNotNull(div);
        assertEquals(""\nOne\nTwo Three\nFour"", div.wholeText());
        assertEquals(""\nOne\nTwo "", div.wholeOwnText());
    }

    @Test public void canDetectAutomaticallyAddedElements() {
        String bare = ""<script>One</script>"";
        String full = ""<html><head><title>Check</title></head><body><p>One</p></body></html>"";

        assertTrue(didAddElements(bare));
        assertFalse(didAddElements(full));
    }

    private boolean didAddElements(String input) {
        // two passes, one as XML and one as HTML. XML does not vivify missing/optional tags
        Document html = Jsoup.parse(input);
        Document xml = Jsoup.parse(input, """", Parser.xmlParser());

        int htmlElementCount = html.getAllElements().size();
        int xmlElementCount = xml.getAllElements().size();
        return htmlElementCount > xmlElementCount;
    }

    @Test public void canSetHtmlOnCreatedTableElements() {
        // https://github.com/jhy/jsoup/issues/1603
        Element element = new Element(""tr"");
        element.html(""<tr><td>One</td></tr>"");
        assertEquals(""<tr>\n <tr>\n  <td>One</td>\n </tr>\n</tr>"", element.outerHtml());
    }

    @Test public void parseFragmentOnCreatedDocument() {
        // https://github.com/jhy/jsoup/issues/1601
        String bareFragment = ""<h2>text</h2>"";
        List<Node> nodes = new Document("""").parser().parseFragmentInput(bareFragment, new Element(""p""), """");
        assertEquals(1, nodes.size());
        Node node = nodes.get(0);
        assertEquals(""h2"", node.nodeName());
        assertEquals(""<p><h2>text</h2></p>"", node.parent().outerHtml());
    }

    @Test public void nestedPFragments() {
        // https://github.com/jhy/jsoup/issues/1602
        String bareFragment = ""<p></p><a></a>"";
        List<Node> nodes = new Document("""").parser().parseFragmentInput(bareFragment, new Element(""p""), """");
        assertEquals(2, nodes.size());
        Node node = nodes.get(0);
        assertEquals(""<p><p></p><a></a></p>"", node.parent().outerHtml()); // mis-nested because fragment forced into the element, OK
    }

    @Test public void nestedAnchorAdoption() {
        // https://github.com/jhy/jsoup/issues/1608
        String html = ""<a>\n<b>\n<div>\n<a>test</a>\n</div>\n</b>\n</a>"";
        Document doc = Jsoup.parse(html);
        assertNotNull(doc);
        assertEquals(""<a> <b> </b></a><b><div><a> </a><a>test</a></div> </b>"", TextUtil.stripNewlines(doc.body().html()));
    }

    @Test public void tagsMustStartWithAscii() {
        // https://github.com/jhy/jsoup/issues/1006
        String[] valid = {""a‰∏Ä"", ""a‰ºöÂëòÊåÇÂçïÈáëÈ¢ù5"", ""table(‚ïØ¬∞‚ñ°¬∞)‚ïØ""};
        String[] invalid = {""‰∏Ä"", ""‰ºöÂëòÊåÇÂçïÈáëÈ¢ù5"", ""(‚ïØ¬∞‚ñ°¬∞)‚ïØ""};

        for (String tag : valid) {
            Document doc = Jsoup.parse(""<"" + tag + "">Text</"" + tag + "">"");
            Elements els = doc.getElementsByTag(tag);
            assertEquals(1, els.size());
            assertEquals(tag, els.get(0).tagName());
            assertEquals(""Text"", els.get(0).text());
        }

        for (String tag : invalid) {
            Document doc = Jsoup.parse(""<"" + tag + "">Text</"" + tag + "">"");
            Elements els = doc.getElementsByTag(tag);
            assertEquals(0, els.size());
            assertEquals(""&lt;"" + tag + ""&gt;Text<!--/"" + tag + ""-->"", doc.body().html());
        }
    }

    @Test void htmlOutputCorrectsInvalidAttributeNames() {
        String html = ""<body style=\""color: red\"" \"" name\""><div =\""\""></div></body>"";
        Document doc = Jsoup.parse(html);
        assertEquals(Document.OutputSettings.Syntax.html, doc.outputSettings().syntax());

        String out = doc.body().outerHtml();
        assertEquals(""<body style=\""color: red\"" name>\n <div></div>\n</body>"", out);
    }

    @Test void templateInHead() {
        // https://try.jsoup.org/~EGp3UZxQe503TJDHQEQEzm8IeUc
        String html = ""<head><template id=1><meta name=tmpl></template><title>Test</title><style>One</style></head><body><p>Two</p>"";
        Document doc = Jsoup.parse(html);

        String want = ""<html><head><template id=\""1\""><meta name=\""tmpl\""></template><title>Test</title><style>One</style></head><body><p>Two</p></body></html>"";
        assertEquals(want, TextUtil.stripNewlines(doc.html()));

        Elements template = doc.select(""template#1"");
        template.select(""meta"").attr(""content"", ""Yes"");
        template.unwrap();

        want = ""<html><head><meta name=\""tmpl\"" content=\""Yes\""><title>Test</title><style>One</style></head><body><p>Two</p></body></html>"";
        assertEquals(want, TextUtil.stripNewlines(doc.html()));
    }

    @Test void nestedTemplateInBody() {
        String html = ""<body><template id=1><table><tr><template id=2><td>One</td><td>Two</td></template></tr></template></body>"";
        Document doc = Jsoup.parse(html);

        String want = ""<html><head></head><body><template id=\""1\""><table><tbody><tr><template id=\""2\""><td>One</td><td>Two</td></template></tr></tbody></table></template></body></html>"";
        assertEquals(want, TextUtil.stripNewlines(doc.html()));

        // todo - will be nice to add some simpler template element handling like clone children etc?
        Element tmplTbl = doc.selectFirst(""template#1"");
        Element tmplRow = doc.selectFirst(""template#2"");
        assertNotNull(tmplRow);
        assertNotNull(tmplTbl);
        tmplRow.appendChild(tmplRow.clone());
        doc.select(""template"").unwrap();

        want = ""<html><head></head><body><table><tbody><tr><td>One</td><td>Two</td><td>One</td><td>Two</td></tr></tbody></table></body></html>"";
        assertEquals(want, TextUtil.stripNewlines(doc.html()));
    }

    @Test void canSelectIntoTemplate() {
        String html = ""<body><div><template><p>Hello</p>"";
        Document doc = Jsoup.parse(html);
        String want = ""<html><head></head><body><div><template><p>Hello</p></template></div></body></html>"";
        assertEquals(want, TextUtil.stripNewlines(doc.html()));

        Element p = doc.selectFirst(""div p"");
        Element p1 = doc.selectFirst(""template :containsOwn(Hello)"");
        assertEquals(""p"", p.normalName());
        assertEquals(p, p1);
    }

    @Test void tableRowFragment() {
        Document doc = Jsoup.parse(""<body><table></table></body"");
        String html = ""<tr><td><img></td></tr>"";
        Element table = doc.selectFirst(""table"");
        table.html(html); // invokes the fragment parser with table as context
        String want = ""<tbody><tr><td><img></td></tr></tbody>"";
        assertEquals(want, TextUtil.stripNewlines(table.html()));
        want = ""<table><tbody><tr><td><img></td></tr></tbody></table>"";
        assertEquals(want, TextUtil.stripNewlines(doc.body().html()));
    }

    @Test void templateTableRowFragment() {
        // https://github.com/jhy/jsoup/issues/1409 (per the fragment <tr> use case)
        Document doc = Jsoup.parse(""<body><table><template></template></table></body"");
        String html = ""<tr><td><img></td></tr>"";
        Element tmpl = doc.selectFirst(""template"");
        tmpl.html(html); // invokes the fragment parser with template as context
        String want = ""<tr><td><img></td></tr>"";
        assertEquals(want, TextUtil.stripNewlines(tmpl.html()));
        tmpl.unwrap();

        want = ""<html><head></head><body><table><tr><td><img></td></tr></table></body></html>"";
        assertEquals(want, TextUtil.stripNewlines(doc.html()));
    }

    @Test void templateNotInTableRowFragment() {
        // https://github.com/jhy/jsoup/issues/1409 (per the fragment <tr> use case)
        Document doc = Jsoup.parse(""<body><template></template></body"");
        String html = ""<tr><td><img></td></tr>"";
        Element tmpl = doc.selectFirst(""template"");
        tmpl.html(html); // invokes the fragment parser with template as context
        String want = ""<tr><td><img></td></tr>"";
        assertEquals(want, TextUtil.stripNewlines(tmpl.html()));
        tmpl.unwrap();

        want = ""<html><head></head><body><tr><td><img></td></tr></body></html>"";
        assertEquals(want, TextUtil.stripNewlines(doc.html()));
    }

    @Test void templateFragment() {
        // https://github.com/jhy/jsoup/issues/1315
        String html = ""<template id=\""lorem-ipsum\""><tr><td>Lorem</td><td>Ipsum</td></tr></template>"";
        Document frag = Jsoup.parseBodyFragment(html);
        String want = ""<template id=\""lorem-ipsum\""><tr><td>Lorem</td><td>Ipsum</td></tr></template>"";
        assertEquals(want, TextUtil.stripNewlines(frag.body().html()));
    }

    @Test void templateInferredForm() {
        // https://github.com/jhy/jsoup/issues/1637 | https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=38987
        Document doc = Jsoup.parse(""<template><isindex action>"");
        assertNotNull(doc);
        assertEquals(""<template><form><hr><label>This is a searchable index. Enter search keywords: <input name=\""isindex\""></label><hr></form></template>"",
            TextUtil.stripNewlines(doc.head().html()));
    }

    @Test void trimNormalizeElementNamesInBuilder() {
        // https://github.com/jhy/jsoup/issues/1637 | https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=38983
        // This is interesting - in TB state, the element name was ""template\u001E"", so no name checks matched. Then,
        // when the Element is created, the name got normalized to ""template"" and so looked like there should be a
        // template on the stack during resetInsertionMode for the select.
        // The issue was that the normalization in Tag.valueOf did a trim which the Token.Tag did not
        Document doc = Jsoup.parse(""<template\u001E<select<input<"");
        assertNotNull(doc);
        assertEquals(""<template><select></select><input>&lt;</template>"",
            TextUtil.stripNewlines(doc.head().html()));
    }
}
"
jhy/jsoup,src/test/java/org/jsoup/parser/TokenQueueTest.java,"package org.jsoup.parser;

import org.jsoup.Jsoup;
import org.jsoup.nodes.Document;
import org.junit.jupiter.api.Test;

import java.util.regex.Pattern;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.fail;

/**
 * Token queue tests.
 */
public class TokenQueueTest {
    @Test public void chompBalanced() {
        TokenQueue tq = new TokenQueue("":contains(one (two) three) four"");
        String pre = tq.consumeTo(""("");
        String guts = tq.chompBalanced('(', ')');
        String remainder = tq.remainder();

        assertEquals("":contains"", pre);
        assertEquals(""one (two) three"", guts);
        assertEquals("" four"", remainder);
    }

    @Test public void chompEscapedBalanced() {
        TokenQueue tq = new TokenQueue("":contains(one (two) \\( \\) \\) three) four"");
        String pre = tq.consumeTo(""("");
        String guts = tq.chompBalanced('(', ')');
        String remainder = tq.remainder();

        assertEquals("":contains"", pre);
        assertEquals(""one (two) \\( \\) \\) three"", guts);
        assertEquals(""one (two) ( ) ) three"", TokenQueue.unescape(guts));
        assertEquals("" four"", remainder);
    }

    @Test public void chompBalancedMatchesAsMuchAsPossible() {
        TokenQueue tq = new TokenQueue(""unbalanced(something(or another)) else"");
        tq.consumeTo(""("");
        String match = tq.chompBalanced('(', ')');
        assertEquals(""something(or another)"", match);
    }

    @Test public void unescape() {
        assertEquals(""one ( ) \\"", TokenQueue.unescape(""one \\( \\) \\\\""));
    }

    @Test public void chompToIgnoreCase() {
        String t = ""<textarea>one < two </TEXTarea>"";
        TokenQueue tq = new TokenQueue(t);
        String data = tq.chompToIgnoreCase(""</textarea"");
        assertEquals(""<textarea>one < two "", data);

        tq = new TokenQueue(""<textarea> one two < three </oops>"");
        data = tq.chompToIgnoreCase(""</textarea"");
        assertEquals(""<textarea> one two < three </oops>"", data);
    }

    @Test public void addFirst() {
        TokenQueue tq = new TokenQueue(""One Two"");
        tq.consumeWord();
        tq.addFirst(""Three"");
        assertEquals(""Three Two"", tq.remainder());
    }


    @Test public void consumeToIgnoreSecondCallTest() {
        String t = ""<textarea>one < two </TEXTarea> third </TEXTarea>"";
        TokenQueue tq = new TokenQueue(t);
        String data = tq.chompToIgnoreCase(""</textarea>"");
        assertEquals(""<textarea>one < two "", data);

        data = tq.chompToIgnoreCase(""</textarea>"");
        assertEquals("" third "", data);
    }

    @Test public void testNestedQuotes() {
        validateNestedQuotes(""<html><body><a id=\""identifier\"" onclick=\""func('arg')\"" /></body></html>"", ""a[onclick*=\""('arg\""]"");
        validateNestedQuotes(""<html><body><a id=\""identifier\"" onclick=func('arg') /></body></html>"", ""a[onclick*=\""('arg\""]"");
        validateNestedQuotes(""<html><body><a id=\""identifier\"" onclick='func(\""arg\"")' /></body></html>"", ""a[onclick*='(\""arg']"");
        validateNestedQuotes(""<html><body><a id=\""identifier\"" onclick=func(\""arg\"") /></body></html>"", ""a[onclick*='(\""arg']"");
    }

    private static void validateNestedQuotes(String html, String selector) {
        assertEquals(""#identifier"", Jsoup.parse(html).select(selector).first().cssSelector());
    }

    @Test
    public void chompBalancedThrowIllegalArgumentException() {
        try {
            TokenQueue tq = new TokenQueue(""unbalanced(something(or another)) else"");
            tq.consumeTo(""("");
            tq.chompBalanced('(', '+');
            fail(""should have thrown IllegalArgumentException"");
        } catch (IllegalArgumentException expected) {
            assertEquals(""Did not find balanced marker at 'something(or another)) else'"", expected.getMessage());
        }
    }

    @Test
    public void testQuotedPattern() {
        final Document doc = Jsoup.parse(""<div>\\) foo1</div><div>( foo2</div><div>1) foo3</div>"");
        assertEquals(""\n\\) foo1"",doc.select(""div:matches("" + Pattern.quote(""\\)"") + "")"").get(0).childNode(0).toString());
        assertEquals(""\n( foo2"",doc.select(""div:matches("" + Pattern.quote(""("") + "")"").get(0).childNode(0).toString());
        assertEquals(""\n1) foo3"",doc.select(""div:matches("" + Pattern.quote(""1)"") + "")"").get(0).childNode(0).toString());
    }
}
"
jhy/jsoup,src/test/java/org/jsoup/integration/SessionTest.java,"package org.jsoup.integration;

import org.jsoup.Connection;
import org.jsoup.Jsoup;
import org.jsoup.integration.servlets.CookieServlet;
import org.jsoup.integration.servlets.EchoServlet;
import org.jsoup.integration.servlets.FileServlet;
import org.jsoup.nodes.Document;
import org.jsoup.parser.Parser;
import org.jsoup.select.Elements;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Test;

import java.io.IOException;
import java.util.Map;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertTrue;

public class SessionTest {
    @BeforeAll
    public static void setUp() {
        TestServer.start();
    }

    private static Elements keyEls(String key, Document doc) {
        return doc.select(""th:contains("" + key + "") + td"");
    }

    private static String keyText(String key, Document doc) {
        return doc.selectFirst(""th:contains("" + key + "") + td"").text();
    }

    @Test
    public void testPathScopedCookies() throws IOException {
        final Connection session = Jsoup.newSession();
        final String userAgent = ""Jsoup Testalot v0.1"";

        session.userAgent(userAgent);
        session.url(CookieServlet.Url);

        // should have no cookies:
        Connection con1 = session.newRequest();
        Document doc1 = con1.get();
        assertEquals(0, doc1.select(""table tr"").size()); // none sent to servlet

        // set the cookies
        Connection con2 = session.newRequest().data(CookieServlet.SetCookiesParam, ""1"");
        Document doc2 = con2.get();
        assertEquals(0, doc2.select(""table tr"").size());  // none sent to servlet - we just got them!
        Map<String, String> cookies = con2.response().cookies(); // simple cookie response, all named ""One"", so should be first sent
        assertEquals(1, cookies.size());
        assertEquals(""Root"", cookies.get(""One""));

        // todo - interrogate cookie-store

        // check that they are sent and filtered to the right path
        Connection con3 = session.newRequest();
        Document doc3 = con3.get();
        assertCookieServlet(doc3);

        Document echo = session.newRequest().url(EchoServlet.Url).get();
        assertEchoServlet(echo);
        assertEquals(userAgent, keyText(""User-Agent"", echo)); // check that customer user agent sent on session arrived

        // check that cookies aren't set out of the session
        Document doc4 = Jsoup.newSession().url(CookieServlet.Url).get();
        assertEquals(0, doc4.select(""table tr"").size()); // none sent to servlet

        // check can add local ones also
        Document doc5 = session.newRequest().cookie(""Bar"", ""Qux"").get();
        Elements doc5Bar = keyEls(""Bar"", doc5);
        assertEquals(""Qux"", doc5Bar.first().text());
    }

    // validate that only cookies set by cookie servlet get to the cookie servlet path
    private void assertCookieServlet(Document doc) {
        assertEquals(2, doc.select(""table tr"").size());  // two of three sent to servlet (/ and /CookieServlet)
        Elements doc3Els = keyEls(""One"", doc);
        assertEquals(2, doc3Els.size());
        assertEquals(""CookieServlet"", doc3Els.get(0).text()); // ordered by most specific path
        assertEquals(""Root"", doc3Els.get(1).text()); // ordered by most specific path
    }

    // validate that only for echo servlet
    private void assertEchoServlet(Document doc) {
        Elements echoEls = keyEls(""Cookie: One"", doc);  // two of three sent to servlet (/ and /EchoServlet)
        assertEquals(2, echoEls.size());
        assertEquals(""EchoServlet"", echoEls.get(0).text()); // ordered by most specific path - /Echo
        assertEquals(""Root"", echoEls.get(1).text()); // ordered by most specific path - /
    }

    @Test
    public void testPathScopedCookiesOnRedirect() throws IOException {
        Connection session = Jsoup.newSession();

        Document doc1 = session.newRequest()
            .url(CookieServlet.Url)
            .data(CookieServlet.LocationParam, EchoServlet.Url)
            .data(CookieServlet.SetCookiesParam, ""1"")
            .get();

        // we should be redirected to the echo servlet with cookies
        assertEquals(EchoServlet.Url, doc1.location());
        assertEchoServlet(doc1); // checks we only have /echo cookies

        Document doc2 = session.newRequest()
            .url(EchoServlet.Url)
            .get();
        assertEchoServlet(doc2); // test retained in session

        Document doc3 = session.newRequest()
            .url(CookieServlet.Url)
            .get();
        assertCookieServlet(doc3); // and so were the /cookie cookies
    }

    @Test
    public void testCanChangeParsers() throws IOException {
        Connection session = Jsoup.newSession().parser(Parser.xmlParser());

        String xmlUrl = FileServlet.urlTo(""/htmltests/xml-test.xml"");
        String xmlVal = ""<doc><val>One<val>Two</val>Three</val></doc>\n"";

        Document doc1 = session.newRequest().url(xmlUrl).get();
        assertEquals(xmlVal, doc1.html()); // not HTML normed, used XML parser

        Document doc2 = session.newRequest().parser(Parser.htmlParser()).url(xmlUrl).get();
        assertTrue(doc2.html().startsWith(""<html>""));

        Document doc3 = session.newRequest().url(xmlUrl).get();
        assertEquals(xmlVal, doc3.html()); // did not blow away xml default
    }
}
"
jhy/jsoup,src/test/java/org/jsoup/parser/HtmlTreeBuilderStateTest.java,"package org.jsoup.parser;

import org.jsoup.Jsoup;
import org.jsoup.internal.StringUtil;
import org.jsoup.parser.HtmlTreeBuilderState.Constants;
import org.junit.jupiter.api.Test;

import java.lang.reflect.Field;
import java.lang.reflect.Modifier;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

import static org.jsoup.parser.HtmlTreeBuilderState.Constants.InBodyStartInputAttribs;
import static org.junit.jupiter.api.Assertions.*;

public class HtmlTreeBuilderStateTest {
    static List<Object[]> findConstantArrays(Class aClass) {
        ArrayList<Object[]> array = new ArrayList<>();
        Field[] fields = aClass.getDeclaredFields();

        for (Field field : fields) {
            int modifiers = field.getModifiers();
            if (Modifier.isStatic(modifiers) && !Modifier.isPrivate(modifiers) && field.getType().isArray()) {
                try {
                    array.add((Object[]) field.get(null));
                } catch (IllegalAccessException e) {
                    throw new IllegalStateException(e);
                }
            }
        }

        return array;
    }

    static void ensureSorted(List<Object[]> constants) {
        for (Object[] array : constants) {
            Object[] copy = Arrays.copyOf(array, array.length);
            Arrays.sort(array);
            assertArrayEquals(array, copy);
        }
    }

    @Test
    public void ensureArraysAreSorted() {
        List<Object[]> constants = findConstantArrays(Constants.class);
        ensureSorted(constants);
        assertEquals(38, constants.size());
    }

    @Test public void ensureTagSearchesAreKnownTags() {
        List<Object[]> constants = findConstantArrays(Constants.class);
        for (Object[] constant : constants) {
            String[] tagNames = (String[]) constant;
            for (String tagName : tagNames) {
                if (StringUtil.inSorted(tagName, InBodyStartInputAttribs))
                    continue; // odd one out in the constant
                assertTrue(Tag.isKnownTag(tagName), String.format(""Unknown tag name: %s"", tagName));
            }
        }
    }


    @Test
    public void nestedAnchorElements01() {
        String html = ""<html>\n"" +
            ""  <body>\n"" +
            ""    <a href='#1'>\n"" +
            ""        <div>\n"" +
            ""          <a href='#2'>child</a>\n"" +
            ""        </div>\n"" +
            ""    </a>\n"" +
            ""  </body>\n"" +
            ""</html>"";
        String s = Jsoup.parse(html).toString();
        assertEquals(""<html>\n"" +
            "" <head></head>\n"" +
            "" <body><a href=\""#1\""> </a>\n"" +
            ""  <div>\n"" +
            ""   <a href=\""#1\""> </a><a href=\""#2\"">child</a>\n"" +
            ""  </div>\n"" +
            "" </body>\n"" +
            ""</html>"", s);
    }

    @Test
    public void nestedAnchorElements02() {
        String html = ""<html>\n"" +
            ""  <body>\n"" +
            ""    <a href='#1'>\n"" +
            ""      <div>\n"" +
            ""        <div>\n"" +
            ""          <a href='#2'>child</a>\n"" +
            ""        </div>\n"" +
            ""      </div>\n"" +
            ""    </a>\n"" +
            ""  </body>\n"" +
            ""</html>"";
        String s = Jsoup.parse(html).toString();
        assertEquals(""<html>\n"" +
            "" <head></head>\n"" +
            "" <body><a href=\""#1\""> </a>\n"" +
            ""  <div>\n"" +
            ""   <a href=\""#1\""> </a>\n"" +
            ""   <div>\n"" +
            ""    <a href=\""#1\""> </a><a href=\""#2\"">child</a>\n"" +
            ""   </div>\n"" +
            ""  </div>\n"" +
            "" </body>\n"" +
            ""</html>"", s);
    }

}"
jhy/jsoup,src/main/java/org/jsoup/nodes/EntitiesData.java,"package org.jsoup.nodes;

/**
 * Holds packed data that represents Entity name=value pairs. Parsed by Entities, created by BuildEntities.
 */
class EntitiesData {
    static final String xmlPoints;
    static final String basePoints;
    static final String fullPoints;

    // https://bugs.java.com/bugdatabase/view_bug.do?bug_id=6447475
    // allocated in static here so not inlined in users; saves 16K from .jar (!)
    static {
        xmlPoints = ""amp=12;1&gt=1q;3&lt=1o;2&quot=y;0&"";
        basePoints = ""AElig=5i;1c&AMP=12;2&Aacute=5d;17&Acirc=5e;18&Agrave=5c;16&Aring=5h;1b&Atilde=5f;19&Auml=5g;1a&COPY=4p;h&Ccedil=5j;1d&ETH=5s;1m&Eacute=5l;1f&Ecirc=5m;1g&Egrave=5k;1e&Euml=5n;1h&GT=1q;6&Iacute=5p;1j&Icirc=5q;1k&Igrave=5o;1i&Iuml=5r;1l&LT=1o;4&Ntilde=5t;1n&Oacute=5v;1p&Ocirc=5w;1q&Ograve=5u;1o&Oslash=60;1u&Otilde=5x;1r&Ouml=5y;1s&QUOT=y;0&REG=4u;n&THORN=66;20&Uacute=62;1w&Ucirc=63;1x&Ugrave=61;1v&Uuml=64;1y&Yacute=65;1z&aacute=69;23&acirc=6a;24&acute=50;u&aelig=6e;28&agrave=68;22&amp=12;3&aring=6d;27&atilde=6b;25&auml=6c;26&brvbar=4m;e&ccedil=6f;29&cedil=54;y&cent=4i;a&copy=4p;i&curren=4k;c&deg=4w;q&divide=6v;2p&eacute=6h;2b&ecirc=6i;2c&egrave=6g;2a&eth=6o;2i&euml=6j;2d&frac12=59;13&frac14=58;12&frac34=5a;14&gt=1q;7&iacute=6l;2f&icirc=6m;2g&iexcl=4h;9&igrave=6k;2e&iquest=5b;15&iuml=6n;2h&laquo=4r;k&lt=1o;5&macr=4v;p&micro=51;v&middot=53;x&nbsp=4g;8&not=4s;l&ntilde=6p;2j&oacute=6r;2l&ocirc=6s;2m&ograve=6q;2k&ordf=4q;j&ordm=56;10&oslash=6w;2q&otilde=6t;2n&ouml=6u;2o&para=52;w&plusmn=4x;r&pound=4j;b&quot=y;1&raquo=57;11&reg=4u;o&sect=4n;f&shy=4t;m&sup1=55;z&sup2=4y;s&sup3=4z;t&szlig=67;21&thorn=72;2w&times=5z;1t&uacute=6y;2s&ucirc=6z;2t&ugrave=6x;2r&uml=4o;g&uuml=70;2u&yacute=71;2v&yen=4l;d&yuml=73;2x&"";
        fullPoints = ""AElig=5i;2v&AMP=12;8&Aacute=5d;2p&Abreve=76;4k&Acirc=5e;2q&Acy=sw;av&Afr=2kn8;1kh&Agrave=5c;2o&Alpha=pd;8d&Amacr=74;4i&And=8cz;1e1&Aogon=78;4m&Aopf=2koo;1ls&ApplyFunction=6e9;ew&Aring=5h;2t&Ascr=2kkc;1jc&Assign=6s4;s6&Atilde=5f;2r&Auml=5g;2s&Backslash=6qe;o1&Barv=8h3;1it&Barwed=6x2;120&Bcy=sx;aw&Because=6r9;pw&Bernoullis=6jw;gn&Beta=pe;8e&Bfr=2kn9;1ki&Bopf=2kop;1lt&Breve=k8;82&Bscr=6jw;gp&Bumpeq=6ry;ro&CHcy=tj;bi&COPY=4p;1q&Cacute=7a;4o&Cap=6vm;zz&CapitalDifferentialD=6kl;h8&Cayleys=6jx;gq&Ccaron=7g;4u&Ccedil=5j;2w&Ccirc=7c;4q&Cconint=6r4;pn&Cdot=7e;4s&Cedilla=54;2e&CenterDot=53;2b&Cfr=6jx;gr&Chi=pz;8y&CircleDot=6u1;x8&CircleMinus=6ty;x3&CirclePlus=6tx;x1&CircleTimes=6tz;x5&ClockwiseContourIntegral=6r6;pp&CloseCurlyDoubleQuote=6cd;e0&CloseCurlyQuote=6c9;dt&Colon=6rb;q1&Colone=8dw;1en&Congruent=6sh;sn&Conint=6r3;pm&ContourIntegral=6r2;pi&Copf=6iq;f7&Coproduct=6q8;nq&CounterClockwiseContourIntegral=6r7;pr&Cross=8bz;1d8&Cscr=2kke;1jd&Cup=6vn;100&CupCap=6rx;rk&DD=6kl;h9&DDotrahd=841;184&DJcy=si;ai&DScy=sl;al&DZcy=sv;au&Dagger=6ch;e7&Darr=6n5;j5&Dashv=8h0;1ir&Dcaron=7i;4w&Dcy=t0;az&Del=6pz;n9&Delta=pg;8g&Dfr=2knb;1kj&DiacriticalAcute=50;27&DiacriticalDot=k9;84&DiacriticalDoubleAcute=kd;8a&DiacriticalGrave=2o;13&DiacriticalTilde=kc;88&Diamond=6v8;za&DifferentialD=6km;ha&Dopf=2kor;1lu&Dot=4o;1n&DotDot=6ho;f5&DotEqual=6s0;rw&DoubleContourIntegral=6r3;pl&DoubleDot=4o;1m&DoubleDownArrow=6oj;m0&DoubleLeftArrow=6og;lq&DoubleLeftRightArrow=6ok;m3&DoubleLeftTee=8h0;1iq&DoubleLongLeftArrow=7w8;17g&DoubleLongLeftRightArrow=7wa;17m&DoubleLongRightArrow=7w9;17j&DoubleRightArrow=6oi;lw&DoubleRightTee=6ug;xz&DoubleUpArrow=6oh;lt&DoubleUpDownArrow=6ol;m7&DoubleVerticalBar=6qt;ov&DownArrow=6mr;i8&DownArrowBar=843;186&DownArrowUpArrow=6ph;mn&DownBreve=lt;8c&DownLeftRightVector=85s;198&DownLeftTeeVector=866;19m&DownLeftVector=6nx;ke&DownLeftVectorBar=85y;19e&DownRightTeeVector=867;19n&DownRightVector=6o1;kq&DownRightVectorBar=85z;19f&DownTee=6uc;xs&DownTeeArrow=6nb;jh&Downarrow=6oj;m1&Dscr=2kkf;1je&Dstrok=7k;4y&ENG=96;6g&ETH=5s;35&Eacute=5l;2y&Ecaron=7u;56&Ecirc=5m;2z&Ecy=tp;bo&Edot=7q;52&Efr=2knc;1kk&Egrave=5k;2x&Element=6q0;na&Emacr=7m;50&EmptySmallSquare=7i3;15x&EmptyVerySmallSquare=7fv;150&Eogon=7s;54&Eopf=2kos;1lv&Epsilon=ph;8h&Equal=8dx;1eo&EqualTilde=6rm;qp&Equilibrium=6oc;li&Escr=6k0;gu&Esim=8dv;1em&Eta=pj;8j&Euml=5n;30&Exists=6pv;mz&ExponentialE=6kn;hc&Fcy=tg;bf&Ffr=2knd;1kl&FilledSmallSquare=7i4;15y&FilledVerySmallSquare=7fu;14w&Fopf=2kot;1lw&ForAll=6ps;ms&Fouriertrf=6k1;gv&Fscr=6k1;gw&GJcy=sj;aj&GT=1q;r&Gamma=pf;8f&Gammad=rg;a5&Gbreve=7y;5a&Gcedil=82;5e&Gcirc=7w;58&Gcy=sz;ay&Gdot=80;5c&Gfr=2kne;1km&Gg=6vt;10c&Gopf=2kou;1lx&GreaterEqual=6sl;sv&GreaterEqualLess=6vv;10i&GreaterFullEqual=6sn;t6&GreaterGreater=8f6;1gh&GreaterLess=6t3;ul&GreaterSlantEqual=8e6;1f5&GreaterTilde=6sz;ub&Gscr=2kki;1jf&Gt=6sr;tr&HARDcy=tm;bl&Hacek=jr;80&Hat=2m;10&Hcirc=84;5f&Hfr=6j0;fe&HilbertSpace=6iz;fa&Hopf=6j1;fg&HorizontalLine=7b4;13i&Hscr=6iz;fc&Hstrok=86;5h&HumpDownHump=6ry;rn&HumpEqual=6rz;rs&IEcy=t1;b0&IJlig=8i;5s&IOcy=sh;ah&Iacute=5p;32&Icirc=5q;33&Icy=t4;b3&Idot=8g;5p&Ifr=6j5;fq&Igrave=5o;31&Im=6j5;fr&Imacr=8a;5l&ImaginaryI=6ko;hf&Implies=6oi;ly&Int=6r0;pf&Integral=6qz;pd&Intersection=6v6;z4&InvisibleComma=6eb;f0&InvisibleTimes=6ea;ey&Iogon=8e;5n&Iopf=2kow;1ly&Iota=pl;8l&Iscr=6j4;fn&Itilde=88;5j&Iukcy=sm;am&Iuml=5r;34&Jcirc=8k;5u&Jcy=t5;b4&Jfr=2knh;1kn&Jopf=2kox;1lz&Jscr=2kkl;1jg&Jsercy=so;ao&Jukcy=sk;ak&KHcy=th;bg&KJcy=ss;as&Kappa=pm;8m&Kcedil=8m;5w&Kcy=t6;b5&Kfr=2kni;1ko&Kopf=2koy;1m0&Kscr=2kkm;1jh&LJcy=sp;ap&LT=1o;m&Lacute=8p;5z&Lambda=pn;8n&Lang=7vu;173&Laplacetrf=6j6;fs&Larr=6n2;j1&Lcaron=8t;63&Lcedil=8r;61&Lcy=t7;b6&LeftAngleBracket=7vs;16x&LeftArrow=6mo;hu&LeftArrowBar=6p0;mj&LeftArrowRightArrow=6o6;l3&LeftCeiling=6x4;121&LeftDoubleBracket=7vq;16t&LeftDownTeeVector=869;19p&LeftDownVector=6o3;kw&LeftDownVectorBar=861;19h&LeftFloor=6x6;125&LeftRightArrow=6ms;ib&LeftRightVector=85q;196&LeftTee=6ub;xq&LeftTeeArrow=6n8;ja&LeftTeeVector=862;19i&LeftTriangle=6uq;ya&LeftTriangleBar=89b;1c0&LeftTriangleEqual=6us;yg&LeftUpDownVector=85t;199&LeftUpTeeVector=868;19o&LeftUpVector=6nz;kk&LeftUpVectorBar=860;19g&LeftVector=6nw;kb&LeftVectorBar=85u;19a&Leftarrow=6og;lr&Leftrightarrow=6ok;m4&LessEqualGreater=6vu;10e&LessFullEqual=6sm;t0&LessGreater=6t2;ui&LessLess=8f5;1gf&LessSlantEqual=8e5;1ez&LessTilde=6sy;u8&Lfr=2knj;1kp&Ll=6vs;109&Lleftarrow=6oq;me&Lmidot=8v;65&LongLeftArrow=7w5;177&LongLeftRightArrow=7w7;17d&LongRightArrow=7w6;17a&Longleftarrow=7w8;17h&Longleftrightarrow=7wa;17n&Longrightarrow=7w9;17k&Lopf=2koz;1m1&LowerLeftArrow=6mx;iq&LowerRightArrow=6mw;in&Lscr=6j6;fu&Lsh=6nk;jv&Lstrok=8x;67&Lt=6sq;tl&Map=83p;17v&Mcy=t8;b7&MediumSpace=6e7;eu&Mellintrf=6k3;gx&Mfr=2knk;1kq&MinusPlus=6qb;nv&Mopf=2kp0;1m2&Mscr=6k3;gz&Mu=po;8o&NJcy=sq;aq&Nacute=8z;69&Ncaron=93;6d&Ncedil=91;6b&Ncy=t9;b8&NegativeMediumSpace=6bv;dc&NegativeThickSpace=6bv;dd&NegativeThinSpace=6bv;de&NegativeVeryThinSpace=6bv;db&NestedGreaterGreater=6sr;tq&NestedLessLess=6sq;tk&NewLine=a;1&Nfr=2knl;1kr&NoBreak=6e8;ev&NonBreakingSpace=4g;1d&Nopf=6j9;fx&Not=8h8;1ix&NotCongruent=6si;sp&NotCupCap=6st;tv&NotDoubleVerticalBar=6qu;p0&NotElement=6q1;ne&NotEqual=6sg;sk&NotEqualTilde=6rm,mw;qn&NotExists=6pw;n1&NotGreater=6sv;tz&NotGreaterEqual=6sx;u5&NotGreaterFullEqual=6sn,mw;t3&NotGreaterGreater=6sr,mw;tn&NotGreaterLess=6t5;uq&NotGreaterSlantEqual=8e6,mw;1f2&NotGreaterTilde=6t1;ug&NotHumpDownHump=6ry,mw;rl&NotHumpEqual=6rz,mw;rq&NotLeftTriangle=6wa;113&NotLeftTriangleBar=89b,mw;1bz&NotLeftTriangleEqual=6wc;119&NotLess=6su;tw&NotLessEqual=6sw;u2&NotLessGreater=6t4;uo&NotLessLess=6sq,mw;th&NotLessSlantEqual=8e5,mw;1ew&NotLessTilde=6t0;ue&NotNestedGreaterGreater=8f6,mw;1gg&NotNestedLessLess=8f5,mw;1ge&NotPrecedes=6tc;vb&NotPrecedesEqual=8fj,mw;1gv&NotPrecedesSlantEqual=6w0;10p&NotReverseElement=6q4;nl&NotRightTriangle=6wb;116&NotRightTriangleBar=89c,mw;1c1&NotRightTriangleEqual=6wd;11c&NotSquareSubset=6tr,mw;wh&NotSquareSubsetEqual=6w2;10t&NotSquareSuperset=6ts,mw;wl&NotSquareSupersetEqual=6w3;10v&NotSubset=6te,6he;vh&NotSubsetEqual=6tk;w0&NotSucceeds=6td;ve&NotSucceedsEqual=8fk,mw;1h1&NotSucceedsSlantEqual=6w1;10r&NotSucceedsTilde=6tb,mw;v7&NotSuperset=6tf,6he;vm&NotSupersetEqual=6tl;w3&NotTilde=6rl;ql&NotTildeEqual=6ro;qv&NotTildeFullEqual=6rr;r1&NotTildeTilde=6rt;r9&NotVerticalBar=6qs;or&Nscr=2kkp;1ji&Ntilde=5t;36&Nu=pp;8p&OElig=9e;6m&Oacute=5v;38&Ocirc=5w;39&Ocy=ta;b9&Odblac=9c;6k&Ofr=2knm;1ks&Ograve=5u;37&Omacr=98;6i&Omega=q1;90&Omicron=pr;8r&Oopf=2kp2;1m3&OpenCurlyDoubleQuote=6cc;dy&OpenCurlyQuote=6c8;dr&Or=8d0;1e2&Oscr=2kkq;1jj&Oslash=60;3d&Otilde=5x;3a&Otimes=8c7;1df&Ouml=5y;3b&OverBar=6da;em&OverBrace=732;13b&OverBracket=71w;134&OverParenthesis=730;139&PartialD=6pu;mx&Pcy=tb;ba&Pfr=2knn;1kt&Phi=py;8x&Pi=ps;8s&PlusMinus=4x;22&Poincareplane=6j0;fd&Popf=6jd;g3&Pr=8fv;1hl&Precedes=6t6;us&PrecedesEqual=8fj;1gy&PrecedesSlantEqual=6t8;uy&PrecedesTilde=6ta;v4&Prime=6cz;eg&Product=6q7;no&Proportion=6rb;q0&Proportional=6ql;oa&Pscr=2kkr;1jk&Psi=q0;8z&QUOT=y;3&Qfr=2kno;1ku&Qopf=6je;g5&Qscr=2kks;1jl&RBarr=840;183&REG=4u;1x&Racute=9g;6o&Rang=7vv;174&Rarr=6n4;j4&Rarrtl=846;187&Rcaron=9k;6s&Rcedil=9i;6q&Rcy=tc;bb&Re=6jg;gb&ReverseElement=6q3;nh&ReverseEquilibrium=6ob;le&ReverseUpEquilibrium=86n;1a4&Rfr=6jg;ga&Rho=pt;8t&RightAngleBracket=7vt;170&RightArrow=6mq;i3&RightArrowBar=6p1;ml&RightArrowLeftArrow=6o4;ky&RightCeiling=6x5;123&RightDoubleBracket=7vr;16v&RightDownTeeVector=865;19l&RightDownVector=6o2;kt&RightDownVectorBar=85x;19d&RightFloor=6x7;127&RightTee=6ua;xo&RightTeeArrow=6na;je&RightTeeVector=863;19j&RightTriangle=6ur;yd&RightTriangleBar=89c;1c2&RightTriangleEqual=6ut;yk&RightUpDownVector=85r;197&RightUpTeeVector=864;19k&RightUpVector=6ny;kh&RightUpVectorBar=85w;19c&RightVector=6o0;kn&RightVectorBar=85v;19b&Rightarrow=6oi;lx&Ropf=6jh;gd&RoundImplies=86o;1a6&Rrightarrow=6or;mg&Rscr=6jf;g7&Rsh=6nl;jx&RuleDelayed=8ac;1cb&SHCHcy=tl;bk&SHcy=tk;bj&SOFTcy=to;bn&Sacute=9m;6u&Sc=8fw;1hm&Scaron=9s;70&Scedil=9q;6y&Scirc=9o;6w&Scy=td;bc&Sfr=2knq;1kv&ShortDownArrow=6mr;i7&ShortLeftArrow=6mo;ht&ShortRightArrow=6mq;i2&ShortUpArrow=6mp;hy&Sigma=pv;8u&SmallCircle=6qg;o6&Sopf=2kp6;1m4&Sqrt=6qi;o9&Square=7fl;14t&SquareIntersection=6tv;ww&SquareSubset=6tr;wi&SquareSubsetEqual=6tt;wp&SquareSuperset=6ts;wm&SquareSupersetEqual=6tu;ws&SquareUnion=6tw;wz&Sscr=2kku;1jm&Star=6va;zf&Sub=6vk;zw&Subset=6vk;zv&SubsetEqual=6ti;vu&Succeeds=6t7;uv&SucceedsEqual=8fk;1h4&SucceedsSlantEqual=6t9;v1&SucceedsTilde=6tb;v8&SuchThat=6q3;ni&Sum=6q9;ns&Sup=6vl;zy&Superset=6tf;vp&SupersetEqual=6tj;vx&Supset=6vl;zx&THORN=66;3j&TRADE=6jm;gf&TSHcy=sr;ar&TScy=ti;bh&Tab=9;0&Tau=pw;8v&Tcaron=9w;74&Tcedil=9u;72&Tcy=te;bd&Tfr=2knr;1kw&Therefore=6r8;pt&Theta=pk;8k&ThickSpace=6e7,6bu;et&ThinSpace=6bt;d7&Tilde=6rg;q9&TildeEqual=6rn;qs&TildeFullEqual=6rp;qy&TildeTilde=6rs;r4&Topf=2kp7;1m5&TripleDot=6hn;f3&Tscr=2kkv;1jn&Tstrok=9y;76&Uacute=62;3f&Uarr=6n3;j2&Uarrocir=85l;193&Ubrcy=su;at&Ubreve=a4;7c&Ucirc=63;3g&Ucy=tf;be&Udblac=a8;7g&Ufr=2kns;1kx&Ugrave=61;3e&Umacr=a2;7a&UnderBar=2n;11&UnderBrace=733;13c&UnderBracket=71x;136&UnderParenthesis=731;13a&Union=6v7;z8&UnionPlus=6tq;wf&Uogon=aa;7i&Uopf=2kp8;1m6&UpArrow=6mp;hz&UpArrowBar=842;185&UpArrowDownArrow=6o5;l1&UpDownArrow=6mt;ie&UpEquilibrium=86m;1a2&UpTee=6ud;xv&UpTeeArrow=6n9;jc&Uparrow=6oh;lu&Updownarrow=6ol;m8&UpperLeftArrow=6mu;ih&UpperRightArrow=6mv;ik&Upsi=r6;9z&Upsilon=px;8w&Uring=a6;7e&Uscr=2kkw;1jo&Utilde=a0;78&Uuml=64;3h&VDash=6uj;y3&Vbar=8h7;1iw&Vcy=sy;ax&Vdash=6uh;y1&Vdashl=8h2;1is&Vee=6v5;z3&Verbar=6c6;dp&Vert=6c6;dq&VerticalBar=6qr;on&VerticalLine=3g;18&VerticalSeparator=7rs;16o&VerticalTilde=6rk;qi&VeryThinSpace=6bu;d9&Vfr=2knt;1ky&Vopf=2kp9;1m7&Vscr=2kkx;1jp&Vvdash=6ui;y2&Wcirc=ac;7k&Wedge=6v4;z0&Wfr=2knu;1kz&Wopf=2kpa;1m8&Wscr=2kky;1jq&Xfr=2knv;1l0&Xi=pq;8q&Xopf=2kpb;1m9&Xscr=2kkz;1jr&YAcy=tr;bq&YIcy=sn;an&YUcy=tq;bp&Yacute=65;3i&Ycirc=ae;7m&Ycy=tn;bm&Yfr=2knw;1l1&Yopf=2kpc;1ma&Yscr=2kl0;1js&Yuml=ag;7o&ZHcy=t2;b1&Zacute=ah;7p&Zcaron=al;7t&Zcy=t3;b2&Zdot=aj;7r&ZeroWidthSpace=6bv;df&Zeta=pi;8i&Zfr=6js;gl&Zopf=6jo;gi&Zscr=2kl1;1jt&aacute=69;3m&abreve=77;4l&ac=6ri;qg&acE=6ri,mr;qe&acd=6rj;qh&acirc=6a;3n&acute=50;28&acy=ts;br&aelig=6e;3r&af=6e9;ex&afr=2kny;1l2&agrave=68;3l&alefsym=6k5;h3&aleph=6k5;h4&alpha=q9;92&amacr=75;4j&amalg=8cf;1dm&amp=12;9&and=6qv;p6&andand=8d1;1e3&andd=8d8;1e9&andslope=8d4;1e6&andv=8d6;1e7&ang=6qo;oj&ange=884;1b1&angle=6qo;oi&angmsd=6qp;ol&angmsdaa=888;1b5&angmsdab=889;1b6&angmsdac=88a;1b7&angmsdad=88b;1b8&angmsdae=88c;1b9&angmsdaf=88d;1ba&angmsdag=88e;1bb&angmsdah=88f;1bc&angrt=6qn;og&angrtvb=6v2;yw&angrtvbd=87x;1b0&angsph=6qq;om&angst=5h;2u&angzarr=70c;12z&aogon=79;4n&aopf=2kpe;1mb&ap=6rs;r8&apE=8ds;1ej&apacir=8dr;1eh&ape=6ru;rd&apid=6rv;rf&apos=13;a&approx=6rs;r5&approxeq=6ru;rc&aring=6d;3q&ascr=2kl2;1ju&ast=16;e&asymp=6rs;r6&asympeq=6rx;rj&atilde=6b;3o&auml=6c;3p&awconint=6r7;ps&awint=8b5;1cr&bNot=8h9;1iy&backcong=6rw;rg&backepsilon=s6;af&backprime=6d1;ei&backsim=6rh;qc&backsimeq=6vh;zp&barvee=6v1;yv&barwed=6x1;11y&barwedge=6x1;11x&bbrk=71x;137&bbrktbrk=71y;138&bcong=6rw;rh&bcy=tt;bs&bdquo=6ce;e4&becaus=6r9;py&because=6r9;px&bemptyv=88g;1bd&bepsi=s6;ag&bernou=6jw;go&beta=qa;93&beth=6k6;h5&between=6ss;tt&bfr=2knz;1l3&bigcap=6v6;z5&bigcirc=7hr;15s&bigcup=6v7;z7&bigodot=8ao;1cd&bigoplus=8ap;1cf&bigotimes=8aq;1ch&bigsqcup=8au;1cl&bigstar=7id;15z&bigtriangledown=7gd;15e&bigtriangleup=7g3;154&biguplus=8as;1cj&bigvee=6v5;z1&bigwedge=6v4;yy&bkarow=83x;17x&blacklozenge=8a3;1c9&blacksquare=7fu;14x&blacktriangle=7g4;156&blacktriangledown=7ge;15g&blacktriangleleft=7gi;15k&blacktriangleright=7g8;15a&blank=74z;13f&blk12=7f6;14r&blk14=7f5;14q&blk34=7f7;14s&block=7ew;14p&bne=1p,6hx;o&bnequiv=6sh,6hx;sm&bnot=6xc;12d&bopf=2kpf;1mc&bot=6ud;xx&bottom=6ud;xu&bowtie=6vc;zi&boxDL=7dj;141&boxDR=7dg;13y&boxDl=7di;140&boxDr=7df;13x&boxH=7dc;13u&boxHD=7dy;14g&boxHU=7e1;14j&boxHd=7dw;14e&boxHu=7dz;14h&boxUL=7dp;147&boxUR=7dm;144&boxUl=7do;146&boxUr=7dl;143&boxV=7dd;13v&boxVH=7e4;14m&boxVL=7dv;14d&boxVR=7ds;14a&boxVh=7e3;14l&boxVl=7du;14c&boxVr=7dr;149&boxbox=895;1bw&boxdL=7dh;13z&boxdR=7de;13w&boxdl=7bk;13m&boxdr=7bg;13l&boxh=7b4;13j&boxhD=7dx;14f&boxhU=7e0;14i&boxhd=7cc;13r&boxhu=7ck;13s&boxminus=6u7;xi&boxplus=6u6;xg&boxtimes=6u8;xk&boxuL=7dn;145&boxuR=7dk;142&boxul=7bs;13o&boxur=7bo;13n&boxv=7b6;13k&boxvH=7e2;14k&boxvL=7dt;14b&boxvR=7dq;148&boxvh=7cs;13t&boxvl=7c4;13q&boxvr=7bw;13p&bprime=6d1;ej&breve=k8;83&brvbar=4m;1k&bscr=2kl3;1jv&bsemi=6dr;er&bsim=6rh;qd&bsime=6vh;zq&bsol=2k;x&bsolb=891;1bv&bsolhsub=7uw;16r&bull=6ci;e9&bullet=6ci;e8&bump=6ry;rp&bumpE=8fi;1gu&bumpe=6rz;ru&bumpeq=6rz;rt&cacute=7b;4p&cap=6qx;pa&capand=8ck;1dq&capbrcup=8cp;1dv&capcap=8cr;1dx&capcup=8cn;1dt&capdot=8cg;1dn&caps=6qx,1e68;p9&caret=6dd;eo&caron=jr;81&ccaps=8ct;1dz&ccaron=7h;4v&ccedil=6f;3s&ccirc=7d;4r&ccups=8cs;1dy&ccupssm=8cw;1e0&cdot=7f;4t&cedil=54;2f&cemptyv=88i;1bf&cent=4i;1g&centerdot=53;2c&cfr=2ko0;1l4&chcy=uf;ce&check=7pv;16j&checkmark=7pv;16i&chi=qv;9s&cir=7gr;15q&cirE=88z;1bt&circ=jq;7z&circeq=6s7;sc&circlearrowleft=6nu;k6&circlearrowright=6nv;k8&circledR=4u;1w&circledS=79k;13g&circledast=6u3;xc&circledcirc=6u2;xa&circleddash=6u5;xe&cire=6s7;sd&cirfnint=8b4;1cq&cirmid=8hb;1j0&cirscir=88y;1bs&clubs=7kz;168&clubsuit=7kz;167&colon=1m;j&colone=6s4;s7&coloneq=6s4;s5&comma=18;g&commat=1s;u&comp=6pt;mv&compfn=6qg;o7&complement=6pt;mu&complexes=6iq;f6&cong=6rp;qz&congdot=8dp;1ef&conint=6r2;pj&copf=2kpg;1md&coprod=6q8;nr&copy=4p;1r&copysr=6jb;fz&crarr=6np;k1&cross=7pz;16k&cscr=2kl4;1jw&csub=8gf;1id&csube=8gh;1if&csup=8gg;1ie&csupe=8gi;1ig&ctdot=6wf;11g&cudarrl=854;18x&cudarrr=851;18u&cuepr=6vy;10m&cuesc=6vz;10o&cularr=6nq;k3&cularrp=859;190&cup=6qy;pc&cupbrcap=8co;1du&cupcap=8cm;1ds&cupcup=8cq;1dw&cupdot=6tp;we&cupor=8cl;1dr&cups=6qy,1e68;pb&curarr=6nr;k5&curarrm=858;18z&curlyeqprec=6vy;10l&curlyeqsucc=6vz;10n&curlyvee=6vi;zr&curlywedge=6vj;zt&curren=4k;1i&curvearrowleft=6nq;k2&curvearrowright=6nr;k4&cuvee=6vi;zs&cuwed=6vj;zu&cwconint=6r6;pq&cwint=6r5;po&cylcty=6y5;12u&dArr=6oj;m2&dHar=86d;19t&dagger=6cg;e5&daleth=6k8;h7&darr=6mr;ia&dash=6c0;dl&dashv=6ub;xr&dbkarow=83z;180&dblac=kd;8b&dcaron=7j;4x&dcy=tw;bv&dd=6km;hb&ddagger=6ch;e6&ddarr=6oa;ld&ddotseq=8dz;1ep&deg=4w;21&delta=qc;95&demptyv=88h;1be&dfisht=873;1aj&dfr=2ko1;1l5&dharl=6o3;kx&dharr=6o2;ku&diam=6v8;zc&diamond=6v8;zb&diamondsuit=7l2;16b&diams=7l2;16c&die=4o;1o&digamma=rh;a6&disin=6wi;11j&div=6v;49&divide=6v;48&divideontimes=6vb;zg&divonx=6vb;zh&djcy=uq;co&dlcorn=6xq;12n&dlcrop=6x9;12a&dollar=10;6&dopf=2kph;1me&dot=k9;85&doteq=6s0;rx&doteqdot=6s1;rz&dotminus=6rc;q2&dotplus=6qc;ny&dotsquare=6u9;xm&doublebarwedge=6x2;11z&downarrow=6mr;i9&downdownarrows=6oa;lc&downharpoonleft=6o3;kv&downharpoonright=6o2;ks&drbkarow=840;182&drcorn=6xr;12p&drcrop=6x8;129&dscr=2kl5;1jx&dscy=ut;cr&dsol=8ae;1cc&dstrok=7l;4z&dtdot=6wh;11i&dtri=7gf;15j&dtrif=7ge;15h&duarr=6ph;mo&duhar=86n;1a5&dwangle=886;1b3&dzcy=v3;d0&dzigrarr=7wf;17r&eDDot=8dz;1eq&eDot=6s1;s0&eacute=6h;3u&easter=8dq;1eg&ecaron=7v;57&ecir=6s6;sb&ecirc=6i;3v&ecolon=6s5;s9&ecy=ul;ck&edot=7r;53&ee=6kn;he&efDot=6s2;s2&efr=2ko2;1l6&eg=8ey;1g9&egrave=6g;3t&egs=8eu;1g5&egsdot=8ew;1g7&el=8ex;1g8&elinters=73b;13e&ell=6j7;fv&els=8et;1g3&elsdot=8ev;1g6&emacr=7n;51&empty=6px;n7&emptyset=6px;n5&emptyv=6px;n6&emsp=6bn;d2&emsp13=6bo;d3&emsp14=6bp;d4&eng=97;6h&ensp=6bm;d1&eogon=7t;55&eopf=2kpi;1mf&epar=6vp;103&eparsl=89v;1c6&eplus=8dt;1ek&epsi=qd;97&epsilon=qd;96&epsiv=s5;ae&eqcirc=6s6;sa&eqcolon=6s5;s8&eqsim=6rm;qq&eqslantgtr=8eu;1g4&eqslantless=8et;1g2&equals=1p;p&equest=6sf;sj&equiv=6sh;so&equivDD=8e0;1er&eqvparsl=89x;1c8&erDot=6s3;s4&erarr=86p;1a7&escr=6jz;gs&esdot=6s0;ry&esim=6rm;qr&eta=qf;99&eth=6o;41&euml=6j;3w&euro=6gc;f2&excl=x;2&exist=6pv;n0&expectation=6k0;gt&exponentiale=6kn;hd&fallingdotseq=6s2;s1&fcy=uc;cb&female=7k0;163&ffilig=1dkz;1ja&fflig=1dkw;1j7&ffllig=1dl0;1jb&ffr=2ko3;1l7&filig=1dkx;1j8&fjlig=2u,2y;15&flat=7l9;16e&fllig=1dky;1j9&fltns=7g1;153&fnof=b6;7v&fopf=2kpj;1mg&forall=6ps;mt&fork=6vo;102&forkv=8gp;1in&fpartint=8b1;1cp&frac12=59;2k&frac13=6kz;hh&frac14=58;2j&frac15=6l1;hj&frac16=6l5;hn&frac18=6l7;hp&frac23=6l0;hi&frac25=6l2;hk&frac34=5a;2m&frac35=6l3;hl&frac38=6l8;hq&frac45=6l4;hm&frac56=6l6;ho&frac58=6l9;hr&frac78=6la;hs&frasl=6dg;eq&frown=6xu;12r&fscr=2kl7;1jy&gE=6sn;t8&gEl=8ek;1ft&gacute=dx;7x&gamma=qb;94&gammad=rh;a7&gap=8ee;1fh&gbreve=7z;5b&gcirc=7x;59&gcy=tv;bu&gdot=81;5d&ge=6sl;sx&gel=6vv;10k&geq=6sl;sw&geqq=6sn;t7&geqslant=8e6;1f6&ges=8e6;1f7&gescc=8fd;1gn&gesdot=8e8;1f9&gesdoto=8ea;1fb&gesdotol=8ec;1fd&gesl=6vv,1e68;10h&gesles=8es;1g1&gfr=2ko4;1l8&gg=6sr;ts&ggg=6vt;10b&gimel=6k7;h6&gjcy=ur;cp&gl=6t3;un&glE=8eq;1fz&gla=8f9;1gj&glj=8f8;1gi&gnE=6sp;tg&gnap=8ei;1fp&gnapprox=8ei;1fo&gne=8eg;1fl&gneq=8eg;1fk&gneqq=6sp;tf&gnsim=6w7;10y&gopf=2kpk;1mh&grave=2o;14&gscr=6iy;f9&gsim=6sz;ud&gsime=8em;1fv&gsiml=8eo;1fx&gt=1q;s&gtcc=8fb;1gl&gtcir=8e2;1et&gtdot=6vr;107&gtlPar=87p;1aw&gtquest=8e4;1ev&gtrapprox=8ee;1fg&gtrarr=86w;1ad&gtrdot=6vr;106&gtreqless=6vv;10j&gtreqqless=8ek;1fs&gtrless=6t3;um&gtrsim=6sz;uc&gvertneqq=6sp,1e68;td&gvnE=6sp,1e68;te&hArr=6ok;m5&hairsp=6bu;da&half=59;2l&hamilt=6iz;fb&hardcy=ui;ch&harr=6ms;id&harrcir=85k;192&harrw=6nh;js&hbar=6j3;fl&hcirc=85;5g&hearts=7l1;16a&heartsuit=7l1;169&hellip=6cm;eb&hercon=6ux;yr&hfr=2ko5;1l9&hksearow=84l;18i&hkswarow=84m;18k&hoarr=6pr;mr&homtht=6rf;q5&hookleftarrow=6nd;jj&hookrightarrow=6ne;jl&hopf=2kpl;1mi&horbar=6c5;do&hscr=2kl9;1jz&hslash=6j3;fi&hstrok=87;5i&hybull=6df;ep&hyphen=6c0;dk&iacute=6l;3y&ic=6eb;f1&icirc=6m;3z&icy=u0;bz&iecy=tx;bw&iexcl=4h;1f&iff=6ok;m6&ifr=2ko6;1la&igrave=6k;3x&ii=6ko;hg&iiiint=8b0;1cn&iiint=6r1;pg&iinfin=89o;1c3&iiota=6jt;gm&ijlig=8j;5t&imacr=8b;5m&image=6j5;fp&imagline=6j4;fm&imagpart=6j5;fo&imath=8h;5r&imof=6uv;yo&imped=c5;7w&in=6q0;nd&incare=6it;f8&infin=6qm;of&infintie=89p;1c4&inodot=8h;5q&int=6qz;pe&intcal=6uy;yt&integers=6jo;gh&intercal=6uy;ys&intlarhk=8bb;1cx&intprod=8cc;1dk&iocy=up;cn&iogon=8f;5o&iopf=2kpm;1mj&iota=qh;9b&iprod=8cc;1dl&iquest=5b;2n&iscr=2kla;1k0&isin=6q0;nc&isinE=6wp;11r&isindot=6wl;11n&isins=6wk;11l&isinsv=6wj;11k&isinv=6q0;nb&it=6ea;ez&itilde=89;5k&iukcy=uu;cs&iuml=6n;40&jcirc=8l;5v&jcy=u1;c0&jfr=2ko7;1lb&jmath=fr;7y&jopf=2kpn;1mk&jscr=2klb;1k1&jsercy=uw;cu&jukcy=us;cq&kappa=qi;9c&kappav=s0;a9&kcedil=8n;5x&kcy=u2;c1&kfr=2ko8;1lc&kgreen=8o;5y&khcy=ud;cc&kjcy=v0;cy&kopf=2kpo;1ml&kscr=2klc;1k2&lAarr=6oq;mf&lArr=6og;ls&lAtail=84b;18a&lBarr=83y;17z&lE=6sm;t2&lEg=8ej;1fr&lHar=86a;19q&lacute=8q;60&laemptyv=88k;1bh&lagran=6j6;ft&lambda=qj;9d&lang=7vs;16z&langd=87l;1as&langle=7vs;16y&lap=8ed;1ff&laquo=4r;1t&larr=6mo;hx&larrb=6p0;mk&larrbfs=84f;18e&larrfs=84d;18c&larrhk=6nd;jk&larrlp=6nf;jo&larrpl=855;18y&larrsim=86r;1a9&larrtl=6n6;j7&lat=8ff;1gp&latail=849;188&late=8fh;1gt&lates=8fh,1e68;1gs&lbarr=83w;17w&lbbrk=7si;16p&lbrace=3f;16&lbrack=2j;v&lbrke=87f;1am&lbrksld=87j;1aq&lbrkslu=87h;1ao&lcaron=8u;64&lcedil=8s;62&lceil=6x4;122&lcub=3f;17&lcy=u3;c2&ldca=852;18v&ldquo=6cc;dz&ldquor=6ce;e3&ldrdhar=86f;19v&ldrushar=85n;195&ldsh=6nm;jz&le=6sk;st&leftarrow=6mo;hv&leftarrowtail=6n6;j6&leftharpoondown=6nx;kd&leftharpoonup=6nw;ka&leftleftarrows=6o7;l6&leftrightarrow=6ms;ic&leftrightarrows=6o6;l4&leftrightharpoons=6ob;lf&leftrightsquigarrow=6nh;jr&leftthreetimes=6vf;zl&leg=6vu;10g&leq=6sk;ss&leqq=6sm;t1&leqslant=8e5;1f0&les=8e5;1f1&lescc=8fc;1gm&lesdot=8e7;1f8&lesdoto=8e9;1fa&lesdotor=8eb;1fc&lesg=6vu,1e68;10d&lesges=8er;1g0&lessapprox=8ed;1fe&lessdot=6vq;104&lesseqgtr=6vu;10f&lesseqqgtr=8ej;1fq&lessgtr=6t2;uj&lesssim=6sy;u9&lfisht=870;1ag&lfloor=6x6;126&lfr=2ko9;1ld&lg=6t2;uk&lgE=8ep;1fy&lhard=6nx;kf&lharu=6nw;kc&lharul=86i;19y&lhblk=7es;14o&ljcy=ux;cv&ll=6sq;tm&llarr=6o7;l7&llcorner=6xq;12m&llhard=86j;19z&lltri=7i2;15w&lmidot=8w;66&lmoust=71s;131&lmoustache=71s;130&lnE=6so;tc&lnap=8eh;1fn&lnapprox=8eh;1fm&lne=8ef;1fj&lneq=8ef;1fi&lneqq=6so;tb&lnsim=6w6;10x&loang=7vw;175&loarr=6pp;mp&lobrk=7vq;16u&longleftarrow=7w5;178&longleftrightarrow=7w7;17e&longmapsto=7wc;17p&longrightarrow=7w6;17b&looparrowleft=6nf;jn&looparrowright=6ng;jp&lopar=879;1ak&lopf=2kpp;1mm&loplus=8bx;1d6&lotimes=8c4;1dc&lowast=6qf;o5&lowbar=2n;12&loz=7gq;15p&lozenge=7gq;15o&lozf=8a3;1ca&lpar=14;b&lparlt=87n;1au&lrarr=6o6;l5&lrcorner=6xr;12o&lrhar=6ob;lg&lrhard=86l;1a1&lrm=6by;di&lrtri=6v3;yx&lsaquo=6d5;ek&lscr=2kld;1k3&lsh=6nk;jw&lsim=6sy;ua&lsime=8el;1fu&lsimg=8en;1fw&lsqb=2j;w&lsquo=6c8;ds&lsquor=6ca;dw&lstrok=8y;68&lt=1o;n&ltcc=8fa;1gk&ltcir=8e1;1es&ltdot=6vq;105&lthree=6vf;zm&ltimes=6vd;zj&ltlarr=86u;1ac&ltquest=8e3;1eu&ltrPar=87q;1ax&ltri=7gj;15n&ltrie=6us;yi&ltrif=7gi;15l&lurdshar=85m;194&luruhar=86e;19u&lvertneqq=6so,1e68;t9&lvnE=6so,1e68;ta&mDDot=6re;q4&macr=4v;20&male=7k2;164&malt=7q8;16m&maltese=7q8;16l&map=6na;jg&mapsto=6na;jf&mapstodown=6nb;ji&mapstoleft=6n8;jb&mapstoup=6n9;jd&marker=7fy;152&mcomma=8bt;1d4&mcy=u4;c3&mdash=6c4;dn&measuredangle=6qp;ok&mfr=2koa;1le&mho=6jr;gj&micro=51;29&mid=6qr;oq&midast=16;d&midcir=8hc;1j1&middot=53;2d&minus=6qa;nu&minusb=6u7;xj&minusd=6rc;q3&minusdu=8bu;1d5&mlcp=8gr;1ip&mldr=6cm;ec&mnplus=6qb;nw&models=6uf;xy&mopf=2kpq;1mn&mp=6qb;nx&mscr=2kle;1k4&mstpos=6ri;qf&mu=qk;9e&multimap=6uw;yp&mumap=6uw;yq&nGg=6vt,mw;10a&nGt=6sr,6he;tp&nGtv=6sr,mw;to&nLeftarrow=6od;lk&nLeftrightarrow=6oe;lm&nLl=6vs,mw;108&nLt=6sq,6he;tj&nLtv=6sq,mw;ti&nRightarrow=6of;lo&nVDash=6un;y7&nVdash=6um;y6&nabla=6pz;n8&nacute=90;6a&nang=6qo,6he;oh&nap=6rt;rb&napE=8ds,mw;1ei&napid=6rv,mw;re&napos=95;6f&napprox=6rt;ra&natur=7la;16g&natural=7la;16f&naturals=6j9;fw&nbsp=4g;1e&nbump=6ry,mw;rm&nbumpe=6rz,mw;rr&ncap=8cj;1dp&ncaron=94;6e&ncedil=92;6c&ncong=6rr;r2&ncongdot=8dp,mw;1ee&ncup=8ci;1do&ncy=u5;c4&ndash=6c3;dm&ne=6sg;sl&neArr=6on;mb&nearhk=84k;18h&nearr=6mv;im&nearrow=6mv;il&nedot=6s0,mw;rv&nequiv=6si;sq&nesear=84o;18n&nesim=6rm,mw;qo&nexist=6pw;n3&nexists=6pw;n2&nfr=2kob;1lf&ngE=6sn,mw;t4&nge=6sx;u7&ngeq=6sx;u6&ngeqq=6sn,mw;t5&ngeqslant=8e6,mw;1f3&nges=8e6,mw;1f4&ngsim=6t1;uh&ngt=6sv;u1&ngtr=6sv;u0&nhArr=6oe;ln&nharr=6ni;ju&nhpar=8he;1j3&ni=6q3;nk&nis=6ws;11u&nisd=6wq;11s&niv=6q3;nj&njcy=uy;cw&nlArr=6od;ll&nlE=6sm,mw;sy&nlarr=6my;iu&nldr=6cl;ea&nle=6sw;u4&nleftarrow=6my;it&nleftrightarrow=6ni;jt&nleq=6sw;u3&nleqq=6sm,mw;sz&nleqslant=8e5,mw;1ex&nles=8e5,mw;1ey&nless=6su;tx&nlsim=6t0;uf&nlt=6su;ty&nltri=6wa;115&nltrie=6wc;11b&nmid=6qs;ou&nopf=2kpr;1mo&not=4s;1u&notin=6q1;ng&notinE=6wp,mw;11q&notindot=6wl,mw;11m&notinva=6q1;nf&notinvb=6wn;11p&notinvc=6wm;11o&notni=6q4;nn&notniva=6q4;nm&notnivb=6wu;11w&notnivc=6wt;11v&npar=6qu;p4&nparallel=6qu;p2&nparsl=8hp,6hx;1j5&npart=6pu,mw;mw&npolint=8b8;1cu&npr=6tc;vd&nprcue=6w0;10q&npre=8fj,mw;1gw&nprec=6tc;vc&npreceq=8fj,mw;1gx&nrArr=6of;lp&nrarr=6mz;iw&nrarrc=84z,mw;18s&nrarrw=6n1,mw;ix&nrightarrow=6mz;iv&nrtri=6wb;118&nrtrie=6wd;11e&nsc=6td;vg&nsccue=6w1;10s&nsce=8fk,mw;1h2&nscr=2klf;1k5&nshortmid=6qs;os&nshortparallel=6qu;p1&nsim=6rl;qm&nsime=6ro;qx&nsimeq=6ro;qw&nsmid=6qs;ot&nspar=6qu;p3&nsqsube=6w2;10u&nsqsupe=6w3;10w&nsub=6tg;vs&nsubE=8g5,mw;1hv&nsube=6tk;w2&nsubset=6te,6he;vi&nsubseteq=6tk;w1&nsubseteqq=8g5,mw;1hw&nsucc=6td;vf&nsucceq=8fk,mw;1h3&nsup=6th;vt&nsupE=8g6,mw;1hz&nsupe=6tl;w5&nsupset=6tf,6he;vn&nsupseteq=6tl;w4&nsupseteqq=8g6,mw;1i0&ntgl=6t5;ur&ntilde=6p;42&ntlg=6t4;up&ntriangleleft=6wa;114&ntrianglelefteq=6wc;11a&ntriangleright=6wb;117&ntrianglerighteq=6wd;11d&nu=ql;9f&num=z;5&numero=6ja;fy&numsp=6br;d5&nvDash=6ul;y5&nvHarr=83o;17u&nvap=6rx,6he;ri&nvdash=6uk;y4&nvge=6sl,6he;su&nvgt=1q,6he;q&nvinfin=89q;1c5&nvlArr=83m;17s&nvle=6sk,6he;sr&nvlt=1o,6he;l&nvltrie=6us,6he;yf&nvrArr=83n;17t&nvrtrie=6ut,6he;yj&nvsim=6rg,6he;q6&nwArr=6om;ma&nwarhk=84j;18g&nwarr=6mu;ij&nwarrow=6mu;ii&nwnear=84n;18m&oS=79k;13h&oacute=6r;44&oast=6u3;xd&ocir=6u2;xb&ocirc=6s;45&ocy=u6;c5&odash=6u5;xf&odblac=9d;6l&odiv=8c8;1dg&odot=6u1;x9&odsold=88s;1bn&oelig=9f;6n&ofcir=88v;1bp&ofr=2koc;1lg&ogon=kb;87&ograve=6q;43&ogt=88x;1br&ohbar=88l;1bi&ohm=q1;91&oint=6r2;pk&olarr=6nu;k7&olcir=88u;1bo&olcross=88r;1bm&oline=6da;en&olt=88w;1bq&omacr=99;6j&omega=qx;9u&omicron=qn;9h&omid=88m;1bj&ominus=6ty;x4&oopf=2kps;1mp&opar=88n;1bk&operp=88p;1bl&oplus=6tx;x2&or=6qw;p8&orarr=6nv;k9&ord=8d9;1ea&order=6k4;h1&orderof=6k4;h0&ordf=4q;1s&ordm=56;2h&origof=6uu;yn&oror=8d2;1e4&orslope=8d3;1e5&orv=8d7;1e8&oscr=6k4;h2&oslash=6w;4a&osol=6u0;x7&otilde=6t;46&otimes=6tz;x6&otimesas=8c6;1de&ouml=6u;47&ovbar=6yl;12x&par=6qt;oz&para=52;2a&parallel=6qt;ox&parsim=8hf;1j4&parsl=8hp;1j6&part=6pu;my&pcy=u7;c6&percnt=11;7&period=1a;h&permil=6cw;ed&perp=6ud;xw&pertenk=6cx;ee&pfr=2kod;1lh&phi=qu;9r&phiv=r9;a2&phmmat=6k3;gy&phone=7im;162&pi=qo;9i&pitchfork=6vo;101&piv=ra;a4&planck=6j3;fj&planckh=6j2;fh&plankv=6j3;fk&plus=17;f&plusacir=8bn;1cz&plusb=6u6;xh&pluscir=8bm;1cy&plusdo=6qc;nz&plusdu=8bp;1d1&pluse=8du;1el&plusmn=4x;23&plussim=8bq;1d2&plustwo=8br;1d3&pm=4x;24&pointint=8b9;1cv&popf=2kpt;1mq&pound=4j;1h&pr=6t6;uu&prE=8fn;1h7&prap=8fr;1he&prcue=6t8;v0&pre=8fj;1h0&prec=6t6;ut&precapprox=8fr;1hd&preccurlyeq=6t8;uz&preceq=8fj;1gz&precnapprox=8ft;1hh&precneqq=8fp;1h9&precnsim=6w8;10z&precsim=6ta;v5&prime=6cy;ef&primes=6jd;g2&prnE=8fp;1ha&prnap=8ft;1hi&prnsim=6w8;110&prod=6q7;np&profalar=6y6;12v&profline=6xe;12e&profsurf=6xf;12f&prop=6ql;oe&propto=6ql;oc&prsim=6ta;v6&prurel=6uo;y8&pscr=2klh;1k6&psi=qw;9t&puncsp=6bs;d6&qfr=2koe;1li&qint=8b0;1co&qopf=2kpu;1mr&qprime=6dz;es&qscr=2kli;1k7&quaternions=6j1;ff&quatint=8ba;1cw&quest=1r;t&questeq=6sf;si&quot=y;4&rAarr=6or;mh&rArr=6oi;lz&rAtail=84c;18b&rBarr=83z;181&rHar=86c;19s&race=6rh,mp;qb&racute=9h;6p&radic=6qi;o8&raemptyv=88j;1bg&rang=7vt;172&rangd=87m;1at&range=885;1b2&rangle=7vt;171&raquo=57;2i&rarr=6mq;i6&rarrap=86t;1ab&rarrb=6p1;mm&rarrbfs=84g;18f&rarrc=84z;18t&rarrfs=84e;18d&rarrhk=6ne;jm&rarrlp=6ng;jq&rarrpl=85h;191&rarrsim=86s;1aa&rarrtl=6n7;j9&rarrw=6n1;iz&ratail=84a;189&ratio=6ra;pz&rationals=6je;g4&rbarr=83x;17y&rbbrk=7sj;16q&rbrace=3h;1b&rbrack=2l;y&rbrke=87g;1an&rbrksld=87i;1ap&rbrkslu=87k;1ar&rcaron=9l;6t&rcedil=9j;6r&rceil=6x5;124&rcub=3h;1c&rcy=u8;c7&rdca=853;18w&rdldhar=86h;19x&rdquo=6cd;e2&rdquor=6cd;e1&rdsh=6nn;k0&real=6jg;g9&realine=6jf;g6&realpart=6jg;g8&reals=6jh;gc&rect=7fx;151&reg=4u;1y&rfisht=871;1ah&rfloor=6x7;128&rfr=2kof;1lj&rhard=6o1;kr&rharu=6o0;ko&rharul=86k;1a0&rho=qp;9j&rhov=s1;ab&rightarrow=6mq;i4&rightarrowtail=6n7;j8&rightharpoondown=6o1;kp&rightharpoonup=6o0;km&rightleftarrows=6o4;kz&rightleftharpoons=6oc;lh&rightrightarrows=6o9;la&rightsquigarrow=6n1;iy&rightthreetimes=6vg;zn&ring=ka;86&risingdotseq=6s3;s3&rlarr=6o4;l0&rlhar=6oc;lj&rlm=6bz;dj&rmoust=71t;133&rmoustache=71t;132&rnmid=8ha;1iz&roang=7vx;176&roarr=6pq;mq&robrk=7vr;16w&ropar=87a;1al&ropf=2kpv;1ms&roplus=8by;1d7&rotimes=8c5;1dd&rpar=15;c&rpargt=87o;1av&rppolint=8b6;1cs&rrarr=6o9;lb&rsaquo=6d6;el&rscr=2klj;1k8&rsh=6nl;jy&rsqb=2l;z&rsquo=6c9;dv&rsquor=6c9;du&rthree=6vg;zo&rtimes=6ve;zk&rtri=7g9;15d&rtrie=6ut;ym&rtrif=7g8;15b&rtriltri=89a;1by&ruluhar=86g;19w&rx=6ji;ge&sacute=9n;6v&sbquo=6ca;dx&sc=6t7;ux&scE=8fo;1h8&scap=8fs;1hg&scaron=9t;71&sccue=6t9;v3&sce=8fk;1h6&scedil=9r;6z&scirc=9p;6x&scnE=8fq;1hc&scnap=8fu;1hk&scnsim=6w9;112&scpolint=8b7;1ct&scsim=6tb;va&scy=u9;c8&sdot=6v9;zd&sdotb=6u9;xn&sdote=8di;1ec&seArr=6oo;mc&searhk=84l;18j&searr=6mw;ip&searrow=6mw;io&sect=4n;1l&semi=1n;k&seswar=84p;18p&setminus=6qe;o2&setmn=6qe;o4&sext=7qu;16n&sfr=2kog;1lk&sfrown=6xu;12q&sharp=7lb;16h&shchcy=uh;cg&shcy=ug;cf&shortmid=6qr;oo&shortparallel=6qt;ow&shy=4t;1v&sigma=qr;9n&sigmaf=qq;9l&sigmav=qq;9m&sim=6rg;qa&simdot=8dm;1ed&sime=6rn;qu&simeq=6rn;qt&simg=8f2;1gb&simgE=8f4;1gd&siml=8f1;1ga&simlE=8f3;1gc&simne=6rq;r0&simplus=8bo;1d0&simrarr=86q;1a8&slarr=6mo;hw&smallsetminus=6qe;o0&smashp=8c3;1db&smeparsl=89w;1c7&smid=6qr;op&smile=6xv;12t&smt=8fe;1go&smte=8fg;1gr&smtes=8fg,1e68;1gq&softcy=uk;cj&sol=1b;i&solb=890;1bu&solbar=6yn;12y&sopf=2kpw;1mt&spades=7kw;166&spadesuit=7kw;165&spar=6qt;oy&sqcap=6tv;wx&sqcaps=6tv,1e68;wv&sqcup=6tw;x0&sqcups=6tw,1e68;wy&sqsub=6tr;wk&sqsube=6tt;wr&sqsubset=6tr;wj&sqsubseteq=6tt;wq&sqsup=6ts;wo&sqsupe=6tu;wu&sqsupset=6ts;wn&sqsupseteq=6tu;wt&squ=7fl;14v&square=7fl;14u&squarf=7fu;14y&squf=7fu;14z&srarr=6mq;i5&sscr=2klk;1k9&ssetmn=6qe;o3&ssmile=6xv;12s&sstarf=6va;ze&star=7ie;161&starf=7id;160&straightepsilon=s5;ac&straightphi=r9;a0&strns=4v;1z&sub=6te;vl&subE=8g5;1hy&subdot=8fx;1hn&sube=6ti;vw&subedot=8g3;1ht&submult=8g1;1hr&subnE=8gb;1i8&subne=6tm;w9&subplus=8fz;1hp&subrarr=86x;1ae&subset=6te;vk&subseteq=6ti;vv&subseteqq=8g5;1hx&subsetneq=6tm;w8&subsetneqq=8gb;1i7&subsim=8g7;1i3&subsub=8gl;1ij&subsup=8gj;1ih&succ=6t7;uw&succapprox=8fs;1hf&succcurlyeq=6t9;v2&succeq=8fk;1h5&succnapprox=8fu;1hj&succneqq=8fq;1hb&succnsim=6w9;111&succsim=6tb;v9&sum=6q9;nt&sung=7l6;16d&sup=6tf;vr&sup1=55;2g&sup2=4y;25&sup3=4z;26&supE=8g6;1i2&supdot=8fy;1ho&supdsub=8go;1im&supe=6tj;vz&supedot=8g4;1hu&suphsol=7ux;16s&suphsub=8gn;1il&suplarr=86z;1af&supmult=8g2;1hs&supnE=8gc;1ic&supne=6tn;wd&supplus=8g0;1hq&supset=6tf;vq&supseteq=6tj;vy&supseteqq=8g6;1i1&supsetneq=6tn;wc&supsetneqq=8gc;1ib&supsim=8g8;1i4&supsub=8gk;1ii&supsup=8gm;1ik&swArr=6op;md&swarhk=84m;18l&swarr=6mx;is&swarrow=6mx;ir&swnwar=84q;18r&szlig=67;3k&target=6xi;12h&tau=qs;9o&tbrk=71w;135&tcaron=9x;75&tcedil=9v;73&tcy=ua;c9&tdot=6hn;f4&telrec=6xh;12g&tfr=2koh;1ll&there4=6r8;pv&therefore=6r8;pu&theta=qg;9a&thetasym=r5;9v&thetav=r5;9x&thickapprox=6rs;r3&thicksim=6rg;q7&thinsp=6bt;d8&thkap=6rs;r7&thksim=6rg;q8&thorn=72;4g&tilde=kc;89&times=5z;3c&timesb=6u8;xl&timesbar=8c1;1da&timesd=8c0;1d9&tint=6r1;ph&toea=84o;18o&top=6uc;xt&topbot=6ye;12w&topcir=8hd;1j2&topf=2kpx;1mu&topfork=8gq;1io&tosa=84p;18q&tprime=6d0;eh&trade=6jm;gg&triangle=7g5;158&triangledown=7gf;15i&triangleleft=7gj;15m&trianglelefteq=6us;yh&triangleq=6sc;sg&triangleright=7g9;15c&trianglerighteq=6ut;yl&tridot=7ho;15r&trie=6sc;sh&triminus=8ca;1di&triplus=8c9;1dh&trisb=899;1bx&tritime=8cb;1dj&trpezium=736;13d&tscr=2kll;1ka&tscy=ue;cd&tshcy=uz;cx&tstrok=9z;77&twixt=6ss;tu&twoheadleftarrow=6n2;j0&twoheadrightarrow=6n4;j3&uArr=6oh;lv&uHar=86b;19r&uacute=6y;4c&uarr=6mp;i1&ubrcy=v2;cz&ubreve=a5;7d&ucirc=6z;4d&ucy=ub;ca&udarr=6o5;l2&udblac=a9;7h&udhar=86m;1a3&ufisht=872;1ai&ufr=2koi;1lm&ugrave=6x;4b&uharl=6nz;kl&uharr=6ny;ki&uhblk=7eo;14n&ulcorn=6xo;12j&ulcorner=6xo;12i&ulcrop=6xb;12c&ultri=7i0;15u&umacr=a3;7b&uml=4o;1p&uogon=ab;7j&uopf=2kpy;1mv&uparrow=6mp;i0&updownarrow=6mt;if&upharpoonleft=6nz;kj&upharpoonright=6ny;kg&uplus=6tq;wg&upsi=qt;9q&upsih=r6;9y&upsilon=qt;9p&upuparrows=6o8;l8&urcorn=6xp;12l&urcorner=6xp;12k&urcrop=6xa;12b&uring=a7;7f&urtri=7i1;15v&uscr=2klm;1kb&utdot=6wg;11h&utilde=a1;79&utri=7g5;159&utrif=7g4;157&uuarr=6o8;l9&uuml=70;4e&uwangle=887;1b4&vArr=6ol;m9&vBar=8h4;1iu&vBarv=8h5;1iv&vDash=6ug;y0&vangrt=87w;1az&varepsilon=s5;ad&varkappa=s0;a8&varnothing=6px;n4&varphi=r9;a1&varpi=ra;a3&varpropto=6ql;ob&varr=6mt;ig&varrho=s1;aa&varsigma=qq;9k&varsubsetneq=6tm,1e68;w6&varsubsetneqq=8gb,1e68;1i5&varsupsetneq=6tn,1e68;wa&varsupsetneqq=8gc,1e68;1i9&vartheta=r5;9w&vartriangleleft=6uq;y9&vartriangleright=6ur;yc&vcy=tu;bt&vdash=6ua;xp&vee=6qw;p7&veebar=6uz;yu&veeeq=6sa;sf&vellip=6we;11f&verbar=3g;19&vert=3g;1a&vfr=2koj;1ln&vltri=6uq;yb&vnsub=6te,6he;vj&vnsup=6tf,6he;vo&vopf=2kpz;1mw&vprop=6ql;od&vrtri=6ur;ye&vscr=2kln;1kc&vsubnE=8gb,1e68;1i6&vsubne=6tm,1e68;w7&vsupnE=8gc,1e68;1ia&vsupne=6tn,1e68;wb&vzigzag=87u;1ay&wcirc=ad;7l&wedbar=8db;1eb&wedge=6qv;p5&wedgeq=6s9;se&weierp=6jc;g0&wfr=2kok;1lo&wopf=2kq0;1mx&wp=6jc;g1&wr=6rk;qk&wreath=6rk;qj&wscr=2klo;1kd&xcap=6v6;z6&xcirc=7hr;15t&xcup=6v7;z9&xdtri=7gd;15f&xfr=2kol;1lp&xhArr=7wa;17o&xharr=7w7;17f&xi=qm;9g&xlArr=7w8;17i&xlarr=7w5;179&xmap=7wc;17q&xnis=6wr;11t&xodot=8ao;1ce&xopf=2kq1;1my&xoplus=8ap;1cg&xotime=8aq;1ci&xrArr=7w9;17l&xrarr=7w6;17c&xscr=2klp;1ke&xsqcup=8au;1cm&xuplus=8as;1ck&xutri=7g3;155&xvee=6v5;z2&xwedge=6v4;yz&yacute=71;4f&yacy=un;cm&ycirc=af;7n&ycy=uj;ci&yen=4l;1j&yfr=2kom;1lq&yicy=uv;ct&yopf=2kq2;1mz&yscr=2klq;1kf&yucy=um;cl&yuml=73;4h&zacute=ai;7q&zcaron=am;7u&zcy=tz;by&zdot=ak;7s&zeetrf=6js;gk&zeta=qe;98&zfr=2kon;1lr&zhcy=ty;bx&zigrarr=6ot;mi&zopf=2kq3;1n0&zscr=2klr;1kg&zwj=6bx;dh&zwnj=6bw;dg&"";
    }
}
"
jhy/jsoup,src/main/java/org/jsoup/parser/HtmlTreeBuilder.java,"package org.jsoup.parser;

import org.jsoup.helper.Validate;
import org.jsoup.internal.StringUtil;
import org.jsoup.nodes.CDataNode;
import org.jsoup.nodes.Comment;
import org.jsoup.nodes.DataNode;
import org.jsoup.nodes.Document;
import org.jsoup.nodes.Element;
import org.jsoup.nodes.FormElement;
import org.jsoup.nodes.Node;
import org.jsoup.nodes.TextNode;

import javax.annotation.Nullable;
import javax.annotation.ParametersAreNonnullByDefault;
import java.io.Reader;
import java.io.StringReader;
import java.util.ArrayList;
import java.util.List;

import static org.jsoup.internal.StringUtil.inSorted;
import static org.jsoup.parser.HtmlTreeBuilderState.Constants.InTableFoster;

/**
 * HTML Tree Builder; creates a DOM from Tokens.
 */
public class HtmlTreeBuilder extends TreeBuilder {
    // tag searches. must be sorted, used in inSorted. HtmlTreeBuilderTest validates they're sorted.
    static final String[] TagsSearchInScope = new String[]{""applet"", ""caption"", ""html"", ""marquee"", ""object"", ""table"", ""td"", ""th""};
    static final String[] TagSearchList = new String[]{""ol"", ""ul""};
    static final String[] TagSearchButton = new String[]{""button""};
    static final String[] TagSearchTableScope = new String[]{""html"", ""table""};
    static final String[] TagSearchSelectScope = new String[]{""optgroup"", ""option""};
    static final String[] TagSearchEndTags = new String[]{""dd"", ""dt"", ""li"", ""optgroup"", ""option"", ""p"", ""rb"", ""rp"", ""rt"", ""rtc""};
    static final String[] TagThoroughSearchEndTags = new String[]{""caption"", ""colgroup"", ""dd"", ""dt"", ""li"", ""optgroup"", ""option"", ""p"", ""rb"", ""rp"", ""rt"", ""rtc"", ""tbody"", ""td"", ""tfoot"", ""th"", ""thead"", ""tr""};
    static final String[] TagSearchSpecial = new String[]{""address"", ""applet"", ""area"", ""article"", ""aside"", ""base"", ""basefont"", ""bgsound"",
        ""blockquote"", ""body"", ""br"", ""button"", ""caption"", ""center"", ""col"", ""colgroup"", ""command"", ""dd"",
        ""details"", ""dir"", ""div"", ""dl"", ""dt"", ""embed"", ""fieldset"", ""figcaption"", ""figure"", ""footer"", ""form"",
        ""frame"", ""frameset"", ""h1"", ""h2"", ""h3"", ""h4"", ""h5"", ""h6"", ""head"", ""header"", ""hgroup"", ""hr"", ""html"",
        ""iframe"", ""img"", ""input"", ""isindex"", ""li"", ""link"", ""listing"", ""marquee"", ""menu"", ""meta"", ""nav"",
        ""noembed"", ""noframes"", ""noscript"", ""object"", ""ol"", ""p"", ""param"", ""plaintext"", ""pre"", ""script"",
        ""section"", ""select"", ""style"", ""summary"", ""table"", ""tbody"", ""td"", ""textarea"", ""tfoot"", ""th"", ""thead"",
        ""title"", ""tr"", ""ul"", ""wbr"", ""xmp""};

    public static final int MaxScopeSearchDepth = 100; // prevents the parser bogging down in exceptionally broken pages

    private HtmlTreeBuilderState state; // the current state
    private HtmlTreeBuilderState originalState; // original / marked state

    private boolean baseUriSetFromDoc;
    private @Nullable Element headElement; // the current head element
    private @Nullable FormElement formElement; // the current form element
    private @Nullable Element contextElement; // fragment parse context -- could be null even if fragment parsing
    private ArrayList<Element> formattingElements; // active (open) formatting elements
    private ArrayList<HtmlTreeBuilderState> tmplInsertMode; // stack of Template Insertion modes
    private List<String> pendingTableCharacters; // chars in table to be shifted out
    private Token.EndTag emptyEnd; // reused empty end tag

    private boolean framesetOk; // if ok to go into frameset
    private boolean fosterInserts; // if next inserts should be fostered
    private boolean fragmentParsing; // if parsing a fragment of html

    ParseSettings defaultSettings() {
        return ParseSettings.htmlDefault;
    }

    @Override
    HtmlTreeBuilder newInstance() {
        return new HtmlTreeBuilder();
    }

    @Override @ParametersAreNonnullByDefault
    protected void initialiseParse(Reader input, String baseUri, Parser parser) {
        super.initialiseParse(input, baseUri, parser);

        // this is a bit mucky. todo - probably just create new parser objects to ensure all reset.
        state = HtmlTreeBuilderState.Initial;
        originalState = null;
        baseUriSetFromDoc = false;
        headElement = null;
        formElement = null;
        contextElement = null;
        formattingElements = new ArrayList<>();
        tmplInsertMode = new ArrayList<>();
        pendingTableCharacters = new ArrayList<>();
        emptyEnd = new Token.EndTag();
        framesetOk = true;
        fosterInserts = false;
        fragmentParsing = false;
    }

    List<Node> parseFragment(String inputFragment, @Nullable Element context, String baseUri, Parser parser) {
        // context may be null
        state = HtmlTreeBuilderState.Initial;
        initialiseParse(new StringReader(inputFragment), baseUri, parser);
        contextElement = context;
        fragmentParsing = true;
        Element root = null;

        if (context != null) {
            if (context.ownerDocument() != null) // quirks setup:
                doc.quirksMode(context.ownerDocument().quirksMode());

            // initialise the tokeniser state:
            String contextTag = context.normalName();
            switch (contextTag) {
                case ""title"":
                case ""textarea"":
                    tokeniser.transition(TokeniserState.Rcdata);
                    break;
                case ""iframe"":
                case ""noembed"":
                case ""noframes"":
                case ""style"":
                case ""xml"":
                    tokeniser.transition(TokeniserState.Rawtext);
                    break;
                case ""script"":
                    tokeniser.transition(TokeniserState.ScriptData);
                    break;
                case ""noscript"":
                    tokeniser.transition(TokeniserState.Data); // if scripting enabled, rawtext
                    break;
                case ""plaintext"":
                    tokeniser.transition(TokeniserState.PLAINTEXT);
                    break;
                case ""template"":
                    tokeniser.transition(TokeniserState.Data);
                    pushTemplateMode(HtmlTreeBuilderState.InTemplate);
                    break;
                default:
                    tokeniser.transition(TokeniserState.Data);
            }
            root = new Element(tagFor(contextTag, settings), baseUri);
            doc.appendChild(root);
            stack.add(root);
            resetInsertionMode();

            // setup form element to nearest form on context (up ancestor chain). ensures form controls are associated
            // with form correctly
            Element formSearch = context;
            while (formSearch != null) {
                if (formSearch instanceof FormElement) {
                    formElement = (FormElement) formSearch;
                    break;
                }
                formSearch = formSearch.parent();
            }
        }

        runParser();
        if (context != null) {
            // depending on context and the input html, content may have been added outside of the root el
            // e.g. context=p, input=div, the div will have been pushed out.
            List<Node> nodes = root.siblingNodes();
            if (!nodes.isEmpty())
                root.insertChildren(-1, nodes);
            return root.childNodes();
        }
        else
            return doc.childNodes();
    }

    @Override
    protected boolean process(Token token) {
        currentToken = token;
        return this.state.process(token, this);
    }

    boolean process(Token token, HtmlTreeBuilderState state) {
        currentToken = token;
        return state.process(token, this);
    }

    void transition(HtmlTreeBuilderState state) {
        this.state = state;
    }

    HtmlTreeBuilderState state() {
        return state;
    }

    void markInsertionMode() {
        originalState = state;
    }

    HtmlTreeBuilderState originalState() {
        return originalState;
    }

    void framesetOk(boolean framesetOk) {
        this.framesetOk = framesetOk;
    }

    boolean framesetOk() {
        return framesetOk;
    }

    Document getDocument() {
        return doc;
    }

    String getBaseUri() {
        return baseUri;
    }

    void maybeSetBaseUri(Element base) {
        if (baseUriSetFromDoc) // only listen to the first <base href> in parse
            return;

        String href = base.absUrl(""href"");
        if (href.length() != 0) { // ignore <base target> etc
            baseUri = href;
            baseUriSetFromDoc = true;
            doc.setBaseUri(href); // set on the doc so doc.createElement(Tag) will get updated base, and to update all descendants
        }
    }

    boolean isFragmentParsing() {
        return fragmentParsing;
    }

    void error(HtmlTreeBuilderState state) {
        if (parser.getErrors().canAddError())
            parser.getErrors().add(new ParseError(reader, ""Unexpected %s token [%s] when in state [%s]"",
                currentToken.tokenType(), currentToken, state));
    }

    Element insert(final Token.StartTag startTag) {
        // cleanup duplicate attributes:
        if (startTag.hasAttributes() && !startTag.attributes.isEmpty()) {
            int dupes = startTag.attributes.deduplicate(settings);
            if (dupes > 0) {
                error(""Dropped duplicate attribute(s) in tag [%s]"", startTag.normalName);
            }
        }

        // handle empty unknown tags
        // when the spec expects an empty tag, will directly hit insertEmpty, so won't generate this fake end tag.
        if (startTag.isSelfClosing()) {
            Element el = insertEmpty(startTag);
            stack.add(el);
            tokeniser.transition(TokeniserState.Data); // handles <script />, otherwise needs breakout steps from script data
            tokeniser.emit(emptyEnd.reset().name(el.tagName()));  // ensure we get out of whatever state we are in. emitted for yielded processing
            return el;
        }

        Element el = new Element(tagFor(startTag.name(), settings), null, settings.normalizeAttributes(startTag.attributes));
        insert(el, startTag);
        return el;
    }

    Element insertStartTag(String startTagName) {
        Element el = new Element(tagFor(startTagName, settings), null);
        insert(el);
        return el;
    }

    void insert(Element el) {
        insertNode(el, null);
        stack.add(el);
    }

    private void insert(Element el, @Nullable Token token) {
        insertNode(el, token);
        stack.add(el);
    }

    Element insertEmpty(Token.StartTag startTag) {
        Tag tag = tagFor(startTag.name(), settings);
        Element el = new Element(tag, null, settings.normalizeAttributes(startTag.attributes));
        insertNode(el, startTag);
        if (startTag.isSelfClosing()) {
            if (tag.isKnownTag()) {
                if (!tag.isEmpty())
                    tokeniser.error(""Tag [%s] cannot be self closing; not a void tag"", tag.normalName());
            }
            else // unknown tag, remember this is self closing for output
                tag.setSelfClosing();
        }
        return el;
    }

    FormElement insertForm(Token.StartTag startTag, boolean onStack, boolean checkTemplateStack) {
        Tag tag = tagFor(startTag.name(), settings);
        FormElement el = new FormElement(tag, null, settings.normalizeAttributes(startTag.attributes));
        if (checkTemplateStack) {
            if(!onStack(""template""))
                setFormElement(el);
        } else
            setFormElement(el);

        insertNode(el, startTag);
        if (onStack)
            stack.add(el);
        return el;
    }

    void insert(Token.Comment commentToken) {
        Comment comment = new Comment(commentToken.getData());
        insertNode(comment, commentToken);
    }

    void insert(Token.Character characterToken) {
        final Node node;
        Element el = currentElement(); // will be doc if no current element; allows for whitespace to be inserted into the doc root object (not on the stack)
        final String tagName = el.normalName();
        final String data = characterToken.getData();

        if (characterToken.isCData())
            node = new CDataNode(data);
        else if (isContentForTagData(tagName))
            node = new DataNode(data);
        else
            node = new TextNode(data);
        el.appendChild(node); // doesn't use insertNode, because we don't foster these; and will always have a stack.
        onNodeInserted(node, characterToken);
    }

    private void insertNode(Node node, @Nullable Token token) {
        // if the stack hasn't been set up yet, elements (doctype, comments) go into the doc
        if (stack.isEmpty())
            doc.appendChild(node);
        else if (isFosterInserts() && StringUtil.inSorted(currentElement().normalName(), InTableFoster))
            insertInFosterParent(node);
        else
            currentElement().appendChild(node);

        // connect form controls to their form element
        if (node instanceof Element && ((Element) node).tag().isFormListed()) {
            if (formElement != null)
                formElement.addElement((Element) node);
        }
        onNodeInserted(node, token);
    }

    Element pop() {
        int size = stack.size();
        return stack.remove(size-1);
    }

    void push(Element element) {
        stack.add(element);
    }

    ArrayList<Element> getStack() {
        return stack;
    }

    boolean onStack(Element el) {
        return onStack(stack, el);
    }

    boolean onStack(String elName) {
        return getFromStack(elName) != null;
    }

    private static final int maxQueueDepth = 256; // an arbitrary tension point between real HTML and crafted pain
    private static boolean onStack(ArrayList<Element> queue, Element element) {
        final int bottom = queue.size() - 1;
        final int upper = bottom >= maxQueueDepth ? bottom - maxQueueDepth : 0;
        for (int pos = bottom; pos >= upper; pos--) {
            Element next = queue.get(pos);
            if (next == element) {
                return true;
            }
        }
        return false;
    }

    @Nullable
    Element getFromStack(String elName) {
        final int bottom = stack.size() - 1;
        final int upper = bottom >= maxQueueDepth ? bottom - maxQueueDepth : 0;
        for (int pos = bottom; pos >= upper; pos--) {
            Element next = stack.get(pos);
            if (next.normalName().equals(elName)) {
                return next;
            }
        }
        return null;
    }

    boolean removeFromStack(Element el) {
        for (int pos = stack.size() -1; pos >= 0; pos--) {
            Element next = stack.get(pos);
            if (next == el) {
                stack.remove(pos);
                return true;
            }
        }
        return false;
    }

    @Nullable
    Element popStackToClose(String elName) {
        for (int pos = stack.size() -1; pos >= 0; pos--) {
            Element el = stack.get(pos);
            stack.remove(pos);
            if (el.normalName().equals(elName)) {
                if (currentToken instanceof Token.EndTag)
                    onNodeClosed(el, currentToken);
                return el;
            }
        }
        return null;
    }

    // elnames is sorted, comes from Constants
    void popStackToClose(String... elNames) {
        for (int pos = stack.size() -1; pos >= 0; pos--) {
            Element next = stack.get(pos);
            stack.remove(pos);
            if (inSorted(next.normalName(), elNames))
                break;
        }
    }

    void popStackToBefore(String elName) {
        for (int pos = stack.size() -1; pos >= 0; pos--) {
            Element next = stack.get(pos);
            if (next.normalName().equals(elName)) {
                break;
            } else {
                stack.remove(pos);
            }
        }
    }

    void clearStackToTableContext() {
        clearStackToContext(""table"", ""template"");
    }

    void clearStackToTableBodyContext() {
        clearStackToContext(""tbody"", ""tfoot"", ""thead"", ""template"");
    }

    void clearStackToTableRowContext() {
        clearStackToContext(""tr"", ""template"");
    }

    private void clearStackToContext(String... nodeNames) {
        for (int pos = stack.size() -1; pos >= 0; pos--) {
            Element next = stack.get(pos);
            if (StringUtil.in(next.normalName(), nodeNames) || next.normalName().equals(""html""))
                break;
            else
                stack.remove(pos);
        }
    }

    @Nullable Element aboveOnStack(Element el) {
        assert onStack(el);
        for (int pos = stack.size() -1; pos >= 0; pos--) {
            Element next = stack.get(pos);
            if (next == el) {
                return stack.get(pos-1);
            }
        }
        return null;
    }

    void insertOnStackAfter(Element after, Element in) {
        int i = stack.lastIndexOf(after);
        Validate.isTrue(i != -1);
        stack.add(i+1, in);
    }

    void replaceOnStack(Element out, Element in) {
        replaceInQueue(stack, out, in);
    }

    private void replaceInQueue(ArrayList<Element> queue, Element out, Element in) {
        int i = queue.lastIndexOf(out);
        Validate.isTrue(i != -1);
        queue.set(i, in);
    }

    /**
     * Reset the insertion mode, by searching up the stack for an appropriate insertion mode. The stack search depth
     * is limited to {@link #maxQueueDepth}.
     * @return true if the insertion mode was actually changed.
     */
    boolean resetInsertionMode() {
        // https://html.spec.whatwg.org/multipage/parsing.html#the-insertion-mode
        boolean last = false;
        final int bottom = stack.size() - 1;
        final int upper = bottom >= maxQueueDepth ? bottom - maxQueueDepth : 0;
        final HtmlTreeBuilderState origState = this.state;

        if (stack.size() == 0) { // nothing left of stack, just get to body
            transition(HtmlTreeBuilderState.InBody);
        }

        LOOP: for (int pos = bottom; pos >= upper; pos--) {
            Element node = stack.get(pos);
            if (pos == upper) {
                last = true;
                if (fragmentParsing)
                    node = contextElement;
            }
            String name = node != null ? node.normalName() : """";
            switch (name) {
                case ""select"":
                    transition(HtmlTreeBuilderState.InSelect);
                    // todo - should loop up (with some limit) and check for table or template hits
                    break LOOP;
                case ""td"":
                case ""th"":
                    if (!last) {
                        transition(HtmlTreeBuilderState.InCell);
                        break LOOP;
                    }
                    break;
                case ""tr"":
                    transition(HtmlTreeBuilderState.InRow);
                    break LOOP;
                case ""tbody"":
                case ""thead"":
                case ""tfoot"":
                    transition(HtmlTreeBuilderState.InTableBody);
                    break LOOP;
                case ""caption"":
                    transition(HtmlTreeBuilderState.InCaption);
                    break LOOP;
                case ""colgroup"":
                    transition(HtmlTreeBuilderState.InColumnGroup);
                    break LOOP;
                case ""table"":
                    transition(HtmlTreeBuilderState.InTable);
                    break LOOP;
                case ""template"":
                    HtmlTreeBuilderState tmplState = currentTemplateMode();
                    Validate.notNull(tmplState, ""Bug: no template insertion mode on stack!"");
                    transition(tmplState);
                    break LOOP;
                case ""head"":
                    if (!last) {
                        transition(HtmlTreeBuilderState.InHead);
                        break LOOP;
                    }
                    break;
                case ""body"":
                    transition(HtmlTreeBuilderState.InBody);
                    break LOOP;
                case ""frameset"":
                    transition(HtmlTreeBuilderState.InFrameset);
                    break LOOP;
                case ""html"":
                    transition(headElement == null ? HtmlTreeBuilderState.BeforeHead : HtmlTreeBuilderState.AfterHead);
                    break LOOP;
            }
            if (last) {
                transition(HtmlTreeBuilderState.InBody);
                break;
            }
        }
        return state != origState;
    }

    /** Places the body back onto the stack and moves to InBody, for cases in AfterBody / AfterAfterBody when more content comes */
    void resetBody() {
        if (!onStack(""body"")) {
            stack.add(doc.body());
        }
        transition(HtmlTreeBuilderState.InBody);
    }

    // todo: tidy up in specific scope methods
    private String[] specificScopeTarget = {null};

    private boolean inSpecificScope(String targetName, String[] baseTypes, String[] extraTypes) {
        specificScopeTarget[0] = targetName;
        return inSpecificScope(specificScopeTarget, baseTypes, extraTypes);
    }

    private boolean inSpecificScope(String[] targetNames, String[] baseTypes, String[] extraTypes) {
        // https://html.spec.whatwg.org/multipage/parsing.html#has-an-element-in-the-specific-scope
        final int bottom = stack.size() -1;
        final int top = bottom > MaxScopeSearchDepth ? bottom - MaxScopeSearchDepth : 0;
        // don't walk too far up the tree

        for (int pos = bottom; pos >= top; pos--) {
            final String elName = stack.get(pos).normalName();
            if (inSorted(elName, targetNames))
                return true;
            if (inSorted(elName, baseTypes))
                return false;
            if (extraTypes != null && inSorted(elName, extraTypes))
                return false;
        }
        //Validate.fail(""Should not be reachable""); // would end up false because hitting 'html' at root (basetypes)
        return false;
    }

    boolean inScope(String[] targetNames) {
        return inSpecificScope(targetNames, TagsSearchInScope, null);
    }

    boolean inScope(String targetName) {
        return inScope(targetName, null);
    }

    boolean inScope(String targetName, String[] extras) {
        return inSpecificScope(targetName, TagsSearchInScope, extras);
        // todo: in mathml namespace: mi, mo, mn, ms, mtext annotation-xml
        // todo: in svg namespace: forignOjbect, desc, title
    }

    boolean inListItemScope(String targetName) {
        return inScope(targetName, TagSearchList);
    }

    boolean inButtonScope(String targetName) {
        return inScope(targetName, TagSearchButton);
    }

    boolean inTableScope(String targetName) {
        return inSpecificScope(targetName, TagSearchTableScope, null);
    }

    boolean inSelectScope(String targetName) {
        for (int pos = stack.size() -1; pos >= 0; pos--) {
            Element el = stack.get(pos);
            String elName = el.normalName();
            if (elName.equals(targetName))
                return true;
            if (!inSorted(elName, TagSearchSelectScope)) // all elements except
                return false;
        }
        Validate.fail(""Should not be reachable"");
        return false;
    }

    void setHeadElement(Element headElement) {
        this.headElement = headElement;
    }

    Element getHeadElement() {
        return headElement;
    }

    boolean isFosterInserts() {
        return fosterInserts;
    }

    void setFosterInserts(boolean fosterInserts) {
        this.fosterInserts = fosterInserts;
    }

    @Nullable FormElement getFormElement() {
        return formElement;
    }

    void setFormElement(FormElement formElement) {
        this.formElement = formElement;
    }

    void newPendingTableCharacters() {
        pendingTableCharacters = new ArrayList<>();
    }

    List<String> getPendingTableCharacters() {
        return pendingTableCharacters;
    }

    /**
     13.2.6.3 Closing elements that have implied end tags
     When the steps below require the UA to generate implied end tags, then, while the current node is a dd element, a dt element, an li element, an optgroup element, an option element, a p element, an rb element, an rp element, an rt element, or an rtc element, the UA must pop the current node off the stack of open elements.

     If a step requires the UA to generate implied end tags but lists an element to exclude from the process, then the UA must perform the above steps as if that element was not in the above list.

     When the steps below require the UA to generate all implied end tags thoroughly, then, while the current node is a caption element, a colgroup element, a dd element, a dt element, an li element, an optgroup element, an option element, a p element, an rb element, an rp element, an rt element, an rtc element, a tbody element, a td element, a tfoot element, a th element, a thead element, or a tr element, the UA must pop the current node off the stack of open elements.

     @param excludeTag If a step requires the UA to generate implied end tags but lists an element to exclude from the
     process, then the UA must perform the above steps as if that element was not in the above list.
     */
    void generateImpliedEndTags(String excludeTag) {
        while (inSorted(currentElement().normalName(), TagSearchEndTags)) {
            if (excludeTag != null && currentElementIs(excludeTag))
                break;
            pop();
        }
    }

    void generateImpliedEndTags() {
        generateImpliedEndTags(false);
    }

    /**
     Pops elements off the stack according to the implied end tag rules
     @param thorough if we are thorough (includes table elements etc) or not
     */
    void generateImpliedEndTags(boolean thorough) {
        final String[] search = thorough ? TagThoroughSearchEndTags : TagSearchEndTags;
        while (inSorted(currentElement().normalName(), search)) {
            pop();
        }
    }

    void closeElement(String name) {
        generateImpliedEndTags(name);
        if (!name.equals(currentElement().normalName())) error(state());
        popStackToClose(name);
    }

    boolean isSpecial(Element el) {
        // todo: mathml's mi, mo, mn
        // todo: svg's foreigObject, desc, title
        String name = el.normalName();
        return inSorted(name, TagSearchSpecial);
    }

    Element lastFormattingElement() {
        return formattingElements.size() > 0 ? formattingElements.get(formattingElements.size()-1) : null;
    }

    int positionOfElement(Element el){
        for (int i = 0; i < formattingElements.size(); i++){
            if (el == formattingElements.get(i))
                return i;
        }
        return -1;
    }

    Element removeLastFormattingElement() {
        int size = formattingElements.size();
        if (size > 0)
            return formattingElements.remove(size-1);
        else
            return null;
    }

    // active formatting elements
    void pushActiveFormattingElements(Element in) {
        checkActiveFormattingElements(in);
        formattingElements.add(in);
    }

    void pushWithBookmark(Element in, int bookmark){
        checkActiveFormattingElements(in);
        // catch any range errors and assume bookmark is incorrect - saves a redundant range check.
        try {
            formattingElements.add(bookmark, in);
        } catch (IndexOutOfBoundsException e) {
            formattingElements.add(in);
        }
    }

    void checkActiveFormattingElements(Element in){
        int numSeen = 0;
        final int size = formattingElements.size() -1;
        int ceil = size - maxUsedFormattingElements; if (ceil <0) ceil = 0;

        for (int pos = size; pos >= ceil; pos--) {
            Element el = formattingElements.get(pos);
            if (el == null) // marker
                break;

            if (isSameFormattingElement(in, el))
                numSeen++;

            if (numSeen == 3) {
                formattingElements.remove(pos);
                break;
            }
        }
    }

    private boolean isSameFormattingElement(Element a, Element b) {
        // same if: same namespace, tag, and attributes. Element.equals only checks tag, might in future check children
        return a.normalName().equals(b.normalName()) &&
                // a.namespace().equals(b.namespace()) &&
                a.attributes().equals(b.attributes());
        // todo: namespaces
    }

    void reconstructFormattingElements() {
        if (stack.size() > maxQueueDepth)
            return;
        Element last = lastFormattingElement();
        if (last == null || onStack(last))
            return;

        Element entry = last;
        int size = formattingElements.size();
        int ceil = size - maxUsedFormattingElements; if (ceil <0) ceil = 0;
        int pos = size - 1;
        boolean skip = false;
        while (true) {
            if (pos == ceil) { // step 4. if none before, skip to 8
                skip = true;
                break;
            }
            entry = formattingElements.get(--pos); // step 5. one earlier than entry
            if (entry == null || onStack(entry)) // step 6 - neither marker nor on stack
                break; // jump to 8, else continue back to 4
        }
        while(true) {
            if (!skip) // step 7: on later than entry
                entry = formattingElements.get(++pos);
            Validate.notNull(entry); // should not occur, as we break at last element

            // 8. create new element from element, 9 insert into current node, onto stack
            skip = false; // can only skip increment from 4.
            Element newEl = new Element(tagFor(entry.normalName(), settings), null, entry.attributes().clone());
            insert(newEl);

            // 10. replace entry with new entry
            formattingElements.set(pos, newEl);

            // 11
            if (pos == size-1) // if not last entry in list, jump to 7
                break;
        }
    }
    private static final int maxUsedFormattingElements = 12; // limit how many elements get recreated

    void clearFormattingElementsToLastMarker() {
        while (!formattingElements.isEmpty()) {
            Element el = removeLastFormattingElement();
            if (el == null)
                break;
        }
    }

    void removeFromActiveFormattingElements(Element el) {
        for (int pos = formattingElements.size() -1; pos >= 0; pos--) {
            Element next = formattingElements.get(pos);
            if (next == el) {
                formattingElements.remove(pos);
                break;
            }
        }
    }

    boolean isInActiveFormattingElements(Element el) {
        return onStack(formattingElements, el);
    }

    Element getActiveFormattingElement(String nodeName) {
        for (int pos = formattingElements.size() -1; pos >= 0; pos--) {
            Element next = formattingElements.get(pos);
            if (next == null) // scope marker
                break;
            else if (next.normalName().equals(nodeName))
                return next;
        }
        return null;
    }

    void replaceActiveFormattingElement(Element out, Element in) {
        replaceInQueue(formattingElements, out, in);
    }

    void insertMarkerToFormattingElements() {
        formattingElements.add(null);
    }

    void insertInFosterParent(Node in) {
        Element fosterParent;
        Element lastTable = getFromStack(""table"");
        boolean isLastTableParent = false;
        if (lastTable != null) {
            if (lastTable.parent() != null) {
                fosterParent = lastTable.parent();
                isLastTableParent = true;
            } else
                fosterParent = aboveOnStack(lastTable);
        } else { // no table == frag
            fosterParent = stack.get(0);
        }

        if (isLastTableParent) {
            Validate.notNull(lastTable); // last table cannot be null by this point.
            lastTable.before(in);
        }
        else
            fosterParent.appendChild(in);
    }

    // Template Insertion Mode stack
    void pushTemplateMode(HtmlTreeBuilderState state) {
        tmplInsertMode.add(state);
    }

    @Nullable HtmlTreeBuilderState popTemplateMode() {
        if (tmplInsertMode.size() > 0) {
            return tmplInsertMode.remove(tmplInsertMode.size() -1);
        } else {
            return null;
        }
    }

    int templateModeSize() {
        return tmplInsertMode.size();
    }

    @Nullable HtmlTreeBuilderState currentTemplateMode() {
        return (tmplInsertMode.size() > 0) ? tmplInsertMode.get(tmplInsertMode.size() -1)  : null;
    }

    @Override
    public String toString() {
        return ""TreeBuilder{"" +
                ""currentToken="" + currentToken +
                "", state="" + state +
                "", currentElement="" + currentElement() +
                '}';
    }

    protected boolean isContentForTagData(final String normalName) {
        return (normalName.equals(""script"") || normalName.equals(""style""));
    }
}
"
jhy/jsoup,src/main/java/org/jsoup/safety/Cleaner.java,"package org.jsoup.safety;

import org.jsoup.helper.Validate;
import org.jsoup.nodes.Attribute;
import org.jsoup.nodes.Attributes;
import org.jsoup.nodes.DataNode;
import org.jsoup.nodes.Document;
import org.jsoup.nodes.Element;
import org.jsoup.nodes.Node;
import org.jsoup.nodes.TextNode;
import org.jsoup.parser.ParseErrorList;
import org.jsoup.parser.Parser;
import org.jsoup.parser.Tag;
import org.jsoup.select.NodeTraversor;
import org.jsoup.select.NodeVisitor;

import java.util.List;


/**
 The safelist based HTML cleaner. Use to ensure that end-user provided HTML contains only the elements and attributes
 that you are expecting; no junk, and no cross-site scripting attacks!
 <p>
 The HTML cleaner parses the input as HTML and then runs it through a safe-list, so the output HTML can only contain
 HTML that is allowed by the safelist.
 </p>
 <p>
 It is assumed that the input HTML is a body fragment; the clean methods only pull from the source's body, and the
 canned safe-lists only allow body contained tags.
 </p>
 <p>
 Rather than interacting directly with a Cleaner object, generally see the {@code clean} methods in {@link org.jsoup.Jsoup}.
 </p>
 */
public class Cleaner {
    private final Safelist safelist;

    /**
     Create a new cleaner, that sanitizes documents using the supplied safelist.
     @param safelist safe-list to clean with
     */
    public Cleaner(Safelist safelist) {
        Validate.notNull(safelist);
        this.safelist = safelist;
    }

    /**
     Creates a new, clean document, from the original dirty document, containing only elements allowed by the safelist.
     The original document is not modified. Only elements from the dirty document's <code>body</code> are used. The
     OutputSettings of the original document are cloned into the clean document.
     @param dirtyDocument Untrusted base document to clean.
     @return cleaned document.
     */
    public Document clean(Document dirtyDocument) {
        Validate.notNull(dirtyDocument);

        Document clean = Document.createShell(dirtyDocument.baseUri());
        copySafeNodes(dirtyDocument.body(), clean.body());
        clean.outputSettings(dirtyDocument.outputSettings().clone());

        return clean;
    }

    /**
     Determines if the input document <b>body</b>is valid, against the safelist. It is considered valid if all the tags and attributes
     in the input HTML are allowed by the safelist, and that there is no content in the <code>head</code>.
     <p>
     This method can be used as a validator for user input. An invalid document will still be cleaned successfully
     using the {@link #clean(Document)} document. If using as a validator, it is recommended to still clean the document
     to ensure enforced attributes are set correctly, and that the output is tidied.
     </p>
     @param dirtyDocument document to test
     @return true if no tags or attributes need to be removed; false if they do
     */
    public boolean isValid(Document dirtyDocument) {
        Validate.notNull(dirtyDocument);

        Document clean = Document.createShell(dirtyDocument.baseUri());
        int numDiscarded = copySafeNodes(dirtyDocument.body(), clean.body());
        return numDiscarded == 0
            && dirtyDocument.head().childNodes().isEmpty(); // because we only look at the body, but we start from a shell, make sure there's nothing in the head
    }

    public boolean isValidBodyHtml(String bodyHtml) {
        Document clean = Document.createShell("""");
        Document dirty = Document.createShell("""");
        ParseErrorList errorList = ParseErrorList.tracking(1);
        List<Node> nodes = Parser.parseFragment(bodyHtml, dirty.body(), """", errorList);
        dirty.body().insertChildren(0, nodes);
        int numDiscarded = copySafeNodes(dirty.body(), clean.body());
        return numDiscarded == 0 && errorList.isEmpty();
    }

    /**
     Iterates the input and copies trusted nodes (tags, attributes, text) into the destination.
     */
    private final class CleaningVisitor implements NodeVisitor {
        private int numDiscarded = 0;
        private final Element root;
        private Element destination; // current element to append nodes to

        private CleaningVisitor(Element root, Element destination) {
            this.root = root;
            this.destination = destination;
        }

        public void head(Node source, int depth) {
            if (source instanceof Element) {
                Element sourceEl = (Element) source;

                if (safelist.isSafeTag(sourceEl.normalName())) { // safe, clone and copy safe attrs
                    ElementMeta meta = createSafeElement(sourceEl);
                    Element destChild = meta.el;
                    destination.appendChild(destChild);

                    numDiscarded += meta.numAttribsDiscarded;
                    destination = destChild;
                } else if (source != root) { // not a safe tag, so don't add. don't count root against discarded.
                    numDiscarded++;
                }
            } else if (source instanceof TextNode) {
                TextNode sourceText = (TextNode) source;
                TextNode destText = new TextNode(sourceText.getWholeText());
                destination.appendChild(destText);
            } else if (source instanceof DataNode && safelist.isSafeTag(source.parent().nodeName())) {
              DataNode sourceData = (DataNode) source;
              DataNode destData = new DataNode(sourceData.getWholeData());
              destination.appendChild(destData);
            } else { // else, we don't care about comments, xml proc instructions, etc
                numDiscarded++;
            }
        }

        public void tail(Node source, int depth) {
            if (source instanceof Element && safelist.isSafeTag(source.nodeName())) {
                destination = destination.parent(); // would have descended, so pop destination stack
            }
        }
    }

    private int copySafeNodes(Element source, Element dest) {
        CleaningVisitor cleaningVisitor = new CleaningVisitor(source, dest);
        NodeTraversor.traverse(cleaningVisitor, source);
        return cleaningVisitor.numDiscarded;
    }

    private ElementMeta createSafeElement(Element sourceEl) {
        String sourceTag = sourceEl.tagName();
        Attributes destAttrs = new Attributes();
        Element dest = new Element(Tag.valueOf(sourceTag), sourceEl.baseUri(), destAttrs);
        int numDiscarded = 0;

        Attributes sourceAttrs = sourceEl.attributes();
        for (Attribute sourceAttr : sourceAttrs) {
            if (safelist.isSafeAttribute(sourceTag, sourceEl, sourceAttr))
                destAttrs.put(sourceAttr);
            else
                numDiscarded++;
        }
        Attributes enforcedAttrs = safelist.getEnforcedAttributes(sourceTag);
        destAttrs.addAll(enforcedAttrs);

        // Copy the original start and end range, if set
        // TODO - might be good to make a generic Element#userData set type interface, and copy those all over
        if (sourceEl.sourceRange().isTracked())
            sourceEl.sourceRange().track(dest, true);
        if (sourceEl.endSourceRange().isTracked())
            sourceEl.endSourceRange().track(dest, false);

        return new ElementMeta(dest, numDiscarded);
    }

    private static class ElementMeta {
        Element el;
        int numAttribsDiscarded;

        ElementMeta(Element el, int numAttribsDiscarded) {
            this.el = el;
            this.numAttribsDiscarded = numAttribsDiscarded;
        }
    }

}
"
jhy/jsoup,src/main/java/org/jsoup/internal/Normalizer.java,"package org.jsoup.internal;

import java.util.Locale;

/**
 * Util methods for normalizing strings. Jsoup internal use only, please don't depend on this API.
 */
public final class Normalizer {

    /** Drops the input string to lower case. */
    public static String lowerCase(final String input) {
        return input != null ? input.toLowerCase(Locale.ENGLISH) : """";
    }

    /** Lower-cases and trims the input string. */
    public static String normalize(final String input) {
        return lowerCase(input).trim();
    }

    /** If a string literal, just lower case the string; otherwise lower-case and trim. */
    public static String normalize(final String input, boolean isStringLiteral) {
        return isStringLiteral ? lowerCase(input) : normalize(input);
    }
}
"
jhy/jsoup,src/test/java/org/jsoup/select/SelectorTest.java,"package org.jsoup.select;

import org.jsoup.Jsoup;
import org.jsoup.MultiLocaleExtension.MultiLocaleTest;
import org.jsoup.nodes.Document;
import org.jsoup.nodes.Element;
import org.jsoup.parser.Parser;
import org.junit.jupiter.api.Test;

import java.util.Locale;

import static org.junit.jupiter.api.Assertions.*;

/**
 * Tests that the selector selects correctly.
 *
 * @author Jonathan Hedley, jonathan@hedley.net
 */
public class SelectorTest {
    @Test public void testByTag() {
        // should be case insensitive
        Elements els = Jsoup.parse(""<div id=1><div id=2><p>Hello</p></div></div><DIV id=3>"").select(""DIV"");
        assertEquals(3, els.size());
        assertEquals(""1"", els.get(0).id());
        assertEquals(""2"", els.get(1).id());
        assertEquals(""3"", els.get(2).id());

        Elements none = Jsoup.parse(""<div id=1><div id=2><p>Hello</p></div></div><div id=3>"").select(""span"");
        assertEquals(0, none.size());
    }

    @Test public void testById() {
        Elements els = Jsoup.parse(""<div><p id=foo>Hello</p><p id=foo>Foo two!</p></div>"").select(""#foo"");
        assertEquals(2, els.size());
        assertEquals(""Hello"", els.get(0).text());
        assertEquals(""Foo two!"", els.get(1).text());

        Elements none = Jsoup.parse(""<div id=1></div>"").select(""#foo"");
        assertEquals(0, none.size());
    }

    @Test public void testByClass() {
        Elements els = Jsoup.parse(""<p id=0 class='ONE two'><p id=1 class='one'><p id=2 class='two'>"").select(""P.One"");
        assertEquals(2, els.size());
        assertEquals(""0"", els.get(0).id());
        assertEquals(""1"", els.get(1).id());

        Elements none = Jsoup.parse(""<div class='one'></div>"").select("".foo"");
        assertEquals(0, none.size());

        Elements els2 = Jsoup.parse(""<div class='One-Two'></div>"").select("".one-two"");
        assertEquals(1, els2.size());
    }

    @Test public void testByClassCaseInsensitive() {
        String html = ""<p Class=foo>One <p Class=Foo>Two <p class=FOO>Three <p class=farp>Four"";
        Elements elsFromClass = Jsoup.parse(html).select(""P.Foo"");
        Elements elsFromAttr = Jsoup.parse(html).select(""p[class=foo]"");

        assertEquals(elsFromAttr.size(), elsFromClass.size());
        assertEquals(3, elsFromClass.size());
        assertEquals(""Two"", elsFromClass.get(1).text());
    }


    @MultiLocaleTest
    public void testByAttribute(Locale locale) {
        Locale.setDefault(locale);

        String h = ""<div Title=Foo /><div Title=Bar /><div Style=Qux /><div title=Balim /><div title=SLIM />"" +
                ""<div data-name='with spaces'/>"";
        Document doc = Jsoup.parse(h);

        Elements withTitle = doc.select(""[title]"");
        assertEquals(4, withTitle.size());

        Elements foo = doc.select(""[TITLE=foo]"");
        assertEquals(1, foo.size());

        Elements foo2 = doc.select(""[title=\""foo\""]"");
        assertEquals(1, foo2.size());

        Elements foo3 = doc.select(""[title=\""Foo\""]"");
        assertEquals(1, foo3.size());

        Elements dataName = doc.select(""[data-name=\""with spaces\""]"");
        assertEquals(1, dataName.size());
        assertEquals(""with spaces"", dataName.first().attr(""data-name""));

        Elements not = doc.select(""div[title!=bar]"");
        assertEquals(5, not.size());
        assertEquals(""Foo"", not.first().attr(""title""));

        Elements starts = doc.select(""[title^=ba]"");
        assertEquals(2, starts.size());
        assertEquals(""Bar"", starts.first().attr(""title""));
        assertEquals(""Balim"", starts.last().attr(""title""));

        Elements ends = doc.select(""[title$=im]"");
        assertEquals(2, ends.size());
        assertEquals(""Balim"", ends.first().attr(""title""));
        assertEquals(""SLIM"", ends.last().attr(""title""));

        Elements contains = doc.select(""[title*=i]"");
        assertEquals(2, contains.size());
        assertEquals(""Balim"", contains.first().attr(""title""));
        assertEquals(""SLIM"", contains.last().attr(""title""));
    }

    @Test public void testNamespacedTag() {
        Document doc = Jsoup.parse(""<div><abc:def id=1>Hello</abc:def></div> <abc:def class=bold id=2>There</abc:def>"");
        Elements byTag = doc.select(""abc|def"");
        assertEquals(2, byTag.size());
        assertEquals(""1"", byTag.first().id());
        assertEquals(""2"", byTag.last().id());

        Elements byAttr = doc.select("".bold"");
        assertEquals(1, byAttr.size());
        assertEquals(""2"", byAttr.last().id());

        Elements byTagAttr = doc.select(""abc|def.bold"");
        assertEquals(1, byTagAttr.size());
        assertEquals(""2"", byTagAttr.last().id());

        Elements byContains = doc.select(""abc|def:contains(e)"");
        assertEquals(2, byContains.size());
        assertEquals(""1"", byContains.first().id());
        assertEquals(""2"", byContains.last().id());
    }

    @Test public void testWildcardNamespacedTag() {
        Document doc = Jsoup.parse(""<div><abc:def id=1>Hello</abc:def></div> <abc:def class=bold id=2>There</abc:def>"");
        Elements byTag = doc.select(""*|def"");
        assertEquals(2, byTag.size());
        assertEquals(""1"", byTag.first().id());
        assertEquals(""2"", byTag.last().id());

        Elements byAttr = doc.select("".bold"");
        assertEquals(1, byAttr.size());
        assertEquals(""2"", byAttr.last().id());

        Elements byTagAttr = doc.select(""*|def.bold"");
        assertEquals(1, byTagAttr.size());
        assertEquals(""2"", byTagAttr.last().id());

        Elements byContains = doc.select(""*|def:contains(e)"");
        assertEquals(2, byContains.size());
        assertEquals(""1"", byContains.first().id());
        assertEquals(""2"", byContains.last().id());
    }

    @Test public void testWildcardNamespacedXmlTag() {
        Document doc = Jsoup.parse(
            ""<div><Abc:Def id=1>Hello</Abc:Def></div> <Abc:Def class=bold id=2>There</abc:def>"",
            """", Parser.xmlParser()
        );

        Elements byTag = doc.select(""*|Def"");
        assertEquals(2, byTag.size());
        assertEquals(""1"", byTag.first().id());
        assertEquals(""2"", byTag.last().id());

        Elements byAttr = doc.select("".bold"");
        assertEquals(1, byAttr.size());
        assertEquals(""2"", byAttr.last().id());

        Elements byTagAttr = doc.select(""*|Def.bold"");
        assertEquals(1, byTagAttr.size());
        assertEquals(""2"", byTagAttr.last().id());

        Elements byContains = doc.select(""*|Def:contains(e)"");
        assertEquals(2, byContains.size());
        assertEquals(""1"", byContains.first().id());
        assertEquals(""2"", byContains.last().id());
    }

    @Test public void testWildCardNamespacedCaseVariations() {
        Document doc = Jsoup.parse(""<One:Two>One</One:Two><three:four>Two</three:four>"", """", Parser.xmlParser());
        Elements els1 = doc.select(""One|Two"");
        Elements els2 = doc.select(""one|two"");
        Elements els3 = doc.select(""Three|Four"");
        Elements els4 = doc.select(""three|Four"");

        assertEquals(els1, els2);
        assertEquals(els3, els4);
        assertEquals(""One"", els1.text());
        assertEquals(1, els1.size());
        assertEquals(""Two"", els3.text());
        assertEquals(1, els2.size());
    }

    @MultiLocaleTest
    public void testByAttributeStarting(Locale locale) {
        Locale.setDefault(locale);

        Document doc = Jsoup.parse(""<div id=1 ATTRIBUTE data-name=jsoup>Hello</div><p data-val=5 id=2>There</p><p id=3>No</p>"");
        Elements withData = doc.select(""[^data-]"");
        assertEquals(2, withData.size());
        assertEquals(""1"", withData.first().id());
        assertEquals(""2"", withData.last().id());

        withData = doc.select(""p[^data-]"");
        assertEquals(1, withData.size());
        assertEquals(""2"", withData.first().id());

        assertEquals(1, doc.select(""[^attrib]"").size());
    }

    @Test public void testByAttributeRegex() {
        Document doc = Jsoup.parse(""<p><img src=foo.png id=1><img src=bar.jpg id=2><img src=qux.JPEG id=3><img src=old.gif><img></p>"");
        Elements imgs = doc.select(""img[src~=(?i)\\.(png|jpe?g)]"");
        assertEquals(3, imgs.size());
        assertEquals(""1"", imgs.get(0).id());
        assertEquals(""2"", imgs.get(1).id());
        assertEquals(""3"", imgs.get(2).id());
    }

    @Test public void testByAttributeRegexCharacterClass() {
        Document doc = Jsoup.parse(""<p><img src=foo.png id=1><img src=bar.jpg id=2><img src=qux.JPEG id=3><img src=old.gif id=4></p>"");
        Elements imgs = doc.select(""img[src~=[o]]"");
        assertEquals(2, imgs.size());
        assertEquals(""1"", imgs.get(0).id());
        assertEquals(""4"", imgs.get(1).id());
    }

    @Test public void testByAttributeRegexCombined() {
        Document doc = Jsoup.parse(""<div><table class=x><td>Hello</td></table></div>"");
        Elements els = doc.select(""div table[class~=x|y]"");
        assertEquals(1, els.size());
        assertEquals(""Hello"", els.text());
    }

    @Test public void testCombinedWithContains() {
        Document doc = Jsoup.parse(""<p id=1>One</p><p>Two +</p><p>Three +</p>"");
        Elements els = doc.select(""p#1 + :contains(+)"");
        assertEquals(1, els.size());
        assertEquals(""Two +"", els.text());
        assertEquals(""p"", els.first().tagName());
    }

    @Test public void testAllElements() {
        String h = ""<div><p>Hello</p><p><b>there</b></p></div>"";
        Document doc = Jsoup.parse(h);
        Elements allDoc = doc.select(""*"");
        Elements allUnderDiv = doc.select(""div *"");
        assertEquals(8, allDoc.size());
        assertEquals(3, allUnderDiv.size());
        assertEquals(""p"", allUnderDiv.first().tagName());
    }

    @Test public void testAllWithClass() {
        String h = ""<p class=first>One<p class=first>Two<p>Three"";
        Document doc = Jsoup.parse(h);
        Elements ps = doc.select(""*.first"");
        assertEquals(2, ps.size());
    }

    @Test public void testGroupOr() {
        String h = ""<div title=foo /><div title=bar /><div /><p></p><img /><span title=qux>"";
        Document doc = Jsoup.parse(h);
        Elements els = doc.select(""p,div,[title]"");

        assertEquals(5, els.size());
        assertEquals(""div"", els.get(0).tagName());
        assertEquals(""foo"", els.get(0).attr(""title""));
        assertEquals(""div"", els.get(1).tagName());
        assertEquals(""bar"", els.get(1).attr(""title""));
        assertEquals(""div"", els.get(2).tagName());
        assertEquals(0, els.get(2).attr(""title"").length()); // missing attributes come back as empty string
        assertFalse(els.get(2).hasAttr(""title""));
        assertEquals(""p"", els.get(3).tagName());
        assertEquals(""span"", els.get(4).tagName());
    }

    @Test public void testGroupOrAttribute() {
        String h = ""<div id=1 /><div id=2 /><div title=foo /><div title=bar />"";
        Elements els = Jsoup.parse(h).select(""[id],[title=foo]"");

        assertEquals(3, els.size());
        assertEquals(""1"", els.get(0).id());
        assertEquals(""2"", els.get(1).id());
        assertEquals(""foo"", els.get(2).attr(""title""));
    }

    @Test public void descendant() {
        String h = ""<div class=head><p class=first>Hello</p><p>There</p></div><p>None</p>"";
        Document doc = Jsoup.parse(h);
        Element root = doc.getElementsByClass(""HEAD"").first();

        Elements els = root.select("".head p"");
        assertEquals(2, els.size());
        assertEquals(""Hello"", els.get(0).text());
        assertEquals(""There"", els.get(1).text());

        Elements p = root.select(""p.first"");
        assertEquals(1, p.size());
        assertEquals(""Hello"", p.get(0).text());

        Elements empty = root.select(""p .first""); // self, not descend, should not match
        assertEquals(0, empty.size());

        Elements aboveRoot = root.select(""body div.head"");
        assertEquals(0, aboveRoot.size());
    }

    @Test public void and() {
        String h = ""<div id=1 class='foo bar' title=bar name=qux><p class=foo title=bar>Hello</p></div"";
        Document doc = Jsoup.parse(h);

        Elements div = doc.select(""div.foo"");
        assertEquals(1, div.size());
        assertEquals(""div"", div.first().tagName());

        Elements p = doc.select(""div .foo""); // space indicates like ""div *.foo""
        assertEquals(1, p.size());
        assertEquals(""p"", p.first().tagName());

        Elements div2 = doc.select(""div#1.foo.bar[title=bar][name=qux]""); // very specific!
        assertEquals(1, div2.size());
        assertEquals(""div"", div2.first().tagName());

        Elements p2 = doc.select(""div *.foo""); // space indicates like ""div *.foo""
        assertEquals(1, p2.size());
        assertEquals(""p"", p2.first().tagName());
    }

    @Test public void deeperDescendant() {
        String h = ""<div class=head><p><span class=first>Hello</div><div class=head><p class=first><span>Another</span><p>Again</div>"";
        Document doc = Jsoup.parse(h);
        Element root = doc.getElementsByClass(""head"").first();

        Elements els = root.select(""div p .first"");
        assertEquals(1, els.size());
        assertEquals(""Hello"", els.first().text());
        assertEquals(""span"", els.first().tagName());

        Elements aboveRoot = root.select(""body p .first"");
        assertEquals(0, aboveRoot.size());
    }

    @Test public void parentChildElement() {
        String h = ""<div id=1><div id=2><div id = 3></div></div></div><div id=4></div>"";
        Document doc = Jsoup.parse(h);

        Elements divs = doc.select(""div > div"");
        assertEquals(2, divs.size());
        assertEquals(""2"", divs.get(0).id()); // 2 is child of 1
        assertEquals(""3"", divs.get(1).id()); // 3 is child of 2

        Elements div2 = doc.select(""div#1 > div"");
        assertEquals(1, div2.size());
        assertEquals(""2"", div2.get(0).id());
    }

    @Test public void parentWithClassChild() {
        String h = ""<h1 class=foo><a href=1 /></h1><h1 class=foo><a href=2 class=bar /></h1><h1><a href=3 /></h1>"";
        Document doc = Jsoup.parse(h);

        Elements allAs = doc.select(""h1 > a"");
        assertEquals(3, allAs.size());
        assertEquals(""a"", allAs.first().tagName());

        Elements fooAs = doc.select(""h1.foo > a"");
        assertEquals(2, fooAs.size());
        assertEquals(""a"", fooAs.first().tagName());

        Elements barAs = doc.select(""h1.foo > a.bar"");
        assertEquals(1, barAs.size());
    }

    @Test public void parentChildStar() {
        String h = ""<div id=1><p>Hello<p><b>there</b></p></div><div id=2><span>Hi</span></div>"";
        Document doc = Jsoup.parse(h);
        Elements divChilds = doc.select(""div > *"");
        assertEquals(3, divChilds.size());
        assertEquals(""p"", divChilds.get(0).tagName());
        assertEquals(""p"", divChilds.get(1).tagName());
        assertEquals(""span"", divChilds.get(2).tagName());
    }

    @Test public void multiChildDescent() {
        String h = ""<div id=foo><h1 class=bar><a href=http://example.com/>One</a></h1></div>"";
        Document doc = Jsoup.parse(h);
        Elements els = doc.select(""div#foo > h1.bar > a[href*=example]"");
        assertEquals(1, els.size());
        assertEquals(""a"", els.first().tagName());
    }

    @Test public void caseInsensitive() {
        String h = ""<dIv tItle=bAr><div>""; // mixed case so a simple toLowerCase() on value doesn't catch
        Document doc = Jsoup.parse(h);

        assertEquals(2, doc.select(""DiV"").size());
        assertEquals(1, doc.select(""DiV[TiTLE]"").size());
        assertEquals(1, doc.select(""DiV[TiTLE=BAR]"").size());
        assertEquals(0, doc.select(""DiV[TiTLE=BARBARELLA]"").size());
    }

    @Test public void adjacentSiblings() {
        String h = ""<ol><li>One<li>Two<li>Three</ol>"";
        Document doc = Jsoup.parse(h);
        Elements sibs = doc.select(""li + li"");
        assertEquals(2, sibs.size());
        assertEquals(""Two"", sibs.get(0).text());
        assertEquals(""Three"", sibs.get(1).text());
    }

    @Test public void adjacentSiblingsWithId() {
        String h = ""<ol><li id=1>One<li id=2>Two<li id=3>Three</ol>"";
        Document doc = Jsoup.parse(h);
        Elements sibs = doc.select(""li#1 + li#2"");
        assertEquals(1, sibs.size());
        assertEquals(""Two"", sibs.get(0).text());
    }

    @Test public void notAdjacent() {
        String h = ""<ol><li id=1>One<li id=2>Two<li id=3>Three</ol>"";
        Document doc = Jsoup.parse(h);
        Elements sibs = doc.select(""li#1 + li#3"");
        assertEquals(0, sibs.size());
    }

    @Test public void mixCombinator() {
        String h = ""<div class=foo><ol><li>One<li>Two<li>Three</ol></div>"";
        Document doc = Jsoup.parse(h);
        Elements sibs = doc.select(""body > div.foo li + li"");

        assertEquals(2, sibs.size());
        assertEquals(""Two"", sibs.get(0).text());
        assertEquals(""Three"", sibs.get(1).text());
    }

    @Test public void mixCombinatorGroup() {
        String h = ""<div class=foo><ol><li>One<li>Two<li>Three</ol></div>"";
        Document doc = Jsoup.parse(h);
        Elements els = doc.select("".foo > ol, ol > li + li"");

        assertEquals(3, els.size());
        assertEquals(""ol"", els.get(0).tagName());
        assertEquals(""Two"", els.get(1).text());
        assertEquals(""Three"", els.get(2).text());
    }

    @Test public void generalSiblings() {
        String h = ""<ol><li id=1>One<li id=2>Two<li id=3>Three</ol>"";
        Document doc = Jsoup.parse(h);
        Elements els = doc.select(""#1 ~ #3"");
        assertEquals(1, els.size());
        assertEquals(""Three"", els.first().text());
    }

    // for http://github.com/jhy/jsoup/issues#issue/10
    @Test public void testCharactersInIdAndClass() {
        // using CSS spec for identifiers (id and class): a-z0-9, -, _. NOT . (which is OK in html spec, but not css)
        String h = ""<div><p id='a1-foo_bar'>One</p><p class='b2-qux_bif'>Two</p></div>"";
        Document doc = Jsoup.parse(h);

        Element el1 = doc.getElementById(""a1-foo_bar"");
        assertEquals(""One"", el1.text());
        Element el2 = doc.getElementsByClass(""b2-qux_bif"").first();
        assertEquals(""Two"", el2.text());

        Element el3 = doc.select(""#a1-foo_bar"").first();
        assertEquals(""One"", el3.text());
        Element el4 = doc.select("".b2-qux_bif"").first();
        assertEquals(""Two"", el4.text());
    }

    // for http://github.com/jhy/jsoup/issues#issue/13
    @Test public void testSupportsLeadingCombinator() {
        String h = ""<div><p><span>One</span><span>Two</span></p></div>"";
        Document doc = Jsoup.parse(h);

        Element p = doc.select(""div > p"").first();
        Elements spans = p.select(""> span"");
        assertEquals(2, spans.size());
        assertEquals(""One"", spans.first().text());

        // make sure doesn't get nested
        h = ""<div id=1><div id=2><div id=3></div></div></div>"";
        doc = Jsoup.parse(h);
        Element div = doc.select(""div"").select("" > div"").first();
        assertEquals(""2"", div.id());
    }

    @Test public void testPseudoLessThan() {
        Document doc = Jsoup.parse(""<div><p>One</p><p>Two</p><p>Three</>p></div><div><p>Four</p>"");
        Elements ps = doc.select(""div p:lt(2)"");
        assertEquals(3, ps.size());
        assertEquals(""One"", ps.get(0).text());
        assertEquals(""Two"", ps.get(1).text());
        assertEquals(""Four"", ps.get(2).text());
    }

    @Test public void testPseudoGreaterThan() {
        Document doc = Jsoup.parse(""<div><p>One</p><p>Two</p><p>Three</p></div><div><p>Four</p>"");
        Elements ps = doc.select(""div p:gt(0)"");
        assertEquals(2, ps.size());
        assertEquals(""Two"", ps.get(0).text());
        assertEquals(""Three"", ps.get(1).text());
    }

    @Test public void testPseudoEquals() {
        Document doc = Jsoup.parse(""<div><p>One</p><p>Two</p><p>Three</>p></div><div><p>Four</p>"");
        Elements ps = doc.select(""div p:eq(0)"");
        assertEquals(2, ps.size());
        assertEquals(""One"", ps.get(0).text());
        assertEquals(""Four"", ps.get(1).text());

        Elements ps2 = doc.select(""div:eq(0) p:eq(0)"");
        assertEquals(1, ps2.size());
        assertEquals(""One"", ps2.get(0).text());
        assertEquals(""p"", ps2.get(0).tagName());
    }

    @Test public void testPseudoBetween() {
        Document doc = Jsoup.parse(""<div><p>One</p><p>Two</p><p>Three</>p></div><div><p>Four</p>"");
        Elements ps = doc.select(""div p:gt(0):lt(2)"");
        assertEquals(1, ps.size());
        assertEquals(""Two"", ps.get(0).text());
    }

    @Test public void testPseudoCombined() {
        Document doc = Jsoup.parse(""<div class='foo'><p>One</p><p>Two</p></div><div><p>Three</p><p>Four</p></div>"");
        Elements ps = doc.select(""div.foo p:gt(0)"");
        assertEquals(1, ps.size());
        assertEquals(""Two"", ps.get(0).text());
    }

    @Test public void testPseudoHas() {
        Document doc = Jsoup.parse(""<div id=0><p><span>Hello</span></p></div> <div id=1><span class=foo>There</span></div> <div id=2><p>Not</p></div>"");

        Elements divs1 = doc.select(""div:has(span)"");
        assertEquals(2, divs1.size());
        assertEquals(""0"", divs1.get(0).id());
        assertEquals(""1"", divs1.get(1).id());

        Elements divs2 = doc.select(""div:has([class])"");
        assertEquals(1, divs2.size());
        assertEquals(""1"", divs2.get(0).id());

        Elements divs3 = doc.select(""div:has(span, p)"");
        assertEquals(3, divs3.size());
        assertEquals(""0"", divs3.get(0).id());
        assertEquals(""1"", divs3.get(1).id());
        assertEquals(""2"", divs3.get(2).id());

        Elements els1 = doc.body().select("":has(p)"");
        assertEquals(3, els1.size()); // body, div, div
        assertEquals(""body"", els1.first().tagName());
        assertEquals(""0"", els1.get(1).id());
        assertEquals(""2"", els1.get(2).id());

        Elements els2 = doc.body().select("":has(> span)"");
        assertEquals(2,els2.size()); // p, div
        assertEquals(""p"",els2.first().tagName());
        assertEquals(""1"", els2.get(1).id());
    }

    @Test public void testNestedHas() {
        Document doc = Jsoup.parse(""<div><p><span>One</span></p></div> <div><p>Two</p></div>"");
        Elements divs = doc.select(""div:has(p:has(span))"");
        assertEquals(1, divs.size());
        assertEquals(""One"", divs.first().text());

        // test matches in has
        divs = doc.select(""div:has(p:matches((?i)two))"");
        assertEquals(1, divs.size());
        assertEquals(""div"", divs.first().tagName());
        assertEquals(""Two"", divs.first().text());

        // test contains in has
        divs = doc.select(""div:has(p:contains(two))"");
        assertEquals(1, divs.size());
        assertEquals(""div"", divs.first().tagName());
        assertEquals(""Two"", divs.first().text());
    }

    @MultiLocaleTest
    public void testPseudoContains(Locale locale) {
        Locale.setDefault(locale);

        Document doc = Jsoup.parse(""<div><p>The Rain.</p> <p class=light>The <i>RAIN</i>.</p> <p>Rain, the.</p></div>"");

        Elements ps1 = doc.select(""p:contains(Rain)"");
        assertEquals(3, ps1.size());

        Elements ps2 = doc.select(""p:contains(the rain)"");
        assertEquals(2, ps2.size());
        assertEquals(""The Rain."", ps2.first().html());
        assertEquals(""The <i>RAIN</i>."", ps2.last().html());

        Elements ps3 = doc.select(""p:contains(the Rain):has(i)"");
        assertEquals(1, ps3.size());
        assertEquals(""light"", ps3.first().className());

        Elements ps4 = doc.select("".light:contains(rain)"");
        assertEquals(1, ps4.size());
        assertEquals(""light"", ps3.first().className());

        Elements ps5 = doc.select("":contains(rain)"");
        assertEquals(8, ps5.size()); // html, body, div,...

        Elements ps6 = doc.select("":contains(RAIN)"");
        assertEquals(8, ps6.size());
    }

    @Test public void testPsuedoContainsWithParentheses() {
        Document doc = Jsoup.parse(""<div><p id=1>This (is good)</p><p id=2>This is bad)</p>"");

        Elements ps1 = doc.select(""p:contains(this (is good))"");
        assertEquals(1, ps1.size());
        assertEquals(""1"", ps1.first().id());

        Elements ps2 = doc.select(""p:contains(this is bad\\))"");
        assertEquals(1, ps2.size());
        assertEquals(""2"", ps2.first().id());
    }

    @Test void containsWholeText() {
        Document doc = Jsoup.parse(""<div><p> jsoup\n The <i>HTML</i> Parser</p><p>jsoup The HTML Parser</div>"");
        Elements ps = doc.select(""p"");

        Elements es1 = doc.select(""p:containsWholeText( jsoup\n The HTML Parser)"");
        Elements es2 = doc.select(""p:containsWholeText(jsoup The HTML Parser)"");
        assertEquals(1, es1.size());
        assertEquals(1, es2.size());
        assertEquals(ps.get(0), es1.first());
        assertEquals(ps.get(1), es2.first());

        assertEquals(0, doc.select(""div:containsWholeText(jsoup the html parser)"").size());
        assertEquals(0, doc.select(""div:containsWholeText(jsoup\n the html parser)"").size());

        doc = Jsoup.parse(""<div><p></p><p> </p><p>.  </p>"");
        Elements blanks = doc.select(""p:containsWholeText(  )"");
        assertEquals(1, blanks.size());
        assertEquals("".  "", blanks.first().wholeText());
    }

    @Test void containsWholeOwnText() {
        Document doc = Jsoup.parse(""<div><p> jsoup\n The <i>HTML</i> Parser</p><p>jsoup The HTML Parser<br></div>"");
        Elements ps = doc.select(""p"");

        Elements es1 = doc.select(""p:containsWholeOwnText( jsoup\n The  Parser)"");
        Elements es2 = doc.select(""p:containsWholeOwnText(jsoup The HTML Parser\n)"");
        assertEquals(1, es1.size());
        assertEquals(1, es2.size());
        assertEquals(ps.get(0), es1.first());
        assertEquals(ps.get(1), es2.first());

        assertEquals(0, doc.select(""div:containsWholeOwnText(jsoup the html parser)"").size());
        assertEquals(0, doc.select(""div:containsWholeOwnText(jsoup\n the  parser)"").size());

        doc = Jsoup.parse(""<div><p></p><p> </p><p>.  </p>"");
        Elements blanks = doc.select(""p:containsWholeOwnText(  )"");
        assertEquals(1, blanks.size());
        assertEquals("".  "", blanks.first().wholeText());
    }

    @MultiLocaleTest
    public void containsOwn(Locale locale) {
        Locale.setDefault(locale);

        Document doc = Jsoup.parse(""<p id=1>Hello <b>there</b> igor</p>"");
        Elements ps = doc.select(""p:containsOwn(Hello IGOR)"");
        assertEquals(1, ps.size());
        assertEquals(""1"", ps.first().id());

        assertEquals(0, doc.select(""p:containsOwn(there)"").size());

        Document doc2 = Jsoup.parse(""<p>Hello <b>there</b> IGOR</p>"");
        assertEquals(1, doc2.select(""p:containsOwn(igor)"").size());

    }

    @Test public void testMatches() {
        Document doc = Jsoup.parse(""<p id=1>The <i>Rain</i></p> <p id=2>There are 99 bottles.</p> <p id=3>Harder (this)</p> <p id=4>Rain</p>"");

        Elements p1 = doc.select(""p:matches(The rain)""); // no match, case sensitive
        assertEquals(0, p1.size());

        Elements p2 = doc.select(""p:matches((?i)the rain)""); // case insense. should include root, html, body
        assertEquals(1, p2.size());
        assertEquals(""1"", p2.first().id());

        Elements p4 = doc.select(""p:matches((?i)^rain$)""); // bounding
        assertEquals(1, p4.size());
        assertEquals(""4"", p4.first().id());

        Elements p5 = doc.select(""p:matches(\\d+)"");
        assertEquals(1, p5.size());
        assertEquals(""2"", p5.first().id());

        Elements p6 = doc.select(""p:matches(\\w+\\s+\\(\\w+\\))""); // test bracket matching
        assertEquals(1, p6.size());
        assertEquals(""3"", p6.first().id());

        Elements p7 = doc.select(""p:matches((?i)the):has(i)""); // multi
        assertEquals(1, p7.size());
        assertEquals(""1"", p7.first().id());
    }

    @Test public void matchesOwn() {
        Document doc = Jsoup.parse(""<p id=1>Hello <b>there</b> now</p>"");

        Elements p1 = doc.select(""p:matchesOwn((?i)hello now)"");
        assertEquals(1, p1.size());
        assertEquals(""1"", p1.first().id());

        assertEquals(0, doc.select(""p:matchesOwn(there)"").size());
    }

    @Test public void matchesWholeText() {
        Document doc = Jsoup.parse(""<p id=1>Hello <b>there</b>\n now</p><p id=2> </p><p id=3></p>"");

        Elements p1 = doc.select(""p:matchesWholeText((?i)hello there\n now)"");
        assertEquals(1, p1.size());
        assertEquals(""1"", p1.first().id());

        assertEquals(1, doc.select(""p:matchesWholeText(there\n now)"").size());
        assertEquals(0, doc.select(""p:matchesWholeText(There\n now)"").size());

        Elements p2 = doc.select(""p:matchesWholeText(^\\s+$)"");
        assertEquals(1, p2.size());
        assertEquals(""2"", p2.first().id());

        Elements p3 = doc.select(""p:matchesWholeText(^$)"");
        assertEquals(1, p3.size());
        assertEquals(""3"", p3.first().id());
    }

    @Test public void matchesWholeOwnText() {
        Document doc = Jsoup.parse(""<p id=1>Hello <b>there</b>\n now</p><p id=2> </p><p id=3><i>Text</i></p>"");

        Elements p1 = doc.select(""p:matchesWholeOwnText((?i)hello \n now)"");
        assertEquals(1, p1.size());
        assertEquals(""1"", p1.first().id());

        assertEquals(0, doc.select(""p:matchesWholeOwnText(there\n now)"").size());

        Elements p2 = doc.select(""p:matchesWholeOwnText(^\\s+$)"");
        assertEquals(1, p2.size());
        assertEquals(""2"", p2.first().id());

        Elements p3 = doc.select(""p:matchesWholeOwnText(^$)"");
        assertEquals(1, p3.size());
        assertEquals(""3"", p3.first().id());
    }

    @Test public void testRelaxedTags() {
        Document doc = Jsoup.parse(""<abc_def id=1>Hello</abc_def> <abc-def id=2>There</abc-def>"");

        Elements el1 = doc.select(""abc_def"");
        assertEquals(1, el1.size());
        assertEquals(""1"", el1.first().id());

        Elements el2 = doc.select(""abc-def"");
        assertEquals(1, el2.size());
        assertEquals(""2"", el2.first().id());
    }

    @Test public void notParas() {
        Document doc = Jsoup.parse(""<p id=1>One</p> <p>Two</p> <p><span>Three</span></p>"");

        Elements el1 = doc.select(""p:not([id=1])"");
        assertEquals(2, el1.size());
        assertEquals(""Two"", el1.first().text());
        assertEquals(""Three"", el1.last().text());

        Elements el2 = doc.select(""p:not(:has(span))"");
        assertEquals(2, el2.size());
        assertEquals(""One"", el2.first().text());
        assertEquals(""Two"", el2.last().text());
    }

    @Test public void notAll() {
        Document doc = Jsoup.parse(""<p>Two</p> <p><span>Three</span></p>"");

        Elements el1 = doc.body().select("":not(p)""); // should just be the span
        assertEquals(2, el1.size());
        assertEquals(""body"", el1.first().tagName());
        assertEquals(""span"", el1.last().tagName());
    }

    @Test public void notClass() {
        Document doc = Jsoup.parse(""<div class=left>One</div><div class=right id=1><p>Two</p></div>"");

        Elements el1 = doc.select(""div:not(.left)"");
        assertEquals(1, el1.size());
        assertEquals(""1"", el1.first().id());
    }

    @Test public void handlesCommasInSelector() {
        Document doc = Jsoup.parse(""<p name='1,2'>One</p><div>Two</div><ol><li>123</li><li>Text</li></ol>"");

        Elements ps = doc.select(""[name=1,2]"");
        assertEquals(1, ps.size());

        Elements containers = doc.select(""div, li:matches([0-9,]+)"");
        assertEquals(2, containers.size());
        assertEquals(""div"", containers.get(0).tagName());
        assertEquals(""li"", containers.get(1).tagName());
        assertEquals(""123"", containers.get(1).text());
    }

    @Test public void selectSupplementaryCharacter() {
        String s = new String(Character.toChars(135361));
        Document doc = Jsoup.parse(""<div k"" + s + ""='"" + s + ""'>^"" + s +""$/div>"");
        assertEquals(""div"", doc.select(""div[k"" + s + ""]"").first().tagName());
        assertEquals(""div"", doc.select(""div:containsOwn("" + s + "")"").first().tagName());
    }

    @Test
    public void selectClassWithSpace() {
        final String html = ""<div class=\""value\"">class without space</div>\n""
                          + ""<div class=\""value \"">class with space</div>"";

        Document doc = Jsoup.parse(html);

        Elements found = doc.select(""div[class=value ]"");
        assertEquals(2, found.size());
        assertEquals(""class without space"", found.get(0).text());
        assertEquals(""class with space"", found.get(1).text());

        found = doc.select(""div[class=\""value \""]"");
        assertEquals(2, found.size());
        assertEquals(""class without space"", found.get(0).text());
        assertEquals(""class with space"", found.get(1).text());

        found = doc.select(""div[class=\""value\\ \""]"");
        assertEquals(0, found.size());
    }

    @Test public void selectSameElements() {
        final String html = ""<div>one</div><div>one</div>"";

        Document doc = Jsoup.parse(html);
        Elements els = doc.select(""div"");
        assertEquals(2, els.size());

        Elements subSelect = els.select("":contains(one)"");
        assertEquals(2, subSelect.size());
    }

    @Test public void attributeWithBrackets() {
        String html = ""<div data='End]'>One</div> <div data='[Another)]]'>Two</div>"";
        Document doc = Jsoup.parse(html);
        assertEquals(""One"", doc.select(""div[data='End]']"").first().text());
        assertEquals(""Two"", doc.select(""div[data='[Another)]]']"").first().text());
        assertEquals(""One"", doc.select(""div[data=\""End]\""]"").first().text());
        assertEquals(""Two"", doc.select(""div[data=\""[Another)]]\""]"").first().text());
    }

    @MultiLocaleTest
    public void containsData(Locale locale) {
        Locale.setDefault(locale);

        String html = ""<p>function</p><script>FUNCTION</script><style>item</style><span><!-- comments --></span>"";
        Document doc = Jsoup.parse(html);
        Element body = doc.body();

        Elements dataEls1 = body.select("":containsData(function)"");
        Elements dataEls2 = body.select(""script:containsData(function)"");
        Elements dataEls3 = body.select(""span:containsData(comments)"");
        Elements dataEls4 = body.select("":containsData(o)"");
        Elements dataEls5 = body.select(""style:containsData(ITEM)"");

        assertEquals(2, dataEls1.size()); // body and script
        assertEquals(1, dataEls2.size());
        assertEquals(dataEls1.last(), dataEls2.first());
        assertEquals(""<script>FUNCTION</script>"", dataEls2.outerHtml());
        assertEquals(1, dataEls3.size());
        assertEquals(""span"", dataEls3.first().tagName());
        assertEquals(3, dataEls4.size());
        assertEquals(""body"", dataEls4.first().tagName());
        assertEquals(""script"", dataEls4.get(1).tagName());
        assertEquals(""span"", dataEls4.get(2).tagName());
        assertEquals(1, dataEls5.size());
    }

    @Test public void containsWithQuote() {
        String html = ""<p>One'One</p><p>One'Two</p>"";
        Document doc = Jsoup.parse(html);
        Elements els = doc.select(""p:contains(One\\'One)"");
        assertEquals(1, els.size());
        assertEquals(""One'One"", els.text());
    }

    @Test public void selectFirst() {
        String html = ""<p>One<p>Two<p>Three"";
        Document doc = Jsoup.parse(html);
        assertEquals(""One"", doc.selectFirst(""p"").text());
    }

    @Test public void selectFirstWithAnd() {
        String html = ""<p>One<p class=foo>Two<p>Three"";
        Document doc = Jsoup.parse(html);
        assertEquals(""Two"", doc.selectFirst(""p.foo"").text());
    }

    @Test public void selectFirstWithOr() {
        String html = ""<p>One<p>Two<p>Three<div>Four"";
        Document doc = Jsoup.parse(html);
        assertEquals(""One"", doc.selectFirst(""p, div"").text());
    }

    @Test public void matchText() {
        String html = ""<p>One<br>Two</p>"";
        Document doc = Jsoup.parse(html);
        String origHtml = doc.html();

        Elements one = doc.select(""p:matchText:first-child"");
        assertEquals(""One"", one.first().text());

        Elements two = doc.select(""p:matchText:last-child"");
        assertEquals(""Two"", two.first().text());

        assertEquals(origHtml, doc.html());

        assertEquals(""Two"", doc.select(""p:matchText + br + *"").text());
    }

    @Test public void nthLastChildWithNoParent() {
        Element el = new Element(""p"").text(""Orphan"");
        Elements els = el.select(""p:nth-last-child(1)"");
        assertEquals(0, els.size());
    }

    @Test public void splitOnBr() {
        String html = ""<div><p>One<br>Two<br>Three</p></div>"";
        Document doc = Jsoup.parse(html);

        Elements els = doc.select(""p:matchText"");
        assertEquals(3, els.size());
        assertEquals(""One"", els.get(0).text());
        assertEquals(""Two"", els.get(1).text());
        assertEquals(""Three"", els.get(2).toString());
    }

    @Test public void matchTextAttributes() {
        Document doc = Jsoup.parse(""<div><p class=one>One<br>Two<p class=two>Three<br>Four"");
        Elements els = doc.select(""p.two:matchText:last-child"");

        assertEquals(1, els.size());
        assertEquals(""Four"", els.text());
    }

    @Test public void findBetweenSpan() {
        Document doc = Jsoup.parse(""<p><span>One</span> Two <span>Three</span>"");
        Elements els = doc.select(""span ~ p:matchText""); // the Two becomes its own p, sibling of the span
        // todo - think this should really be 'p:matchText span ~ p'. The :matchText should behave as a modifier to expand the nodes.

        assertEquals(1, els.size());
        assertEquals(""Two"", els.text());
    }

    @Test public void startsWithBeginsWithSpace() {
        Document doc = Jsoup.parse(""<small><a href=\"" mailto:abc@def.net\"">(abc@def.net)</a></small>"");
        Elements els = doc.select(""a[href^=' mailto']"");

        assertEquals(1, els.size());
    }

    @Test public void endsWithEndsWithSpaces() {
        Document doc = Jsoup.parse(""<small><a href=\"" mailto:abc@def.net \"">(abc@def.net)</a></small>"");
        Elements els = doc.select(""a[href$='.net ']"");

        assertEquals(1, els.size());
    }

    // https://github.com/jhy/jsoup/issues/1257
    private final String mixedCase =
        ""<html xmlns:n=\""urn:ns\""><n:mixedCase>text</n:mixedCase></html>"";
    private final String lowercase =
        ""<html xmlns:n=\""urn:ns\""><n:lowercase>text</n:lowercase></html>"";

    @Test
    public void html_mixed_case_simple_name() {
        Document doc = Jsoup.parse(mixedCase, """", Parser.htmlParser());
        assertEquals(0, doc.select(""mixedCase"").size());
    }

    @Test
    public void html_mixed_case_wildcard_name() {
        Document doc = Jsoup.parse(mixedCase, """", Parser.htmlParser());
        assertEquals(1, doc.select(""*|mixedCase"").size());
    }

    @Test
    public void html_lowercase_simple_name() {
        Document doc = Jsoup.parse(lowercase, """", Parser.htmlParser());
        assertEquals(0, doc.select(""lowercase"").size());
    }

    @Test
    public void html_lowercase_wildcard_name() {
        Document doc = Jsoup.parse(lowercase, """", Parser.htmlParser());
        assertEquals(1, doc.select(""*|lowercase"").size());
    }

    @Test
    public void xml_mixed_case_simple_name() {
        Document doc = Jsoup.parse(mixedCase, """", Parser.xmlParser());
        assertEquals(0, doc.select(""mixedCase"").size());
    }

    @Test
    public void xml_mixed_case_wildcard_name() {
        Document doc = Jsoup.parse(mixedCase, """", Parser.xmlParser());
        assertEquals(1, doc.select(""*|mixedCase"").size());
    }

    @Test
    public void xml_lowercase_simple_name() {
        Document doc = Jsoup.parse(lowercase, """", Parser.xmlParser());
        assertEquals(0, doc.select(""lowercase"").size());
    }

    @Test
    public void xml_lowercase_wildcard_name() {
        Document doc = Jsoup.parse(lowercase, """", Parser.xmlParser());
        assertEquals(1, doc.select(""*|lowercase"").size());
    }

    @Test
    public void trimSelector() {
        // https://github.com/jhy/jsoup/issues/1274
        Document doc = Jsoup.parse(""<p><span>Hello"");
        Elements els = doc.select("" p span "");
        assertEquals(1, els.size());
        assertEquals(""Hello"", els.first().text());
    }

    @Test
    public void xmlWildcardNamespaceTest() {
        // https://github.com/jhy/jsoup/issues/1208
        Document doc = Jsoup.parse(""<ns1:MyXmlTag>1111</ns1:MyXmlTag><ns2:MyXmlTag>2222</ns2:MyXmlTag>"", """", Parser.xmlParser());
        Elements select = doc.select(""*|MyXmlTag"");
        assertEquals(2, select.size());
        assertEquals(""1111"", select.get(0).text());
        assertEquals(""2222"", select.get(1).text());
    }

    @Test
    public void childElements() {
        // https://github.com/jhy/jsoup/issues/1292
        String html = ""<body><span id=1>One <span id=2>Two</span></span></body>"";
        Document doc = Jsoup.parse(html);

        Element outer = doc.selectFirst(""span"");
        Element span = outer.selectFirst(""span"");
        Element inner = outer.selectFirst(""* span"");

        assertEquals(""1"", outer.id());
        assertEquals(""1"", span.id());
        assertEquals(""2"", inner.id());
        assertEquals(outer, span);
        assertNotEquals(outer, inner);
    }

    @Test
    public void selectFirstLevelChildrenOnly() {
        // testcase for https://github.com/jhy/jsoup/issues/984
        String html = ""<div><span>One <span>Two</span></span> <span>Three <span>Four</span></span>"";
        Document doc = Jsoup.parse(html);

        Element div = doc.selectFirst(""div"");
        assertNotNull(div);

        // want to select One and Three only - the first level children
        Elements spans = div.select("":root > span"");
        assertEquals(2, spans.size());
        assertEquals(""One Two"", spans.get(0).text());
        assertEquals(""Three Four"", spans.get(1).text());
    }

    @Test
    public void wildcardNamespaceMatchesNoNamespace() {
        // https://github.com/jhy/jsoup/issues/1565
        String xml = ""<package><meta>One</meta><opf:meta>Two</opf:meta></package>"";
        Document doc = Jsoup.parse(xml, """", Parser.xmlParser());

        Elements metaEls = doc.select(""meta"");
        assertEquals(1, metaEls.size());
        assertEquals(""One"", metaEls.get(0).text());

        Elements nsEls = doc.select(""*|meta"");
        assertEquals(2, nsEls.size());
        assertEquals(""One"", nsEls.get(0).text());
        assertEquals(""Two"", nsEls.get(1).text());
    }

    @Test void containsTextQueryIsNormalized() {
        Document doc = Jsoup.parse(""<p><p id=1>Hello  there now<em>!</em>"");
        Elements a = doc.select(""p:contains(Hello   there  now!)"");
        Elements b = doc.select("":containsOwn(hello   there  now)"");
        Elements c = doc.select(""p:contains(Hello there now)"");
        Elements d = doc.select("":containsOwn(hello There now)"");
        Elements e = doc.select(""p:contains(HelloThereNow)"");

        assertEquals(1, a.size());
        assertEquals(a, b);
        assertEquals(a, c);
        assertEquals(a, d);
        assertEquals(0, e.size());
        assertNotEquals(a, e);
    }

    @Test public void selectorExceptionNotStringFormatException() {
        Selector.SelectorParseException ex = new Selector.SelectorParseException(""%&"");
        assertEquals(""%&"", ex.getMessage());
    }
}
"
jhy/jsoup,src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java,"package org.jsoup.parser;

import org.jsoup.internal.StringUtil;
import org.jsoup.nodes.Attribute;
import org.jsoup.nodes.Attributes;
import org.jsoup.nodes.Document;
import org.jsoup.nodes.DocumentType;
import org.jsoup.nodes.Element;
import org.jsoup.nodes.Node;

import java.util.ArrayList;

import static org.jsoup.internal.StringUtil.inSorted;
import static org.jsoup.parser.HtmlTreeBuilderState.Constants.*;

/**
 * The Tree Builder's current state. Each state embodies the processing for the state, and transitions to other states.
 */
enum HtmlTreeBuilderState {
    Initial {
        boolean process(Token t, HtmlTreeBuilder tb) {
            if (isWhitespace(t)) {
                return true; // ignore whitespace until we get the first content
            } else if (t.isComment()) {
                tb.insert(t.asComment());
            } else if (t.isDoctype()) {
                // todo: parse error check on expected doctypes
                // todo: quirk state check on doctype ids
                Token.Doctype d = t.asDoctype();
                DocumentType doctype = new DocumentType(
                    tb.settings.normalizeTag(d.getName()), d.getPublicIdentifier(), d.getSystemIdentifier());
                doctype.setPubSysKey(d.getPubSysKey());
                tb.getDocument().appendChild(doctype);
                tb.onNodeInserted(doctype, t);
                if (d.isForceQuirks())
                    tb.getDocument().quirksMode(Document.QuirksMode.quirks);
                tb.transition(BeforeHtml);
            } else {
                // todo: check not iframe srcdoc
                tb.transition(BeforeHtml);
                return tb.process(t); // re-process token
            }
            return true;
        }
    },
    BeforeHtml {
        boolean process(Token t, HtmlTreeBuilder tb) {
            if (t.isDoctype()) {
                tb.error(this);
                return false;
            } else if (t.isComment()) {
                tb.insert(t.asComment());
            } else if (isWhitespace(t)) {
                tb.insert(t.asCharacter()); // out of spec - include whitespace
            } else if (t.isStartTag() && t.asStartTag().normalName().equals(""html"")) {
                tb.insert(t.asStartTag());
                tb.transition(BeforeHead);
            } else if (t.isEndTag() && (inSorted(t.asEndTag().normalName(), BeforeHtmlToHead))) {
                return anythingElse(t, tb);
            } else if (t.isEndTag()) {
                tb.error(this);
                return false;
            } else {
                return anythingElse(t, tb);
            }
            return true;
        }

        private boolean anythingElse(Token t, HtmlTreeBuilder tb) {
            tb.insertStartTag(""html"");
            tb.transition(BeforeHead);
            return tb.process(t);
        }
    },
    BeforeHead {
        boolean process(Token t, HtmlTreeBuilder tb) {
            if (isWhitespace(t)) {
                tb.insert(t.asCharacter()); // out of spec - include whitespace
            } else if (t.isComment()) {
                tb.insert(t.asComment());
            } else if (t.isDoctype()) {
                tb.error(this);
                return false;
            } else if (t.isStartTag() && t.asStartTag().normalName().equals(""html"")) {
                return InBody.process(t, tb); // does not transition
            } else if (t.isStartTag() && t.asStartTag().normalName().equals(""head"")) {
                Element head = tb.insert(t.asStartTag());
                tb.setHeadElement(head);
                tb.transition(InHead);
            } else if (t.isEndTag() && (inSorted(t.asEndTag().normalName(), BeforeHtmlToHead))) {
                tb.processStartTag(""head"");
                return tb.process(t);
            } else if (t.isEndTag()) {
                tb.error(this);
                return false;
            } else {
                tb.processStartTag(""head"");
                return tb.process(t);
            }
            return true;
        }
    },
    InHead {
        boolean process(Token t, HtmlTreeBuilder tb) {
            if (isWhitespace(t)) {
                tb.insert(t.asCharacter()); // out of spec - include whitespace
                return true;
            }
            switch (t.type) {
                case Comment:
                    tb.insert(t.asComment());
                    break;
                case Doctype:
                    tb.error(this);
                    return false;
                case StartTag:
                    Token.StartTag start = t.asStartTag();
                    String name = start.normalName();
                    if (name.equals(""html"")) {
                        return InBody.process(t, tb);
                    } else if (inSorted(name, InHeadEmpty)) {
                        Element el = tb.insertEmpty(start);
                        // jsoup special: update base the first time it is seen
                        if (name.equals(""base"") && el.hasAttr(""href""))
                            tb.maybeSetBaseUri(el);
                    } else if (name.equals(""meta"")) {
                        tb.insertEmpty(start);
                        // todo: charset switches
                    } else if (name.equals(""title"")) {
                        handleRcData(start, tb);
                    } else if (inSorted(name, InHeadRaw)) {
                        handleRawtext(start, tb);
                    } else if (name.equals(""noscript"")) {
                        // else if noscript && scripting flag = true: rawtext (jsoup doesn't run script, to handle as noscript)
                        tb.insert(start);
                        tb.transition(InHeadNoscript);
                    } else if (name.equals(""script"")) {
                        // skips some script rules as won't execute them
                        tb.tokeniser.transition(TokeniserState.ScriptData);
                        tb.markInsertionMode();
                        tb.transition(Text);
                        tb.insert(start);
                    } else if (name.equals(""head"")) {
                        tb.error(this);
                        return false;
                    } else if (name.equals(""template"")) {
                        tb.insert(start);
                        tb.insertMarkerToFormattingElements();
                        tb.framesetOk(false);
                        tb.transition(InTemplate);
                        tb.pushTemplateMode(InTemplate);
                    } else {
                        return anythingElse(t, tb);
                    }
                    break;
                case EndTag:
                    Token.EndTag end = t.asEndTag();
                    name = end.normalName();
                    if (name.equals(""head"")) {
                        tb.pop();
                        tb.transition(AfterHead);
                    } else if (inSorted(name, Constants.InHeadEnd)) {
                        return anythingElse(t, tb);
                    } else if (name.equals(""template"")) {
                        if (!tb.onStack(name)) {
                            tb.error(this);
                        } else {
                            tb.generateImpliedEndTags(true);
                            if (!name.equals(tb.currentElement().normalName())) tb.error(this);
                            tb.popStackToClose(name);
                            tb.clearFormattingElementsToLastMarker();
                            tb.popTemplateMode();
                            tb.resetInsertionMode();
                        }
                    }
                    else {
                        tb.error(this);
                        return false;
                    }
                    break;
                default:
                    return anythingElse(t, tb);
            }
            return true;
        }

        private boolean anythingElse(Token t, TreeBuilder tb) {
            tb.processEndTag(""head"");
            return tb.process(t);
        }
    },
    InHeadNoscript {
        boolean process(Token t, HtmlTreeBuilder tb) {
            if (t.isDoctype()) {
                tb.error(this);
            } else if (t.isStartTag() && t.asStartTag().normalName().equals(""html"")) {
                return tb.process(t, InBody);
            } else if (t.isEndTag() && t.asEndTag().normalName().equals(""noscript"")) {
                tb.pop();
                tb.transition(InHead);
            } else if (isWhitespace(t) || t.isComment() || (t.isStartTag() && inSorted(t.asStartTag().normalName(),
                    InHeadNoScriptHead))) {
                return tb.process(t, InHead);
            } else if (t.isEndTag() && t.asEndTag().normalName().equals(""br"")) {
                return anythingElse(t, tb);
            } else if ((t.isStartTag() && inSorted(t.asStartTag().normalName(), InHeadNoscriptIgnore)) || t.isEndTag()) {
                tb.error(this);
                return false;
            } else {
                return anythingElse(t, tb);
            }
            return true;
        }

        private boolean anythingElse(Token t, HtmlTreeBuilder tb) {
            // note that this deviates from spec, which is to pop out of noscript and reprocess in head:
            // https://html.spec.whatwg.org/multipage/parsing.html#parsing-main-inheadnoscript
            // allows content to be inserted as data
            tb.error(this);
            tb.insert(new Token.Character().data(t.toString()));
            return true;
        }
    },
    AfterHead {
        boolean process(Token t, HtmlTreeBuilder tb) {
            if (isWhitespace(t)) {
                tb.insert(t.asCharacter());
            } else if (t.isComment()) {
                tb.insert(t.asComment());
            } else if (t.isDoctype()) {
                tb.error(this);
            } else if (t.isStartTag()) {
                Token.StartTag startTag = t.asStartTag();
                String name = startTag.normalName();
                if (name.equals(""html"")) {
                    return tb.process(t, InBody);
                } else if (name.equals(""body"")) {
                    tb.insert(startTag);
                    tb.framesetOk(false);
                    tb.transition(InBody);
                } else if (name.equals(""frameset"")) {
                    tb.insert(startTag);
                    tb.transition(InFrameset);
                } else if (inSorted(name, InBodyStartToHead)) {
                    tb.error(this);
                    Element head = tb.getHeadElement();
                    tb.push(head);
                    tb.process(t, InHead);
                    tb.removeFromStack(head);
                } else if (name.equals(""head"")) {
                    tb.error(this);
                    return false;
                } else {
                    anythingElse(t, tb);
                }
            } else if (t.isEndTag()) {
                String name = t.asEndTag().normalName();
                if (inSorted(name, AfterHeadBody)) {
                    anythingElse(t, tb);
                } else if (name.equals(""template"")) {
                    tb.process(t, InHead);
                }
                else {
                    tb.error(this);
                    return false;
                }
            } else {
                anythingElse(t, tb);
            }
            return true;
        }

        private boolean anythingElse(Token t, HtmlTreeBuilder tb) {
            tb.processStartTag(""body"");
            tb.framesetOk(true);
            return tb.process(t);
        }
    },
    InBody {
        boolean process(Token t, HtmlTreeBuilder tb) {
            switch (t.type) {
                case Character: {
                    Token.Character c = t.asCharacter();
                    if (c.getData().equals(nullString)) {
                        // todo confirm that check
                        tb.error(this);
                        return false;
                    } else if (tb.framesetOk() && isWhitespace(c)) { // don't check if whitespace if frames already closed
                        tb.reconstructFormattingElements();
                        tb.insert(c);
                    } else {
                        tb.reconstructFormattingElements();
                        tb.insert(c);
                        tb.framesetOk(false);
                    }
                    break;
                }
                case Comment: {
                    tb.insert(t.asComment());
                    break;
                }
                case Doctype: {
                    tb.error(this);
                    return false;
                }
                case StartTag:
                    return inBodyStartTag(t, tb);
                case EndTag:
                    return inBodyEndTag(t, tb);
                case EOF:
                    if (tb.templateModeSize() > 0)
                        return tb.process(t, InTemplate);
                    // todo: error if stack contains something not dd, dt, li, p, tbody, td, tfoot, th, thead, tr, body, html
                    // stop parsing
                    break;
            }
            return true;
        }

        private boolean inBodyStartTag(Token t, HtmlTreeBuilder tb) {
            final Token.StartTag startTag = t.asStartTag();
            final String name = startTag.normalName();
            final ArrayList<Element> stack;
            Element el;

            switch (name) {
                case ""a"":
                    if (tb.getActiveFormattingElement(""a"") != null) {
                        tb.error(this);
                        tb.processEndTag(""a"");

                        // still on stack?
                        Element remainingA = tb.getFromStack(""a"");
                        if (remainingA != null) {
                            tb.removeFromActiveFormattingElements(remainingA);
                            tb.removeFromStack(remainingA);
                        }
                    }
                    tb.reconstructFormattingElements();
                    el = tb.insert(startTag);
                    tb.pushActiveFormattingElements(el);
                    break;
                case ""span"":
                    // same as final else, but short circuits lots of checks
                    tb.reconstructFormattingElements();
                    tb.insert(startTag);
                    break;
                case ""li"":
                    tb.framesetOk(false);
                    stack = tb.getStack();
                    for (int i = stack.size() - 1; i > 0; i--) {
                        el = stack.get(i);
                        if (el.normalName().equals(""li"")) {
                            tb.processEndTag(""li"");
                            break;
                        }
                        if (tb.isSpecial(el) && !inSorted(el.normalName(), Constants.InBodyStartLiBreakers))
                            break;
                    }
                    if (tb.inButtonScope(""p"")) {
                        tb.processEndTag(""p"");
                    }
                    tb.insert(startTag);
                    break;
                case ""html"":
                    tb.error(this);
                    if (tb.onStack(""template"")) return false; // ignore
                    // otherwise, merge attributes onto real html (if present)
                    stack = tb.getStack();
                    if (stack.size() > 0) {
                        Element html = tb.getStack().get(0);
                        if (startTag.hasAttributes()) {
                            for (Attribute attribute : startTag.attributes) {
                                if (!html.hasAttr(attribute.getKey()))
                                    html.attributes().put(attribute);
                            }
                        }
                    }
                    break;
                case ""body"":
                    tb.error(this);
                    stack = tb.getStack();
                    if (stack.size() == 1 || (stack.size() > 2 && !stack.get(1).normalName().equals(""body"")) || tb.onStack(""template"")) {
                        // only in fragment case
                        return false; // ignore
                    } else {
                        tb.framesetOk(false);
                        // will be on stack if this is a nested body. won't be if closed (which is a variance from spec, which leaves it on)
                        Element body;
                        if (startTag.hasAttributes() && (body = tb.getFromStack(""body"")) != null) { // we only ever put one body on stack
                            for (Attribute attribute : startTag.attributes) {
                                if (!body.hasAttr(attribute.getKey()))
                                    body.attributes().put(attribute);
                            }
                        }
                    }
                    break;
                case ""frameset"":
                    tb.error(this);
                    stack = tb.getStack();
                    if (stack.size() == 1 || (stack.size() > 2 && !stack.get(1).normalName().equals(""body""))) {
                        // only in fragment case
                        return false; // ignore
                    } else if (!tb.framesetOk()) {
                        return false; // ignore frameset
                    } else {
                        Element second = stack.get(1);
                        if (second.parent() != null)
                            second.remove();
                        // pop up to html element
                        while (stack.size() > 1)
                            stack.remove(stack.size() - 1);
                        tb.insert(startTag);
                        tb.transition(InFrameset);
                    }
                    break;
                case ""form"":
                    if (tb.getFormElement() != null && !tb.onStack(""template"")) {
                        tb.error(this);
                        return false;
                    }
                    if (tb.inButtonScope(""p"")) {
                        tb.closeElement(""p"");
                    }
                    tb.insertForm(startTag, true, true); // won't associate to any template
                    break;
                case ""plaintext"":
                    if (tb.inButtonScope(""p"")) {
                        tb.processEndTag(""p"");
                    }
                    tb.insert(startTag);
                    tb.tokeniser.transition(TokeniserState.PLAINTEXT); // once in, never gets out
                    break;
                case ""button"":
                    if (tb.inButtonScope(""button"")) {
                        // close and reprocess
                        tb.error(this);
                        tb.processEndTag(""button"");
                        tb.process(startTag);
                    } else {
                        tb.reconstructFormattingElements();
                        tb.insert(startTag);
                        tb.framesetOk(false);
                    }
                    break;
                case ""nobr"":
                    tb.reconstructFormattingElements();
                    if (tb.inScope(""nobr"")) {
                        tb.error(this);
                        tb.processEndTag(""nobr"");
                        tb.reconstructFormattingElements();
                    }
                    el = tb.insert(startTag);
                    tb.pushActiveFormattingElements(el);
                    break;
                case ""table"":
                    if (tb.getDocument().quirksMode() != Document.QuirksMode.quirks && tb.inButtonScope(""p"")) {
                        tb.processEndTag(""p"");
                    }
                    tb.insert(startTag);
                    tb.framesetOk(false);
                    tb.transition(InTable);
                    break;
                case ""input"":
                    tb.reconstructFormattingElements();
                    el = tb.insertEmpty(startTag);
                    if (!el.attr(""type"").equalsIgnoreCase(""hidden""))
                        tb.framesetOk(false);
                    break;
                case ""hr"":
                    if (tb.inButtonScope(""p"")) {
                        tb.processEndTag(""p"");
                    }
                    tb.insertEmpty(startTag);
                    tb.framesetOk(false);
                    break;
                case ""image"":
                    if (tb.getFromStack(""svg"") == null)
                        return tb.process(startTag.name(""img"")); // change <image> to <img>, unless in svg
                    else
                        tb.insert(startTag);
                    break;
                case ""isindex"":
                    // how much do we care about the early 90s?
                    tb.error(this);
                    if (tb.getFormElement() != null)
                        return false;

                    tb.processStartTag(""form"");
                    if (startTag.hasAttribute(""action"")) {
                        Element form = tb.getFormElement();
                        if (form != null && startTag.hasAttribute(""action"")) {
                            String action = startTag.attributes.get(""action"");
                            form.attributes().put(""action"", action); // always LC, so don't need to scan up for ownerdoc
                        }
                    }
                    tb.processStartTag(""hr"");
                    tb.processStartTag(""label"");
                    // hope you like english.
                    String prompt = startTag.hasAttribute(""prompt"") ?
                        startTag.attributes.get(""prompt"") :
                        ""This is a searchable index. Enter search keywords: "";

                    tb.process(new Token.Character().data(prompt));

                    // input
                    Attributes inputAttribs = new Attributes();
                    if (startTag.hasAttributes()) {
                        for (Attribute attr : startTag.attributes) {
                            if (!inSorted(attr.getKey(), Constants.InBodyStartInputAttribs))
                                inputAttribs.put(attr);
                        }
                    }
                    inputAttribs.put(""name"", ""isindex"");
                    tb.processStartTag(""input"", inputAttribs);
                    tb.processEndTag(""label"");
                    tb.processStartTag(""hr"");
                    tb.processEndTag(""form"");
                    break;
                case ""textarea"":
                    tb.insert(startTag);
                    if (!startTag.isSelfClosing()) {
                        tb.tokeniser.transition(TokeniserState.Rcdata);
                        tb.markInsertionMode();
                        tb.framesetOk(false);
                        tb.transition(Text);
                    }
                    break;
                case ""xmp"":
                    if (tb.inButtonScope(""p"")) {
                        tb.processEndTag(""p"");
                    }
                    tb.reconstructFormattingElements();
                    tb.framesetOk(false);
                    handleRawtext(startTag, tb);
                    break;
                case ""iframe"":
                    tb.framesetOk(false);
                    handleRawtext(startTag, tb);
                    break;
                case ""noembed"":
                    // also handle noscript if script enabled
                    handleRawtext(startTag, tb);
                    break;
                case ""select"":
                    tb.reconstructFormattingElements();
                    tb.insert(startTag);
                    tb.framesetOk(false);
                    if (startTag.selfClosing) break; // don't change states if not added to the stack

                    HtmlTreeBuilderState state = tb.state();
                    if (state.equals(InTable) || state.equals(InCaption) || state.equals(InTableBody) || state.equals(InRow) || state.equals(InCell))
                        tb.transition(InSelectInTable);
                    else
                        tb.transition(InSelect);
                    break;
                case ""math"":
                    tb.reconstructFormattingElements();
                    // todo: handle A start tag whose tag name is ""math"" (i.e. foreign, mathml)
                    tb.insert(startTag);
                    break;
                case ""svg"":
                    tb.reconstructFormattingElements();
                    // todo: handle A start tag whose tag name is ""svg"" (xlink, svg)
                    tb.insert(startTag);
                    break;
                // static final String[] Headings = new String[]{""h1"", ""h2"", ""h3"", ""h4"", ""h5"", ""h6""};
                case ""h1"":
                case ""h2"":
                case ""h3"":
                case ""h4"":
                case ""h5"":
                case ""h6"":
                    if (tb.inButtonScope(""p"")) {
                        tb.processEndTag(""p"");
                    }
                    if (inSorted(tb.currentElement().normalName(), Constants.Headings)) {
                        tb.error(this);
                        tb.pop();
                    }
                    tb.insert(startTag);
                    break;
                // static final String[] InBodyStartPreListing = new String[]{""listing"", ""pre""};
                case ""pre"":
                case ""listing"":
                    if (tb.inButtonScope(""p"")) {
                        tb.processEndTag(""p"");
                    }
                    tb.insert(startTag);
                    tb.reader.matchConsume(""\n""); // ignore LF if next token
                    tb.framesetOk(false);
                    break;
                // static final String[] DdDt = new String[]{""dd"", ""dt""};
                case ""dd"":
                case ""dt"":
                    tb.framesetOk(false);
                    stack = tb.getStack();
                    final int bottom = stack.size() - 1;
                    final int upper = bottom >= MaxStackScan ? bottom - MaxStackScan : 0;
                    for (int i = bottom; i >= upper; i--) {
                        el = stack.get(i);
                        if (inSorted(el.normalName(), Constants.DdDt)) {
                            tb.processEndTag(el.normalName());
                            break;
                        }
                        if (tb.isSpecial(el) && !inSorted(el.normalName(), Constants.InBodyStartLiBreakers))
                            break;
                    }
                    if (tb.inButtonScope(""p"")) {
                        tb.processEndTag(""p"");
                    }
                    tb.insert(startTag);
                    break;
                // static final String[] InBodyStartOptions = new String[]{""optgroup"", ""option""};
                case ""optgroup"":
                case ""option"":
                    if (tb.currentElementIs(""option""))
                        tb.processEndTag(""option"");
                    tb.reconstructFormattingElements();
                    tb.insert(startTag);
                    break;
                // static final String[] InBodyStartRuby = new String[]{""rp"", ""rt""};
                case ""rp"":
                case ""rt"":
                    if (tb.inScope(""ruby"")) {
                        tb.generateImpliedEndTags();
                        if (!tb.currentElementIs(""ruby"")) {
                            tb.error(this);
                            tb.popStackToBefore(""ruby""); // i.e. close up to but not include name
                        }
                        tb.insert(startTag);
                    }
                    // todo - is this right? drops rp, rt if ruby not in scope?
                    break;
                // InBodyStartEmptyFormatters:
                case ""area"":
                case ""br"":
                case ""embed"":
                case ""img"":
                case ""keygen"":
                case ""wbr"":
                    tb.reconstructFormattingElements();
                    tb.insertEmpty(startTag);
                    tb.framesetOk(false);
                    break;
                // Formatters:
                case ""b"":
                case ""big"":
                case ""code"":
                case ""em"":
                case ""font"":
                case ""i"":
                case ""s"":
                case ""small"":
                case ""strike"":
                case ""strong"":
                case ""tt"":
                case ""u"":
                    tb.reconstructFormattingElements();
                    el = tb.insert(startTag);
                    tb.pushActiveFormattingElements(el);
                    break;
                default:
                    // todo - bring scan groups in if desired
                    if (!Tag.isKnownTag(name)) { // no special rules for custom tags
                        tb.insert(startTag);
                    } else if (inSorted(name, Constants.InBodyStartPClosers)) {
                        if (tb.inButtonScope(""p"")) {
                            tb.processEndTag(""p"");
                        }
                        tb.insert(startTag);
                    } else if (inSorted(name, Constants.InBodyStartToHead)) {
                        return tb.process(t, InHead);
                    } else if (inSorted(name, Constants.InBodyStartApplets)) {
                        tb.reconstructFormattingElements();
                        tb.insert(startTag);
                        tb.insertMarkerToFormattingElements();
                        tb.framesetOk(false);
                    } else if (inSorted(name, Constants.InBodyStartMedia)) {
                        tb.insertEmpty(startTag);
                    } else if (inSorted(name, Constants.InBodyStartDrop)) {
                        tb.error(this);
                        return false;
                    } else {
                        tb.reconstructFormattingElements();
                        tb.insert(startTag);
                    }
            }
            return true;
        }
        private static final int MaxStackScan = 24; // used for DD / DT scan, prevents runaway

        private boolean inBodyEndTag(Token t, HtmlTreeBuilder tb) {
            final Token.EndTag endTag = t.asEndTag();
            final String name = endTag.normalName();

            switch (name) {
                case ""template"":
                    tb.process(t, InHead);
                    break;
                case ""sarcasm"": // *sigh*
                case ""span"":
                    // same as final fall through, but saves short circuit
                    return anyOtherEndTag(t, tb);
                case ""li"":
                    if (!tb.inListItemScope(name)) {
                        tb.error(this);
                        return false;
                    } else {
                        tb.generateImpliedEndTags(name);
                        if (!tb.currentElementIs(name))
                            tb.error(this);
                        tb.popStackToClose(name);
                    }
                    break;
                case ""body"":
                    if (!tb.inScope(""body"")) {
                        tb.error(this);
                        return false;
                    } else {
                        // todo: error if stack contains something not dd, dt, li, optgroup, option, p, rp, rt, tbody, td, tfoot, th, thead, tr, body, html
                        anyOtherEndTag(t, tb);
                        tb.transition(AfterBody);
                    }
                    break;
                case ""html"":
                    boolean notIgnored = tb.processEndTag(""body"");
                    if (notIgnored)
                        return tb.process(endTag);
                    break;
                case ""form"":
                    if (!tb.onStack(""template"")) {
                        Element currentForm = tb.getFormElement();
                        tb.setFormElement(null);
                        if (currentForm == null || !tb.inScope(name)) {
                            tb.error(this);
                            return false;
                        }
                        tb.generateImpliedEndTags();
                        if (!tb.currentElementIs(name))
                            tb.error(this);
                        // remove currentForm from stack. will shift anything under up.
                        tb.removeFromStack(currentForm);
                    } else { // template on stack
                        if (!tb.inScope(name)) {
                            tb.error(this);
                            return false;
                        }
                        tb.generateImpliedEndTags();
                        if (!tb.currentElementIs(name)) tb.error(this);
                        tb.popStackToClose(name);
                    }
                    break;
                case ""p"":
                    if (!tb.inButtonScope(name)) {
                        tb.error(this);
                        tb.processStartTag(name); // if no p to close, creates an empty <p></p>
                        return tb.process(endTag);
                    } else {
                        tb.generateImpliedEndTags(name);
                        if (!tb.currentElementIs(name))
                            tb.error(this);
                        tb.popStackToClose(name);
                    }
                    break;
                case ""dd"":
                case ""dt"":
                    if (!tb.inScope(name)) {
                        tb.error(this);
                        return false;
                    } else {
                        tb.generateImpliedEndTags(name);
                        if (!tb.currentElementIs(name))
                            tb.error(this);
                        tb.popStackToClose(name);
                    }
                    break;
                case ""h1"":
                case ""h2"":
                case ""h3"":
                case ""h4"":
                case ""h5"":
                case ""h6"":
                    if (!tb.inScope(Constants.Headings)) {
                        tb.error(this);
                        return false;
                    } else {
                        tb.generateImpliedEndTags(name);
                        if (!tb.currentElementIs(name))
                            tb.error(this);
                        tb.popStackToClose(Constants.Headings);
                    }
                    break;
                case ""br"":
                    tb.error(this);
                    tb.processStartTag(""br"");
                    return false;
                default:
                    // todo - move rest to switch if desired
                    if (inSorted(name, Constants.InBodyEndAdoptionFormatters)) {
                        return inBodyEndTagAdoption(t, tb);
                    } else if (inSorted(name, Constants.InBodyEndClosers)) {
                        if (!tb.inScope(name)) {
                            // nothing to close
                            tb.error(this);
                            return false;
                        } else {
                            tb.generateImpliedEndTags();
                            if (!tb.currentElementIs(name))
                                tb.error(this);
                            tb.popStackToClose(name);
                        }
                    } else if (inSorted(name, Constants.InBodyStartApplets)) {
                        if (!tb.inScope(""name"")) {
                            if (!tb.inScope(name)) {
                                tb.error(this);
                                return false;
                            }
                            tb.generateImpliedEndTags();
                            if (!tb.currentElementIs(name))
                                tb.error(this);
                            tb.popStackToClose(name);
                            tb.clearFormattingElementsToLastMarker();
                        }
                    } else {
                        return anyOtherEndTag(t, tb);
                    }
            }
            return true;
        }

        boolean anyOtherEndTag(Token t, HtmlTreeBuilder tb) {
            final String name = t.asEndTag().normalName; // case insensitive search - goal is to preserve output case, not for the parse to be case sensitive
            final ArrayList<Element> stack = tb.getStack();

            // deviate from spec slightly to speed when super deeply nested
            Element elFromStack = tb.getFromStack(name);
            if (elFromStack == null) {
                tb.error(this);
                return false;
            }

            for (int pos = stack.size() - 1; pos >= 0; pos--) {
                Element node = stack.get(pos);
                if (node.normalName().equals(name)) {
                    tb.generateImpliedEndTags(name);
                    if (!tb.currentElementIs(name))
                        tb.error(this);
                    tb.popStackToClose(name);
                    break;
                } else {
                    if (tb.isSpecial(node)) {
                        tb.error(this);
                        return false;
                    }
                }
            }
            return true;
        }

        // Adoption Agency Algorithm.
        private boolean inBodyEndTagAdoption(Token t, HtmlTreeBuilder tb) {
            final Token.EndTag endTag = t.asEndTag();
            final String name = endTag.normalName();

            final ArrayList<Element> stack = tb.getStack();
            Element el;
            for (int i = 0; i < 8; i++) {
                Element formatEl = tb.getActiveFormattingElement(name);
                if (formatEl == null)
                    return anyOtherEndTag(t, tb);
                else if (!tb.onStack(formatEl)) {
                    tb.error(this);
                    tb.removeFromActiveFormattingElements(formatEl);
                    return true;
                } else if (!tb.inScope(formatEl.normalName())) {
                    tb.error(this);
                    return false;
                } else if (tb.currentElement() != formatEl)
                    tb.error(this);

                Element furthestBlock = null;
                Element commonAncestor = null;
                boolean seenFormattingElement = false;
                // the spec doesn't limit to < 64, but in degenerate cases (9000+ stack depth) this prevents run-aways
                final int stackSize = stack.size();
                int bookmark = -1;
                for (int si = 1; si < stackSize && si < 64; si++) {
                    // TODO: this no longer matches the current spec at https://html.spec.whatwg.org/#adoption-agency-algorithm and should be updated
                    el = stack.get(si);
                    if (el == formatEl) {
                        commonAncestor = stack.get(si - 1);
                        seenFormattingElement = true;
                        // Let a bookmark note the position of the formatting element in the list of active formatting elements relative to the elements on either side of it in the list.
                        bookmark = tb.positionOfElement(el);
                    } else if (seenFormattingElement && tb.isSpecial(el)) {
                        furthestBlock = el;
                        break;
                    }
                }
                if (furthestBlock == null) {
                    tb.popStackToClose(formatEl.normalName());
                    tb.removeFromActiveFormattingElements(formatEl);
                    return true;
                }

                Element node = furthestBlock;
                Element lastNode = furthestBlock;
                for (int j = 0; j < 3; j++) {
                    if (tb.onStack(node))
                        node = tb.aboveOnStack(node);
                    if (!tb.isInActiveFormattingElements(node)) { // note no bookmark check
                        tb.removeFromStack(node);
                        continue;
                    } else if (node == formatEl)
                        break;

                    Element replacement = new Element(tb.tagFor(node.nodeName(), ParseSettings.preserveCase), tb.getBaseUri());
                    // case will follow the original node (so honours ParseSettings)
                    tb.replaceActiveFormattingElement(node, replacement);
                    tb.replaceOnStack(node, replacement);
                    node = replacement;

                    if (lastNode == furthestBlock) {
                        // move the aforementioned bookmark to be immediately after the new node in the list of active formatting elements.
                        // not getting how this bookmark both straddles the element above, but is inbetween here...
                        bookmark = tb.positionOfElement(node) + 1;
                    }
                    if (lastNode.parent() != null)
                        lastNode.remove();
                    node.appendChild(lastNode);

                    lastNode = node;
                }

                if (commonAncestor != null) { // safety check, but would be an error if null
                    if (inSorted(commonAncestor.normalName(), Constants.InBodyEndTableFosters)) {
                        if (lastNode.parent() != null)
                            lastNode.remove();
                        tb.insertInFosterParent(lastNode);
                    } else {
                        if (lastNode.parent() != null)
                            lastNode.remove();
                        commonAncestor.appendChild(lastNode);
                    }
                }

                Element adopter = new Element(formatEl.tag(), tb.getBaseUri());
                adopter.attributes().addAll(formatEl.attributes());
                adopter.appendChildren(furthestBlock.childNodes());
                furthestBlock.appendChild(adopter);
                tb.removeFromActiveFormattingElements(formatEl);
                // insert the new element into the list of active formatting elements at the position of the aforementioned bookmark.
                tb.pushWithBookmark(adopter, bookmark);
                tb.removeFromStack(formatEl);
                tb.insertOnStackAfter(furthestBlock, adopter);
            }
            return true;
        }
    },
    Text {
        // in script, style etc. normally treated as data tags
        boolean process(Token t, HtmlTreeBuilder tb) {
            if (t.isCharacter()) {
                tb.insert(t.asCharacter());
            } else if (t.isEOF()) {
                tb.error(this);
                // if current node is script: already started
                tb.pop();
                tb.transition(tb.originalState());
                return tb.process(t);
            } else if (t.isEndTag()) {
                // if: An end tag whose tag name is ""script"" -- scripting nesting level, if evaluating scripts
                tb.pop();
                tb.transition(tb.originalState());
            }
            return true;
        }
    },
    InTable {
        boolean process(Token t, HtmlTreeBuilder tb) {
            if (t.isCharacter() && inSorted(tb.currentElement().normalName(), InTableFoster)) {
                tb.newPendingTableCharacters();
                tb.markInsertionMode();
                tb.transition(InTableText);
                return tb.process(t);
            } else if (t.isComment()) {
                tb.insert(t.asComment());
                return true;
            } else if (t.isDoctype()) {
                tb.error(this);
                return false;
            } else if (t.isStartTag()) {
                Token.StartTag startTag = t.asStartTag();
                String name = startTag.normalName();
                if (name.equals(""caption"")) {
                    tb.clearStackToTableContext();
                    tb.insertMarkerToFormattingElements();
                    tb.insert(startTag);
                    tb.transition(InCaption);
                } else if (name.equals(""colgroup"")) {
                    tb.clearStackToTableContext();
                    tb.insert(startTag);
                    tb.transition(InColumnGroup);
                } else if (name.equals(""col"")) {
                    tb.clearStackToTableContext();
                    tb.processStartTag(""colgroup"");
                    return tb.process(t);
                } else if (inSorted(name, InTableToBody)) {
                    tb.clearStackToTableContext();
                    tb.insert(startTag);
                    tb.transition(InTableBody);
                } else if (inSorted(name, InTableAddBody)) {
                    tb.clearStackToTableContext();
                    tb.processStartTag(""tbody"");
                    return tb.process(t);
                } else if (name.equals(""table"")) {
                    tb.error(this);
                    if (!tb.inTableScope(name)) { // ignore it
                        return false;
                    } else {
                        tb.popStackToClose(name);
                        if (!tb.resetInsertionMode()) {
                            // not per spec - but haven't transitioned out of table. so try something else
                            tb.insert(startTag);
                            return true;
                        }
                        return tb.process(t);
                    }
                } else if (inSorted(name, InTableToHead)) {
                    return tb.process(t, InHead);
                } else if (name.equals(""input"")) {
                    if (!(startTag.hasAttributes() && startTag.attributes.get(""type"").equalsIgnoreCase(""hidden""))) {
                        return anythingElse(t, tb);
                    } else {
                        tb.insertEmpty(startTag);
                    }
                } else if (name.equals(""form"")) {
                    tb.error(this);
                    if (tb.getFormElement() != null || tb.onStack(""template""))
                        return false;
                    else {
                        tb.insertForm(startTag, false, false); // not added to stack. can associate to template
                    }
                } else {
                    return anythingElse(t, tb);
                }
                return true; // todo: check if should return processed http://www.whatwg.org/specs/web-apps/current-work/multipage/tree-construction.html#parsing-main-intable
            } else if (t.isEndTag()) {
                Token.EndTag endTag = t.asEndTag();
                String name = endTag.normalName();

                if (name.equals(""table"")) {
                    if (!tb.inTableScope(name)) {
                        tb.error(this);
                        return false;
                    } else {
                        tb.popStackToClose(""table"");
                        tb.resetInsertionMode();
                    }
                } else if (inSorted(name, InTableEndErr)) {
                    tb.error(this);
                    return false;
                } else if (name.equals(""template"")) {
                    tb.process(t, InHead);
                } else {
                    return anythingElse(t, tb);
                }
                return true; // todo: as above todo
            } else if (t.isEOF()) {
                if (tb.currentElementIs(""html""))
                    tb.error(this);
                return true; // stops parsing
            }
            return anythingElse(t, tb);
        }

        boolean anythingElse(Token t, HtmlTreeBuilder tb) {
            tb.error(this);
            tb.setFosterInserts(true);
            tb.process(t, InBody);
            tb.setFosterInserts(false);
            return true;
        }
    },
    InTableText {
        boolean process(Token t, HtmlTreeBuilder tb) {
            if (t.type == Token.TokenType.Character) {
                Token.Character c = t.asCharacter();
                if (c.getData().equals(nullString)) {
                    tb.error(this);
                    return false;
                } else {
                    tb.getPendingTableCharacters().add(c.getData());
                }
            } else {// todo - don't really like the way these table character data lists are built
                if (tb.getPendingTableCharacters().size() > 0) {
                    for (String character : tb.getPendingTableCharacters()) {
                        if (!isWhitespace(character)) {
                            // InTable anything else section:
                            tb.error(this);
                            if (inSorted(tb.currentElement().normalName(), InTableFoster)) {
                                tb.setFosterInserts(true);
                                tb.process(new Token.Character().data(character), InBody);
                                tb.setFosterInserts(false);
                            } else {
                                tb.process(new Token.Character().data(character), InBody);
                            }
                        } else
                            tb.insert(new Token.Character().data(character));
                    }
                    tb.newPendingTableCharacters();
                }
                tb.transition(tb.originalState());
                return tb.process(t);
            }
            return true;
        }
    },
    InCaption {
        boolean process(Token t, HtmlTreeBuilder tb) {
            if (t.isEndTag() && t.asEndTag().normalName().equals(""caption"")) {
                Token.EndTag endTag = t.asEndTag();
                String name = endTag.normalName();
                if (!tb.inTableScope(name)) {
                    tb.error(this);
                    return false;
                } else {
                    tb.generateImpliedEndTags();
                    if (!tb.currentElementIs(""caption""))
                        tb.error(this);
                    tb.popStackToClose(""caption"");
                    tb.clearFormattingElementsToLastMarker();
                    tb.transition(InTable);
                }
            } else if ((
                    t.isStartTag() && inSorted(t.asStartTag().normalName(), InCellCol) ||
                            t.isEndTag() && t.asEndTag().normalName().equals(""table""))
                    ) {
                tb.error(this);
                boolean processed = tb.processEndTag(""caption"");
                if (processed)
                    return tb.process(t);
            } else if (t.isEndTag() && inSorted(t.asEndTag().normalName(), InCaptionIgnore)) {
                tb.error(this);
                return false;
            } else {
                return tb.process(t, InBody);
            }
            return true;
        }
    },
    InColumnGroup {
        boolean process(Token t, HtmlTreeBuilder tb) {
            if (isWhitespace(t)) {
                tb.insert(t.asCharacter());
                return true;
            }
            switch (t.type) {
                case Comment:
                    tb.insert(t.asComment());
                    break;
                case Doctype:
                    tb.error(this);
                    break;
                case StartTag:
                    Token.StartTag startTag = t.asStartTag();
                    switch (startTag.normalName()) {
                        case ""html"":
                            return tb.process(t, InBody);
                        case ""col"":
                            tb.insertEmpty(startTag);
                            break;
                        case ""template"":
                            tb.process(t, InHead);
                            break;
                        default:
                            return anythingElse(t, tb);
                    }
                    break;
                case EndTag:
                    Token.EndTag endTag = t.asEndTag();
                    String name = endTag.normalName();
                    switch (name) {
                        case ""colgroup"":
                            if (!tb.currentElementIs(name)) {
                                tb.error(this);
                                return false;
                            } else {
                                tb.pop();
                                tb.transition(InTable);
                            }
                            break;
                        case ""template"":
                            tb.process(t, InHead);
                            break;
                        default:
                            return anythingElse(t, tb);
                    }
                    break;
                case EOF:
                    if (tb.currentElementIs(""html""))
                        return true; // stop parsing; frag case
                    else
                        return anythingElse(t, tb);
                default:
                    return anythingElse(t, tb);
            }
            return true;
        }

        private boolean anythingElse(Token t, HtmlTreeBuilder tb) {
            if (!tb.currentElementIs(""colgroup"")) {
                tb.error(this);
                return false;
            }
            tb.pop();
            tb.transition(InTable);
            tb.process(t);
            return true;
        }
    },
    InTableBody {
        boolean process(Token t, HtmlTreeBuilder tb) {
            switch (t.type) {
                case StartTag:
                    Token.StartTag startTag = t.asStartTag();
                    String name = startTag.normalName();
                    if (name.equals(""tr"")) {
                        tb.clearStackToTableBodyContext();
                        tb.insert(startTag);
                        tb.transition(InRow);
                    } else if (inSorted(name, InCellNames)) {
                        tb.error(this);
                        tb.processStartTag(""tr"");
                        return tb.process(startTag);
                    } else if (inSorted(name, InTableBodyExit)) {
                        return exitTableBody(t, tb);
                    } else
                        return anythingElse(t, tb);
                    break;
                case EndTag:
                    Token.EndTag endTag = t.asEndTag();
                    name = endTag.normalName();
                    if (inSorted(name, InTableEndIgnore)) {
                        if (!tb.inTableScope(name)) {
                            tb.error(this);
                            return false;
                        } else {
                            tb.clearStackToTableBodyContext();
                            tb.pop();
                            tb.transition(InTable);
                        }
                    } else if (name.equals(""table"")) {
                        return exitTableBody(t, tb);
                    } else if (inSorted(name, InTableBodyEndIgnore)) {
                        tb.error(this);
                        return false;
                    } else
                        return anythingElse(t, tb);
                    break;
                default:
                    return anythingElse(t, tb);
            }
            return true;
        }

        private boolean exitTableBody(Token t, HtmlTreeBuilder tb) {
            if (!(tb.inTableScope(""tbody"") || tb.inTableScope(""thead"") || tb.inScope(""tfoot""))) {
                // frag case
                tb.error(this);
                return false;
            }
            tb.clearStackToTableBodyContext();
            tb.processEndTag(tb.currentElement().normalName()); // tbody, tfoot, thead
            return tb.process(t);
        }

        private boolean anythingElse(Token t, HtmlTreeBuilder tb) {
            return tb.process(t, InTable);
        }
    },
    InRow {
        boolean process(Token t, HtmlTreeBuilder tb) {
            if (t.isStartTag()) {
                Token.StartTag startTag = t.asStartTag();
                String name = startTag.normalName();

                if (inSorted(name, InCellNames)) {
                    tb.clearStackToTableRowContext();
                    tb.insert(startTag);
                    tb.transition(InCell);
                    tb.insertMarkerToFormattingElements();
                } else if (inSorted(name, InRowMissing)) {
                    return handleMissingTr(t, tb);
                } else {
                    return anythingElse(t, tb);
                }
            } else if (t.isEndTag()) {
                Token.EndTag endTag = t.asEndTag();
                String name = endTag.normalName();

                if (name.equals(""tr"")) {
                    if (!tb.inTableScope(name)) {
                        tb.error(this); // frag
                        return false;
                    }
                    tb.clearStackToTableRowContext();
                    tb.pop(); // tr
                    tb.transition(InTableBody);
                } else if (name.equals(""table"")) {
                    return handleMissingTr(t, tb);
                } else if (inSorted(name, InTableToBody)) {
                    if (!tb.inTableScope(name) || !tb.inTableScope(""tr"")) {
                        tb.error(this);
                        return false;
                    }
                    tb.clearStackToTableRowContext();
                    tb.pop(); // tr
                    tb.transition(InTableBody);
                } else if (inSorted(name, InRowIgnore)) {
                    tb.error(this);
                    return false;
                } else {
                    return anythingElse(t, tb);
                }
            } else {
                return anythingElse(t, tb);
            }
            return true;
        }

        private boolean anythingElse(Token t, HtmlTreeBuilder tb) {
            return tb.process(t, InTable);
        }

        private boolean handleMissingTr(Token t, TreeBuilder tb) {
            boolean processed = tb.processEndTag(""tr"");
            if (processed)
                return tb.process(t);
            else
                return false;
        }
    },
    InCell {
        boolean process(Token t, HtmlTreeBuilder tb) {
            if (t.isEndTag()) {
                Token.EndTag endTag = t.asEndTag();
                String name = endTag.normalName();

                if (inSorted(name, Constants.InCellNames)) {
                    if (!tb.inTableScope(name)) {
                        tb.error(this);
                        tb.transition(InRow); // might not be in scope if empty: <td /> and processing fake end tag
                        return false;
                    }
                    tb.generateImpliedEndTags();
                    if (!tb.currentElementIs(name))
                        tb.error(this);
                    tb.popStackToClose(name);
                    tb.clearFormattingElementsToLastMarker();
                    tb.transition(InRow);
                } else if (inSorted(name, Constants.InCellBody)) {
                    tb.error(this);
                    return false;
                } else if (inSorted(name, Constants.InCellTable)) {
                    if (!tb.inTableScope(name)) {
                        tb.error(this);
                        return false;
                    }
                    closeCell(tb);
                    return tb.process(t);
                } else {
                    return anythingElse(t, tb);
                }
            } else if (t.isStartTag() &&
                    inSorted(t.asStartTag().normalName(), Constants.InCellCol)) {
                if (!(tb.inTableScope(""td"") || tb.inTableScope(""th""))) {
                    tb.error(this);
                    return false;
                }
                closeCell(tb);
                return tb.process(t);
            } else {
                return anythingElse(t, tb);
            }
            return true;
        }

        private boolean anythingElse(Token t, HtmlTreeBuilder tb) {
            return tb.process(t, InBody);
        }

        private void closeCell(HtmlTreeBuilder tb) {
            if (tb.inTableScope(""td""))
                tb.processEndTag(""td"");
            else
                tb.processEndTag(""th""); // only here if th or td in scope
        }
    },
    InSelect {
        boolean process(Token t, HtmlTreeBuilder tb) {
            switch (t.type) {
                case Character:
                    Token.Character c = t.asCharacter();
                    if (c.getData().equals(nullString)) {
                        tb.error(this);
                        return false;
                    } else {
                        tb.insert(c);
                    }
                    break;
                case Comment:
                    tb.insert(t.asComment());
                    break;
                case Doctype:
                    tb.error(this);
                    return false;
                case StartTag:
                    Token.StartTag start = t.asStartTag();
                    String name = start.normalName();
                    if (name.equals(""html""))
                        return tb.process(start, InBody);
                    else if (name.equals(""option"")) {
                        if (tb.currentElementIs(""option""))
                            tb.processEndTag(""option"");
                        tb.insert(start);
                    } else if (name.equals(""optgroup"")) {
                        if (tb.currentElementIs(""option""))
                            tb.processEndTag(""option""); // pop option and flow to pop optgroup
                        if (tb.currentElementIs(""optgroup""))
                            tb.processEndTag(""optgroup"");
                        tb.insert(start);
                    } else if (name.equals(""select"")) {
                        tb.error(this);
                        return tb.processEndTag(""select"");
                    } else if (inSorted(name, InSelectEnd)) {
                        tb.error(this);
                        if (!tb.inSelectScope(""select""))
                            return false; // frag
                        tb.processEndTag(""select"");
                        return tb.process(start);
                    } else if (name.equals(""script"") || name.equals(""template"")) {
                        return tb.process(t, InHead);
                    } else {
                        return anythingElse(t, tb);
                    }
                    break;
                case EndTag:
                    Token.EndTag end = t.asEndTag();
                    name = end.normalName();
                    switch (name) {
                        case ""optgroup"":
                            if (tb.currentElementIs(""option"") && tb.aboveOnStack(tb.currentElement()) != null && tb.aboveOnStack(tb.currentElement()).normalName().equals(""optgroup""))
                                tb.processEndTag(""option"");
                            if (tb.currentElementIs(""optgroup""))
                                tb.pop();
                            else
                                tb.error(this);
                            break;
                        case ""option"":
                            if (tb.currentElementIs(""option""))
                                tb.pop();
                            else
                                tb.error(this);
                            break;
                        case ""select"":
                            if (!tb.inSelectScope(name)) {
                                tb.error(this);
                                return false;
                            } else {
                                tb.popStackToClose(name);
                                tb.resetInsertionMode();
                            }
                            break;
                        case ""template"":
                            return tb.process(t, InHead);
                        default:
                            return anythingElse(t, tb);
                    }
                    break;
                case EOF:
                    if (!tb.currentElementIs(""html""))
                        tb.error(this);
                    break;
                default:
                    return anythingElse(t, tb);
            }
            return true;
        }

        private boolean anythingElse(Token t, HtmlTreeBuilder tb) {
            tb.error(this);
            return false;
        }
    },
    InSelectInTable {
        boolean process(Token t, HtmlTreeBuilder tb) {
            if (t.isStartTag() && inSorted(t.asStartTag().normalName(), InSelectTableEnd)) {
                tb.error(this);
                tb.popStackToClose(""select"");
                tb.resetInsertionMode();
                return tb.process(t);
            } else if (t.isEndTag() && inSorted(t.asEndTag().normalName(), InSelectTableEnd)) {
                tb.error(this);
                if (tb.inTableScope(t.asEndTag().normalName())) {
                    tb.popStackToClose(""select"");
                    tb.resetInsertionMode();
                    return (tb.process(t));
                } else
                    return false;
            } else {
                return tb.process(t, InSelect);
            }
        }
    },
    InTemplate {
        boolean process(Token t, HtmlTreeBuilder tb) {
            final String name;
            switch (t.type) {
                case Character:
                case Comment:
                case Doctype:
                    tb.process(t, InBody);
                    break;
                case StartTag:
                    name = t.asStartTag().normalName();
                    if (inSorted(name, InTemplateToHead))
                        tb.process(t, InHead);
                    else if (inSorted(name, InTemplateToTable)) {
                        tb.popTemplateMode();
                        tb.pushTemplateMode(InTable);
                        tb.transition(InTable);
                        return tb.process(t);
                    }
                    else if (name.equals(""col"")) {
                        tb.popTemplateMode();
                        tb.pushTemplateMode(InColumnGroup);
                        tb.transition(InColumnGroup);
                        return tb.process(t);
                    } else if (name.equals(""tr"")) {
                        tb.popTemplateMode();
                        tb.pushTemplateMode(InTableBody);
                        tb.transition(InTableBody);
                        return tb.process(t);
                    } else if (name.equals(""td"") || name.equals(""th"")) {
                        tb.popTemplateMode();
                        tb.pushTemplateMode(InRow);
                        tb.transition(InRow);
                        return tb.process(t);
                    } else {
                        tb.popTemplateMode();
                        tb.pushTemplateMode(InBody);
                        tb.transition(InBody);
                        return tb.process(t);
                    }

                    break;
                case EndTag:
                    name = t.asEndTag().normalName();
                    if (name.equals(""template""))
                        tb.process(t, InHead);
                    else {
                        tb.error(this);
                        return false;
                    }
                    break;
                case EOF:
                    if (!tb.onStack(""template"")) {// stop parsing
                        return true;
                    }
                    tb.error(this);
                    tb.popStackToClose(""template"");
                    tb.clearFormattingElementsToLastMarker();
                    tb.popTemplateMode();
                    tb.resetInsertionMode();
                    // spec deviation - if we did not break out of Template, stop processing, and don't worry about cleaning up ultra-deep template stacks
                    // limited depth because this can recurse and will blow stack if too deep
                    if (tb.state() != InTemplate && tb.templateModeSize() < 12)
                        return tb.process(t);
                    else return true;
            }
            return true;
        }
    },
    AfterBody {
        boolean process(Token t, HtmlTreeBuilder tb) {
            if (isWhitespace(t)) {
                tb.insert(t.asCharacter()); // out of spec - include whitespace. spec would move into body
            } else if (t.isComment()) {
                tb.insert(t.asComment()); // into html node
            } else if (t.isDoctype()) {
                tb.error(this);
                return false;
            } else if (t.isStartTag() && t.asStartTag().normalName().equals(""html"")) {
                return tb.process(t, InBody);
            } else if (t.isEndTag() && t.asEndTag().normalName().equals(""html"")) {
                if (tb.isFragmentParsing()) {
                    tb.error(this);
                    return false;
                } else {
                    if (tb.onStack(""html"")) tb.popStackToClose(""html"");
                    tb.transition(AfterAfterBody);
                }
            } else if (t.isEOF()) {
                // chillax! we're done
            } else {
                tb.error(this);
                tb.resetBody();
                return tb.process(t);
            }
            return true;
        }
    },
    InFrameset {
        boolean process(Token t, HtmlTreeBuilder tb) {
            if (isWhitespace(t)) {
                tb.insert(t.asCharacter());
            } else if (t.isComment()) {
                tb.insert(t.asComment());
            } else if (t.isDoctype()) {
                tb.error(this);
                return false;
            } else if (t.isStartTag()) {
                Token.StartTag start = t.asStartTag();
                switch (start.normalName()) {
                    case ""html"":
                        return tb.process(start, InBody);
                    case ""frameset"":
                        tb.insert(start);
                        break;
                    case ""frame"":
                        tb.insertEmpty(start);
                        break;
                    case ""noframes"":
                        return tb.process(start, InHead);
                    default:
                        tb.error(this);
                        return false;
                }
            } else if (t.isEndTag() && t.asEndTag().normalName().equals(""frameset"")) {
                if (tb.currentElementIs(""html"")) { // frag
                    tb.error(this);
                    return false;
                } else {
                    tb.pop();
                    if (!tb.isFragmentParsing() && !tb.currentElementIs(""frameset"")) {
                        tb.transition(AfterFrameset);
                    }
                }
            } else if (t.isEOF()) {
                if (!tb.currentElementIs(""html"")) {
                    tb.error(this);
                    return true;
                }
            } else {
                tb.error(this);
                return false;
            }
            return true;
        }
    },
    AfterFrameset {
        boolean process(Token t, HtmlTreeBuilder tb) {
            if (isWhitespace(t)) {
                tb.insert(t.asCharacter());
            } else if (t.isComment()) {
                tb.insert(t.asComment());
            } else if (t.isDoctype()) {
                tb.error(this);
                return false;
            } else if (t.isStartTag() && t.asStartTag().normalName().equals(""html"")) {
                return tb.process(t, InBody);
            } else if (t.isEndTag() && t.asEndTag().normalName().equals(""html"")) {
                tb.transition(AfterAfterFrameset);
            } else if (t.isStartTag() && t.asStartTag().normalName().equals(""noframes"")) {
                return tb.process(t, InHead);
            } else if (t.isEOF()) {
                // cool your heels, we're complete
            } else {
                tb.error(this);
                return false;
            }
            return true;
        }
    },
    AfterAfterBody {
        boolean process(Token t, HtmlTreeBuilder tb) {
            if (t.isComment()) {
                tb.insert(t.asComment());
            } else if (t.isDoctype() || (t.isStartTag() && t.asStartTag().normalName().equals(""html""))) {
                return tb.process(t, InBody);
            } else if (isWhitespace(t)) {
                tb.insert(t.asCharacter());
            }else if (t.isEOF()) {
                // nice work chuck
            } else {
                tb.error(this);
                tb.resetBody();
                return tb.process(t);
            }
            return true;
        }
    },
    AfterAfterFrameset {
        boolean process(Token t, HtmlTreeBuilder tb) {
            if (t.isComment()) {
                tb.insert(t.asComment());
            } else if (t.isDoctype() || isWhitespace(t) || (t.isStartTag() && t.asStartTag().normalName().equals(""html""))) {
                return tb.process(t, InBody);
            } else if (t.isEOF()) {
                // nice work chuck
            } else if (t.isStartTag() && t.asStartTag().normalName().equals(""noframes"")) {
                return tb.process(t, InHead);
            } else {
                tb.error(this);
                return false;
            }
            return true;
        }
    },
    ForeignContent {
        boolean process(Token t, HtmlTreeBuilder tb) {
            return true;
            // todo: implement. Also; how do we get here?
        }
    };

    private static final String nullString = String.valueOf('\u0000');

    abstract boolean process(Token t, HtmlTreeBuilder tb);

    private static boolean isWhitespace(Token t) {
        if (t.isCharacter()) {
            String data = t.asCharacter().getData();
            return StringUtil.isBlank(data);
        }
        return false;
    }

    private static boolean isWhitespace(String data) {
        return StringUtil.isBlank(data);
    }

    private static void handleRcData(Token.StartTag startTag, HtmlTreeBuilder tb) {
        tb.tokeniser.transition(TokeniserState.Rcdata);
        tb.markInsertionMode();
        tb.transition(Text);
        tb.insert(startTag);
    }

    private static void handleRawtext(Token.StartTag startTag, HtmlTreeBuilder tb) {
        tb.tokeniser.transition(TokeniserState.Rawtext);
        tb.markInsertionMode();
        tb.transition(Text);
        tb.insert(startTag);
    }

    // lists of tags to search through
    static final class Constants {
        static final String[] InHeadEmpty = new String[]{""base"", ""basefont"", ""bgsound"", ""command"", ""link""};
        static final String[] InHeadRaw = new String[]{""noframes"", ""style""};
        static final String[] InHeadEnd = new String[]{""body"", ""br"", ""html""};
        static final String[] AfterHeadBody = new String[]{""body"", ""br"", ""html""};
        static final String[] BeforeHtmlToHead = new String[]{""body"", ""br"", ""head"", ""html"", };
        static final String[] InHeadNoScriptHead = new String[]{""basefont"", ""bgsound"", ""link"", ""meta"", ""noframes"", ""style""};
        static final String[] InBodyStartToHead = new String[]{""base"", ""basefont"", ""bgsound"", ""command"", ""link"", ""meta"", ""noframes"", ""script"", ""style"", ""template"", ""title""};
        static final String[] InBodyStartPClosers = new String[]{""address"", ""article"", ""aside"", ""blockquote"", ""center"", ""details"", ""dir"", ""div"", ""dl"",
            ""fieldset"", ""figcaption"", ""figure"", ""footer"", ""header"", ""hgroup"", ""menu"", ""nav"", ""ol"",
            ""p"", ""section"", ""summary"", ""ul""};
        static final String[] Headings = new String[]{""h1"", ""h2"", ""h3"", ""h4"", ""h5"", ""h6""};
        static final String[] InBodyStartLiBreakers = new String[]{""address"", ""div"", ""p""};
        static final String[] DdDt = new String[]{""dd"", ""dt""};
        static final String[] InBodyStartApplets = new String[]{""applet"", ""marquee"", ""object""};
        static final String[] InBodyStartMedia = new String[]{""param"", ""source"", ""track""};
        static final String[] InBodyStartInputAttribs = new String[]{""action"", ""name"", ""prompt""};
        static final String[] InBodyStartDrop = new String[]{""caption"", ""col"", ""colgroup"", ""frame"", ""head"", ""tbody"", ""td"", ""tfoot"", ""th"", ""thead"", ""tr""};
        static final String[] InBodyEndClosers = new String[]{""address"", ""article"", ""aside"", ""blockquote"", ""button"", ""center"", ""details"", ""dir"", ""div"",
            ""dl"", ""fieldset"", ""figcaption"", ""figure"", ""footer"", ""header"", ""hgroup"", ""listing"", ""menu"",
            ""nav"", ""ol"", ""pre"", ""section"", ""summary"", ""ul""};
        static final String[] InBodyEndAdoptionFormatters = new String[]{""a"", ""b"", ""big"", ""code"", ""em"", ""font"", ""i"", ""nobr"", ""s"", ""small"", ""strike"", ""strong"", ""tt"", ""u""};
        static final String[] InBodyEndTableFosters = new String[]{""table"", ""tbody"", ""tfoot"", ""thead"", ""tr""};
        static final String[] InTableToBody = new String[]{""tbody"", ""tfoot"", ""thead""};
        static final String[] InTableAddBody = new String[]{""td"", ""th"", ""tr""};
        static final String[] InTableToHead = new String[]{""script"", ""style"", ""template""};
        static final String[] InCellNames = new String[]{""td"", ""th""};
        static final String[] InCellBody = new String[]{""body"", ""caption"", ""col"", ""colgroup"", ""html""};
        static final String[] InCellTable = new String[]{ ""table"", ""tbody"", ""tfoot"", ""thead"", ""tr""};
        static final String[] InCellCol = new String[]{""caption"", ""col"", ""colgroup"", ""tbody"", ""td"", ""tfoot"", ""th"", ""thead"", ""tr""};
        static final String[] InTableEndErr = new String[]{""body"", ""caption"", ""col"", ""colgroup"", ""html"", ""tbody"", ""td"", ""tfoot"", ""th"", ""thead"", ""tr""};
        static final String[] InTableFoster = new String[]{""table"", ""tbody"", ""tfoot"", ""thead"", ""tr""};
        static final String[] InTableBodyExit = new String[]{""caption"", ""col"", ""colgroup"", ""tbody"", ""tfoot"", ""thead""};
        static final String[] InTableBodyEndIgnore = new String[]{""body"", ""caption"", ""col"", ""colgroup"", ""html"", ""td"", ""th"", ""tr""};
        static final String[] InRowMissing = new String[]{""caption"", ""col"", ""colgroup"", ""tbody"", ""tfoot"", ""thead"", ""tr""};
        static final String[] InRowIgnore = new String[]{""body"", ""caption"", ""col"", ""colgroup"", ""html"", ""td"", ""th""};
        static final String[] InSelectEnd = new String[]{""input"", ""keygen"", ""textarea""};
        static final String[] InSelectTableEnd = new String[]{""caption"", ""table"", ""tbody"", ""td"", ""tfoot"", ""th"", ""thead"", ""tr""};
        static final String[] InTableEndIgnore = new String[]{""tbody"", ""tfoot"", ""thead""};
        static final String[] InHeadNoscriptIgnore = new String[]{""head"", ""noscript""};
        static final String[] InCaptionIgnore = new String[]{""body"", ""col"", ""colgroup"", ""html"", ""tbody"", ""td"", ""tfoot"", ""th"", ""thead"", ""tr""};
        static final String[] InTemplateToHead = new String[] {""base"", ""basefont"", ""bgsound"", ""link"", ""meta"", ""noframes"", ""script"", ""style"", ""template"", ""title""};
        static final String[] InTemplateToTable = new String[] {""caption"", ""colgroup"", ""tbody"", ""tfoot"", ""thead""};
    }
}
"
jhy/jsoup,src/main/java/org/jsoup/nodes/Entities.java,"package org.jsoup.nodes;

import org.jsoup.SerializationException;
import org.jsoup.internal.StringUtil;
import org.jsoup.helper.Validate;
import org.jsoup.nodes.Document.OutputSettings;
import org.jsoup.parser.CharacterReader;
import org.jsoup.parser.Parser;

import java.io.IOException;
import java.nio.charset.CharsetEncoder;
import java.util.Arrays;
import java.util.HashMap;

import static org.jsoup.nodes.Document.OutputSettings.*;
import static org.jsoup.nodes.Entities.EscapeMode.base;
import static org.jsoup.nodes.Entities.EscapeMode.extended;

/**
 * HTML entities, and escape routines. Source: <a href=""http://www.w3.org/TR/html5/named-character-references.html#named-character-references"">W3C
 * HTML named character references</a>.
 */
public class Entities {
    private static final int empty = -1;
    private static final String emptyName = """";
    static final int codepointRadix = 36;
    private static final char[] codeDelims = {',', ';'};
    private static final HashMap<String, String> multipoints = new HashMap<>(); // name -> multiple character references
    private static final OutputSettings DefaultOutput = new OutputSettings();

    public enum EscapeMode {
        /**
         * Restricted entities suitable for XHTML output: lt, gt, amp, and quot only.
         */
        xhtml(EntitiesData.xmlPoints, 4),
        /**
         * Default HTML output entities.
         */
        base(EntitiesData.basePoints, 106),
        /**
         * Complete HTML entities.
         */
        extended(EntitiesData.fullPoints, 2125);

        // table of named references to their codepoints. sorted so we can binary search. built by BuildEntities.
        private String[] nameKeys;
        private int[] codeVals; // limitation is the few references with multiple characters; those go into multipoints.

        // table of codepoints to named entities.
        private int[] codeKeys; // we don't support multicodepoints to single named value currently
        private String[] nameVals;

        EscapeMode(String file, int size) {
            load(this, file, size);
        }

        int codepointForName(final String name) {
            int index = Arrays.binarySearch(nameKeys, name);
            return index >= 0 ? codeVals[index] : empty;
        }

        String nameForCodepoint(final int codepoint) {
            final int index = Arrays.binarySearch(codeKeys, codepoint);
            if (index >= 0) {
                // the results are ordered so lower case versions of same codepoint come after uppercase, and we prefer to emit lower
                // (and binary search for same item with multi results is undefined
                return (index < nameVals.length - 1 && codeKeys[index + 1] == codepoint) ?
                    nameVals[index + 1] : nameVals[index];
            }
            return emptyName;
        }

        private int size() {
            return nameKeys.length;
        }
    }

    private Entities() {
    }

    /**
     * Check if the input is a known named entity
     *
     * @param name the possible entity name (e.g. ""lt"" or ""amp"")
     * @return true if a known named entity
     */
    public static boolean isNamedEntity(final String name) {
        return extended.codepointForName(name) != empty;
    }

    /**
     * Check if the input is a known named entity in the base entity set.
     *
     * @param name the possible entity name (e.g. ""lt"" or ""amp"")
     * @return true if a known named entity in the base set
     * @see #isNamedEntity(String)
     */
    public static boolean isBaseNamedEntity(final String name) {
        return base.codepointForName(name) != empty;
    }

    /**
     * Get the character(s) represented by the named entity
     *
     * @param name entity (e.g. ""lt"" or ""amp"")
     * @return the string value of the character(s) represented by this entity, or """" if not defined
     */
    public static String getByName(String name) {
        String val = multipoints.get(name);
        if (val != null)
            return val;
        int codepoint = extended.codepointForName(name);
        if (codepoint != empty)
            return new String(new int[]{codepoint}, 0, 1);
        return emptyName;
    }

    public static int codepointsForName(final String name, final int[] codepoints) {
        String val = multipoints.get(name);
        if (val != null) {
            codepoints[0] = val.codePointAt(0);
            codepoints[1] = val.codePointAt(1);
            return 2;
        }
        int codepoint = extended.codepointForName(name);
        if (codepoint != empty) {
            codepoints[0] = codepoint;
            return 1;
        }
        return 0;
    }

    /**
     * HTML escape an input string. That is, {@code <} is returned as {@code &lt;}
     *
     * @param string the un-escaped string to escape
     * @param out the output settings to use
     * @return the escaped string
     */
    public static String escape(String string, OutputSettings out) {
        if (string == null)
            return """";
        StringBuilder accum = StringUtil.borrowBuilder();
        try {
            escape(accum, string, out, false, false, false, false);
        } catch (IOException e) {
            throw new SerializationException(e); // doesn't happen
        }
        return StringUtil.releaseBuilder(accum);
    }

    /**
     * HTML escape an input string, using the default settings (UTF-8, base entities). That is, {@code <} is returned as
     * {@code &lt;}
     *
     * @param string the un-escaped string to escape
     * @return the escaped string
     */
    public static String escape(String string) {
        return escape(string, DefaultOutput);
    }

    // this method does a lot, but other breakups cause rescanning and stringbuilder generations
    static void escape(Appendable accum, String string, OutputSettings out,
                       boolean inAttribute, boolean normaliseWhite, boolean stripLeadingWhite, boolean trimTrailing) throws IOException {

        boolean lastWasWhite = false;
        boolean reachedNonWhite = false;
        final EscapeMode escapeMode = out.escapeMode();
        final CharsetEncoder encoder = out.encoder();
        final CoreCharset coreCharset = out.coreCharset; // init in out.prepareEncoder()
        final int length = string.length();

        int codePoint;
        boolean skipped = false;
        for (int offset = 0; offset < length; offset += Character.charCount(codePoint)) {
            codePoint = string.codePointAt(offset);

            if (normaliseWhite) {
                if (StringUtil.isWhitespace(codePoint)) {
                    if (stripLeadingWhite && !reachedNonWhite) continue;
                    if (lastWasWhite) continue;
                    if (trimTrailing) {
                        skipped = true;
                        continue;
                    }
                    accum.append(' ');
                    lastWasWhite = true;
                    continue;
                } else {
                    lastWasWhite = false;
                    reachedNonWhite = true;
                    if (skipped) {
                        accum.append(' '); // wasn't the end, so need to place a normalized space
                        skipped = false;
                    }
                }
            }
            // surrogate pairs, split implementation for efficiency on single char common case (saves creating strings, char[]):
            if (codePoint < Character.MIN_SUPPLEMENTARY_CODE_POINT) {
                final char c = (char) codePoint;
                // html specific and required escapes:
                switch (c) {
                    case '&':
                        accum.append(""&amp;"");
                        break;
                    case 0xA0:
                        if (escapeMode != EscapeMode.xhtml)
                            accum.append(""&nbsp;"");
                        else
                            accum.append(""&#xa0;"");
                        break;
                    case '<':
                        // escape when in character data or when in a xml attribute val or XML syntax; not needed in html attr val
                        if (!inAttribute || escapeMode == EscapeMode.xhtml || out.syntax() == Syntax.xml)
                            accum.append(""&lt;"");
                        else
                            accum.append(c);
                        break;
                    case '>':
                        if (!inAttribute)
                            accum.append(""&gt;"");
                        else
                            accum.append(c);
                        break;
                    case '""':
                        if (inAttribute)
                            accum.append(""&quot;"");
                        else
                            accum.append(c);
                        break;
                    // we escape ascii control <x20 (other than tab, line-feed, carriage return)  for XML compliance (required) and HTML ease of reading (not required) - https://www.w3.org/TR/xml/#charsets
                    case 0x9:
                    case 0xA:
                    case 0xD:
                        accum.append(c);
                        break;
                    default:
                        if (c < 0x20 || !canEncode(coreCharset, c, encoder))
                            appendEncoded(accum, escapeMode, codePoint);
                        else
                            accum.append(c);
                }
            } else {
                final String c = new String(Character.toChars(codePoint));
                if (encoder.canEncode(c)) // uses fallback encoder for simplicity
                    accum.append(c);
                else
                    appendEncoded(accum, escapeMode, codePoint);
            }
        }
    }

    private static void appendEncoded(Appendable accum, EscapeMode escapeMode, int codePoint) throws IOException {
        final String name = escapeMode.nameForCodepoint(codePoint);
        if (!emptyName.equals(name)) // ok for identity check
            accum.append('&').append(name).append(';');
        else
            accum.append(""&#x"").append(Integer.toHexString(codePoint)).append(';');
    }

    /**
     * Un-escape an HTML escaped string. That is, {@code &lt;} is returned as {@code <}.
     *
     * @param string the HTML string to un-escape
     * @return the unescaped string
     */
    public static String unescape(String string) {
        return unescape(string, false);
    }

    /**
     * Unescape the input string.
     *
     * @param string to un-HTML-escape
     * @param strict if ""strict"" (that is, requires trailing ';' char, otherwise that's optional)
     * @return unescaped string
     */
    static String unescape(String string, boolean strict) {
        return Parser.unescapeEntities(string, strict);
    }

    /*
     * Provides a fast-path for Encoder.canEncode, which drastically improves performance on Android post JellyBean.
     * After KitKat, the implementation of canEncode degrades to the point of being useless. For non ASCII or UTF,
     * performance may be bad. We can add more encoders for common character sets that are impacted by performance
     * issues on Android if required.
     *
     * Benchmarks:     *
     * OLD toHtml() impl v New (fastpath) in millis
     * Wiki: 1895, 16
     * CNN: 6378, 55
     * Alterslash: 3013, 28
     * Jsoup: 167, 2
     */
    private static boolean canEncode(final CoreCharset charset, final char c, final CharsetEncoder fallback) {
        // todo add more charset tests if impacted by Android's bad perf in canEncode
        switch (charset) {
            case ascii:
                return c < 0x80;
            case utf:
                return true; // real is:!(Character.isLowSurrogate(c) || Character.isHighSurrogate(c)); - but already check above
            default:
                return fallback.canEncode(c);
        }
    }

    enum CoreCharset {
        ascii, utf, fallback;

        static CoreCharset byName(final String name) {
            if (name.equals(""US-ASCII""))
                return ascii;
            if (name.startsWith(""UTF-"")) // covers UTF-8, UTF-16, et al
                return utf;
            return fallback;
        }
    }

    private static void load(EscapeMode e, String pointsData, int size) {
        e.nameKeys = new String[size];
        e.codeVals = new int[size];
        e.codeKeys = new int[size];
        e.nameVals = new String[size];

        int i = 0;
        CharacterReader reader = new CharacterReader(pointsData);
        try {
            while (!reader.isEmpty()) {
                // NotNestedLessLess=10913,824;1887&

                final String name = reader.consumeTo('=');
                reader.advance();
                final int cp1 = Integer.parseInt(reader.consumeToAny(codeDelims), codepointRadix);
                final char codeDelim = reader.current();
                reader.advance();
                final int cp2;
                if (codeDelim == ',') {
                    cp2 = Integer.parseInt(reader.consumeTo(';'), codepointRadix);
                    reader.advance();
                } else {
                    cp2 = empty;
                }
                final String indexS = reader.consumeTo('&');
                final int index = Integer.parseInt(indexS, codepointRadix);
                reader.advance();

                e.nameKeys[i] = name;
                e.codeVals[i] = cp1;
                e.codeKeys[index] = cp1;
                e.nameVals[index] = name;

                if (cp2 != empty) {
                    multipoints.put(name, new String(new int[]{cp1, cp2}, 0, 2));
                }
                i++;
            }

            Validate.isTrue(i == size, ""Unexpected count of entities loaded"");
        } finally {
            reader.close();
        }
    }
}
"
jhy/jsoup,src/test/java/org/jsoup/integration/servlets/BaseServlet.java,"package org.jsoup.integration.servlets;

import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;

public abstract class BaseServlet extends HttpServlet {
    static final String TextHtml = ""text/html; charset=UTF-8"";

    // these are overridden just to get the response name to be 'res' not 'resp'
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse res) throws ServletException, IOException {
        super.doGet(req, res);
    }

    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse res) throws ServletException, IOException {
        super.doPost(req, res);
    }

    @Override
    protected void doPut(HttpServletRequest req, HttpServletResponse res) throws ServletException, IOException {
        super.doPut(req, res);
    }
}
"
jhy/jsoup,src/test/java/org/jsoup/integration/servlets/InterruptedServlet.java,"package org.jsoup.integration.servlets;

import org.jsoup.integration.TestServer;
import org.jsoup.parser.CharacterReaderTest;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;

public class InterruptedServlet extends BaseServlet {
    public static final String Url = TestServer.map(InterruptedServlet.class);
    public static final String Magnitude = ""magnitude"";
    public static final String Larger = ""larger"";


    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse res) throws IOException {
        String magnitude = req.getParameter(Magnitude);
        magnitude  = magnitude == null ? """" : magnitude;
        res.setContentType(TextHtml);
        res.setStatus(HttpServletResponse.SC_OK);

        StringBuilder sb = new StringBuilder();
        sb.append(""<title>Something</title>"");
        while (sb.length() <= CharacterReaderTest.maxBufferLen) {
            sb.append(""A suitable amount of data. \n"");
        }
        sb.append(""<p>Finale.</p>"");
        String data = sb.toString();

        int contentLength = magnitude.equals(Larger) ? data.length() * 2 : data.length() / 2;
        res.setContentLength(contentLength);

        res.getWriter().write(data);

    }
}
"
jhy/jsoup,src/test/java/org/jsoup/integration/servlets/Deflateservlet.java,"package org.jsoup.integration.servlets;

import org.jsoup.integration.TestServer;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.util.zip.Deflater;
import java.util.zip.DeflaterOutputStream;

public class Deflateservlet extends BaseServlet {
    public static final String Url = TestServer.map(Deflateservlet.class);

    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse res) throws IOException {
        res.setContentType(TextHtml);
        res.setStatus(HttpServletResponse.SC_OK);
        res.setHeader(""Content-Encoding"", ""deflate"");

        String doc = ""<p>Hello, World!<p>That should be enough, right?<p>Hello, World!<p>That should be enough, right?"";

        DeflaterOutputStream stream = new DeflaterOutputStream(
            res.getOutputStream(),
            new Deflater(Deflater.BEST_COMPRESSION, true)); // true = nowrap zlib headers

       stream.write(doc.getBytes(StandardCharsets.UTF_8));
       stream.close();
    }

    // allow the servlet to run as a main program, for local test
    public static void main(String[] args) {
        TestServer.start();
        System.out.println(Url);
    }
}
"
jhy/jsoup,src/main/java/org/jsoup/nodes/XmlDeclaration.java,"package org.jsoup.nodes;

import org.jsoup.SerializationException;
import org.jsoup.internal.StringUtil;
import org.jsoup.helper.Validate;

import java.io.IOException;

/**
 * An XML Declaration.
 */
public class XmlDeclaration extends LeafNode {
    // todo this impl isn't really right, the data shouldn't be attributes, just a run of text after the name
    private final boolean isProcessingInstruction; // <! if true, <? if false, declaration (and last data char should be ?)

    /**
     * Create a new XML declaration
     * @param name of declaration
     * @param isProcessingInstruction is processing instruction
     */
    public XmlDeclaration(String name, boolean isProcessingInstruction) {
        Validate.notNull(name);
        value = name;
        this.isProcessingInstruction = isProcessingInstruction;
    }

    public String nodeName() {
        return ""#declaration"";
    }

    /**
     * Get the name of this declaration.
     * @return name of this declaration.
     */
    public String name() {
        return coreValue();
    }

    /**
     * Get the unencoded XML declaration.
     * @return XML declaration
     */
    public String getWholeDeclaration() {
        StringBuilder sb = StringUtil.borrowBuilder();
        try {
            getWholeDeclaration(sb, new Document.OutputSettings());
        } catch (IOException e) {
            throw new SerializationException(e);
        }
        return StringUtil.releaseBuilder(sb).trim();
    }

    private void getWholeDeclaration(Appendable accum, Document.OutputSettings out) throws IOException {
        for (Attribute attribute : attributes()) {
            String key = attribute.getKey();
            String val = attribute.getValue();
            if (!key.equals(nodeName())) { // skips coreValue (name)
                accum.append(' ');
                // basically like Attribute, but skip empty vals in XML
                accum.append(key);
                if (!val.isEmpty()) {
                    accum.append(""=\"""");
                    Entities.escape(accum, val, out, true, false, false, false);
                    accum.append('""');
                }
            }
        }
    }

    void outerHtmlHead(Appendable accum, int depth, Document.OutputSettings out) throws IOException {
        accum
            .append(""<"")
            .append(isProcessingInstruction ? ""!"" : ""?"")
            .append(coreValue());
        getWholeDeclaration(accum, out);
        accum
            .append(isProcessingInstruction ? ""!"" : ""?"")
            .append("">"");
    }

    void outerHtmlTail(Appendable accum, int depth, Document.OutputSettings out) {
    }

    @Override
    public String toString() {
        return outerHtml();
    }

    @Override
    public XmlDeclaration clone() {
        return (XmlDeclaration) super.clone();
    }
}
"
jhy/jsoup,src/main/java/org/jsoup/internal/NonnullByDefault.java,"package org.jsoup.internal;

import javax.annotation.Nonnull;
import javax.annotation.meta.TypeQualifierDefault;
import java.lang.annotation.Documented;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;

@Documented
@Nonnull
@TypeQualifierDefault({ElementType.METHOD, ElementType.PARAMETER, ElementType.FIELD})
@Retention(value = RetentionPolicy.CLASS)

/**
 Indicates that all components (methods, returns, fields) are not nullable, unless otherwise specified by @Nullable.
 @see javax.annotation.ParametersAreNonnullByDefault
 */
public @interface NonnullByDefault {
}
"
jhy/jsoup,src/main/java/org/jsoup/nodes/LeafNode.java,"package org.jsoup.nodes;

import org.jsoup.helper.Validate;

import java.util.Collections;
import java.util.List;

abstract class LeafNode extends Node {
    Object value; // either a string value, or an attribute map (in the rare case multiple attributes are set)

    protected final boolean hasAttributes() {
        return value instanceof Attributes;
    }

    @Override
    public final Attributes attributes() {
        ensureAttributes();
        return (Attributes) value;
    }

    private void ensureAttributes() {
        if (!hasAttributes()) {
            Object coreValue = value;
            Attributes attributes = new Attributes();
            value = attributes;
            if (coreValue != null)
                attributes.put(nodeName(), (String) coreValue);
        }
    }

    String coreValue() {
        return attr(nodeName());
    }

    void coreValue(String value) {
        attr(nodeName(), value);
    }

    @Override
    public String attr(String key) {
        if (!hasAttributes()) {
            return nodeName().equals(key) ? (String) value : EmptyString;
        }
        return super.attr(key);
    }

    @Override
    public Node attr(String key, String value) {
        if (!hasAttributes() && key.equals(nodeName())) {
            this.value = value;
        } else {
            ensureAttributes();
            super.attr(key, value);
        }
        return this;
    }

    @Override
    public boolean hasAttr(String key) {
        ensureAttributes();
        return super.hasAttr(key);
    }

    @Override
    public Node removeAttr(String key) {
        ensureAttributes();
        return super.removeAttr(key);
    }

    @Override
    public String absUrl(String key) {
        ensureAttributes();
        return super.absUrl(key);
    }

    @Override
    public String baseUri() {
        return hasParent() ? parent().baseUri() : """";
    }

    @Override
    protected void doSetBaseUri(String baseUri) {
        // noop
    }

    @Override
    public int childNodeSize() {
        return 0;
    }

    @Override
    public Node empty() {
        return this;
    }

    @Override
    protected List<Node> ensureChildNodes() {
        return EmptyNodes;
    }

    @Override
    protected LeafNode doClone(Node parent) {
        LeafNode clone = (LeafNode) super.doClone(parent);

        // Object value could be plain string or attributes - need to clone
        if (hasAttributes())
            clone.value = ((Attributes) value).clone();

        return clone;
    }
}
"
jhy/jsoup,src/test/java/org/jsoup/safety/CleanerTest.java,"package org.jsoup.safety;

import org.jsoup.Jsoup;
import org.jsoup.MultiLocaleExtension.MultiLocaleTest;
import org.jsoup.TextUtil;
import org.jsoup.nodes.Document;
import org.jsoup.nodes.Element;
import org.jsoup.nodes.Entities;
import org.jsoup.nodes.Range;
import org.jsoup.parser.Parser;
import org.junit.jupiter.api.Test;

import java.util.Locale;

import static org.junit.jupiter.api.Assertions.*;

/**
 Tests for the cleaner.

 @author Jonathan Hedley, jonathan@hedley.net */
public class CleanerTest {
    @Test public void simpleBehaviourTest() {
        String h = ""<div><p class=foo><a href='http://evil.com'>Hello <b id=bar>there</b>!</a></div>"";
        String cleanHtml = Jsoup.clean(h, Safelist.simpleText());

        assertEquals(""Hello <b>there</b>!"", TextUtil.stripNewlines(cleanHtml));
    }

    @Test public void simpleBehaviourTest2() {
        String h = ""Hello <b>there</b>!"";
        String cleanHtml = Jsoup.clean(h, Safelist.simpleText());

        assertEquals(""Hello <b>there</b>!"", TextUtil.stripNewlines(cleanHtml));
    }

    @Test public void basicBehaviourTest() {
        String h = ""<div><p><a href='javascript:sendAllMoney()'>Dodgy</a> <A HREF='HTTP://nice.com'>Nice</a></p><blockquote>Hello</blockquote>"";
        String cleanHtml = Jsoup.clean(h, Safelist.basic());

        assertEquals(""<p><a rel=\""nofollow\"">Dodgy</a> <a href=\""http://nice.com\"" rel=\""nofollow\"">Nice</a></p><blockquote>Hello</blockquote>"",
                TextUtil.stripNewlines(cleanHtml));
    }

    @Test public void basicWithImagesTest() {
        String h = ""<div><p><img src='http://example.com/' alt=Image></p><p><img src='ftp://ftp.example.com'></p></div>"";
        String cleanHtml = Jsoup.clean(h, Safelist.basicWithImages());
        assertEquals(""<p><img src=\""http://example.com/\"" alt=\""Image\""></p><p><img></p>"", TextUtil.stripNewlines(cleanHtml));
    }

    @Test public void testRelaxed() {
        String h = ""<h1>Head</h1><table><tr><td>One<td>Two</td></tr></table>"";
        String cleanHtml = Jsoup.clean(h, Safelist.relaxed());
        assertEquals(""<h1>Head</h1><table><tbody><tr><td>One</td><td>Two</td></tr></tbody></table>"", TextUtil.stripNewlines(cleanHtml));
    }

    @Test public void testRemoveTags() {
        String h = ""<div><p><A HREF='HTTP://nice.com'>Nice</a></p><blockquote>Hello</blockquote>"";
        String cleanHtml = Jsoup.clean(h, Safelist.basic().removeTags(""a""));

        assertEquals(""<p>Nice</p><blockquote>Hello</blockquote>"", TextUtil.stripNewlines(cleanHtml));
    }

    @Test public void testRemoveAttributes() {
        String h = ""<div><p>Nice</p><blockquote cite='http://example.com/quotations'>Hello</blockquote>"";
        String cleanHtml = Jsoup.clean(h, Safelist.basic().removeAttributes(""blockquote"", ""cite""));

        assertEquals(""<p>Nice</p><blockquote>Hello</blockquote>"", TextUtil.stripNewlines(cleanHtml));
    }

    @Test public void testRemoveEnforcedAttributes() {
        String h = ""<div><p><A HREF='HTTP://nice.com'>Nice</a></p><blockquote>Hello</blockquote>"";
        String cleanHtml = Jsoup.clean(h, Safelist.basic().removeEnforcedAttribute(""a"", ""rel""));

        assertEquals(""<p><a href=\""http://nice.com\"">Nice</a></p><blockquote>Hello</blockquote>"",
                TextUtil.stripNewlines(cleanHtml));
    }

    @Test public void testRemoveProtocols() {
        String h = ""<p>Contact me <a href='mailto:info@example.com'>here</a></p>"";
        String cleanHtml = Jsoup.clean(h, Safelist.basic().removeProtocols(""a"", ""href"", ""ftp"", ""mailto""));

        assertEquals(""<p>Contact me <a rel=\""nofollow\"">here</a></p>"",
                TextUtil.stripNewlines(cleanHtml));
    }

    @MultiLocaleTest
    public void safeListedProtocolShouldBeRetained(Locale locale) {
        Locale.setDefault(locale);

        Safelist safelist = Safelist.none()
                .addTags(""a"")
                .addAttributes(""a"", ""href"")
                .addProtocols(""a"", ""href"", ""something"");

        String cleanHtml = Jsoup.clean(""<a href=\""SOMETHING://x\""></a>"", safelist);

        assertEquals(""<a href=\""SOMETHING://x\""></a>"", TextUtil.stripNewlines(cleanHtml));
    }

    @Test public void testDropComments() {
        String h = ""<p>Hello<!-- no --></p>"";
        String cleanHtml = Jsoup.clean(h, Safelist.relaxed());
        assertEquals(""<p>Hello</p>"", cleanHtml);
    }

    @Test public void testDropXmlProc() {
        String h = ""<?import namespace=\""xss\""><p>Hello</p>"";
        String cleanHtml = Jsoup.clean(h, Safelist.relaxed());
        assertEquals(""<p>Hello</p>"", cleanHtml);
    }

    @Test public void testDropScript() {
        String h = ""<SCRIPT SRC=//ha.ckers.org/.j><SCRIPT>alert(/XSS/.source)</SCRIPT>"";
        String cleanHtml = Jsoup.clean(h, Safelist.relaxed());
        assertEquals("""", cleanHtml);
    }

    @Test public void testDropImageScript() {
        String h = ""<IMG SRC=\""javascript:alert('XSS')\"">"";
        String cleanHtml = Jsoup.clean(h, Safelist.relaxed());
        assertEquals(""<img>"", cleanHtml);
    }

    @Test public void testCleanJavascriptHref() {
        String h = ""<A HREF=\""javascript:document.location='http://www.google.com/'\"">XSS</A>"";
        String cleanHtml = Jsoup.clean(h, Safelist.relaxed());
        assertEquals(""<a>XSS</a>"", cleanHtml);
    }

    @Test public void testCleanAnchorProtocol() {
        String validAnchor = ""<a href=\""#valid\"">Valid anchor</a>"";
        String invalidAnchor = ""<a href=\""#anchor with spaces\"">Invalid anchor</a>"";

        // A Safelist that does not allow anchors will strip them out.
        String cleanHtml = Jsoup.clean(validAnchor, Safelist.relaxed());
        assertEquals(""<a>Valid anchor</a>"", cleanHtml);

        cleanHtml = Jsoup.clean(invalidAnchor, Safelist.relaxed());
        assertEquals(""<a>Invalid anchor</a>"", cleanHtml);

        // A Safelist that allows them will keep them.
        Safelist relaxedWithAnchor = Safelist.relaxed().addProtocols(""a"", ""href"", ""#"");

        cleanHtml = Jsoup.clean(validAnchor, relaxedWithAnchor);
        assertEquals(validAnchor, cleanHtml);

        // An invalid anchor is never valid.
        cleanHtml = Jsoup.clean(invalidAnchor, relaxedWithAnchor);
        assertEquals(""<a>Invalid anchor</a>"", cleanHtml);
    }

    @Test public void testDropsUnknownTags() {
        String h = ""<p><custom foo=true>Test</custom></p>"";
        String cleanHtml = Jsoup.clean(h, Safelist.relaxed());
        assertEquals(""<p>Test</p>"", cleanHtml);
    }

    @Test public void testHandlesEmptyAttributes() {
        String h = ""<img alt=\""\"" src= unknown=''>"";
        String cleanHtml = Jsoup.clean(h, Safelist.basicWithImages());
        assertEquals(""<img alt=\""\"">"", cleanHtml);
    }

    @Test public void testIsValidBodyHtml() {
        String ok = ""<p>Test <b><a href='http://example.com/' rel='nofollow'>OK</a></b></p>"";
        String ok1 = ""<p>Test <b><a href='http://example.com/'>OK</a></b></p>""; // missing enforced is OK because still needs run thru cleaner
        String nok1 = ""<p><script></script>Not <b>OK</b></p>"";
        String nok2 = ""<p align=right>Test Not <b>OK</b></p>"";
        String nok3 = ""<!-- comment --><p>Not OK</p>""; // comments and the like will be cleaned
        String nok4 = ""<html><head>Foo</head><body><b>OK</b></body></html>""; // not body html
        String nok5 = ""<p>Test <b><a href='http://example.com/' rel='nofollowme'>OK</a></b></p>"";
        String nok6 = ""<p>Test <b><a href='http://example.com/'>OK</b></p>""; // missing close tag
        String nok7 = ""</div>What"";
        assertTrue(Jsoup.isValid(ok, Safelist.basic()));
        assertTrue(Jsoup.isValid(ok1, Safelist.basic()));
        assertFalse(Jsoup.isValid(nok1, Safelist.basic()));
        assertFalse(Jsoup.isValid(nok2, Safelist.basic()));
        assertFalse(Jsoup.isValid(nok3, Safelist.basic()));
        assertFalse(Jsoup.isValid(nok4, Safelist.basic()));
        assertFalse(Jsoup.isValid(nok5, Safelist.basic()));
        assertFalse(Jsoup.isValid(nok6, Safelist.basic()));
        assertFalse(Jsoup.isValid(ok, Safelist.none()));
        assertFalse(Jsoup.isValid(nok7, Safelist.basic()));
    }

    @Test public void testIsValidDocument() {
        String ok = ""<html><head></head><body><p>Hello</p></body><html>"";
        String nok = ""<html><head><script>woops</script><title>Hello</title></head><body><p>Hello</p></body><html>"";

        Safelist relaxed = Safelist.relaxed();
        Cleaner cleaner = new Cleaner(relaxed);
        Document okDoc = Jsoup.parse(ok);
        assertTrue(cleaner.isValid(okDoc));
        assertFalse(cleaner.isValid(Jsoup.parse(nok)));
        assertFalse(new Cleaner(Safelist.none()).isValid(okDoc));
    }

    @Test public void resolvesRelativeLinks() {
        String html = ""<a href='/foo'>Link</a><img src='/bar'>"";
        String clean = Jsoup.clean(html, ""http://example.com/"", Safelist.basicWithImages());
        assertEquals(""<a href=\""http://example.com/foo\"" rel=\""nofollow\"">Link</a><img src=\""http://example.com/bar\"">"", clean);
    }

    @Test public void preservesRelativeLinksIfConfigured() {
        String html = ""<a href='/foo'>Link</a><img src='/bar'> <img src='javascript:alert()'>"";
        String clean = Jsoup.clean(html, ""http://example.com/"", Safelist.basicWithImages().preserveRelativeLinks(true));
        assertEquals(""<a href=\""/foo\"" rel=\""nofollow\"">Link</a><img src=\""/bar\""> <img>"", clean);
    }

    @Test public void dropsUnresolvableRelativeLinks() {
        String html = ""<a href='/foo'>Link</a>"";
        String clean = Jsoup.clean(html, Safelist.basic());
        assertEquals(""<a rel=\""nofollow\"">Link</a>"", clean);
    }

    @Test void dropsConcealedJavascriptProtocolWhenRelativesLinksEnabled() {
        Safelist safelist = Safelist.basic().preserveRelativeLinks(true);
        String html = ""<a href=\""&#0013;ja&Tab;va&Tab;script&#0010;:alert(1)\"">Link</a>"";
        String clean = Jsoup.clean(html, ""https://"", safelist);
        assertEquals(""<a rel=\""nofollow\"">Link</a>"", clean);

        String colon = ""<a href=\""ja&Tab;va&Tab;script&colon;alert(1)\"">Link</a>"";
        String cleanColon = Jsoup.clean(colon, ""https://"", safelist);
        assertEquals(""<a rel=\""nofollow\"">Link</a>"", cleanColon);
    }

    @Test void dropsConcealedJavascriptProtocolWhenRelativesLinksDisabled() {
        Safelist safelist = Safelist.basic().preserveRelativeLinks(false);
        String html = ""<a href=\""ja&Tab;vas&#0013;cript:alert(1)\"">Link</a>"";
        String clean = Jsoup.clean(html, ""https://"", safelist);
        assertEquals(""<a rel=\""nofollow\"">Link</a>"", clean);
    }

    @Test public void handlesCustomProtocols() {
        String html = ""<img src='cid:12345' /> <img src='data:gzzt' />"";
        String dropped = Jsoup.clean(html, Safelist.basicWithImages());
        assertEquals(""<img> <img>"", dropped);

        String preserved = Jsoup.clean(html, Safelist.basicWithImages().addProtocols(""img"", ""src"", ""cid"", ""data""));
        assertEquals(""<img src=\""cid:12345\""> <img src=\""data:gzzt\"">"", preserved);
    }

    @Test public void handlesAllPseudoTag() {
        String html = ""<p class='foo' src='bar'><a class='qux'>link</a></p>"";
        Safelist safelist = new Safelist()
                .addAttributes("":all"", ""class"")
                .addAttributes(""p"", ""style"")
                .addTags(""p"", ""a"");

        String clean = Jsoup.clean(html, safelist);
        assertEquals(""<p class=\""foo\""><a class=\""qux\"">link</a></p>"", clean);
    }

    @Test public void addsTagOnAttributesIfNotSet() {
        String html = ""<p class='foo' src='bar'>One</p>"";
        Safelist safelist = new Safelist()
            .addAttributes(""p"", ""class"");
        // ^^ safelist does not have explicit tag add for p, inferred from add attributes.
        String clean = Jsoup.clean(html, safelist);
        assertEquals(""<p class=\""foo\"">One</p>"", clean);
    }

    @Test public void supplyOutputSettings() {
        // test that one can override the default document output settings
        Document.OutputSettings os = new Document.OutputSettings();
        os.prettyPrint(false);
        os.escapeMode(Entities.EscapeMode.extended);
        os.charset(""ascii"");

        String html = ""<div><p>&bernou;</p></div>"";
        String customOut = Jsoup.clean(html, ""http://foo.com/"", Safelist.relaxed(), os);
        String defaultOut = Jsoup.clean(html, ""http://foo.com/"", Safelist.relaxed());
        assertNotSame(defaultOut, customOut);

        assertEquals(""<div><p>&Bscr;</p></div>"", customOut); // entities now prefers shorted names if aliased
        assertEquals(""<div>\n"" +
            "" <p>‚Ñ¨</p>\n"" +
            ""</div>"", defaultOut);

        os.charset(""ASCII"");
        os.escapeMode(Entities.EscapeMode.base);
        String customOut2 = Jsoup.clean(html, ""http://foo.com/"", Safelist.relaxed(), os);
        assertEquals(""<div><p>&#x212c;</p></div>"", customOut2);
    }

    @Test public void handlesFramesets() {
        String dirty = ""<html><head><script></script><noscript></noscript></head><frameset><frame src=\""foo\"" /><frame src=\""foo\"" /></frameset></html>"";
        String clean = Jsoup.clean(dirty, Safelist.basic());
        assertEquals("""", clean); // nothing good can come out of that

        Document dirtyDoc = Jsoup.parse(dirty);
        Document cleanDoc = new Cleaner(Safelist.basic()).clean(dirtyDoc);
        assertNotNull(cleanDoc);
        assertEquals(0, cleanDoc.body().childNodeSize());
    }

    @Test public void cleansInternationalText() {
        assertEquals(""–ø—Ä–∏–≤–µ—Ç"", Jsoup.clean(""–ø—Ä–∏–≤–µ—Ç"", Safelist.none()));
    }

    @Test
    public void testScriptTagInSafeList() {
        Safelist safelist = Safelist.relaxed();
        safelist.addTags( ""script"" );
        assertTrue( Jsoup.isValid(""Hello<script>alert('Doh')</script>World !"", safelist) );
    }

    @Test
    public void bailsIfRemovingProtocolThatsNotSet() {
        assertThrows(IllegalArgumentException.class, () -> {
            // a case that came up on the email list
            Safelist w = Safelist.none();

            // note no add tag, and removing protocol without adding first
            w.addAttributes(""a"", ""href"");
            w.removeProtocols(""a"", ""href"", ""javascript""); // with no protocols enforced, this was a noop. Now validates.
        });
    }

    @Test public void handlesControlCharactersAfterTagName() {
        String html = ""<a/\06>"";
        String clean = Jsoup.clean(html, Safelist.basic());
        assertEquals(""<a rel=\""nofollow\""></a>"", clean);
    }

    @Test public void handlesAttributesWithNoValue() {
        // https://github.com/jhy/jsoup/issues/973
        String clean = Jsoup.clean(""<a href>Clean</a>"", Safelist.basic());

        assertEquals(""<a rel=\""nofollow\"">Clean</a>"", clean);
    }

    @Test public void handlesNoHrefAttribute() {
        String dirty = ""<a>One</a> <a href>Two</a>"";
        Safelist relaxedWithAnchor = Safelist.relaxed().addProtocols(""a"", ""href"", ""#"");
        String clean = Jsoup.clean(dirty, relaxedWithAnchor);
        assertEquals(""<a>One</a> <a>Two</a>"", clean);
    }

    @Test public void handlesNestedQuotesInAttribute() {
        // https://github.com/jhy/jsoup/issues/1243 - no repro
        String orig = ""<div style=\""font-family: 'Calibri'\"">Will (not) fail</div>"";
        Safelist allow = Safelist.relaxed()
            .addAttributes(""div"", ""style"");

        String clean = Jsoup.clean(orig, allow);
        boolean isValid = Jsoup.isValid(orig, allow);

        assertEquals(orig, TextUtil.stripNewlines(clean)); // only difference is pretty print wrap & indent
        assertTrue(isValid);
    }

    @Test public void copiesOutputSettings() {
        Document orig = Jsoup.parse(""<p>test<br></p>"");
        orig.outputSettings().syntax(Document.OutputSettings.Syntax.xml);
        orig.outputSettings().escapeMode(Entities.EscapeMode.xhtml);
        Safelist safelist = Safelist.none().addTags(""p"", ""br"");

        Document result = new Cleaner(safelist).clean(orig);
        assertEquals(Document.OutputSettings.Syntax.xml, result.outputSettings().syntax());
        assertEquals(""<p>test<br /></p>"", result.body().html());
    }

    @Test void preservesSourcePositionViaUserData() {
        Document orig = Jsoup.parse(""<script>xss</script>\n <p>Hello</p>"", Parser.htmlParser().setTrackPosition(true));
        Element p = orig.expectFirst(""p"");
        Range origRange = p.sourceRange();
        assertEquals(""2,2:22-2,5:25"", origRange.toString());

        Document clean = new Cleaner(Safelist.relaxed()).clean(orig);
        Element cleanP = clean.expectFirst(""p"");
        Range cleanRange = cleanP.sourceRange();
        assertEquals(cleanRange, origRange);
        assertEquals(clean.endSourceRange(), orig.endSourceRange());
    }
}
"
jhy/jsoup,src/main/java/org/jsoup/select/Elements.java,"package org.jsoup.select;

import org.jsoup.helper.Validate;
import org.jsoup.internal.StringUtil;
import org.jsoup.nodes.Comment;
import org.jsoup.nodes.DataNode;
import org.jsoup.nodes.Element;
import org.jsoup.nodes.FormElement;
import org.jsoup.nodes.Node;
import org.jsoup.nodes.TextNode;

import javax.annotation.Nullable;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.List;

/**
 A list of {@link Element}s, with methods that act on every element in the list.
 <p>
 To get an {@code Elements} object, use the {@link Element#select(String)} method.
 </p>

 @author Jonathan Hedley, jonathan@hedley.net */
public class Elements extends ArrayList<Element> {
    public Elements() {
    }

    public Elements(int initialCapacity) {
        super(initialCapacity);
    }

    public Elements(Collection<Element> elements) {
        super(elements);
    }
    
    public Elements(List<Element> elements) {
        super(elements);
    }
    
    public Elements(Element... elements) {
    	super(Arrays.asList(elements));
    }

    /**
     * Creates a deep copy of these elements.
     * @return a deep copy
     */
    @Override
	public Elements clone() {
        Elements clone = new Elements(size());

        for(Element e : this)
    		clone.add(e.clone());
    	
    	return clone;
	}

	// attribute methods
    /**
     Get an attribute value from the first matched element that has the attribute.
     @param attributeKey The attribute key.
     @return The attribute value from the first matched element that has the attribute.. If no elements were matched (isEmpty() == true),
     or if the no elements have the attribute, returns empty string.
     @see #hasAttr(String)
     */
    public String attr(String attributeKey) {
        for (Element element : this) {
            if (element.hasAttr(attributeKey))
                return element.attr(attributeKey);
        }
        return """";
    }

    /**
     Checks if any of the matched elements have this attribute defined.
     @param attributeKey attribute key
     @return true if any of the elements have the attribute; false if none do.
     */
    public boolean hasAttr(String attributeKey) {
        for (Element element : this) {
            if (element.hasAttr(attributeKey))
                return true;
        }
        return false;
    }

    /**
     * Get the attribute value for each of the matched elements. If an element does not have this attribute, no value is
     * included in the result set for that element.
     * @param attributeKey the attribute name to return values for. You can add the {@code abs:} prefix to the key to
     * get absolute URLs from relative URLs, e.g.: {@code doc.select(""a"").eachAttr(""abs:href"")} .
     * @return a list of each element's attribute value for the attribute
     */
    public List<String> eachAttr(String attributeKey) {
        List<String> attrs = new ArrayList<>(size());
        for (Element element : this) {
            if (element.hasAttr(attributeKey))
                attrs.add(element.attr(attributeKey));
        }
        return attrs;
    }

    /**
     * Set an attribute on all matched elements.
     * @param attributeKey attribute key
     * @param attributeValue attribute value
     * @return this
     */
    public Elements attr(String attributeKey, String attributeValue) {
        for (Element element : this) {
            element.attr(attributeKey, attributeValue);
        }
        return this;
    }

    /**
     * Remove an attribute from every matched element.
     * @param attributeKey The attribute to remove.
     * @return this (for chaining)
     */
    public Elements removeAttr(String attributeKey) {
        for (Element element : this) {
            element.removeAttr(attributeKey);
        }
        return this;
    }

    /**
     Add the class name to every matched element's {@code class} attribute.
     @param className class name to add
     @return this
     */
    public Elements addClass(String className) {
        for (Element element : this) {
            element.addClass(className);
        }
        return this;
    }

    /**
     Remove the class name from every matched element's {@code class} attribute, if present.
     @param className class name to remove
     @return this
     */
    public Elements removeClass(String className) {
        for (Element element : this) {
            element.removeClass(className);
        }
        return this;
    }

    /**
     Toggle the class name on every matched element's {@code class} attribute.
     @param className class name to add if missing, or remove if present, from every element.
     @return this
     */
    public Elements toggleClass(String className) {
        for (Element element : this) {
            element.toggleClass(className);
        }
        return this;
    }

    /**
     Determine if any of the matched elements have this class name set in their {@code class} attribute.
     @param className class name to check for
     @return true if any do, false if none do
     */
    public boolean hasClass(String className) {
        for (Element element : this) {
            if (element.hasClass(className))
                return true;
        }
        return false;
    }
    
    /**
     * Get the form element's value of the first matched element.
     * @return The form element's value, or empty if not set.
     * @see Element#val()
     */
    public String val() {
        if (size() > 0)
            //noinspection ConstantConditions
            return first().val(); // first() != null as size() > 0
        else
            return """";
    }
    
    /**
     * Set the form element's value in each of the matched elements.
     * @param value The value to set into each matched element
     * @return this (for chaining)
     */
    public Elements val(String value) {
        for (Element element : this)
            element.val(value);
        return this;
    }
    
    /**
     * Get the combined text of all the matched elements.
     * <p>
     * Note that it is possible to get repeats if the matched elements contain both parent elements and their own
     * children, as the Element.text() method returns the combined text of a parent and all its children.
     * @return string of all text: unescaped and no HTML.
     * @see Element#text()
     * @see #eachText()
     */
    public String text() {
        StringBuilder sb = StringUtil.borrowBuilder();
        for (Element element : this) {
            if (sb.length() != 0)
                sb.append("" "");
            sb.append(element.text());
        }
        return StringUtil.releaseBuilder(sb);
    }

    /**
     Test if any matched Element has any text content, that is not just whitespace.
     @return true if any element has non-blank text content.
     @see Element#hasText()
     */
    public boolean hasText() {
        for (Element element: this) {
            if (element.hasText())
                return true;
        }
        return false;
    }

    /**
     * Get the text content of each of the matched elements. If an element has no text, then it is not included in the
     * result.
     * @return A list of each matched element's text content.
     * @see Element#text()
     * @see Element#hasText()
     * @see #text()
     */
    public List<String> eachText() {
        ArrayList<String> texts = new ArrayList<>(size());
        for (Element el: this) {
            if (el.hasText())
                texts.add(el.text());
        }
        return texts;
    }
    
    /**
     * Get the combined inner HTML of all matched elements.
     * @return string of all element's inner HTML.
     * @see #text()
     * @see #outerHtml()
     */
    public String html() {
        StringBuilder sb = StringUtil.borrowBuilder();
        for (Element element : this) {
            if (sb.length() != 0)
                sb.append(""\n"");
            sb.append(element.html());
        }
        return StringUtil.releaseBuilder(sb);
    }
    
    /**
     * Get the combined outer HTML of all matched elements.
     * @return string of all element's outer HTML.
     * @see #text()
     * @see #html()
     */
    public String outerHtml() {
        StringBuilder sb = StringUtil.borrowBuilder();
        for (Element element : this) {
            if (sb.length() != 0)
                sb.append(""\n"");
            sb.append(element.outerHtml());
        }
        return StringUtil.releaseBuilder(sb);
    }

    /**
     * Get the combined outer HTML of all matched elements. Alias of {@link #outerHtml()}.
     * @return string of all element's outer HTML.
     * @see #text()
     * @see #html()
     */
    @Override
    public String toString() {
        return outerHtml();
    }

    /**
     * Update (rename) the tag name of each matched element. For example, to change each {@code <i>} to a {@code <em>}, do
     * {@code doc.select(""i"").tagName(""em"");}
     *
     * @param tagName the new tag name
     * @return this, for chaining
     * @see Element#tagName(String)
     */
    public Elements tagName(String tagName) {
        for (Element element : this) {
            element.tagName(tagName);
        }
        return this;
    }
    
    /**
     * Set the inner HTML of each matched element.
     * @param html HTML to parse and set into each matched element.
     * @return this, for chaining
     * @see Element#html(String)
     */
    public Elements html(String html) {
        for (Element element : this) {
            element.html(html);
        }
        return this;
    }
    
    /**
     * Add the supplied HTML to the start of each matched element's inner HTML.
     * @param html HTML to add inside each element, before the existing HTML
     * @return this, for chaining
     * @see Element#prepend(String)
     */
    public Elements prepend(String html) {
        for (Element element : this) {
            element.prepend(html);
        }
        return this;
    }
    
    /**
     * Add the supplied HTML to the end of each matched element's inner HTML.
     * @param html HTML to add inside each element, after the existing HTML
     * @return this, for chaining
     * @see Element#append(String)
     */
    public Elements append(String html) {
        for (Element element : this) {
            element.append(html);
        }
        return this;
    }
    
    /**
     * Insert the supplied HTML before each matched element's outer HTML.
     * @param html HTML to insert before each element
     * @return this, for chaining
     * @see Element#before(String)
     */
    public Elements before(String html) {
        for (Element element : this) {
            element.before(html);
        }
        return this;
    }
    
    /**
     * Insert the supplied HTML after each matched element's outer HTML.
     * @param html HTML to insert after each element
     * @return this, for chaining
     * @see Element#after(String)
     */
    public Elements after(String html) {
        for (Element element : this) {
            element.after(html);
        }
        return this;
    }

    /**
     Wrap the supplied HTML around each matched elements. For example, with HTML
     {@code <p><b>This</b> is <b>Jsoup</b></p>},
     <code>doc.select(""b"").wrap(""&lt;i&gt;&lt;/i&gt;"");</code>
     becomes {@code <p><i><b>This</b></i> is <i><b>jsoup</b></i></p>}
     @param html HTML to wrap around each element, e.g. {@code <div class=""head""></div>}. Can be arbitrarily deep.
     @return this (for chaining)
     @see Element#wrap
     */
    public Elements wrap(String html) {
        Validate.notEmpty(html);
        for (Element element : this) {
            element.wrap(html);
        }
        return this;
    }

    /**
     * Removes the matched elements from the DOM, and moves their children up into their parents. This has the effect of
     * dropping the elements but keeping their children.
     * <p>
     * This is useful for e.g removing unwanted formatting elements but keeping their contents.
     * </p>
     * 
     * E.g. with HTML: <p>{@code <div><font>One</font> <font><a href=""/"">Two</a></font></div>}</p>
     * <p>{@code doc.select(""font"").unwrap();}</p>
     * <p>HTML = {@code <div>One <a href=""/"">Two</a></div>}</p>
     *
     * @return this (for chaining)
     * @see Node#unwrap
     */
    public Elements unwrap() {
        for (Element element : this) {
            element.unwrap();
        }
        return this;
    }

    /**
     * Empty (remove all child nodes from) each matched element. This is similar to setting the inner HTML of each
     * element to nothing.
     * <p>
     * E.g. HTML: {@code <div><p>Hello <b>there</b></p> <p>now</p></div>}<br>
     * <code>doc.select(""p"").empty();</code><br>
     * HTML = {@code <div><p></p> <p></p></div>}
     * @return this, for chaining
     * @see Element#empty()
     * @see #remove()
     */
    public Elements empty() {
        for (Element element : this) {
            element.empty();
        }
        return this;
    }

    /**
     * Remove each matched element from the DOM. This is similar to setting the outer HTML of each element to nothing.
     * <p>
     * E.g. HTML: {@code <div><p>Hello</p> <p>there</p> <img /></div>}<br>
     * <code>doc.select(""p"").remove();</code><br>
     * HTML = {@code <div> <img /></div>}
     * <p>
     * Note that this method should not be used to clean user-submitted HTML; rather, use {@link org.jsoup.safety.Cleaner} to clean HTML.
     * @return this, for chaining
     * @see Element#empty()
     * @see #empty()
     */
    public Elements remove() {
        for (Element element : this) {
            element.remove();
        }
        return this;
    }
    
    // filters
    
    /**
     * Find matching elements within this element list.
     * @param query A {@link Selector} query
     * @return the filtered list of elements, or an empty list if none match.
     */
    public Elements select(String query) {
        return Selector.select(query, this);
    }

    /**
     * Remove elements from this list that match the {@link Selector} query.
     * <p>
     * E.g. HTML: {@code <div class=logo>One</div> <div>Two</div>}<br>
     * <code>Elements divs = doc.select(""div"").not("".logo"");</code><br>
     * Result: {@code divs: [<div>Two</div>]}
     * <p>
     * @param query the selector query whose results should be removed from these elements
     * @return a new elements list that contains only the filtered results
     */
    public Elements not(String query) {
        Elements out = Selector.select(query, this);
        return Selector.filterOut(this, out);
    }
    
    /**
     * Get the <i>nth</i> matched element as an Elements object.
     * <p>
     * See also {@link #get(int)} to retrieve an Element.
     * @param index the (zero-based) index of the element in the list to retain
     * @return Elements containing only the specified element, or, if that element did not exist, an empty list.
     */
    public Elements eq(int index) {
        return size() > index ? new Elements(get(index)) : new Elements();
    }
    
    /**
     * Test if any of the matched elements match the supplied query.
     * @param query A selector
     * @return true if at least one element in the list matches the query.
     */
    public boolean is(String query) {
        Evaluator eval = QueryParser.parse(query);
        for (Element e : this) {
            if (e.is(eval))
                return true;
        }
        return false;
    }

    /**
     * Get the immediate next element sibling of each element in this list.
     * @return next element siblings.
     */
    public Elements next() {
        return siblings(null, true, false);
    }

    /**
     * Get the immediate next element sibling of each element in this list, filtered by the query.
     * @param query CSS query to match siblings against
     * @return next element siblings.
     */
    public Elements next(String query) {
        return siblings(query, true, false);
    }

    /**
     * Get each of the following element siblings of each element in this list.
     * @return all following element siblings.
     */
    public Elements nextAll() {
        return siblings(null, true, true);
    }

    /**
     * Get each of the following element siblings of each element in this list, that match the query.
     * @param query CSS query to match siblings against
     * @return all following element siblings.
     */
    public Elements nextAll(String query) {
        return siblings(query, true, true);
    }

    /**
     * Get the immediate previous element sibling of each element in this list.
     * @return previous element siblings.
     */
    public Elements prev() {
        return siblings(null, false, false);
    }

    /**
     * Get the immediate previous element sibling of each element in this list, filtered by the query.
     * @param query CSS query to match siblings against
     * @return previous element siblings.
     */
    public Elements prev(String query) {
        return siblings(query, false, false);
    }

    /**
     * Get each of the previous element siblings of each element in this list.
     * @return all previous element siblings.
     */
    public Elements prevAll() {
        return siblings(null, false, true);
    }

    /**
     * Get each of the previous element siblings of each element in this list, that match the query.
     * @param query CSS query to match siblings against
     * @return all previous element siblings.
     */
    public Elements prevAll(String query) {
        return siblings(query, false, true);
    }

    private Elements siblings(@Nullable String query, boolean next, boolean all) {
        Elements els = new Elements();
        Evaluator eval = query != null? QueryParser.parse(query) : null;
        for (Element e : this) {
            do {
                Element sib = next ? e.nextElementSibling() : e.previousElementSibling();
                if (sib == null) break;
                if (eval == null)
                    els.add(sib);
                else if (sib.is(eval))
                    els.add(sib);
                e = sib;
            } while (all);
        }
        return els;
    }

    /**
     * Get all of the parents and ancestor elements of the matched elements.
     * @return all of the parents and ancestor elements of the matched elements
     */
    public Elements parents() {
        HashSet<Element> combo = new LinkedHashSet<>();
        for (Element e: this) {
            combo.addAll(e.parents());
        }
        return new Elements(combo);
    }

    // list-like methods
    /**
     Get the first matched element.
     @return The first matched element, or <code>null</code> if contents is empty.
     */
    public @Nullable Element first() {
        return isEmpty() ? null : get(0);
    }

    /**
     Get the last matched element.
     @return The last matched element, or <code>null</code> if contents is empty.
     */
    public @Nullable Element last() {
        return isEmpty() ? null : get(size() - 1);
    }

    /**
     * Perform a depth-first traversal on each of the selected elements.
     * @param nodeVisitor the visitor callbacks to perform on each node
     * @return this, for chaining
     */
    public Elements traverse(NodeVisitor nodeVisitor) {
        NodeTraversor.traverse(nodeVisitor, this);
        return this;
    }

    /**
     * Perform a depth-first filtering on each of the selected elements.
     * @param nodeFilter the filter callbacks to perform on each node
     * @return this, for chaining
     */
    public Elements filter(NodeFilter nodeFilter) {
        NodeTraversor.filter(nodeFilter, this);
        return this;
    }

    /**
     * Get the {@link FormElement} forms from the selected elements, if any.
     * @return a list of {@link FormElement}s pulled from the matched elements. The list will be empty if the elements contain
     * no forms.
     */
    public List<FormElement> forms() {
        ArrayList<FormElement> forms = new ArrayList<>();
        for (Element el: this)
            if (el instanceof FormElement)
                forms.add((FormElement) el);
        return forms;
    }

    /**
     * Get {@link Comment} nodes that are direct child nodes of the selected elements.
     * @return Comment nodes, or an empty list if none.
     */
    public List<Comment> comments() {
        return childNodesOfType(Comment.class);
    }

    /**
     * Get {@link TextNode} nodes that are direct child nodes of the selected elements.
     * @return TextNode nodes, or an empty list if none.
     */
    public List<TextNode> textNodes() {
        return childNodesOfType(TextNode.class);
    }

    /**
     * Get {@link DataNode} nodes that are direct child nodes of the selected elements. DataNode nodes contain the
     * content of tags such as {@code script}, {@code style} etc and are distinct from {@link TextNode}s.
     * @return Comment nodes, or an empty list if none.
     */
    public List<DataNode> dataNodes() {
        return childNodesOfType(DataNode.class);
    }

    private <T extends Node> List<T> childNodesOfType(Class<T> tClass) {
        ArrayList<T> nodes = new ArrayList<>();
        for (Element el: this) {
            for (int i = 0; i < el.childNodeSize(); i++) {
                Node node = el.childNode(i);
                if (tClass.isInstance(node))
                    nodes.add(tClass.cast(node));
            }
        }
        return nodes;
    }

}
"
jhy/jsoup,src/test/java/org/jsoup/select/XpathTest.java,"package org.jsoup.select;

import org.jsoup.Jsoup;
import org.jsoup.nodes.Document;
import org.jsoup.nodes.Element;
import org.jsoup.nodes.Node;
import org.jsoup.nodes.TextNode;
import org.jsoup.parser.Parser;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.Arguments;
import org.junit.jupiter.params.provider.MethodSource;

import javax.xml.xpath.XPath;
import javax.xml.xpath.XPathFactory;
import javax.xml.xpath.XPathFactoryConfigurationException;
import javax.xml.xpath.XPathFunctionResolver;
import javax.xml.xpath.XPathVariableResolver;
import java.util.List;
import java.util.stream.Stream;

import static org.jsoup.helper.W3CDom.XPathFactoryProperty;
import static org.junit.jupiter.api.Assertions.*;

public class XpathTest {

    @Test
    public void supportsXpath() {
        String html = ""<body><div><p>One</div><div><p>Two</div><div>Three</div>"";
        Document doc = Jsoup.parse(html);

        Elements els = doc.selectXpath(""//div/p"");
        assertEquals(2, els.size());
        assertEquals(""One"", els.get(0).text());
        assertEquals(""Two"", els.get(1).text());
    }

    @Test public void supportsXpathFromElement() {
        String html = ""<body><div><p>One</div><div><p>Two</div><div>Three</div>"";
        Document doc = Jsoup.parse(html);

        Element div = doc.selectFirst(""div"");
        assertNotNull(div);
        Element w3cDiv = div.selectXpath(""."").first(); // self
        assertSame(div, w3cDiv);

        Elements els = div.selectXpath(""p"");
        assertEquals(1, els.size());
        assertEquals(""One"", els.get(0).text());
        assertEquals(""p"", els.get(0).tagName());

        assertEquals(1, div.selectXpath(""//body"").size()); // the whole document is visible on the div context
        assertEquals(1, doc.selectXpath(""//body"").size());
    }

    @Test public void emptyElementsIfNoResults() {
        Document doc = Jsoup.parse(""<p>One<p>Two"");
        assertEquals(0, doc.selectXpath(""//div"").size());
    }

    @Test
    public void throwsSelectException() {
        Document doc = Jsoup.parse(""<p>One<p>Two"");
        boolean threw = false;
        try {
            doc.selectXpath(""//???"");
        } catch (Selector.SelectorParseException e) {
            threw = true;
            // checks exception message within jsoup's control, rest may be JDK impl specific
            // was - Could not evaluate XPath query [//???]: javax.xml.transform.TransformerException: A location step was expected following the '/' or '//' token.
            assertTrue(e.getMessage().startsWith(""Could not evaluate XPath query [//???]:""));
        }
        assertTrue(threw);
    }

    @Test
    public void supportsLocalname() {
        String xhtml = ""<html xmlns='http://www.w3.org/1999/xhtml'><body id='One'><div>hello</div></body></html>"";
        Document doc = Jsoup.parse(xhtml, Parser.xmlParser());
        Elements elements = doc.selectXpath(""//*[local-name()='body']"");
        assertEquals(1, elements.size());
        assertEquals(""One"", elements.first().id());
    }

    @Test
    public void canDitchNamespaces() {
        String xhtml = ""<html xmlns='http://www.w3.org/1999/xhtml'><body id='One'><div>hello</div></body></html>"";
        Document doc = Jsoup.parse(xhtml, Parser.xmlParser());
        doc.select(""[xmlns]"").removeAttr(""xmlns"");
        Elements elements = doc.selectXpath(""//*[local-name()='body']"");
        assertEquals(1, elements.size());

        elements = doc.selectXpath(""//body"");
        assertEquals(1, elements.size());
        assertEquals(""One"", elements.first().id());
    }

    @ParameterizedTest
    @MethodSource(""provideEvaluators"")
    void cssAndXpathEquivalents(Document doc, String css, String xpath) {
        Elements fromCss = doc.select(css);
        Elements fromXpath = doc.selectXpath(xpath);

        assertTrue(fromCss.size() >= 1);
        assertTrue(fromXpath.size() >= 1);
        // tests same size, order, and contents
        assertEquals(fromCss, fromXpath);
    }

    private static Stream<Arguments> provideEvaluators() {
        String html = ""<div id=1><div id=2><p class=foo>Hello</p></div></div><DIV id=3>"";
        Document doc = Jsoup.parse(html);

        return Stream.of(
           Arguments.of(doc, ""DIV"", ""//div""),
           Arguments.of(doc, ""div > p.foo"", ""//div/p[@class]""),
           Arguments.of(doc, ""div + div"", ""//div/following-sibling::div[1]""),
           Arguments.of(doc, ""p:containsOwn(Hello)"", ""//p[contains(text(),\""Hello\"")]"")
        );
    }

    @Test void canSelectTextNodes() {
        String html = ""<div><p>One<p><a>Two</a><p>Three and some more"";
        Document doc = Jsoup.parse(html);

        //  as text nodes:
        List<TextNode> text = doc.selectXpath(""//body//p//text()"", TextNode.class);
        assertEquals(3, text.size());
        assertEquals(""One"", text.get(0).text());
        assertEquals(""Two"", text.get(1).text());
        assertEquals(""Three and some more"", text.get(2).text());

        //  as just nodes:
        List<Node> nodes = doc.selectXpath(""//body//p//text()"", Node.class);
        assertEquals(3, nodes.size());
        assertEquals(""One"", nodes.get(0).outerHtml());
        assertEquals(""Two"", nodes.get(1).outerHtml());
        assertEquals(""Three and some more"", nodes.get(2).outerHtml());
    }

    @Test void selectByAttribute() {
        Document doc = Jsoup.parse(""<p><a href='/foo'>Foo</a><a href='/bar'>Bar</a><a>None</a>"");
        List<String> hrefs = doc.selectXpath(""//a[@href]"").eachAttr(""href"");
        assertEquals(2, hrefs.size());
        assertEquals(""/foo"", hrefs.get(0));
        assertEquals(""/bar"", hrefs.get(1));
    }

    @Test void selectOutsideOfElementTree() {
        Document doc = Jsoup.parse(""<p>One<p>Two<p>Three"");
        Elements ps = doc.selectXpath(""//p"");
        assertEquals(3, ps.size());

        Element p1 = ps.get(0);
        assertEquals(""One"", p1.text());

        Elements sibs = p1.selectXpath(""following-sibling::p"");
        assertEquals(2, sibs.size());
        assertEquals(""Two"", sibs.get(0).text());
        assertEquals(""Three"", sibs.get(1).text());
    }

    @Test void selectAncestorsOnContextElement() {
        // https://github.com/jhy/jsoup/issues/1652
        Document doc = Jsoup.parse(""<div><p>Hello"");
        Element p = doc.selectFirst(""p"");
        assertNotNull(p);
        Elements chain = p.selectXpath(""ancestor-or-self::*"");
        assertEquals(4, chain.size());
        assertEquals(""html"", chain.get(0).tagName());
        assertEquals(""p"", chain.get(3).tagName());
    }

    @Test
    public void canSupplyAlternateFactoryImpl() {
        // previously we had a test to load Saxon and do an XPath 2.0 query. But we know Saxon works and so that's
        // redundant - really just need to test that an alternate XPath factory can be used

        System.setProperty(XPathFactoryProperty, AlternateXpathFactory.class.getName());

        String xhtml = ""<html xmlns='http://www.w3.org/1999/xhtml'><body id='One'><div>hello</div></body></html>"";
        boolean threw = false;
        try {
            Document doc = Jsoup.parse(xhtml, Parser.xmlParser());
            Elements elements = doc.selectXpath(""//*:body"");

        } catch (IllegalArgumentException e) {
            assertTrue(e.getMessage().contains(""Sorry, no can do!""));
            threw = true;
        }
        assertTrue(threw);
        System.clearProperty(XPathFactoryProperty);
    }

    @Test
    public void notNamespaceAware() {
        String xhtml = ""<html xmlns='http://www.w3.org/1999/xhtml'><body id='One'><div>hello</div></body></html>"";
        Document doc = Jsoup.parse(xhtml, Parser.xmlParser());
        Elements elements = doc.selectXpath(""//body"");
        assertEquals(1, elements.size());
        assertEquals(""One"", elements.first().id());
    }

    @Test
    public void supportsPrefixes() {
        // example from https://www.w3.org/TR/xml-names/
        String xml = ""<?xml version=\""1.0\""?>\n"" +
            ""<bk:book xmlns:bk='urn:loc.gov:books'\n"" +
            ""         xmlns:isbn='urn:ISBN:0-395-36341-6'>\n"" +
            ""    <bk:title>Cheaper by the Dozen</bk:title>\n"" +
            ""    <isbn:number>1568491379</isbn:number>\n"" +
            ""</bk:book>"";
        Document doc = Jsoup.parse(xml, Parser.xmlParser());

        //Elements elements = doc.selectXpath(""//bk:book/bk:title"");
        Elements elements = doc.selectXpath(""//book/title"");
        assertEquals(1, elements.size());
        assertEquals(""Cheaper by the Dozen"", elements.first().text());

        // with prefix
        Elements byPrefix = doc.selectXpath(""//*[name()='bk:book']/*[name()='bk:title']"");
        assertEquals(1, byPrefix.size());
        assertEquals(""Cheaper by the Dozen"", byPrefix.first().text());

        Elements byLocalName = doc.selectXpath(""//*[local-name()='book']/*[local-name()='title']"");
        assertEquals(1, byLocalName.size());
        assertEquals(""Cheaper by the Dozen"", byLocalName.first().text());

        Elements isbn = doc.selectXpath(""//book/number"");
        assertEquals(1, isbn.size());
        assertEquals(""1568491379"", isbn.first().text());
    }

    // minimal, no-op implementation class to verify users can load a factory to support XPath 2.0 etc
    public static class AlternateXpathFactory extends XPathFactory {
        public AlternateXpathFactory() {
            super();
        }

        @Override
        public boolean isObjectModelSupported(String objectModel) {
            return true;
        }

        @Override
        public void setFeature(String name, boolean value) throws XPathFactoryConfigurationException {

        }

        @Override
        public boolean getFeature(String name) throws XPathFactoryConfigurationException {
            return true;
        }

        @Override
        public void setXPathVariableResolver(XPathVariableResolver resolver) {

        }

        @Override
        public void setXPathFunctionResolver(XPathFunctionResolver resolver) {

        }

        @Override
        public XPath newXPath() {
            throw new IllegalArgumentException(""Sorry, no can do!"");
        }
    }
}
"
jhy/jsoup,src/test/java/org/jsoup/parser/CharacterReaderTest.java,"package org.jsoup.parser;

import org.jsoup.integration.ParseTest;
import org.junit.jupiter.api.Test;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.StringReader;

import static org.junit.jupiter.api.Assertions.*;

/**
 * Test suite for character reader.
 *
 * @author Jonathan Hedley, jonathan@hedley.net
 */
public class CharacterReaderTest {
    public final static int maxBufferLen = CharacterReader.maxBufferLen;

    @Test public void consume() {
        CharacterReader r = new CharacterReader(""one"");
        assertEquals(0, r.pos());
        assertEquals('o', r.current());
        assertEquals('o', r.consume());
        assertEquals(1, r.pos());
        assertEquals('n', r.current());
        assertEquals(1, r.pos());
        assertEquals('n', r.consume());
        assertEquals('e', r.consume());
        assertTrue(r.isEmpty());
        assertEquals(CharacterReader.EOF, r.consume());
        assertTrue(r.isEmpty());
        assertEquals(CharacterReader.EOF, r.consume());
    }

    @Test public void unconsume() {
        CharacterReader r = new CharacterReader(""one"");
        assertEquals('o', r.consume());
        assertEquals('n', r.current());
        r.unconsume();
        assertEquals('o', r.current());

        assertEquals('o', r.consume());
        assertEquals('n', r.consume());
        assertEquals('e', r.consume());
        assertTrue(r.isEmpty());
        r.unconsume();
        assertFalse(r.isEmpty());
        assertEquals('e', r.current());
        assertEquals('e', r.consume());
        assertTrue(r.isEmpty());

        assertEquals(CharacterReader.EOF, r.consume());
        r.unconsume(); // read past, so have to eat again
        assertTrue(r.isEmpty());
        r.unconsume();
        assertFalse(r.isEmpty());

        assertEquals('e', r.consume());
        assertTrue(r.isEmpty());

        assertEquals(CharacterReader.EOF, r.consume());
        assertTrue(r.isEmpty());
    }

    @Test public void mark() {
        CharacterReader r = new CharacterReader(""one"");
        r.consume();
        r.mark();
        assertEquals(1, r.pos());
        assertEquals('n', r.consume());
        assertEquals('e', r.consume());
        assertTrue(r.isEmpty());
        r.rewindToMark();
        assertEquals(1, r.pos());
        assertEquals('n', r.consume());
        assertFalse(r.isEmpty());
        assertEquals(2, r.pos());
    }

    @Test public void consumeToEnd() {
        String in = ""one two three"";
        CharacterReader r = new CharacterReader(in);
        String toEnd = r.consumeToEnd();
        assertEquals(in, toEnd);
        assertTrue(r.isEmpty());
    }

    @Test public void nextIndexOfChar() {
        String in = ""blah blah"";
        CharacterReader r = new CharacterReader(in);

        assertEquals(-1, r.nextIndexOf('x'));
        assertEquals(3, r.nextIndexOf('h'));
        String pull = r.consumeTo('h');
        assertEquals(""bla"", pull);
        r.consume();
        assertEquals(2, r.nextIndexOf('l'));
        assertEquals("" blah"", r.consumeToEnd());
        assertEquals(-1, r.nextIndexOf('x'));
    }

    @Test public void nextIndexOfString() {
        String in = ""One Two something Two Three Four"";
        CharacterReader r = new CharacterReader(in);

        assertEquals(-1, r.nextIndexOf(""Foo""));
        assertEquals(4, r.nextIndexOf(""Two""));
        assertEquals(""One Two "", r.consumeTo(""something""));
        assertEquals(10, r.nextIndexOf(""Two""));
        assertEquals(""something Two Three Four"", r.consumeToEnd());
        assertEquals(-1, r.nextIndexOf(""Two""));
    }

    @Test public void nextIndexOfUnmatched() {
        CharacterReader r = new CharacterReader(""<[[one]]"");
        assertEquals(-1, r.nextIndexOf(""]]>""));
    }

    @Test public void consumeToChar() {
        CharacterReader r = new CharacterReader(""One Two Three"");
        assertEquals(""One "", r.consumeTo('T'));
        assertEquals("""", r.consumeTo('T')); // on Two
        assertEquals('T', r.consume());
        assertEquals(""wo "", r.consumeTo('T'));
        assertEquals('T', r.consume());
        assertEquals(""hree"", r.consumeTo('T')); // consume to end
    }

    @Test public void consumeToString() {
        CharacterReader r = new CharacterReader(""One Two Two Four"");
        assertEquals(""One "", r.consumeTo(""Two""));
        assertEquals('T', r.consume());
        assertEquals(""wo "", r.consumeTo(""Two""));
        assertEquals('T', r.consume());
        // To handle strings straddling across buffers, consumeTo() may return the
        // data in multiple pieces near EOF.
        StringBuilder builder = new StringBuilder();
        String part;
        do {
            part = r.consumeTo(""Qux"");
            builder.append(part);
        } while (!part.isEmpty());
        assertEquals(""wo Four"", builder.toString());
    }

    @Test public void advance() {
        CharacterReader r = new CharacterReader(""One Two Three"");
        assertEquals('O', r.consume());
        r.advance();
        assertEquals('e', r.consume());
    }

    @Test public void consumeToAny() {
        CharacterReader r = new CharacterReader(""One &bar; qux"");
        assertEquals(""One "", r.consumeToAny('&', ';'));
        assertTrue(r.matches('&'));
        assertTrue(r.matches(""&bar;""));
        assertEquals('&', r.consume());
        assertEquals(""bar"", r.consumeToAny('&', ';'));
        assertEquals(';', r.consume());
        assertEquals("" qux"", r.consumeToAny('&', ';'));
    }

    @Test public void consumeLetterSequence() {
        CharacterReader r = new CharacterReader(""One &bar; qux"");
        assertEquals(""One"", r.consumeLetterSequence());
        assertEquals("" &"", r.consumeTo(""bar;""));
        assertEquals(""bar"", r.consumeLetterSequence());
        assertEquals(""; qux"", r.consumeToEnd());
    }

    @Test public void consumeLetterThenDigitSequence() {
        CharacterReader r = new CharacterReader(""One12 Two &bar; qux"");
        assertEquals(""One12"", r.consumeLetterThenDigitSequence());
        assertEquals(' ', r.consume());
        assertEquals(""Two"", r.consumeLetterThenDigitSequence());
        assertEquals("" &bar; qux"", r.consumeToEnd());
    }

    @Test public void matches() {
        CharacterReader r = new CharacterReader(""One Two Three"");
        assertTrue(r.matches('O'));
        assertTrue(r.matches(""One Two Three""));
        assertTrue(r.matches(""One""));
        assertFalse(r.matches(""one""));
        assertEquals('O', r.consume());
        assertFalse(r.matches(""One""));
        assertTrue(r.matches(""ne Two Three""));
        assertFalse(r.matches(""ne Two Three Four""));
        assertEquals(""ne Two Three"", r.consumeToEnd());
        assertFalse(r.matches(""ne""));
        assertTrue(r.isEmpty());
    }

    @Test
    public void matchesIgnoreCase() {
        CharacterReader r = new CharacterReader(""One Two Three"");
        assertTrue(r.matchesIgnoreCase(""O""));
        assertTrue(r.matchesIgnoreCase(""o""));
        assertTrue(r.matches('O'));
        assertFalse(r.matches('o'));
        assertTrue(r.matchesIgnoreCase(""One Two Three""));
        assertTrue(r.matchesIgnoreCase(""ONE two THREE""));
        assertTrue(r.matchesIgnoreCase(""One""));
        assertTrue(r.matchesIgnoreCase(""one""));
        assertEquals('O', r.consume());
        assertFalse(r.matchesIgnoreCase(""One""));
        assertTrue(r.matchesIgnoreCase(""NE Two Three""));
        assertFalse(r.matchesIgnoreCase(""ne Two Three Four""));
        assertEquals(""ne Two Three"", r.consumeToEnd());
        assertFalse(r.matchesIgnoreCase(""ne""));
    }

    @Test public void containsIgnoreCase() {
        CharacterReader r = new CharacterReader(""One TWO three"");
        assertTrue(r.containsIgnoreCase(""two""));
        assertTrue(r.containsIgnoreCase(""three""));
        // weird one: does not find one, because it scans for consistent case only
        assertFalse(r.containsIgnoreCase(""one""));
    }

    @Test void containsIgnoreCaseBuffer() {
        String html = ""<p><p><p></title><p></TITLE><p>"" + BufferBuster(""Foo Bar Qux "") + ""<foo><bar></title>"";
        CharacterReader r = new CharacterReader(html);

        assertTrue(r.containsIgnoreCase(""</title>""));
        assertFalse(r.containsIgnoreCase(""</not>""));
        assertFalse(r.containsIgnoreCase(""</not>"")); // cached, but we only test functionally here
        assertTrue(r.containsIgnoreCase(""</title>""));
        r.consumeTo(""</title>"");
        assertTrue(r.containsIgnoreCase(""</title>""));
        r.consumeTo(""<p>"");
        assertTrue(r.matches(""<p>""));

        assertTrue(r.containsIgnoreCase(""</title>""));
        assertTrue(r.containsIgnoreCase(""</title>""));
        assertFalse(r.containsIgnoreCase(""</not>""));
        assertFalse(r.containsIgnoreCase(""</not>""));

        r.consumeTo(""</TITLE>"");
        r.consumeTo(""<p>"");
        assertTrue(r.matches(""<p>""));
        assertFalse(r.containsIgnoreCase(""</title>"")); // because we haven't buffered up yet, we don't know
        r.consumeTo(""<foo>"");
        assertFalse(r.matches(""<foo>"")); // buffer underrun
        r.consumeTo(""<foo>"");
        assertTrue(r.matches(""<foo>"")); // cross the buffer
        assertTrue(r.containsIgnoreCase(""</TITLE>""));
        assertTrue(r.containsIgnoreCase(""</title>""));
    }

    static String BufferBuster(String content) {
        StringBuilder builder = new StringBuilder();
        while (builder.length() < maxBufferLen)
            builder.append(content);
        return builder.toString();
    }

    @Test public void matchesAny() {
        char[] scan = {' ', '\n', '\t'};
        CharacterReader r = new CharacterReader(""One\nTwo\tThree"");
        assertFalse(r.matchesAny(scan));
        assertEquals(""One"", r.consumeToAny(scan));
        assertTrue(r.matchesAny(scan));
        assertEquals('\n', r.consume());
        assertFalse(r.matchesAny(scan));
    }

    @Test public void cachesStrings() {
        CharacterReader r = new CharacterReader(""Check\tCheck\tCheck\tCHOKE\tA string that is longer than 16 chars"");
        String one = r.consumeTo('\t');
        r.consume();
        String two = r.consumeTo('\t');
        r.consume();
        String three = r.consumeTo('\t');
        r.consume();
        String four = r.consumeTo('\t');
        r.consume();
        String five = r.consumeTo('\t');

        assertEquals(""Check"", one);
        assertEquals(""Check"", two);
        assertEquals(""Check"", three);
        assertEquals(""CHOKE"", four);
        assertSame(one, two);
        assertSame(two, three);
        assertNotSame(three, four);
        assertNotSame(four, five);
        assertEquals(five, ""A string that is longer than 16 chars"");
    }

    @Test
    public void rangeEquals() {
        CharacterReader r = new CharacterReader(""Check\tCheck\tCheck\tCHOKE"");
        assertTrue(r.rangeEquals(0, 5, ""Check""));
        assertFalse(r.rangeEquals(0, 5, ""CHOKE""));
        assertFalse(r.rangeEquals(0, 5, ""Chec""));

        assertTrue(r.rangeEquals(6, 5, ""Check""));
        assertFalse(r.rangeEquals(6, 5, ""Chuck""));

        assertTrue(r.rangeEquals(12, 5, ""Check""));
        assertFalse(r.rangeEquals(12, 5, ""Cheeky""));

        assertTrue(r.rangeEquals(18, 5, ""CHOKE""));
        assertFalse(r.rangeEquals(18, 5, ""CHIKE""));
    }

    @Test
    public void empty() {
        CharacterReader r = new CharacterReader(""One"");
        assertTrue(r.matchConsume(""One""));
        assertTrue(r.isEmpty());

        r = new CharacterReader(""Two"");
        String two = r.consumeToEnd();
        assertEquals(""Two"", two);
    }

    @Test
    public void consumeToNonexistentEndWhenAtAnd() {
        CharacterReader r = new CharacterReader(""<!"");
        assertTrue(r.matchConsume(""<!""));
        assertTrue(r.isEmpty());

        String after = r.consumeTo('>');
        assertEquals("""", after);

        assertTrue(r.isEmpty());
    }

    @Test
    public void notEmptyAtBufferSplitPoint() {
        CharacterReader r = new CharacterReader(new StringReader(""How about now""), 3);
        assertEquals(""How"", r.consumeTo(' '));
        assertFalse(r.isEmpty(), ""Should not be empty"");

        assertEquals(' ', r.consume());
        assertFalse(r.isEmpty());
        assertEquals(4, r.pos());
        assertEquals('a', r.consume());
        assertEquals(5, r.pos());
        assertEquals('b', r.consume());
        assertEquals('o', r.consume());
        assertEquals('u', r.consume());
        assertEquals('t', r.consume());
        assertEquals(' ', r.consume());
        assertEquals('n', r.consume());
        assertEquals('o', r.consume());
        assertEquals('w', r.consume());
        assertTrue(r.isEmpty());
    }

    @Test public void bufferUp() {
        String note = ""HelloThere""; // + ! = 11 chars
        int loopCount = 64;
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < loopCount; i++) {
            sb.append(note);
            sb.append(""!"");
        }

        String s = sb.toString();
        BufferedReader br = new BufferedReader(new StringReader(s));

        CharacterReader r = new CharacterReader(br);
        for (int i = 0; i < loopCount; i++) {
            String pull = r.consumeTo('!');
            assertEquals(note, pull);
            assertEquals('!', r.current());
            r.advance();
        }

        assertTrue(r.isEmpty());
    }

    @Test public void canEnableAndDisableLineNumberTracking() {
        CharacterReader reader = new CharacterReader(""Hello!"");
        assertFalse(reader.isTrackNewlines());
        reader.trackNewlines(true);
        assertTrue(reader.isTrackNewlines());
        reader.trackNewlines(false);
        assertFalse(reader.isTrackNewlines());
    }

    @Test public void canTrackNewlines() {
        StringBuilder builder = new StringBuilder();
        builder.append(""<foo>\n<bar>\n<qux>\n"");
        while (builder.length() < maxBufferLen)
            builder.append(""Lorem ipsum dolor sit amet, consectetur adipiscing elit."");
        builder.append(""[foo]\n[bar]"");
        String content = builder.toString();

        CharacterReader noTrack = new CharacterReader(content);
        assertFalse(noTrack.isTrackNewlines());
        CharacterReader track = new CharacterReader(content);
        track.trackNewlines(true);
        assertTrue(track.isTrackNewlines());

        // check that no tracking works as expected (pos is 0 indexed, line number stays at 1, col is pos+1)
        assertEquals(0, noTrack.pos());
        assertEquals(1, noTrack.lineNumber());
        assertEquals(1, noTrack.columnNumber());
        noTrack.consumeTo(""<qux>"");
        assertEquals(12, noTrack.pos());
        assertEquals(1, noTrack.lineNumber());
        assertEquals(13, noTrack.columnNumber());
        assertEquals(""1:13"", noTrack.cursorPos());
        // get over the buffer
        while (!noTrack.matches(""[foo]""))
            noTrack.consumeTo(""[foo]"");
        assertEquals(32778, noTrack.pos());
        assertEquals(1, noTrack.lineNumber());
        assertEquals(noTrack.pos()+1, noTrack.columnNumber());
        assertEquals(""1:32779"", noTrack.cursorPos());

        // and the line numbers: ""<foo>\n<bar>\n<qux>\n""
        assertEquals(0, track.pos());
        assertEquals(1, track.lineNumber());
        assertEquals(1, track.columnNumber());

        track.consumeTo('\n');
        assertEquals(1, track.lineNumber());
        assertEquals(6, track.columnNumber());
        track.consume();
        assertEquals(2, track.lineNumber());
        assertEquals(1, track.columnNumber());

        assertEquals(""<bar>"", track.consumeTo('\n'));
        assertEquals(2, track.lineNumber());
        assertEquals(6, track.columnNumber());

        assertEquals(""\n"", track.consumeTo(""<qux>""));
        assertEquals(12, track.pos());
        assertEquals(3, track.lineNumber());
        assertEquals(1, track.columnNumber());
        assertEquals(""3:1"", track.cursorPos());
        assertEquals(""<qux>"", track.consumeTo('\n'));
        assertEquals(""3:6"", track.cursorPos());
        // get over the buffer
        while (!track.matches(""[foo]""))
            track.consumeTo(""[foo]"");
        assertEquals(32778, track.pos());
        assertEquals(4, track.lineNumber());
        assertEquals(32761, track.columnNumber());
        assertEquals(""4:32761"", track.cursorPos());
        track.consumeTo('\n');
        assertEquals(""4:32766"", track.cursorPos());

        track.consumeTo(""[bar]"");
        assertEquals(5, track.lineNumber());
        assertEquals(""5:1"", track.cursorPos());
        track.consumeToEnd();
        assertEquals(""5:6"", track.cursorPos());
    }

    @Test public void countsColumnsOverBufferWhenNoNewlines() {
        StringBuilder builder = new StringBuilder();
        while (builder.length() < maxBufferLen * 4)
            builder.append(""Lorem ipsum dolor sit amet, consectetur adipiscing elit."");
        String content = builder.toString();
        CharacterReader reader = new CharacterReader(content);
        reader.trackNewlines(true);

        assertEquals(""1:1"", reader.cursorPos());
        while (!reader.isEmpty())
            reader.consume();
        assertEquals(131096, reader.pos());
        assertEquals(reader.pos() + 1, reader.columnNumber());
        assertEquals(1, reader.lineNumber());
    }

    @Test public void linenumbersAgreeWithEditor() throws IOException {
        String content = ParseTest.getFileAsString(ParseTest.getFile(""/htmltests/large.html""));
        CharacterReader reader = new CharacterReader(content);
        reader.trackNewlines(true);

        String scan = ""<p>VESTIBULUM""; // near the end of the file
        while (!reader.matches(scan))
            reader.consumeTo(scan);

        assertEquals(280218, reader.pos());
        assertEquals(1002, reader.lineNumber());
        assertEquals(1, reader.columnNumber());
        reader.consumeTo(' ');
        assertEquals(1002, reader.lineNumber());
        assertEquals(14, reader.columnNumber());
    }

}
"
jhy/jsoup,src/main/java/org/jsoup/helper/Consumer.java,"package org.jsoup.helper;

/**
 A functional interface (ala Java's {@link java.util.function.Consumer} interface, implemented here for cross compatibility with Android.
 @param <T> the input type
 */
@FunctionalInterface
public interface Consumer<T> {

    /**
     * Execute this operation on the supplied argument. It is expected to have side effects.
     *
     * @param t the input argument
     */
    void accept(T t);
}
"
jhy/jsoup,src/main/java/org/jsoup/internal/StringUtil.java,"package org.jsoup.internal;

import org.jsoup.helper.Validate;

import javax.annotation.Nullable;
import java.net.MalformedURLException;
import java.net.URL;
import java.util.Arrays;
import java.util.Collection;
import java.util.Iterator;
import java.util.Stack;
import java.util.regex.Pattern;

/**
 A minimal String utility class. Designed for <b>internal</b> jsoup use only - the API and outcome may change without
 notice.
 */
public final class StringUtil {
    // memoised padding up to 21 (blocks 0 to 20 spaces)
    static final String[] padding = {"""", "" "", ""  "", ""   "", ""    "", ""     "", ""      "", ""       "", ""        "",
        ""         "", ""          "", ""           "", ""            "", ""             "", ""              "", ""               "",
        ""                "", ""                 "", ""                  "", ""                   "", ""                    ""};

    /**
     * Join a collection of strings by a separator
     * @param strings collection of string objects
     * @param sep string to place between strings
     * @return joined string
     */
    public static String join(Collection<?> strings, String sep) {
        return join(strings.iterator(), sep);
    }

    /**
     * Join a collection of strings by a separator
     * @param strings iterator of string objects
     * @param sep string to place between strings
     * @return joined string
     */
    public static String join(Iterator<?> strings, String sep) {
        if (!strings.hasNext())
            return """";

        String start = strings.next().toString();
        if (!strings.hasNext()) // only one, avoid builder
            return start;

        StringJoiner j = new StringJoiner(sep);
        j.add(start);
        while (strings.hasNext()) {
            j.add(strings.next());
        }
        return j.complete();
    }

    /**
     * Join an array of strings by a separator
     * @param strings collection of string objects
     * @param sep string to place between strings
     * @return joined string
     */
    public static String join(String[] strings, String sep) {
        return join(Arrays.asList(strings), sep);
    }

    /**
     A StringJoiner allows incremental / filtered joining of a set of stringable objects.
     @since 1.14.1
     */
    public static class StringJoiner {
        @Nullable StringBuilder sb = borrowBuilder(); // sets null on builder release so can't accidentally be reused
        final String separator;
        boolean first = true;

        /**
         Create a new joiner, that uses the specified separator. MUST call {@link #complete()} or will leak a thread
         local string builder.

         @param separator the token to insert between strings
         */
        public StringJoiner(String separator) {
            this.separator = separator;
        }

        /**
         Add another item to the joiner, will be separated
         */
        public StringJoiner add(Object stringy) {
            Validate.notNull(sb); // don't reuse
            if (!first)
                sb.append(separator);
            sb.append(stringy);
            first = false;
            return this;
        }

        /**
         Append content to the current item; not separated
         */
        public StringJoiner append(Object stringy) {
            Validate.notNull(sb); // don't reuse
            sb.append(stringy);
            return this;
        }

        /**
         Return the joined string, and release the builder back to the pool. This joiner cannot be reused.
         */
        public String complete() {
            String string = releaseBuilder(sb);
            sb = null;
            return string;
        }
    }

    /**
     * Returns space padding (up to the default max of 30). Use {@link #padding(int, int)} to specify a different limit.
     * @param width amount of padding desired
     * @return string of spaces * width
     * @see #padding(int, int) 
      */
    public static String padding(int width) {
        return padding(width, 30);
    }

    /**
     * Returns space padding, up to a max of maxPaddingWidth.
     * @param width amount of padding desired
     * @param maxPaddingWidth maximum padding to apply. Set to {@code -1} for unlimited.
     * @return string of spaces * width
     */
    public static String padding(int width, int maxPaddingWidth) {
        Validate.isTrue(width >= 0, ""width must be >= 0"");
        Validate.isTrue(maxPaddingWidth >= -1);
        if (maxPaddingWidth != -1)
            width = Math.min(width, maxPaddingWidth);
        if (width < padding.length)
            return padding[width];        
        char[] out = new char[width];
        for (int i = 0; i < width; i++)
            out[i] = ' ';
        return String.valueOf(out);
    }

    /**
     * Tests if a string is blank: null, empty, or only whitespace ("" "", \r\n, \t, etc)
     * @param string string to test
     * @return if string is blank
     */
    public static boolean isBlank(final String string) {
        if (string == null || string.length() == 0)
            return true;

        int l = string.length();
        for (int i = 0; i < l; i++) {
            if (!StringUtil.isWhitespace(string.codePointAt(i)))
                return false;
        }
        return true;
    }

    /**
     Tests if a string starts with a newline character
     @param string string to test
     @return if its first character is a newline
     */
    public static boolean startsWithNewline(final String string) {
        if (string == null || string.length() == 0)
            return false;
        return string.charAt(0) == '\n';
    }

    /**
     * Tests if a string is numeric, i.e. contains only digit characters
     * @param string string to test
     * @return true if only digit chars, false if empty or null or contains non-digit chars
     */
    public static boolean isNumeric(String string) {
        if (string == null || string.length() == 0)
            return false;

        int l = string.length();
        for (int i = 0; i < l; i++) {
            if (!Character.isDigit(string.codePointAt(i)))
                return false;
        }
        return true;
    }

    /**
     * Tests if a code point is ""whitespace"" as defined in the HTML spec. Used for output HTML.
     * @param c code point to test
     * @return true if code point is whitespace, false otherwise
     * @see #isActuallyWhitespace(int)
     */
    public static boolean isWhitespace(int c){
        return c == ' ' || c == '\t' || c == '\n' || c == '\f' || c == '\r';
    }

    /**
     * Tests if a code point is ""whitespace"" as defined by what it looks like. Used for Element.text etc.
     * @param c code point to test
     * @return true if code point is whitespace, false otherwise
     */
    public static boolean isActuallyWhitespace(int c){
        return c == ' ' || c == '\t' || c == '\n' || c == '\f' || c == '\r' || c == 160;
        // 160 is &nbsp; (non-breaking space). Not in the spec but expected.
    }

    public static boolean isInvisibleChar(int c) {
        return c == 8203 || c == 173; // zero width sp, soft hyphen
        // previously also included zw non join, zw join - but removing those breaks semantic meaning of text
    }

    /**
     * Normalise the whitespace within this string; multiple spaces collapse to a single, and all whitespace characters
     * (e.g. newline, tab) convert to a simple space.
     * @param string content to normalise
     * @return normalised string
     */
    public static String normaliseWhitespace(String string) {
        StringBuilder sb = StringUtil.borrowBuilder();
        appendNormalisedWhitespace(sb, string, false);
        return StringUtil.releaseBuilder(sb);
    }

    /**
     * After normalizing the whitespace within a string, appends it to a string builder.
     * @param accum builder to append to
     * @param string string to normalize whitespace within
     * @param stripLeading set to true if you wish to remove any leading whitespace
     */
    public static void appendNormalisedWhitespace(StringBuilder accum, String string, boolean stripLeading) {
        boolean lastWasWhite = false;
        boolean reachedNonWhite = false;

        int len = string.length();
        int c;
        for (int i = 0; i < len; i+= Character.charCount(c)) {
            c = string.codePointAt(i);
            if (isActuallyWhitespace(c)) {
                if ((stripLeading && !reachedNonWhite) || lastWasWhite)
                    continue;
                accum.append(' ');
                lastWasWhite = true;
            }
            else if (!isInvisibleChar(c)) {
                accum.appendCodePoint(c);
                lastWasWhite = false;
                reachedNonWhite = true;
            }
        }
    }

    public static boolean in(final String needle, final String... haystack) {
        final int len = haystack.length;
        for (int i = 0; i < len; i++) {
            if (haystack[i].equals(needle))
            return true;
        }
        return false;
    }

    public static boolean inSorted(String needle, String[] haystack) {
        return Arrays.binarySearch(haystack, needle) >= 0;
    }

    /**
     Tests that a String contains only ASCII characters.
     @param string scanned string
     @return true if all characters are in range 0 - 127
     */
    public static boolean isAscii(String string) {
        Validate.notNull(string);
        for (int i = 0; i < string.length(); i++) {
            int c = string.charAt(i);
            if (c > 127) { // ascii range
                return false;
            }
        }
        return true;
    }

    private static final Pattern extraDotSegmentsPattern = Pattern.compile(""^/((\\.{1,2}/)+)"");
    /**
     * Create a new absolute URL, from a provided existing absolute URL and a relative URL component.
     * @param base the existing absolute base URL
     * @param relUrl the relative URL to resolve. (If it's already absolute, it will be returned)
     * @return the resolved absolute URL
     * @throws MalformedURLException if an error occurred generating the URL
     */
    public static URL resolve(URL base, String relUrl) throws MalformedURLException {
        relUrl = stripControlChars(relUrl);
        // workaround: java resolves '//path/file + ?foo' to '//path/?foo', not '//path/file?foo' as desired
        if (relUrl.startsWith(""?""))
            relUrl = base.getPath() + relUrl;
        // workaround: //example.com + ./foo = //example.com/./foo, not //example.com/foo
        URL url = new URL(base, relUrl);
        String fixedFile = extraDotSegmentsPattern.matcher(url.getFile()).replaceFirst(""/"");
        if (url.getRef() != null) {
            fixedFile = fixedFile + ""#"" + url.getRef();
        }
        return new URL(url.getProtocol(), url.getHost(), url.getPort(), fixedFile);
    }

    /**
     * Create a new absolute URL, from a provided existing absolute URL and a relative URL component.
     * @param baseUrl the existing absolute base URL
     * @param relUrl the relative URL to resolve. (If it's already absolute, it will be returned)
     * @return an absolute URL if one was able to be generated, or the empty string if not
     */
    public static String resolve(String baseUrl, String relUrl) {
        // workaround: java will allow control chars in a path URL and may treat as relative, but Chrome / Firefox will strip and may see as a scheme. Normalize to browser's view.
        baseUrl = stripControlChars(baseUrl); relUrl = stripControlChars(relUrl);
        try {
            URL base;
            try {
                base = new URL(baseUrl);
            } catch (MalformedURLException e) {
                // the base is unsuitable, but the attribute/rel may be abs on its own, so try that
                URL abs = new URL(relUrl);
                return abs.toExternalForm();
            }
            return resolve(base, relUrl).toExternalForm();
        } catch (MalformedURLException e) {
            // it may still be valid, just that Java doesn't have a registered stream handler for it, e.g. tel
            // we test here vs at start to normalize supported URLs (e.g. HTTP -> http)
            return validUriScheme.matcher(relUrl).find() ? relUrl : """";
        }
    }
    private static final Pattern validUriScheme = Pattern.compile(""^[a-zA-Z][a-zA-Z0-9+-.]*:"");

    private static final Pattern controlChars = Pattern.compile(""[\\x00-\\x1f]*""); // matches ascii 0 - 31, to strip from url
    private static String stripControlChars(final String input) {
        return controlChars.matcher(input).replaceAll("""");
    }

    private static final ThreadLocal<Stack<StringBuilder>> threadLocalBuilders = new ThreadLocal<Stack<StringBuilder>>() {
        @Override
        protected Stack<StringBuilder> initialValue() {
            return new Stack<>();
        }
    };

    /**
     * Maintains cached StringBuilders in a flyweight pattern, to minimize new StringBuilder GCs. The StringBuilder is
     * prevented from growing too large.
     * <p>
     * Care must be taken to release the builder once its work has been completed, with {@link #releaseBuilder}
     * @return an empty StringBuilder
     */
    public static StringBuilder borrowBuilder() {
        Stack<StringBuilder> builders = threadLocalBuilders.get();
        return builders.empty() ?
            new StringBuilder(MaxCachedBuilderSize) :
            builders.pop();
    }

    /**
     * Release a borrowed builder. Care must be taken not to use the builder after it has been returned, as its
     * contents may be changed by this method, or by a concurrent thread.
     * @param sb the StringBuilder to release.
     * @return the string value of the released String Builder (as an incentive to release it!).
     */
    public static String releaseBuilder(StringBuilder sb) {
        Validate.notNull(sb);
        String string = sb.toString();

        if (sb.length() > MaxCachedBuilderSize)
            sb = new StringBuilder(MaxCachedBuilderSize); // make sure it hasn't grown too big
        else
            sb.delete(0, sb.length()); // make sure it's emptied on release

        Stack<StringBuilder> builders = threadLocalBuilders.get();
        builders.push(sb);

        while (builders.size() > MaxIdleBuilders) {
            builders.pop();
        }
        return string;
    }

    private static final int MaxCachedBuilderSize = 8 * 1024;
    private static final int MaxIdleBuilders = 8;
}
"
jhy/jsoup,src/main/java/org/jsoup/nodes/Node.java,"package org.jsoup.nodes;

import org.jsoup.SerializationException;
import org.jsoup.helper.Consumer;
import org.jsoup.helper.Validate;
import org.jsoup.internal.StringUtil;
import org.jsoup.select.NodeFilter;
import org.jsoup.select.NodeTraversor;
import org.jsoup.select.NodeVisitor;

import javax.annotation.Nullable;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;

/**
 The base, abstract Node model. Elements, Documents, Comments etc are all Node instances.

 @author Jonathan Hedley, jonathan@hedley.net */
public abstract class Node implements Cloneable {
    static final List<Node> EmptyNodes = Collections.emptyList();
    static final String EmptyString = """";
    @Nullable Node parentNode; // Nodes don't always have parents
    int siblingIndex;

    /**
     * Default constructor. Doesn't setup base uri, children, or attributes; use with caution.
     */
    protected Node() {
    }

    /**
     Get the node name of this node. Use for debugging purposes and not logic switching (for that, use instanceof).
     @return node name
     */
    public abstract String nodeName();

    /**
     * Check if this Node has an actual Attributes object.
     */
    protected abstract boolean hasAttributes();

    /**
     Checks if this node has a parent. Nodes won't have parents if (e.g.) they are newly created and not added as a child
     to an existing node, or if they are a {@link #shallowClone()}. In such cases, {@link #parent()} will return {@code null}.
     @return if this node has a parent.
     */
    public boolean hasParent() {
        return parentNode != null;
    }

    /**
     * Get an attribute's value by its key. <b>Case insensitive</b>
     * <p>
     * To get an absolute URL from an attribute that may be a relative URL, prefix the key with <code><b>abs</b></code>,
     * which is a shortcut to the {@link #absUrl} method.
     * </p>
     * E.g.:
     * <blockquote><code>String url = a.attr(""abs:href"");</code></blockquote>
     *
     * @param attributeKey The attribute key.
     * @return The attribute, or empty string if not present (to avoid nulls).
     * @see #attributes()
     * @see #hasAttr(String)
     * @see #absUrl(String)
     */
    public String attr(String attributeKey) {
        Validate.notNull(attributeKey);
        if (!hasAttributes())
            return EmptyString;

        String val = attributes().getIgnoreCase(attributeKey);
        if (val.length() > 0)
            return val;
        else if (attributeKey.startsWith(""abs:""))
            return absUrl(attributeKey.substring(""abs:"".length()));
        else return """";
    }

    /**
     * Get all of the element's attributes.
     * @return attributes (which implements iterable, in same order as presented in original HTML).
     */
    public abstract Attributes attributes();

    /**
     Get the number of attributes that this Node has.
     @return the number of attributes
     @since 1.14.2
     */
    public int attributesSize() {
        // added so that we can test how many attributes exist without implicitly creating the Attributes object
        return hasAttributes() ? attributes().size() : 0;
    }

    /**
     * Set an attribute (key=value). If the attribute already exists, it is replaced. The attribute key comparison is
     * <b>case insensitive</b>. The key will be set with case sensitivity as set in the parser settings.
     * @param attributeKey The attribute key.
     * @param attributeValue The attribute value.
     * @return this (for chaining)
     */
    public Node attr(String attributeKey, String attributeValue) {
        attributeKey = NodeUtils.parser(this).settings().normalizeAttribute(attributeKey);
        attributes().putIgnoreCase(attributeKey, attributeValue);
        return this;
    }

    /**
     * Test if this Node has an attribute. <b>Case insensitive</b>.
     * @param attributeKey The attribute key to check.
     * @return true if the attribute exists, false if not.
     */
    public boolean hasAttr(String attributeKey) {
        Validate.notNull(attributeKey);
        if (!hasAttributes())
            return false;

        if (attributeKey.startsWith(""abs:"")) {
            String key = attributeKey.substring(""abs:"".length());
            if (attributes().hasKeyIgnoreCase(key) && !absUrl(key).isEmpty())
                return true;
        }
        return attributes().hasKeyIgnoreCase(attributeKey);
    }

    /**
     * Remove an attribute from this node.
     * @param attributeKey The attribute to remove.
     * @return this (for chaining)
     */
    public Node removeAttr(String attributeKey) {
        Validate.notNull(attributeKey);
        if (hasAttributes())
            attributes().removeIgnoreCase(attributeKey);
        return this;
    }

    /**
     * Clear (remove) all of the attributes in this node.
     * @return this, for chaining
     */
    public Node clearAttributes() {
        if (hasAttributes()) {
            Iterator<Attribute> it = attributes().iterator();
            while (it.hasNext()) {
                it.next();
                it.remove();
            }
        }
        return this;
    }

    /**
     Get the base URI that applies to this node. Will return an empty string if not defined. Used to make relative links
     absolute.

     @return base URI
     @see #absUrl
     */
    public abstract String baseUri();

    /**
     * Set the baseUri for just this node (not its descendants), if this Node tracks base URIs.
     * @param baseUri new URI
     */
    protected abstract void doSetBaseUri(String baseUri);

    /**
     Update the base URI of this node and all of its descendants.
     @param baseUri base URI to set
     */
    public void setBaseUri(final String baseUri) {
        Validate.notNull(baseUri);
        doSetBaseUri(baseUri);
    }

    /**
     * Get an absolute URL from a URL attribute that may be relative (such as an <code>&lt;a href&gt;</code> or
     * <code>&lt;img src&gt;</code>).
     * <p>
     * E.g.: <code>String absUrl = linkEl.absUrl(""href"");</code>
     * </p>
     * <p>
     * If the attribute value is already absolute (i.e. it starts with a protocol, like
     * <code>http://</code> or <code>https://</code> etc), and it successfully parses as a URL, the attribute is
     * returned directly. Otherwise, it is treated as a URL relative to the element's {@link #baseUri}, and made
     * absolute using that.
     * </p>
     * <p>
     * As an alternate, you can use the {@link #attr} method with the <code>abs:</code> prefix, e.g.:
     * <code>String absUrl = linkEl.attr(""abs:href"");</code>
     * </p>
     *
     * @param attributeKey The attribute key
     * @return An absolute URL if one could be made, or an empty string (not null) if the attribute was missing or
     * could not be made successfully into a URL.
     * @see #attr
     * @see java.net.URL#URL(java.net.URL, String)
     */
    public String absUrl(String attributeKey) {
        Validate.notEmpty(attributeKey);
        if (!(hasAttributes() && attributes().hasKeyIgnoreCase(attributeKey))) // not using hasAttr, so that we don't recurse down hasAttr->absUrl
            return """";

        return StringUtil.resolve(baseUri(), attributes().getIgnoreCase(attributeKey));
    }

    protected abstract List<Node> ensureChildNodes();

    /**
     Get a child node by its 0-based index.
     @param index index of child node
     @return the child node at this index. Throws a {@code IndexOutOfBoundsException} if the index is out of bounds.
     */
    public Node childNode(int index) {
        return ensureChildNodes().get(index);
    }

    /**
     Get this node's children. Presented as an unmodifiable list: new children can not be added, but the child nodes
     themselves can be manipulated.
     @return list of children. If no children, returns an empty list.
     */
    public List<Node> childNodes() {
        if (childNodeSize() == 0)
            return EmptyNodes;

        List<Node> children = ensureChildNodes();
        List<Node> rewrap = new ArrayList<>(children.size()); // wrapped so that looping and moving will not throw a CME as the source changes
        rewrap.addAll(children);
        return Collections.unmodifiableList(rewrap);
    }

    /**
     * Returns a deep copy of this node's children. Changes made to these nodes will not be reflected in the original
     * nodes
     * @return a deep copy of this node's children
     */
    public List<Node> childNodesCopy() {
        final List<Node> nodes = ensureChildNodes();
        final ArrayList<Node> children = new ArrayList<>(nodes.size());
        for (Node node : nodes) {
            children.add(node.clone());
        }
        return children;
    }

    /**
     * Get the number of child nodes that this node holds.
     * @return the number of child nodes that this node holds.
     */
    public abstract int childNodeSize();

    protected Node[] childNodesAsArray() {
        return ensureChildNodes().toArray(new Node[0]);
    }

    /**
     * Delete all this node's children.
     * @return this node, for chaining
     */
    public abstract Node empty();


    /**
     Gets this node's parent node.
     @return parent node; or null if no parent.
     @see #hasParent()
     */
    public @Nullable Node parent() {
        return parentNode;
    }

    /**
     Gets this node's parent node. Not overridable by extending classes, so useful if you really just need the Node type.
     @return parent node; or null if no parent.
     */
    public @Nullable final Node parentNode() {
        return parentNode;
    }

    /**
     * Get this node's root node; that is, its topmost ancestor. If this node is the top ancestor, returns {@code this}.
     * @return topmost ancestor.
     */
    public Node root() {
        Node node = this;
        while (node.parentNode != null)
            node = node.parentNode;
        return node;
    }

    /**
     * Gets the Document associated with this Node.
     * @return the Document associated with this Node, or null if there is no such Document.
     */
    public @Nullable Document ownerDocument() {
        Node root = root();
        return (root instanceof Document) ? (Document) root : null;
    }

    /**
     * Remove (delete) this node from the DOM tree. If this node has children, they are also removed.
     */
    public void remove() {
        Validate.notNull(parentNode);
        parentNode.removeChild(this);
    }

    /**
     * Insert the specified HTML into the DOM before this node (as a preceding sibling).
     * @param html HTML to add before this node
     * @return this node, for chaining
     * @see #after(String)
     */
    public Node before(String html) {
        addSiblingHtml(siblingIndex, html);
        return this;
    }

    /**
     * Insert the specified node into the DOM before this node (as a preceding sibling).
     * @param node to add before this node
     * @return this node, for chaining
     * @see #after(Node)
     */
    public Node before(Node node) {
        Validate.notNull(node);
        Validate.notNull(parentNode);

        parentNode.addChildren(siblingIndex, node);
        return this;
    }

    /**
     * Insert the specified HTML into the DOM after this node (as a following sibling).
     * @param html HTML to add after this node
     * @return this node, for chaining
     * @see #before(String)
     */
    public Node after(String html) {
        addSiblingHtml(siblingIndex + 1, html);
        return this;
    }

    /**
     * Insert the specified node into the DOM after this node (as a following sibling).
     * @param node to add after this node
     * @return this node, for chaining
     * @see #before(Node)
     */
    public Node after(Node node) {
        Validate.notNull(node);
        Validate.notNull(parentNode);

        parentNode.addChildren(siblingIndex + 1, node);
        return this;
    }

    private void addSiblingHtml(int index, String html) {
        Validate.notNull(html);
        Validate.notNull(parentNode);

        Element context = parent() instanceof Element ? (Element) parent() : null;
        List<Node> nodes = NodeUtils.parser(this).parseFragmentInput(html, context, baseUri());
        parentNode.addChildren(index, nodes.toArray(new Node[0]));
    }

    /**
     Wrap the supplied HTML around this node.

     @param html HTML to wrap around this node, e.g. {@code <div class=""head""></div>}. Can be arbitrarily deep. If
     the input HTML does not parse to a result starting with an Element, this will be a no-op.
     @return this node, for chaining.
     */
    public Node wrap(String html) {
        Validate.notEmpty(html);

        // Parse context - parent (because wrapping), this, or null
        Element context =
            parentNode != null && parentNode instanceof Element ? (Element) parentNode :
                this instanceof Element ? (Element) this :
                    null;
        List<Node> wrapChildren = NodeUtils.parser(this).parseFragmentInput(html, context, baseUri());
        Node wrapNode = wrapChildren.get(0);
        if (!(wrapNode instanceof Element)) // nothing to wrap with; noop
            return this;

        Element wrap = (Element) wrapNode;
        Element deepest = getDeepChild(wrap);
        if (parentNode != null)
            parentNode.replaceChild(this, wrap);
        deepest.addChildren(this); // side effect of tricking wrapChildren to lose first

        // remainder (unbalanced wrap, like <div></div><p></p> -- The <p> is remainder
        if (wrapChildren.size() > 0) {
            //noinspection ForLoopReplaceableByForEach (beacause it allocates an Iterator which is wasteful here)
            for (int i = 0; i < wrapChildren.size(); i++) {
                Node remainder = wrapChildren.get(i);
                // if no parent, this could be the wrap node, so skip
                if (wrap == remainder)
                    continue;

                if (remainder.parentNode != null)
                    remainder.parentNode.removeChild(remainder);
                wrap.after(remainder);
            }
        }
        return this;
    }

    /**
     * Removes this node from the DOM, and moves its children up into the node's parent. This has the effect of dropping
     * the node but keeping its children.
     * <p>
     * For example, with the input html:
     * </p>
     * <p>{@code <div>One <span>Two <b>Three</b></span></div>}</p>
     * Calling {@code element.unwrap()} on the {@code span} element will result in the html:
     * <p>{@code <div>One Two <b>Three</b></div>}</p>
     * and the {@code ""Two ""} {@link TextNode} being returned.
     *
     * @return the first child of this node, after the node has been unwrapped. @{code Null} if the node had no children.
     * @see #remove()
     * @see #wrap(String)
     */
    public @Nullable Node unwrap() {
        Validate.notNull(parentNode);
        Node firstChild = firstChild();
        parentNode.addChildren(siblingIndex, this.childNodesAsArray());
        this.remove();

        return firstChild;
    }

    private Element getDeepChild(Element el) {
        List<Element> children = el.children();
        if (children.size() > 0)
            return getDeepChild(children.get(0));
        else
            return el;
    }

    void nodelistChanged() {
        // Element overrides this to clear its shadow children elements
    }

    /**
     * Replace this node in the DOM with the supplied node.
     * @param in the node that will replace the existing node.
     */
    public void replaceWith(Node in) {
        Validate.notNull(in);
        Validate.notNull(parentNode);
        parentNode.replaceChild(this, in);
    }

    protected void setParentNode(Node parentNode) {
        Validate.notNull(parentNode);
        if (this.parentNode != null)
            this.parentNode.removeChild(this);
        this.parentNode = parentNode;
    }

    protected void replaceChild(Node out, Node in) {
        Validate.isTrue(out.parentNode == this);
        Validate.notNull(in);
        if (in.parentNode != null)
            in.parentNode.removeChild(in);

        final int index = out.siblingIndex;
        ensureChildNodes().set(index, in);
        in.parentNode = this;
        in.setSiblingIndex(index);
        out.parentNode = null;
    }

    protected void removeChild(Node out) {
        Validate.isTrue(out.parentNode == this);
        final int index = out.siblingIndex;
        ensureChildNodes().remove(index);
        reindexChildren(index);
        out.parentNode = null;
    }

    protected void addChildren(Node... children) {
        //most used. short circuit addChildren(int), which hits reindex children and array copy
        final List<Node> nodes = ensureChildNodes();

        for (Node child: children) {
            reparentChild(child);
            nodes.add(child);
            child.setSiblingIndex(nodes.size()-1);
        }
    }

    protected void addChildren(int index, Node... children) {
        Validate.notNull(children);
        if (children.length == 0) {
            return;
        }
        final List<Node> nodes = ensureChildNodes();

        // fast path - if used as a wrap (index=0, children = child[0].parent.children - do inplace
        final Node firstParent = children[0].parent();
        if (firstParent != null && firstParent.childNodeSize() == children.length) {
            boolean sameList = true;
            final List<Node> firstParentNodes = firstParent.ensureChildNodes();
            // identity check contents to see if same
            int i = children.length;
            while (i-- > 0) {
                if (children[i] != firstParentNodes.get(i)) {
                    sameList = false;
                    break;
                }
            }
            if (sameList) { // moving, so OK to empty firstParent and short-circuit
                boolean wasEmpty = childNodeSize() == 0;
                firstParent.empty();
                nodes.addAll(index, Arrays.asList(children));
                i = children.length;
                while (i-- > 0) {
                    children[i].parentNode = this;
                }
                if (!(wasEmpty && children[0].siblingIndex == 0)) // skip reindexing if we just moved
                    reindexChildren(index);
                return;
            }
        }

        Validate.noNullElements(children);
        for (Node child : children) {
            reparentChild(child);
        }
        nodes.addAll(index, Arrays.asList(children));
        reindexChildren(index);
    }
    
    protected void reparentChild(Node child) {
        child.setParentNode(this);
    }

    private void reindexChildren(int start) {
        final int size = childNodeSize();
        if (size == 0) return;
        final List<Node> childNodes = ensureChildNodes();
        for (int i = start; i < size; i++) {
            childNodes.get(i).setSiblingIndex(i);
        }
    }

    /**
     Retrieves this node's sibling nodes. Similar to {@link #childNodes() node.parent.childNodes()}, but does not
     include this node (a node is not a sibling of itself).
     @return node siblings. If the node has no parent, returns an empty list.
     */
    public List<Node> siblingNodes() {
        if (parentNode == null)
            return Collections.emptyList();

        List<Node> nodes = parentNode.ensureChildNodes();
        List<Node> siblings = new ArrayList<>(nodes.size() - 1);
        for (Node node: nodes)
            if (node != this)
                siblings.add(node);
        return siblings;
    }

    /**
     Get this node's next sibling.
     @return next sibling, or @{code null} if this is the last sibling
     */
    public @Nullable Node nextSibling() {
        if (parentNode == null)
            return null; // root

        final List<Node> siblings = parentNode.ensureChildNodes();
        final int index = siblingIndex+1;
        if (siblings.size() > index)
            return siblings.get(index);
        else
            return null;
    }

    /**
     Get this node's previous sibling.
     @return the previous sibling, or @{code null} if this is the first sibling
     */
    public @Nullable Node previousSibling() {
        if (parentNode == null)
            return null; // root

        if (siblingIndex > 0)
            return parentNode.ensureChildNodes().get(siblingIndex-1);
        else
            return null;
    }

    /**
     * Get the list index of this node in its node sibling list. E.g. if this is the first node
     * sibling, returns 0.
     * @return position in node sibling list
     * @see org.jsoup.nodes.Element#elementSiblingIndex()
     */
    public int siblingIndex() {
        return siblingIndex;
    }

    protected void setSiblingIndex(int siblingIndex) {
        this.siblingIndex = siblingIndex;
    }

    /**
     Gets the first child node of this node, or {@code null} if there is none. This could be any Node type, such as an
     Element, TextNode, Comment, etc. Use {@link Element#firstElementChild()} to get the first Element child.
     @return the first child node, or null if there are no children.
     @see Element#firstElementChild()
     @see #lastChild()
     @since 1.15.2
     */
    public @Nullable Node firstChild() {
        if (childNodeSize() == 0) return null;
        return ensureChildNodes().get(0);
    }

    /**
     Gets the last child node of this node, or {@code null} if there is none.
     @return the last child node, or null if there are no children.
     @see Element#lastElementChild()
     @see #firstChild()
     @since 1.15.2
     */
    public @Nullable Node lastChild() {
        final int size = childNodeSize();
        if (size == 0) return null;
        List<Node> children = ensureChildNodes();
        return children.get(size - 1);
    }

    /**
     * Perform a depth-first traversal through this node and its descendants.
     * @param nodeVisitor the visitor callbacks to perform on each node
     * @return this node, for chaining
     */
    public Node traverse(NodeVisitor nodeVisitor) {
        Validate.notNull(nodeVisitor);
        NodeTraversor.traverse(nodeVisitor, this);
        return this;
    }

    /**
     Perform the supplied action on this Node and each of its descendants, during a depth-first traversal. Nodes may be
     inspected, changed, added, replaced, or removed.
     @param action the function to perform on the node
     @return this Node, for chaining
     @see Element#forEach(Consumer)
     */
    public Node forEachNode(Consumer<? super Node> action) {
        Validate.notNull(action);
        NodeTraversor.traverse((node, depth) -> action.accept(node), this);
        return this;
    }

    /**
     * Perform a depth-first filtering through this node and its descendants.
     * @param nodeFilter the filter callbacks to perform on each node
     * @return this node, for chaining
     */
    public Node filter(NodeFilter nodeFilter) {
        Validate.notNull(nodeFilter);
        NodeTraversor.filter(nodeFilter, this);
        return this;
    }

    /**
     Get the outer HTML of this node. For example, on a {@code p} element, may return {@code <p>Para</p>}.
     @return outer HTML
     @see Element#html()
     @see Element#text()
     */
    public String outerHtml() {
        StringBuilder accum = StringUtil.borrowBuilder();
        outerHtml(accum);
        return StringUtil.releaseBuilder(accum);
    }

    protected void outerHtml(Appendable accum) {
        NodeTraversor.traverse(new OuterHtmlVisitor(accum, NodeUtils.outputSettings(this)), this);
    }

    /**
     Get the outer HTML of this node.
     @param accum accumulator to place HTML into
     @throws IOException if appending to the given accumulator fails.
     */
    abstract void outerHtmlHead(final Appendable accum, int depth, final Document.OutputSettings out) throws IOException;

    abstract void outerHtmlTail(final Appendable accum, int depth, final Document.OutputSettings out) throws IOException;

    /**
     * Write this node and its children to the given {@link Appendable}.
     *
     * @param appendable the {@link Appendable} to write to.
     * @return the supplied {@link Appendable}, for chaining.
     */
    public <T extends Appendable> T html(T appendable) {
        outerHtml(appendable);
        return appendable;
    }

    /**
     Get the source range (start and end positions) in the original input source that this node was parsed from. Position
     tracking must be enabled prior to parsing the content. For an Element, this will be the positions of the start tag.
     @return the range for the start of the node.
     @see org.jsoup.parser.Parser#setTrackPosition(boolean)
     @see Element#endSourceRange()
     @since 1.15.2
     */
    public Range sourceRange() {
        return Range.of(this, true);
    }

    /**
     * Gets this node's outer HTML.
     * @return outer HTML.
     * @see #outerHtml()
     */
	public String toString() {
        return outerHtml();
    }

    protected void indent(Appendable accum, int depth, Document.OutputSettings out) throws IOException {
        accum.append('\n').append(StringUtil.padding(depth * out.indentAmount(), out.maxPaddingWidth()));
    }

    /**
     * Check if this node is the same instance of another (object identity test).
     * <p>For an node value equality check, see {@link #hasSameValue(Object)}</p>
     * @param o other object to compare to
     * @return true if the content of this node is the same as the other
     * @see Node#hasSameValue(Object)
     */
    @Override
    public boolean equals(@Nullable Object o) {
        // implemented just so that javadoc is clear this is an identity test
        return this == o;
    }

    /**
     Provides a hashCode for this Node, based on it's object identity. Changes to the Node's content will not impact the
     result.
     @return an object identity based hashcode for this Node
     */
    @Override
    public int hashCode() {
        // implemented so that javadoc and scanners are clear this is an identity test
        return super.hashCode();
    }

    /**
     * Check if this node has the same content as another node. A node is considered the same if its name, attributes and content match the
     * other node; particularly its position in the tree does not influence its similarity.
     * @param o other object to compare to
     * @return true if the content of this node is the same as the other
     */
    public boolean hasSameValue(@Nullable Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;

        return this.outerHtml().equals(((Node) o).outerHtml());
    }

    /**
     * Create a stand-alone, deep copy of this node, and all of its children. The cloned node will have no siblings or
     * parent node. As a stand-alone object, any changes made to the clone or any of its children will not impact the
     * original node.
     * <p>
     * The cloned node may be adopted into another Document or node structure using {@link Element#appendChild(Node)}.
     * @return a stand-alone cloned node, including clones of any children
     * @see #shallowClone()
     */
    @SuppressWarnings(""MethodDoesntCallSuperMethod"") // because it does call super.clone in doClone - analysis just isn't following
    @Override
    public Node clone() {
        Node thisClone = doClone(null); // splits for orphan

        // Queue up nodes that need their children cloned (BFS).
        final LinkedList<Node> nodesToProcess = new LinkedList<>();
        nodesToProcess.add(thisClone);

        while (!nodesToProcess.isEmpty()) {
            Node currParent = nodesToProcess.remove();

            final int size = currParent.childNodeSize();
            for (int i = 0; i < size; i++) {
                final List<Node> childNodes = currParent.ensureChildNodes();
                Node childClone = childNodes.get(i).doClone(currParent);
                childNodes.set(i, childClone);
                nodesToProcess.add(childClone);
            }
        }

        return thisClone;
    }

    /**
     * Create a stand-alone, shallow copy of this node. None of its children (if any) will be cloned, and it will have
     * no parent or sibling nodes.
     * @return a single independent copy of this node
     * @see #clone()
     */
    public Node shallowClone() {
        return doClone(null);
    }

    /*
     * Return a clone of the node using the given parent (which can be null).
     * Not a deep copy of children.
     */
    protected Node doClone(@Nullable Node parent) {
        Node clone;

        try {
            clone = (Node) super.clone();
        } catch (CloneNotSupportedException e) {
            throw new RuntimeException(e);
        }

        clone.parentNode = parent; // can be null, to create an orphan split
        clone.siblingIndex = parent == null ? 0 : siblingIndex;
        // if not keeping the parent, shallowClone the ownerDocument to preserve its settings
        if (parent == null && !(this instanceof Document)) {
            Document doc = ownerDocument();
            if (doc != null) {
                Document docClone = doc.shallowClone();
                clone.parentNode = docClone;
                docClone.ensureChildNodes().add(clone);
            }
        }

        return clone;
    }

    private static class OuterHtmlVisitor implements NodeVisitor {
        private final Appendable accum;
        private final Document.OutputSettings out;

        OuterHtmlVisitor(Appendable accum, Document.OutputSettings out) {
            this.accum = accum;
            this.out = out;
            out.prepareEncoder();
        }

        public void head(Node node, int depth) {
            try {
				node.outerHtmlHead(accum, depth, out);
			} catch (IOException exception) {
				throw new SerializationException(exception);
			}
        }

        public void tail(Node node, int depth) {
            if (!node.nodeName().equals(""#text"")) { // saves a void hit.
				try {
					node.outerHtmlTail(accum, depth, out);
				} catch (IOException exception) {
					throw new SerializationException(exception);
				}
            }
        }
    }
}
"
jhy/jsoup,src/main/java/org/jsoup/nodes/Attributes.java,"package org.jsoup.nodes;

import org.jsoup.SerializationException;
import org.jsoup.helper.Validate;
import org.jsoup.internal.StringUtil;
import org.jsoup.parser.ParseSettings;

import javax.annotation.Nullable;
import java.io.IOException;
import java.util.AbstractMap;
import java.util.AbstractSet;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;

import static org.jsoup.internal.Normalizer.lowerCase;

/**
 * The attributes of an Element.
 * <p>
 * Attributes are treated as a map: there can be only one value associated with an attribute key/name.
 * </p>
 * <p>
 * Attribute name and value comparisons are generally <b>case sensitive</b>. By default for HTML, attribute names are
 * normalized to lower-case on parsing. That means you should use lower-case strings when referring to attributes by
 * name.
 * </p>
 *
 * @author Jonathan Hedley, jonathan@hedley.net
 */
public class Attributes implements Iterable<Attribute>, Cloneable {
    // The Attributes object is only created on the first use of an attribute; the Element will just have a null
    // Attribute slot otherwise
    protected static final String dataPrefix = ""data-"";
    // Indicates a jsoup internal key. Can't be set via HTML. (It could be set via accessor, but not too worried about
    // that. Suppressed from list, iter.
    static final char InternalPrefix = '/';
    private static final int InitialCapacity = 3; // sampling found mean count when attrs present = 1.49; 1.08 overall. 2.6:1 don't have any attrs.

    // manages the key/val arrays
    private static final int GrowthFactor = 2;
    static final int NotFound = -1;
    private static final String EmptyString = """";

    // the number of instance fields is kept as low as possible giving an object size of 24 bytes
    private int size = 0; // number of slots used (not total capacity, which is keys.length)
    String[] keys = new String[InitialCapacity];
    Object[] vals = new Object[InitialCapacity]; // Genericish: all non-internal attribute values must be Strings and are cast on access.

    // check there's room for more
    private void checkCapacity(int minNewSize) {
        Validate.isTrue(minNewSize >= size);
        int curCap = keys.length;
        if (curCap >= minNewSize)
            return;
        int newCap = curCap >= InitialCapacity ? size * GrowthFactor : InitialCapacity;
        if (minNewSize > newCap)
            newCap = minNewSize;

        keys = Arrays.copyOf(keys, newCap);
        vals = Arrays.copyOf(vals, newCap);
    }

    int indexOfKey(String key) {
        Validate.notNull(key);
        for (int i = 0; i < size; i++) {
            if (key.equals(keys[i]))
                return i;
        }
        return NotFound;
    }

    private int indexOfKeyIgnoreCase(String key) {
        Validate.notNull(key);
        for (int i = 0; i < size; i++) {
            if (key.equalsIgnoreCase(keys[i]))
                return i;
        }
        return NotFound;
    }

    // we track boolean attributes as null in values - they're just keys. so returns empty for consumers
    // casts to String, so only for non-internal attributes
    static String checkNotNull(@Nullable Object val) {
        return val == null ? EmptyString : (String) val;
    }

    /**
     Get an attribute value by key.
     @param key the (case-sensitive) attribute key
     @return the attribute value if set; or empty string if not set (or a boolean attribute).
     @see #hasKey(String)
     */
    public String get(String key) {
        int i = indexOfKey(key);
        return i == NotFound ? EmptyString : checkNotNull(vals[i]);
    }

    /**
     * Get an attribute's value by case-insensitive key
     * @param key the attribute name
     * @return the first matching attribute value if set; or empty string if not set (ora boolean attribute).
     */
    public String getIgnoreCase(String key) {
        int i = indexOfKeyIgnoreCase(key);
        return i == NotFound ? EmptyString : checkNotNull(vals[i]);
    }

    /**
     Get an arbitrary user data object by key.
     * @param key case sensitive key to the object.
     * @return the object associated to this key, or {@code null} if not found.
     */
    @Nullable
    Object getUserData(String key) {
        Validate.notNull(key);
        if (!isInternalKey(key)) key = internalKey(key);
        int i = indexOfKeyIgnoreCase(key);
        return i == NotFound ? null : vals[i];
    }

    /**
     * Adds a new attribute. Will produce duplicates if the key already exists.
     * @see Attributes#put(String, String)
     */
    public Attributes add(String key, @Nullable String value) {
        addObject(key, value);
        return this;
    }

    private void addObject(String key, @Nullable Object value) {
        checkCapacity(size + 1);
        keys[size] = key;
        vals[size] = value;
        size++;
    }

    /**
     * Set a new attribute, or replace an existing one by key.
     * @param key case sensitive attribute key (not null)
     * @param value attribute value (may be null, to set a boolean attribute)
     * @return these attributes, for chaining
     */
    public Attributes put(String key, @Nullable String value) {
        Validate.notNull(key);
        int i = indexOfKey(key);
        if (i != NotFound)
            vals[i] = value;
        else
            add(key, value);
        return this;
    }

    /**
     Put an arbitrary user-data object by key. Will be treated as an internal attribute, so will not be emitted in HTML.
     * @param key case sensitive key
     * @param value object value
     * @return these attributes
     * @see #getUserData(String)
     */
    Attributes putUserData(String key, Object value) {
        Validate.notNull(key);
        if (!isInternalKey(key)) key = internalKey(key);
        Validate.notNull(value);
        int i = indexOfKey(key);
        if (i != NotFound)
            vals[i] = value;
        else
            addObject(key, value);
        return this;
    }

    void putIgnoreCase(String key, @Nullable String value) {
        int i = indexOfKeyIgnoreCase(key);
        if (i != NotFound) {
            vals[i] = value;
            if (!keys[i].equals(key)) // case changed, update
                keys[i] = key;
        }
        else
            add(key, value);
    }

    /**
     * Set a new boolean attribute, remove attribute if value is false.
     * @param key case <b>insensitive</b> attribute key
     * @param value attribute value
     * @return these attributes, for chaining
     */
    public Attributes put(String key, boolean value) {
        if (value)
            putIgnoreCase(key, null);
        else
            remove(key);
        return this;
    }

    /**
     Set a new attribute, or replace an existing one by key.
     @param attribute attribute with case sensitive key
     @return these attributes, for chaining
     */
    public Attributes put(Attribute attribute) {
        Validate.notNull(attribute);
        put(attribute.getKey(), attribute.getValue());
        attribute.parent = this;
        return this;
    }

    // removes and shifts up
    @SuppressWarnings(""AssignmentToNull"")
    private void remove(int index) {
        Validate.isFalse(index >= size);
        int shifted = size - index - 1;
        if (shifted > 0) {
            System.arraycopy(keys, index + 1, keys, index, shifted);
            System.arraycopy(vals, index + 1, vals, index, shifted);
        }
        size--;
        keys[size] = null; // release hold
        vals[size] = null;
    }

    /**
     Remove an attribute by key. <b>Case sensitive.</b>
     @param key attribute key to remove
     */
    public void remove(String key) {
        int i = indexOfKey(key);
        if (i != NotFound)
            remove(i);
    }

    /**
     Remove an attribute by key. <b>Case insensitive.</b>
     @param key attribute key to remove
     */
    public void removeIgnoreCase(String key) {
        int i = indexOfKeyIgnoreCase(key);
        if (i != NotFound)
            remove(i);
    }

    /**
     Tests if these attributes contain an attribute with this key.
     @param key case-sensitive key to check for
     @return true if key exists, false otherwise
     */
    public boolean hasKey(String key) {
        return indexOfKey(key) != NotFound;
    }

    /**
     Tests if these attributes contain an attribute with this key.
     @param key key to check for
     @return true if key exists, false otherwise
     */
    public boolean hasKeyIgnoreCase(String key) {
        return indexOfKeyIgnoreCase(key) != NotFound;
    }

    /**
     * Check if these attributes contain an attribute with a value for this key.
     * @param key key to check for
     * @return true if key exists, and it has a value
     */
    public boolean hasDeclaredValueForKey(String key) {
        int i = indexOfKey(key);
        return i != NotFound && vals[i] != null;
    }

    /**
     * Check if these attributes contain an attribute with a value for this key.
     * @param key case-insensitive key to check for
     * @return true if key exists, and it has a value
     */
    public boolean hasDeclaredValueForKeyIgnoreCase(String key) {
        int i = indexOfKeyIgnoreCase(key);
        return i != NotFound && vals[i] != null;
    }

    /**
     Get the number of attributes in this set, including any jsoup internal-only attributes. Internal attributes are
     excluded from the {@link #html()}, {@link #asList()}, and {@link #iterator()} methods.
     @return size
     */
    public int size() {
        return size;
    }

    /**
     * Test if this Attributes list is empty (size==0).
     */
    public boolean isEmpty() {
        return size == 0;
    }

    /**
     Add all the attributes from the incoming set to this set.
     @param incoming attributes to add to these attributes.
     */
    public void addAll(Attributes incoming) {
        if (incoming.size() == 0)
            return;
        checkCapacity(size + incoming.size);

        boolean needsPut = size != 0; // if this set is empty, no need to check existing set, so can add() vs put()
        // (and save bashing on the indexOfKey()
        for (Attribute attr : incoming) {
            if (needsPut)
                put(attr);
            else
                add(attr.getKey(), attr.getValue());
        }
    }

    public Iterator<Attribute> iterator() {
        return new Iterator<Attribute>() {
            int i = 0;

            @Override
            public boolean hasNext() {
                while (i < size) {
                    if (isInternalKey(keys[i])) // skip over internal keys
                        i++;
                    else
                        break;
                }

                return i < size;
            }

            @Override
            public Attribute next() {
                final Attribute attr = new Attribute(keys[i], (String) vals[i], Attributes.this);
                i++;
                return attr;
            }

            @Override
            public void remove() {
                Attributes.this.remove(--i); // next() advanced, so rewind
            }
        };
    }

    /**
     Get the attributes as a List, for iteration.
     @return a view of the attributes as an unmodifiable List.
     */
    public List<Attribute> asList() {
        ArrayList<Attribute> list = new ArrayList<>(size);
        for (int i = 0; i < size; i++) {
            if (isInternalKey(keys[i]))
                continue; // skip internal keys
            Attribute attr = new Attribute(keys[i], (String) vals[i], Attributes.this);
            list.add(attr);
        }
        return Collections.unmodifiableList(list);
    }

    /**
     * Retrieves a filtered view of attributes that are HTML5 custom data attributes; that is, attributes with keys
     * starting with {@code data-}.
     * @return map of custom data attributes.
     */
    public Map<String, String> dataset() {
        return new Dataset(this);
    }

    /**
     Get the HTML representation of these attributes.
     @return HTML
     */
    public String html() {
        StringBuilder sb = StringUtil.borrowBuilder();
        try {
            html(sb, (new Document("""")).outputSettings()); // output settings a bit funky, but this html() seldom used
        } catch (IOException e) { // ought never happen
            throw new SerializationException(e);
        }
        return StringUtil.releaseBuilder(sb);
    }

    final void html(final Appendable accum, final Document.OutputSettings out) throws IOException {
        final int sz = size;
        for (int i = 0; i < sz; i++) {
            if (isInternalKey(keys[i]))
                continue;
            final String key = Attribute.getValidKey(keys[i], out.syntax());
            if (key != null)
                Attribute.htmlNoValidate(key, (String) vals[i], accum.append(' '), out);
        }
    }

    @Override
    public String toString() {
        return html();
    }

    /**
     * Checks if these attributes are equal to another set of attributes, by comparing the two sets. Note that the order
     * of the attributes does not impact this equality (as per the Map interface equals()).
     * @param o attributes to compare with
     * @return if both sets of attributes have the same content
     */
    @Override
    public boolean equals(@Nullable Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;

        Attributes that = (Attributes) o;
        if (size != that.size) return false;
        for (int i = 0; i < size; i++) {
            String key = keys[i];
            int thatI = that.indexOfKey(key);
            if (thatI == NotFound)
                return false;
            Object val = vals[i];
            Object thatVal = that.vals[thatI];
            if (val == null) {
                if (thatVal != null)
                    return false;
            } else if (!val.equals(thatVal))
                return false;
        }
        return true;
    }

    /**
     * Calculates the hashcode of these attributes, by iterating all attributes and summing their hashcodes.
     * @return calculated hashcode
     */
    @Override
    public int hashCode() {
        int result = size;
        result = 31 * result + Arrays.hashCode(keys);
        result = 31 * result + Arrays.hashCode(vals);
        return result;
    }

    @Override
    public Attributes clone() {
        Attributes clone;
        try {
            clone = (Attributes) super.clone();
        } catch (CloneNotSupportedException e) {
            throw new RuntimeException(e);
        }
        clone.size = size;
        clone.keys = Arrays.copyOf(keys, size);
        clone.vals = Arrays.copyOf(vals, size);
        return clone;
    }

    /**
     * Internal method. Lowercases all keys.
     */
    public void normalize() {
        for (int i = 0; i < size; i++) {
            keys[i] = lowerCase(keys[i]);
        }
    }

    /**
     * Internal method. Removes duplicate attribute by name. Settings for case sensitivity of key names.
     * @param settings case sensitivity
     * @return number of removed dupes
     */
    public int deduplicate(ParseSettings settings) {
        if (isEmpty())
            return 0;
        boolean preserve = settings.preserveAttributeCase();
        int dupes = 0;
        OUTER: for (int i = 0; i < keys.length; i++) {
            for (int j = i + 1; j < keys.length; j++) {
                if (keys[j] == null)
                    continue OUTER; // keys.length doesn't shrink when removing, so re-test
                if ((preserve && keys[i].equals(keys[j])) || (!preserve && keys[i].equalsIgnoreCase(keys[j]))) {
                    dupes++;
                    remove(j);
                    j--;
                }
            }
        }
        return dupes;
    }

    private static class Dataset extends AbstractMap<String, String> {
        private final Attributes attributes;

        private Dataset(Attributes attributes) {
            this.attributes = attributes;
        }

        @Override
        public Set<Entry<String, String>> entrySet() {
            return new EntrySet();
        }

        @Override
        public String put(String key, String value) {
            String dataKey = dataKey(key);
            String oldValue = attributes.hasKey(dataKey) ? attributes.get(dataKey) : null;
            attributes.put(dataKey, value);
            return oldValue;
        }

        private class EntrySet extends AbstractSet<Map.Entry<String, String>> {

            @Override
            public Iterator<Map.Entry<String, String>> iterator() {
                return new DatasetIterator();
            }

            @Override
            public int size() {
                int count = 0;
                Iterator iter = new DatasetIterator();
                while (iter.hasNext())
                    count++;
                return count;
            }
        }

        private class DatasetIterator implements Iterator<Map.Entry<String, String>> {
            private Iterator<Attribute> attrIter = attributes.iterator();
            private Attribute attr;
            public boolean hasNext() {
                while (attrIter.hasNext()) {
                    attr = attrIter.next();
                    if (attr.isDataAttribute()) return true;
                }
                return false;
            }

            public Entry<String, String> next() {
                return new Attribute(attr.getKey().substring(dataPrefix.length()), attr.getValue());
            }

            public void remove() {
                attributes.remove(attr.getKey());
            }
        }
    }

    private static String dataKey(String key) {
        return dataPrefix + key;
    }

    static String internalKey(String key) {
        return InternalPrefix + key;
    }

    private boolean isInternalKey(String key) {
        return key != null && key.length() > 1 && key.charAt(0) == InternalPrefix;
    }
}
"
jhy/jsoup,src/test/java/org/jsoup/integration/ParseTest.java,"package org.jsoup.integration;

import org.jsoup.Jsoup;
import org.jsoup.helper.DataUtil;
import org.jsoup.nodes.Document;
import org.jsoup.nodes.Element;
import org.jsoup.parser.ParseErrorList;
import org.jsoup.parser.Parser;
import org.jsoup.select.Elements;
import org.junit.jupiter.api.Test;

import java.io.*;
import java.net.URISyntaxException;
import java.net.URL;
import java.nio.ByteBuffer;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.util.zip.GZIPInputStream;

import static org.junit.jupiter.api.Assertions.*;

/**
 * Integration test: parses from real-world example HTML.
 *
 * @author Jonathan Hedley, jonathan@hedley.net
 */
public class ParseTest {

    @Test
    public void testSmhBizArticle() throws IOException {
        File in = getFile(""/htmltests/smh-biz-article-1.html.gz"");
        Document doc = Jsoup.parse(in, ""UTF-8"",
                ""http://www.smh.com.au/business/the-boards-next-fear-the-female-quota-20100106-lteq.html"");
        assertEquals(""The board‚Äôs next fear: the female quota"",
                doc.title()); // note that the apos in the source is a literal ‚Äô (8217), not escaped or '
        assertEquals(""en"", doc.select(""html"").attr(""xml:lang""));

        Elements articleBody = doc.select("".articleBody > *"");
        assertEquals(17, articleBody.size());
        // todo: more tests!

    }

    @Test
    public void testNewsHomepage() throws IOException {
        File in = getFile(""/htmltests/news-com-au-home.html.gz"");
        Document doc = Jsoup.parse(in, ""UTF-8"", ""http://www.news.com.au/"");
        assertEquals(""News.com.au | News from Australia and around the world online | NewsComAu"", doc.title());
        assertEquals(""Brace yourself for Metro meltdown"", doc.select("".id1225817868581 h4"").text().trim());

        Element a = doc.select(""a[href=/entertainment/horoscopes]"").first();
        assertEquals(""/entertainment/horoscopes"", a.attr(""href""));
        assertEquals(""http://www.news.com.au/entertainment/horoscopes"", a.attr(""abs:href""));

        Element hs = doc.select(""a[href*=naughty-corners-are-a-bad-idea]"").first();
        assertEquals(
                ""http://www.heraldsun.com.au/news/naughty-corners-are-a-bad-idea-for-kids/story-e6frf7jo-1225817899003"",
                hs.attr(""href""));
        assertEquals(hs.attr(""href""), hs.attr(""abs:href""));
    }

    @Test
    public void testGoogleSearchIpod() throws IOException {
        File in = getFile(""/htmltests/google-ipod.html.gz"");
        Document doc = Jsoup.parse(in, ""UTF-8"", ""http://www.google.com/search?hl=en&q=ipod&aq=f&oq=&aqi=g10"");
        assertEquals(""ipod - Google Search"", doc.title());
        Elements results = doc.select(""h3.r > a"");
        assertEquals(12, results.size());
        assertEquals(
                ""http://news.google.com/news?hl=en&q=ipod&um=1&ie=UTF-8&ei=uYlKS4SbBoGg6gPf-5XXCw&sa=X&oi=news_group&ct=title&resnum=1&ved=0CCIQsQQwAA"",
                results.get(0).attr(""href""));
        assertEquals(""http://www.apple.com/itunes/"",
                results.get(1).attr(""href""));
    }

    @Test
    public void testYahooJp() throws IOException {
        File in = getFile(""/htmltests/yahoo-jp.html.gz"");
        Document doc = Jsoup.parse(in, ""UTF-8"", ""http://www.yahoo.co.jp/index.html""); // http charset is utf-8.
        assertEquals(""Yahoo! JAPAN"", doc.title());
        Element a = doc.select(""a[href=t/2322m2]"").first();
        assertEquals(""http://www.yahoo.co.jp/_ylh=X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2"",
                a.attr(""abs:href"")); // session put into <base>
        assertEquals(""ÂÖ®ÂõΩ„ÄÅ‰∫∫Ê∞ó„ÅÆÈßÖ„É©„É≥„Ç≠„É≥„Ç∞"", a.text());
    }

    @Test
    public void testBaidu() throws IOException {
        // tests <meta http-equiv=""Content-Type"" content=""text/html;charset=gb2312"">
        File in = getFile(""/htmltests/baidu-cn-home.html"");
        Document doc = Jsoup.parse(in, null,
                ""http://www.baidu.com/""); // http charset is gb2312, but NOT specifying it, to test http-equiv parse
        Element submit = doc.select(""#su"").first();
        assertEquals(""ÁôæÂ∫¶‰∏Ä‰∏ã"", submit.attr(""value""));

        // test from attribute match
        submit = doc.select(""input[value=ÁôæÂ∫¶‰∏Ä‰∏ã]"").first();
        assertEquals(""su"", submit.id());
        Element newsLink = doc.select(""a:contains(Êñ∞)"").first();
        assertEquals(""http://news.baidu.com"", newsLink.absUrl(""href""));

        // check auto-detect from meta
        assertEquals(""GB2312"", doc.outputSettings().charset().displayName());
        assertEquals(""<title>ÁôæÂ∫¶‰∏Ä‰∏ãÔºå‰Ω†Â∞±Áü•ÈÅì      </title>"", doc.select(""title"").outerHtml());

        doc.outputSettings().charset(""ascii"");
        assertEquals(""<title>&#x767e;&#x5ea6;&#x4e00;&#x4e0b;&#xff0c;&#x4f60;&#x5c31;&#x77e5;&#x9053;      </title>"",
                doc.select(""title"").outerHtml());
    }

    @Test
    public void testBaiduVariant() throws IOException {
        // tests <meta charset> when preceded by another <meta>
        File in = getFile(""/htmltests/baidu-variant.html"");
        Document doc = Jsoup.parse(in, null,
                ""http://www.baidu.com/""); // http charset is gb2312, but NOT specifying it, to test http-equiv parse
        // check auto-detect from meta
        assertEquals(""GB2312"", doc.outputSettings().charset().displayName());
        assertEquals(""<title>ÁôæÂ∫¶‰∏Ä‰∏ãÔºå‰Ω†Â∞±Áü•ÈÅì</title>"", doc.select(""title"").outerHtml());
    }

    @Test
    public void testHtml5Charset() throws IOException {
        // test that <meta charset=""gb2312""> works
        File in = getFile(""/htmltests/meta-charset-1.html"");
        Document doc = Jsoup.parse(in, null, ""http://example.com/""); //gb2312, has html5 <meta charset>
        assertEquals(""Êñ∞"", doc.text());
        assertEquals(""GB2312"", doc.outputSettings().charset().displayName());

        // double check, no charset, falls back to utf8 which is incorrect
        in = getFile(""/htmltests/meta-charset-2.html""); //
        doc = Jsoup.parse(in, null, ""http://example.com""); // gb2312, no charset
        assertEquals(""UTF-8"", doc.outputSettings().charset().displayName());
        assertNotEquals(""Êñ∞"", doc.text());

        // confirm fallback to utf8
        in = getFile(""/htmltests/meta-charset-3.html"");
        doc = Jsoup.parse(in, null, ""http://example.com/""); // utf8, no charset
        assertEquals(""UTF-8"", doc.outputSettings().charset().displayName());
        assertEquals(""Êñ∞"", doc.text());
    }

    @Test
    public void testBrokenHtml5CharsetWithASingleDoubleQuote() throws IOException {
        InputStream in = inputStreamFrom(""<html>\n"" +
                ""<head><meta charset=UTF-8\""></head>\n"" +
                ""<body></body>\n"" +
                ""</html>"");
        Document doc = Jsoup.parse(in, null, ""http://example.com/"");
        assertEquals(""UTF-8"", doc.outputSettings().charset().displayName());
    }

    @Test
    public void testNytArticle() throws IOException {
        // has tags like <nyt_text>
        File in = getFile(""/htmltests/nyt-article-1.html.gz"");
        Document doc = Jsoup.parse(in, null, ""http://www.nytimes.com/2010/07/26/business/global/26bp.html?hp"");

        Element headline = doc.select(""nyt_headline[version=1.0]"").first();
        assertEquals(""As BP Lays Out Future, It Will Not Include Hayward"", headline.text());
    }

    @Test
    public void testYahooArticle() throws IOException {
        File in = getFile(""/htmltests/yahoo-article-1.html.gz"");
        Document doc = Jsoup.parse(in, ""UTF-8"", ""http://news.yahoo.com/s/nm/20100831/bs_nm/us_gm_china"");
        Element p = doc.select(""p:contains(Volt will be sold in the United States)"").first();
        assertEquals(""In July, GM said its electric Chevrolet Volt will be sold in the United States at $41,000 -- $8,000 more than its nearest competitor, the Nissan Leaf."", p.text());
    }

    @Test
    public void testLowercaseUtf8Charset() throws IOException {
        File in = getFile(""/htmltests/lowercase-charset-test.html"");
        Document doc = Jsoup.parse(in, null);

        Element form = doc.select(""#form"").first();
        assertEquals(2, form.children().size());
        assertEquals(""UTF-8"", doc.outputSettings().charset().name());
    }

    @Test
    public void testXwiki() throws IOException {
        // https://github.com/jhy/jsoup/issues/1324
        // this tests that when in CharacterReader we hit a buffer while marked, we preserve the mark when buffered up and can rewind
        File in = getFile(""/htmltests/xwiki-1324.html.gz"");
        Document doc = Jsoup.parse(in, null, ""https://localhost/"");
        assertEquals(""XWiki Jetty HSQLDB 12.1-SNAPSHOT"", doc.select(""#xwikiplatformversion"").text());

        // was getting busted at =userdirectory, because it hit the bufferup point but the mark was then lost. so
        // updated to preserve the mark.
        String wantHtml = ""<a class=\""list-group-item\"" data-id=\""userdirectory\"" href=\""/xwiki/bin/admin/XWiki/XWikiPreferences?editor=globaladmin&amp;section=userdirectory\"" title=\""Customize the user directory live table.\"">User Directory</a>"";
        assertEquals(wantHtml, doc.select(""[data-id=userdirectory]"").outerHtml());
    }

    @Test
    public void testXwikiExpanded() throws IOException {
        // https://github.com/jhy/jsoup/issues/1324
        // this tests that if there is a huge illegal character reference, we can get through a buffer and rewind, and still catch that it's an invalid refence,
        // and the parse tree is correct.
        File in = getFile(""/htmltests/xwiki-edit.html.gz"");
        Parser parser = Parser.htmlParser();
        Document doc = Jsoup.parse(new GZIPInputStream(new FileInputStream(in)), ""UTF-8"", ""https://localhost/"", parser.setTrackErrors(100));
        ParseErrorList errors = parser.getErrors();

        assertEquals(""XWiki Jetty HSQLDB 12.1-SNAPSHOT"", doc.select(""#xwikiplatformversion"").text());
        assertEquals(0, errors.size()); // not an invalid reference because did not look legit

        // was getting busted at =userdirectory, because it hit the bufferup point but the mark was then lost. so
        // updated to preserve the mark.
        String wantHtml = ""<a class=\""list-group-item\"" data-id=\""userdirectory\"" href=\""/xwiki/bin/admin/XWiki/XWikiPreferences?editor=globaladmin&amp;RIGHTHERERIGHTHERERIGHTHERERIGHTHERE"";
        assertTrue(doc.select(""[data-id=userdirectory]"").outerHtml().startsWith(wantHtml));
    }

    @Test public void testWikiExpandedFromString() throws IOException {
        File in = getFile(""/htmltests/xwiki-edit.html.gz"");
        String html = getFileAsString(in);
        Document doc = Jsoup.parse(html);
        assertEquals(""XWiki Jetty HSQLDB 12.1-SNAPSHOT"", doc.select(""#xwikiplatformversion"").text());
        String wantHtml = ""<a class=\""list-group-item\"" data-id=\""userdirectory\"" href=\""/xwiki/bin/admin/XWiki/XWikiPreferences?editor=globaladmin&amp;RIGHTHERERIGHTHERERIGHTHERERIGHTHERE"";
        assertTrue(doc.select(""[data-id=userdirectory]"").outerHtml().startsWith(wantHtml));
    }

    @Test public void testWikiFromString() throws IOException {
        File in = getFile(""/htmltests/xwiki-1324.html.gz"");
        String html = getFileAsString(in);
        Document doc = Jsoup.parse(html);
        assertEquals(""XWiki Jetty HSQLDB 12.1-SNAPSHOT"", doc.select(""#xwikiplatformversion"").text());
        String wantHtml = ""<a class=\""list-group-item\"" data-id=\""userdirectory\"" href=\""/xwiki/bin/admin/XWiki/XWikiPreferences?editor=globaladmin&amp;section=userdirectory\"" title=\""Customize the user directory live table.\"">User Directory</a>"";
        assertEquals(wantHtml, doc.select(""[data-id=userdirectory]"").outerHtml());
    }

    @Test public void testFileParseNoCharsetMethod() throws IOException {
        File in = getFile(""/htmltests/xwiki-1324.html.gz"");
        Document doc = Jsoup.parse(in);
        assertEquals(""XWiki Jetty HSQLDB 12.1-SNAPSHOT"", doc.select(""#xwikiplatformversion"").text());
    }


    public static File getFile(String resourceName) {
        try {
            URL resource = ParseTest.class.getResource(resourceName);
            return resource != null ? new File(resource.toURI()) : new File(""/404"");
        } catch (URISyntaxException e) {
            throw new IllegalStateException(e);
        }
    }

    public static InputStream inputStreamFrom(String s) {
        return new ByteArrayInputStream(s.getBytes(StandardCharsets.UTF_8));
    }

    public static String getFileAsString(File file) throws IOException {
        byte[] bytes;
        if (file.getName().endsWith("".gz"")) {
            InputStream stream = new GZIPInputStream(new FileInputStream(file));
            ByteBuffer byteBuffer = DataUtil.readToByteBuffer(stream, 0);
            bytes = byteBuffer.array();
        } else {
            bytes = Files.readAllBytes(file.toPath());
        }
        return new String(bytes);
    }

}
"
jhy/jsoup,src/main/java/org/jsoup/select/package-info.java,"/**
 Packages to support the CSS-style element selector.
 {@link org.jsoup.select.Selector Selector defines the query syntax.}
 */
@NonnullByDefault
package org.jsoup.select;

import org.jsoup.internal.NonnullByDefault;
"
jhy/jsoup,src/main/java/org/jsoup/nodes/Comment.java,"package org.jsoup.nodes;

import org.jsoup.parser.ParseSettings;
import org.jsoup.parser.Parser;

import javax.annotation.Nullable;
import java.io.IOException;

/**
 A comment node.

 @author Jonathan Hedley, jonathan@hedley.net */
public class Comment extends LeafNode {
    /**
     Create a new comment node.
     @param data The contents of the comment
     */
    public Comment(String data) {
        value = data;
    }

    public String nodeName() {
        return ""#comment"";
    }

    /**
     Get the contents of the comment.
     @return comment content
     */
    public String getData() {
        return coreValue();
    }

    public Comment setData(String data) {
        coreValue(data);
        return this;
    }

	void outerHtmlHead(Appendable accum, int depth, Document.OutputSettings out) throws IOException {
        if (out.prettyPrint() && ((siblingIndex() == 0 && parentNode instanceof Element && ((Element) parentNode).tag().formatAsBlock()) || (out.outline() )))
            indent(accum, depth, out);
        accum
                .append(""<!--"")
                .append(getData())
                .append(""-->"");
    }

	void outerHtmlTail(Appendable accum, int depth, Document.OutputSettings out) {}

    @Override
    public String toString() {
        return outerHtml();
    }

    @Override
    public Comment clone() {
        return (Comment) super.clone();
    }

    /**
     * Check if this comment looks like an XML Declaration.
     * @return true if it looks like, maybe, it's an XML Declaration.
     */
    public boolean isXmlDeclaration() {
        String data = getData();
        return isXmlDeclarationData(data);
    }

    private static boolean isXmlDeclarationData(String data) {
        return (data.length() > 1 && (data.startsWith(""!"") || data.startsWith(""?"")));
    }

    /**
     * Attempt to cast this comment to an XML Declaration node.
     * @return an XML declaration if it could be parsed as one, null otherwise.
     */
    public @Nullable XmlDeclaration asXmlDeclaration() {
        String data = getData();

        XmlDeclaration decl = null;
        String declContent = data.substring(1, data.length() - 1);
        // make sure this bogus comment is not immediately followed by another, treat as comment if so
        if (isXmlDeclarationData(declContent))
            return null;

        String fragment = ""<"" + declContent + "">"";
        // use the HTML parser not XML, so we don't get into a recursive XML Declaration on contrived data
        Document doc = Parser.htmlParser().settings(ParseSettings.preserveCase).parseInput(fragment, baseUri());
        if (doc.body().children().size() > 0) {
            Element el = doc.body().child(0);
            decl = new XmlDeclaration(NodeUtils.parser(doc).settings().normalizeTag(el.tagName()), data.startsWith(""!""));
            decl.attributes().addAll(el.attributes());
        }
        return decl;
    }
}
"
jhy/jsoup,src/main/java/org/jsoup/parser/TokenQueue.java,"package org.jsoup.parser;

import org.jsoup.internal.StringUtil;
import org.jsoup.helper.Validate;

/**
 * A character queue with parsing helpers.
 *
 * @author Jonathan Hedley
 */
public class TokenQueue {
    private String queue;
    private int pos = 0;
    
    private static final char ESC = '\\'; // escape char for chomp balanced.

    /**
     Create a new TokenQueue.
     @param data string of data to back queue.
     */
    public TokenQueue(String data) {
        Validate.notNull(data);
        queue = data;
    }

    /**
     * Is the queue empty?
     * @return true if no data left in queue.
     */
    public boolean isEmpty() {
        return remainingLength() == 0;
    }
    
    private int remainingLength() {
        return queue.length() - pos;
    }

    /**
     Add a string to the start of the queue.
     @param seq string to add.
     */
    public void addFirst(String seq) {
        // not very performant, but an edge case
        queue = seq + queue.substring(pos);
        pos = 0;
    }

    /**
     * Tests if the next characters on the queue match the sequence. Case insensitive.
     * @param seq String to check queue for.
     * @return true if the next characters match.
     */
    public boolean matches(String seq) {
        return queue.regionMatches(true, pos, seq, 0, seq.length());
    }

    /**
     Tests if the next characters match any of the sequences. Case insensitive.
     @param seq list of strings to case insensitively check for
     @return true of any matched, false if none did
     */
    public boolean matchesAny(String... seq) {
        for (String s : seq) {
            if (matches(s))
                return true;
        }
        return false;
    }

    public boolean matchesAny(char... seq) {
        if (isEmpty())
            return false;

        for (char c: seq) {
            if (queue.charAt(pos) == c)
                return true;
        }
        return false;
    }

    /**
     * Tests if the queue matches the sequence (as with match), and if they do, removes the matched string from the
     * queue.
     * @param seq String to search for, and if found, remove from queue.
     * @return true if found and removed, false if not found.
     */
    public boolean matchChomp(String seq) {
        if (matches(seq)) {
            pos += seq.length();
            return true;
        } else {
            return false;
        }
    }

    /**
     Tests if queue starts with a whitespace character.
     @return if starts with whitespace
     */
    public boolean matchesWhitespace() {
        return !isEmpty() && StringUtil.isWhitespace(queue.charAt(pos));
    }

    /**
     Test if the queue matches a word character (letter or digit).
     @return if matches a word character
     */
    public boolean matchesWord() {
        return !isEmpty() && Character.isLetterOrDigit(queue.charAt(pos));
    }

    /**
     * Drops the next character off the queue.
     */
    public void advance() {
        if (!isEmpty()) pos++;
    }

    /**
     * Consume one character off queue.
     * @return first character on queue.
     */
    public char consume() {
        return queue.charAt(pos++);
    }

    /**
     * Consumes the supplied sequence of the queue. If the queue does not start with the supplied sequence, will
     * throw an illegal state exception -- but you should be running match() against that condition.
     <p>
     Case insensitive.
     * @param seq sequence to remove from head of queue.
     */
    public void consume(String seq) {
        if (!matches(seq))
            throw new IllegalStateException(""Queue did not match expected sequence"");
        int len = seq.length();
        if (len > remainingLength())
            throw new IllegalStateException(""Queue not long enough to consume sequence"");
        
        pos += len;
    }

    /**
     * Pulls a string off the queue, up to but exclusive of the match sequence, or to the queue running out.
     * @param seq String to end on (and not include in return, but leave on queue). <b>Case sensitive.</b>
     * @return The matched data consumed from queue.
     */
    public String consumeTo(String seq) {
        int offset = queue.indexOf(seq, pos);
        if (offset != -1) {
            String consumed = queue.substring(pos, offset);
            pos += consumed.length();
            return consumed;
        } else {
            return remainder();
        }
    }
    
    public String consumeToIgnoreCase(String seq) {
        int start = pos;
        String first = seq.substring(0, 1);
        boolean canScan = first.toLowerCase().equals(first.toUpperCase()); // if first is not cased, use index of
        while (!isEmpty()) {
            if (matches(seq))
                break;
            
            if (canScan) {
                int skip = queue.indexOf(first, pos) - pos;
                if (skip == 0) // this char is the skip char, but not match, so force advance of pos
                    pos++;
                else if (skip < 0) // no chance of finding, grab to end
                    pos = queue.length();
                else
                    pos += skip;
            }
            else
                pos++;
        }

        return queue.substring(start, pos);
    }

    /**
     Consumes to the first sequence provided, or to the end of the queue. Leaves the terminator on the queue.
     @param seq any number of terminators to consume to. <b>Case insensitive.</b>
     @return consumed string   
     */
    // todo: method name. not good that consumeTo cares for case, and consume to any doesn't. And the only use for this
    // is a case sensitive time...
    public String consumeToAny(String... seq) {
        int start = pos;
        while (!isEmpty() && !matchesAny(seq)) {
            pos++;
        }

        return queue.substring(start, pos);
    }

    /**
     * Pulls a string off the queue (like consumeTo), and then pulls off the matched string (but does not return it).
     * <p>
     * If the queue runs out of characters before finding the seq, will return as much as it can (and queue will go
     * isEmpty() == true).
     * @param seq String to match up to, and not include in return, and to pull off queue. <b>Case sensitive.</b>
     * @return Data matched from queue.
     */
    public String chompTo(String seq) {
        String data = consumeTo(seq);
        matchChomp(seq);
        return data;
    }
    
    public String chompToIgnoreCase(String seq) {
        String data = consumeToIgnoreCase(seq); // case insensitive scan
        matchChomp(seq);
        return data;
    }

    /**
     * Pulls a balanced string off the queue. E.g. if queue is ""(one (two) three) four"", (,) will return ""one (two) three"",
     * and leave "" four"" on the queue. Unbalanced openers and closers can be quoted (with ' or "") or escaped (with \). Those escapes will be left
     * in the returned string, which is suitable for regexes (where we need to preserve the escape), but unsuitable for
     * contains text strings; use unescape for that.
     * @param open opener
     * @param close closer
     * @return data matched from the queue
     */
    public String chompBalanced(char open, char close) {
        int start = -1;
        int end = -1;
        int depth = 0;
        char last = 0;
        boolean inSingleQuote = false;
        boolean inDoubleQuote = false;
        boolean inRegexQE = false; // regex \Q .. \E escapes from Pattern.quote()

        do {
            if (isEmpty()) break;
            char c = consume();
            if (last != ESC) {
                if (c == '\'' && c != open && !inDoubleQuote)
                    inSingleQuote = !inSingleQuote;
                else if (c == '""' && c != open && !inSingleQuote)
                    inDoubleQuote = !inDoubleQuote;
                if (inSingleQuote || inDoubleQuote || inRegexQE){
                    last = c;
                    continue;
                }

                if (c == open) {
                    depth++;
                    if (start == -1)
                        start = pos;
                }
                else if (c == close)
                    depth--;
            } else if (c == 'Q') {
                inRegexQE = true;
            } else if (c == 'E') {
                inRegexQE = false;
            }

            if (depth > 0 && last != 0)
                end = pos; // don't include the outer match pair in the return
            last = c;
        } while (depth > 0);
        final String out = (end >= 0) ? queue.substring(start, end) : """";
        if (depth > 0) {// ran out of queue before seeing enough )
            Validate.fail(""Did not find balanced marker at '"" + out + ""'"");
        }
        return out;
    }
    
    /**
     * Unescape a \ escaped string.
     * @param in backslash escaped string
     * @return unescaped string
     */
    public static String unescape(String in) {
        StringBuilder out = StringUtil.borrowBuilder();
        char last = 0;
        for (char c : in.toCharArray()) {
            if (c == ESC) {
                if (last == ESC)
                    out.append(c);
            }
            else 
                out.append(c);
            last = c;
        }
        return StringUtil.releaseBuilder(out);
    }

    /**
     * Pulls the next run of whitespace characters of the queue.
     * @return Whether consuming whitespace or not
     */
    public boolean consumeWhitespace() {
        boolean seen = false;
        while (matchesWhitespace()) {
            pos++;
            seen = true;
        }
        return seen;
    }

    /**
     * Retrieves the next run of word type (letter or digit) off the queue.
     * @return String of word characters from queue, or empty string if none.
     */
    public String consumeWord() {
        int start = pos;
        while (matchesWord())
            pos++;
        return queue.substring(start, pos);
    }

    
    /**
     * Consume a CSS element selector (tag name, but | instead of : for namespaces (or *| for wildcard namespace), to not conflict with :pseudo selects).
     * 
     * @return tag name
     */
    public String consumeElementSelector() {
        int start = pos;
        while (!isEmpty() && (matchesWord() || matchesAny(""*|"",""|"", ""_"", ""-"")))
            pos++;
        
        return queue.substring(start, pos);
    }

    /**
     Consume a CSS identifier (ID or class) off the queue (letter, digit, -, _)
     http://www.w3.org/TR/CSS2/syndata.html#value-def-identifier
     @return identifier
     */
    public String consumeCssIdentifier() {
        int start = pos;
        while (!isEmpty() && (matchesWord() || matchesAny('-', '_')))
            pos++;

        return queue.substring(start, pos);
    }

    /**
     Consume and return whatever is left on the queue.
     @return remained of queue.
     */
    public String remainder() {
        final String remainder = queue.substring(pos);
        pos = queue.length();
        return remainder;
    }
    
    @Override
    public String toString() {
        return queue.substring(pos);
    }
}
"
jhy/jsoup,src/main/java/org/jsoup/select/Selector.java,"package org.jsoup.select;

import org.jsoup.helper.Validate;
import org.jsoup.nodes.Element;

import javax.annotation.Nullable;
import java.util.ArrayList;
import java.util.Collection;
import java.util.IdentityHashMap;

/**
 * CSS-like element selector, that finds elements matching a query.
 *
 * <h2>Selector syntax</h2>
 * <p>
 * A selector is a chain of simple selectors, separated by combinators. Selectors are <b>case insensitive</b> (including against
 * elements, attributes, and attribute values).
 * </p>
 * <p>
 * The universal selector (*) is implicit when no element selector is supplied (i.e. {@code *.header} and {@code .header}
 * is equivalent).
 * </p>
 * <style>table.syntax tr td {vertical-align: top; padding-right: 2em; padding-top:0.5em; padding-bottom:0.5em; } table.syntax tr:hover{background-color: #eee;} table.syntax {border-spacing: 0px 0px;}</style>
 * <table summary="""" class=""syntax""><colgroup><col span=""1"" style=""width: 20%;""><col span=""1"" style=""width: 40%;""><col span=""1"" style=""width: 40%;""></colgroup>
 * <tr><th align=""left"">Pattern</th><th align=""left"">Matches</th><th align=""left"">Example</th></tr>
 * <tr><td><code>*</code></td><td>any element</td><td><code>*</code></td></tr>
 * <tr><td><code>tag</code></td><td>elements with the given tag name</td><td><code>div</code></td></tr>
 * <tr><td><code>*|E</code></td><td>elements of type E in any namespace (including non-namespaced)</td><td><code>*|name</code> finds <code>&lt;fb:name&gt;</code> and <code>&lt;name&gt;</code> elements</td></tr>
 * <tr><td><code>ns|E</code></td><td>elements of type E in the namespace <i>ns</i></td><td><code>fb|name</code> finds <code>&lt;fb:name&gt;</code> elements</td></tr>
 * <tr><td><code>#id</code></td><td>elements with attribute ID of ""id""</td><td><code>div#wrap</code>, <code>#logo</code></td></tr>
 * <tr><td><code>.class</code></td><td>elements with a class name of ""class""</td><td><code>div.left</code>, <code>.result</code></td></tr>
 * <tr><td><code>[attr]</code></td><td>elements with an attribute named ""attr"" (with any value)</td><td><code>a[href]</code>, <code>[title]</code></td></tr>
 * <tr><td><code>[^attrPrefix]</code></td><td>elements with an attribute name starting with ""attrPrefix"". Use to find elements with HTML5 datasets</td><td><code>[^data-]</code>, <code>div[^data-]</code></td></tr>
 * <tr><td><code>[attr=val]</code></td><td>elements with an attribute named ""attr"", and value equal to ""val""</td><td><code>img[width=500]</code>, <code>a[rel=nofollow]</code></td></tr>
 * <tr><td><code>[attr=&quot;val&quot;]</code></td><td>elements with an attribute named ""attr"", and value equal to ""val""</td><td><code>span[hello=""Cleveland""][goodbye=""Columbus""]</code>, <code>a[rel=&quot;nofollow&quot;]</code></td></tr>
 * <tr><td><code>[attr^=valPrefix]</code></td><td>elements with an attribute named ""attr"", and value starting with ""valPrefix""</td><td><code>a[href^=http:]</code></td></tr>
 * <tr><td><code>[attr$=valSuffix]</code></td><td>elements with an attribute named ""attr"", and value ending with ""valSuffix""</td><td><code>img[src$=.png]</code></td></tr>
 * <tr><td><code>[attr*=valContaining]</code></td><td>elements with an attribute named ""attr"", and value containing ""valContaining""</td><td><code>a[href*=/search/]</code></td></tr>
 * <tr><td><code>[attr~=<em>regex</em>]</code></td><td>elements with an attribute named ""attr"", and value matching the regular expression</td><td><code>img[src~=(?i)\\.(png|jpe?g)]</code></td></tr>
 * <tr><td></td><td>The above may be combined in any order</td><td><code>div.header[title]</code></td></tr>
 * <tr><td><td colspan=""3""><h3>Combinators</h3></td></tr>
 * <tr><td><code>E F</code></td><td>an F element descended from an E element</td><td><code>div a</code>, <code>.logo h1</code></td></tr>
 * <tr><td><code>E {@literal >} F</code></td><td>an F direct child of E</td><td><code>ol {@literal >} li</code></td></tr>
 * <tr><td><code>E + F</code></td><td>an F element immediately preceded by sibling E</td><td><code>li + li</code>, <code>div.head + div</code></td></tr>
 * <tr><td><code>E ~ F</code></td><td>an F element preceded by sibling E</td><td><code>h1 ~ p</code></td></tr>
 * <tr><td><code>E, F, G</code></td><td>all matching elements E, F, or G</td><td><code>a[href], div, h3</code></td></tr>
 * <tr><td><td colspan=""3""><h3>Pseudo selectors</h3></td></tr>
 * <tr><td><code>:lt(<em>n</em>)</code></td><td>elements whose sibling index is less than <em>n</em></td><td><code>td:lt(3)</code> finds the first 3 cells of each row</td></tr>
 * <tr><td><code>:gt(<em>n</em>)</code></td><td>elements whose sibling index is greater than <em>n</em></td><td><code>td:gt(1)</code> finds cells after skipping the first two</td></tr>
 * <tr><td><code>:eq(<em>n</em>)</code></td><td>elements whose sibling index is equal to <em>n</em></td><td><code>td:eq(0)</code> finds the first cell of each row</td></tr>
 * <tr><td><code>:has(<em>selector</em>)</code></td><td>elements that contains at least one element matching the <em>selector</em></td><td><code>div:has(p)</code> finds <code>div</code>s that contain <code>p</code> elements.<br><code>div:has(&gt; a)</code> selects <code>div</code> elements that have at least one direct child <code>a</code> element.</td></tr>
 * <tr><td><code>:not(<em>selector</em>)</code></td><td>elements that do not match the <em>selector</em>. See also {@link Elements#not(String)}</td><td><code>div:not(.logo)</code> finds all divs that do not have the ""logo"" class.<p><code>div:not(:has(div))</code> finds divs that do not contain divs.</p></td></tr>
 * <tr><td><code>:contains(<em>text</em>)</code></td><td>elements that contains the specified text. The search is case insensitive. The text may appear in the found element, or any of its descendants. The text is whitespace normalized. <p>To find content that includes parentheses, escape those with a {@code \}.</p></td><td><code>p:contains(jsoup)</code> finds p elements containing the text ""jsoup"".<p>{@code p:contains(hello \(there\) finds p elements containing the text ""Hello (There)""}</p></td></tr>
 * <tr><td><code>:containsOwn(<em>text</em>)</code></td><td>elements that directly contain the specified text. The search is case insensitive. The text must appear in the found element, not any of its descendants.</td><td><code>p:containsOwn(jsoup)</code> finds p elements with own text ""jsoup"".</td></tr>
 * <tr><td><code>:containsData(<em>data</em>)</code></td><td>elements that contains the specified <em>data</em>. The contents of {@code script} and {@code style} elements, and {@code comment} nodes (etc) are considered data nodes, not text nodes. The search is case insensitive. The data may appear in the found element, or any of its descendants.</td><td><code>script:contains(jsoup)</code> finds script elements containing the data ""jsoup"".</td></tr>
 * <tr><td><code>:containsWholeText(<em>text</em>)</code></td><td>elements that contains the specified <b>non-normalized</b> text. The search is case sensitive, and will match exactly against spaces and newlines found in the original input. The text may appear in the found element, or any of its descendants. <p>To find content that includes parentheses, escape those with a {@code \}.</p></td><td><code>p:containsWholeText(jsoup\nThe Java HTML Parser)</code> finds p elements containing the text <code>""jsoup\nThe Java HTML Parser""</code> (and not other variations of whitespace or casing, as <code>:contains()</code> would. Note that {@code br} elements are presented as a newline.</p></td></tr>
 * <tr><td><code>:containsWholeOwnText(<em>text</em>)</code></td><td>elements that <b>directly</b> contain the specified <b>non-normalized</b> text. The search is case sensitive, and will match exactly against spaces and newlines found in the original input. The text may appear in the found element, but not in its descendants. <p>To find content that includes parentheses, escape those with a {@code \}.</p></td><td><code>p:containsWholeOwnText(jsoup\nThe Java HTML Parser)</code> finds p elements directly containing the text <code>""jsoup\nThe Java HTML Parser""</code> (and not other variations of whitespace or casing, as <code>:contains()</code> would. Note that {@code br} elements are presented as a newline.</p></td></tr>
 * <tr><td><code>:matches(<em>regex</em>)</code></td><td>elements containing <b>whitespace normalized</b> text that matches the specified regular expression. The text may appear in the found element, or any of its descendants.</td><td><code>td:matches(\\d+)</code> finds table cells containing digits. <code>div:matches((?i)login)</code> finds divs containing the text, case insensitively.</td></tr>
 * <tr><td><code>:matchesWholeText(<em>regex</em>)</code></td><td>elements containing <b>non-normalized</b> whole text that matches the specified regular expression. The text may appear in the found element, or any of its descendants.</td><td><code>td:matchesWholeText(\\s{2,})</code> finds table cells a run of at least two space characters.</td></tr>
 * <tr><td><code>:matchesWholeOwnText(<em>regex</em>)</code></td><td>elements whose own <b>non-normalized</b> whole text matches the specified regular expression. The text must appear in the found element, not any of its descendants.</td><td><code>td:matchesWholeOwnText(\n\\d+)</code> finds table cells directly containing digits following a neewline.</td></tr>
 * <tr><td></td><td>The above may be combined in any order and with other selectors</td><td><code>.light:contains(name):eq(0)</code></td></tr>
 * <tr><td><code>:matchText</code></td><td>treats text nodes as elements, and so allows you to match against and select text nodes.<p><b>Note</b> that using this selector will modify the DOM, so you may want to {@code clone} your document before using.</td><td>{@code p:matchText:firstChild} with input {@code <p>One<br />Two</p>} will return one {@link org.jsoup.nodes.PseudoTextElement} with text ""{@code One}"".</td></tr>
 * <tr><td colspan=""3""><h3>Structural pseudo selectors</h3></td></tr>
 * <tr><td><code>:root</code></td><td>The element that is the root of the document. In HTML, this is the <code>html</code> element</td><td><code>:root</code></td></tr>
 * <tr><td><code>:nth-child(<em>a</em>n+<em>b</em>)</code></td><td><p>elements that have <code><em>a</em>n+<em>b</em>-1</code> siblings <b>before</b> it in the document tree, for any positive integer or zero value of <code>n</code>, and has a parent element. For values of <code>a</code> and <code>b</code> greater than zero, this effectively divides the element's children into groups of a elements (the last group taking the remainder), and selecting the <em>b</em>th element of each group. For example, this allows the selectors to address every other row in a table, and could be used to alternate the color of paragraph text in a cycle of four. The <code>a</code> and <code>b</code> values must be integers (positive, negative, or zero). The index of the first child of an element is 1.</p>
 * In addition to this, <code>:nth-child()</code> can take <code>odd</code> and <code>even</code> as arguments instead. <code>odd</code> has the same signification as <code>2n+1</code>, and <code>even</code> has the same signification as <code>2n</code>.</td><td><code>tr:nth-child(2n+1)</code> finds every odd row of a table. <code>:nth-child(10n-1)</code> the 9th, 19th, 29th, etc, element. <code>li:nth-child(5)</code> the 5h li</td></tr>
 * <tr><td><code>:nth-last-child(<em>a</em>n+<em>b</em>)</code></td><td>elements that have <code><em>a</em>n+<em>b</em>-1</code> siblings <b>after</b> it in the document tree. Otherwise like <code>:nth-child()</code></td><td><code>tr:nth-last-child(-n+2)</code> the last two rows of a table</td></tr>
 * <tr><td><code>:nth-of-type(<em>a</em>n+<em>b</em>)</code></td><td>pseudo-class notation represents an element that has <code><em>a</em>n+<em>b</em>-1</code> siblings with the same expanded element name <em>before</em> it in the document tree, for any zero or positive integer value of n, and has a parent element</td><td><code>img:nth-of-type(2n+1)</code></td></tr>
 * <tr><td><code>:nth-last-of-type(<em>a</em>n+<em>b</em>)</code></td><td>pseudo-class notation represents an element that has <code><em>a</em>n+<em>b</em>-1</code> siblings with the same expanded element name <em>after</em> it in the document tree, for any zero or positive integer value of n, and has a parent element</td><td><code>img:nth-last-of-type(2n+1)</code></td></tr>
 * <tr><td><code>:first-child</code></td><td>elements that are the first child of some other element.</td><td><code>div {@literal >} p:first-child</code></td></tr>
 * <tr><td><code>:last-child</code></td><td>elements that are the last child of some other element.</td><td><code>ol {@literal >} li:last-child</code></td></tr>
 * <tr><td><code>:first-of-type</code></td><td>elements that are the first sibling of its type in the list of children of its parent element</td><td><code>dl dt:first-of-type</code></td></tr>
 * <tr><td><code>:last-of-type</code></td><td>elements that are the last sibling of its type in the list of children of its parent element</td><td><code>tr {@literal >} td:last-of-type</code></td></tr>
 * <tr><td><code>:only-child</code></td><td>elements that have a parent element and whose parent element have no other element children</td><td></td></tr>
 * <tr><td><code>:only-of-type</code></td><td> an element that has a parent element and whose parent element has no other element children with the same expanded element name</td><td></td></tr>
 * <tr><td><code>:empty</code></td><td>elements that have no children at all</td><td></td></tr>
 * </table>
 *
 * <p>A word on using regular expressions in these selectors: depending on the content of the regex, you will need to quote the pattern using <b><code>Pattern.quote(""regex"")</code></b> for it to parse correclty through both the selector parser and the regex parser. E.g. <code>String query = ""div:matches("" + Pattern.quote(regex) + "");""</code>.</p>
 *
 * @author Jonathan Hedley, jonathan@hedley.net
 * @see Element#select(String)
 */
public class Selector {
    // not instantiable
    private Selector() {}

    /**
     * Find elements matching selector.
     *
     * @param query CSS selector
     * @param root  root element to descend into
     * @return matching elements, empty if none
     * @throws Selector.SelectorParseException (unchecked) on an invalid CSS query.
     */
    public static Elements select(String query, Element root) {
        Validate.notEmpty(query);
        return select(QueryParser.parse(query), root);
    }

    /**
     * Find elements matching selector.
     *
     * @param evaluator CSS selector
     * @param root root element to descend into
     * @return matching elements, empty if none
     */
    public static Elements select(Evaluator evaluator, Element root) {
        Validate.notNull(evaluator);
        Validate.notNull(root);
        return Collector.collect(evaluator, root);
    }

    /**
     * Find elements matching selector.
     *
     * @param query CSS selector
     * @param roots root elements to descend into
     * @return matching elements, empty if none
     */
    public static Elements select(String query, Iterable<Element> roots) {
        Validate.notEmpty(query);
        Validate.notNull(roots);
        Evaluator evaluator = QueryParser.parse(query);
        Elements elements = new Elements();
        IdentityHashMap<Element, Boolean> seenElements = new IdentityHashMap<>();
        // dedupe elements by identity, not equality

        for (Element root : roots) {
            final Elements found = select(evaluator, root);
            for (Element el : found) {
                if (seenElements.put(el, Boolean.TRUE) == null) {
                    elements.add(el);
                }
            }
        }
        return elements;
    }

    // exclude set. package open so that Elements can implement .not() selector.
    static Elements filterOut(Collection<Element> elements, Collection<Element> outs) {
        Elements output = new Elements();
        for (Element el : elements) {
            boolean found = false;
            for (Element out : outs) {
                if (el.equals(out)) {
                    found = true;
                    break;
                }
            }
            if (!found)
                output.add(el);
        }
        return output;
    }

    /**
     * Find the first element that matches the query.
     * @param cssQuery CSS selector
     * @param root root element to descend into
     * @return the matching element, or <b>null</b> if none.
     */
    public static @Nullable Element selectFirst(String cssQuery, Element root) {
        Validate.notEmpty(cssQuery);
        return Collector.findFirst(QueryParser.parse(cssQuery), root);
    }

    public static class SelectorParseException extends IllegalStateException {
        public SelectorParseException(String msg) {
            super(msg);
        }

        public SelectorParseException(String msg, Object... params) {
            super(String.format(msg, params));
        }
    }
}
"
jhy/jsoup,src/main/java/org/jsoup/helper/CookieUtil.java,"package org.jsoup.helper;

import org.jsoup.Connection;
import org.jsoup.internal.StringUtil;

import java.io.IOException;
import java.net.HttpURLConnection;
import java.net.MalformedURLException;
import java.net.URI;
import java.net.URISyntaxException;
import java.net.URL;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

/**
 Helper functions to support the Cookie Manager / Cookie Storage in HttpConnection.

 @since 1.14.1 */
class CookieUtil {
    // cookie manager get() wants request headers but doesn't use them, so we just pass a dummy object here
    private static final Map<String, List<String>> EmptyRequestHeaders = Collections.unmodifiableMap(new HashMap<>());
    private static final String Sep = ""; "";
    private static final String CookieName = ""Cookie"";
    private static final String Cookie2Name = ""Cookie2"";

    /**
     Pre-request, get any applicable headers out of the Request cookies and the Cookie Store, and add them to the request
     headers. If the Cookie Store duplicates any Request cookies (same name and value), they will be discarded.
     */
    static void applyCookiesToRequest(HttpConnection.Request req, HttpURLConnection con) throws IOException {
        // Request key/val cookies. LinkedHashSet used to preserve order, as cookie store will return most specific path first
        Set<String> cookieSet = requestCookieSet(req);
        Set<String> cookies2 = null;

        // stored:
        Map<String, List<String>> storedCookies = req.cookieManager().get(asUri(req.url), EmptyRequestHeaders);
        for (Map.Entry<String, List<String>> entry : storedCookies.entrySet()) {
            // might be Cookie: name=value; name=value\nCookie2: name=value; name=value
            List<String> cookies = entry.getValue(); // these will be name=val
            if (cookies == null || cookies.size() == 0) // the cookie store often returns just an empty ""Cookie"" key, no val
                continue;

            String key = entry.getKey(); // Cookie or Cookie2
            Set<String> set;
            if (CookieName.equals(key))
                set = cookieSet;
            else if (Cookie2Name.equals(key)) {
                set = new HashSet<>();
                cookies2 = set;
            } else {
                continue; // unexpected header key
            }
            set.addAll(cookies);
        }

        if (cookieSet.size() > 0)
            con.addRequestProperty(CookieName, StringUtil.join(cookieSet, Sep));
        if (cookies2 != null && cookies2.size() > 0)
            con.addRequestProperty(Cookie2Name, StringUtil.join(cookies2, Sep));
    }

    private static LinkedHashSet<String> requestCookieSet(Connection.Request req) {
        LinkedHashSet<String> set = new LinkedHashSet<>();
        // req cookies are the wildcard key/val cookies (no domain, path, etc)
        for (Map.Entry<String, String> cookie : req.cookies().entrySet()) {
            set.add(cookie.getKey() + ""="" + cookie.getValue());
        }
        return set;
    }

    static URI asUri(URL url) throws IOException {
        try {
            return url.toURI();
        } catch (URISyntaxException e) {  // this would be a WTF because we construct the URL
            MalformedURLException ue = new MalformedURLException(e.getMessage());
            ue.initCause(e);
            throw ue;
        }
    }

    static void storeCookies(HttpConnection.Request req, URL url, Map<String, List<String>> resHeaders) throws IOException {
        req.cookieManager().put(CookieUtil.asUri(url), resHeaders); // stores cookies for session

    }
}
"
jhy/jsoup,src/main/java/org/jsoup/nodes/PseudoTextElement.java,"package org.jsoup.nodes;

import org.jsoup.parser.Tag;

/**
 * Represents a {@link TextNode} as an {@link Element}, to enable text nodes to be selected with
 * the {@link org.jsoup.select.Selector} {@code :matchText} syntax.
 */
public class PseudoTextElement extends Element {

    public PseudoTextElement(Tag tag, String baseUri, Attributes attributes) {
        super(tag, baseUri, attributes);
    }

    @Override
    void outerHtmlHead(Appendable accum, int depth, Document.OutputSettings out) {
    }

    @Override
    void outerHtmlTail(Appendable accum, int depth, Document.OutputSettings out) {
    }
}
"
jhy/jsoup,src/test/java/org/jsoup/integration/SessionIT.java,"package org.jsoup.integration;

import org.jsoup.Connection;
import org.jsoup.Jsoup;
import org.jsoup.UncheckedIOException;
import org.jsoup.integration.servlets.FileServlet;
import org.jsoup.integration.servlets.SlowRider;
import org.jsoup.nodes.Document;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Test;

import java.io.IOException;
import java.util.concurrent.atomic.AtomicInteger;

import static org.junit.jupiter.api.Assertions.assertEquals;

/** Integration tests to test longer running Connection */
public class SessionIT {
    @BeforeAll
    public static void setUp() {
        TestServer.start();
    }

    @Test
    public void multiThread() throws InterruptedException {
        int numThreads = 20;
        int numThreadLoops = 5;
        String[] urls = {
            FileServlet.urlTo(""/htmltests/smh-biz-article-1.html.gz""),
            FileServlet.urlTo(""/htmltests/news-com-au-home.html.gz""),
            FileServlet.urlTo(""/htmltests/google-ipod.html.gz""),
            FileServlet.urlTo(""/htmltests/large.html""),
        };
        String[] titles = {
            ""The board‚Äôs next fear: the female quota"",
            ""News.com.au | News from Australia and around the world online | NewsComAu"",
            ""ipod - Google Search"",
            ""Large HTML""
        };
        ThreadCatcher catcher = new ThreadCatcher();

        Connection session = Jsoup.newSession();

        Thread[] threads = new Thread[numThreads];
        for (int threadNum = 0; threadNum < numThreads; threadNum++) {
            Thread thread = new Thread(() -> {
                for (int loop = 0; loop < numThreadLoops; loop++) {
                    for (int i = 0; i < urls.length; i++) {
                        try {
                            Document doc = session.newRequest().url(urls[i]).get();
                            assertEquals(titles[i], doc.title());
                        } catch (IOException e) {
                            throw new UncheckedIOException(e);
                        }
                    }
                }
            });
            thread.setName(""Runner-"" + threadNum);
            thread.start();
            thread.setUncaughtExceptionHandler(catcher);
            threads[threadNum] = thread;
        }

        // now join them all
        for (Thread thread : threads) {
            thread.join();
        }

        assertEquals(0, catcher.exceptionCount.get());
    }

    // test that we throw a nice clear exception if you try to multi-thread by forget .newRequest()
    @Test
    public void multiThreadWithoutNewRequestBlowsUp() throws InterruptedException {
        int numThreads = 20;
        String url = SlowRider.Url + ""?"" + SlowRider.MaxTimeParam + ""=10000""; // this makes sure that the first req is still executing whilst the others run
        String title = ""Slow Rider"";

        ThreadCatcher catcher = new ThreadCatcher();
        Connection session = Jsoup.newSession();

        Thread[] threads = new Thread[numThreads];
        for (int threadNum = 0; threadNum < numThreads; threadNum++) {
            Thread thread = new Thread(() -> {
                try {
                    Document doc = session.url(url).get();
                    assertEquals(title, doc.title());
                } catch (IOException e) {
                    throw new UncheckedIOException(e);
                }
            });
            thread.setName(""Runner-"" + threadNum);
            thread.start();
            thread.setUncaughtExceptionHandler(catcher);
            threads[threadNum] = thread;
        }

        // now join them all
        for (Thread thread : threads) {
            thread.join();
        }

        // only one should have passed, rest should have blown up (assuming the started whilst other was running)
        assertEquals(numThreads - 1, catcher.multiThreadExceptions.get());
        assertEquals(numThreads - 1, catcher.exceptionCount.get());
    }


    static class ThreadCatcher implements Thread.UncaughtExceptionHandler {
        AtomicInteger exceptionCount = new AtomicInteger();
        AtomicInteger multiThreadExceptions = new AtomicInteger();

        @Override
        public void uncaughtException(Thread t, Throwable e) {
            if (e instanceof IllegalArgumentException && e.getMessage().contains(""Multiple threads""))
                multiThreadExceptions.incrementAndGet();
            else
                e.printStackTrace();
            exceptionCount.incrementAndGet();
        }
    }

}
"
jhy/jsoup,src/main/java/org/jsoup/helper/DataUtil.java,"package org.jsoup.helper;

import org.jsoup.UncheckedIOException;
import org.jsoup.internal.ConstrainableInputStream;
import org.jsoup.internal.Normalizer;
import org.jsoup.internal.StringUtil;
import org.jsoup.nodes.Comment;
import org.jsoup.nodes.Document;
import org.jsoup.nodes.Element;
import org.jsoup.nodes.Node;
import org.jsoup.nodes.XmlDeclaration;
import org.jsoup.parser.Parser;
import org.jsoup.select.Elements;

import javax.annotation.Nullable;
import javax.annotation.WillClose;

import java.io.BufferedReader;
import java.io.CharArrayReader;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.nio.Buffer;
import java.nio.ByteBuffer;
import java.nio.CharBuffer;
import java.nio.charset.Charset;
import java.nio.charset.IllegalCharsetNameException;
import java.util.Locale;
import java.util.Random;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.zip.GZIPInputStream;

/**
 * Internal static utilities for handling data.
 *
 */
@SuppressWarnings(""CharsetObjectCanBeUsed"")
public final class DataUtil {
    private static final Pattern charsetPattern = Pattern.compile(""(?i)\\bcharset=\\s*(?:[\""'])?([^\\s,;\""']*)"");
    public static final Charset UTF_8 = Charset.forName(""UTF-8""); // Don't use StandardCharsets, as those only appear in Android API 19, and we target 10.
    static final String defaultCharsetName = UTF_8.name(); // used if not found in header or meta charset
    private static final int firstReadBufferSize = 1024 * 5;
    static final int bufferSize = 1024 * 32;
    private static final char[] mimeBoundaryChars =
            ""-_1234567890abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"".toCharArray();
    static final int boundaryLength = 32;

    private DataUtil() {}

    /**
     * Loads and parses a file to a Document, with the HtmlParser. Files that are compressed with gzip (and end in {@code .gz} or {@code .z})
     * are supported in addition to uncompressed files.
     *
     * @param file file to load
     * @param charsetName (optional) character set of input; specify {@code null} to attempt to autodetect. A BOM in
     *     the file will always override this setting.
     * @param baseUri base URI of document, to resolve relative links against
     * @return Document
     * @throws IOException on IO error
     */
    public static Document load(File file, @Nullable String charsetName, String baseUri) throws IOException {
        return load(file, charsetName, baseUri, Parser.htmlParser());
    }

    /**
     * Loads and parses a file to a Document. Files that are compressed with gzip (and end in {@code .gz} or {@code .z})
     * are supported in addition to uncompressed files.
     *
     * @param file file to load
     * @param charsetName (optional) character set of input; specify {@code null} to attempt to autodetect. A BOM in
     *     the file will always override this setting.
     * @param baseUri base URI of document, to resolve relative links against
     * @param parser alternate {@link Parser#xmlParser() parser} to use.

     * @return Document
     * @throws IOException on IO error
     * @since 1.14.2
     */
    public static Document load(File file, @Nullable String charsetName, String baseUri, Parser parser) throws IOException {
        InputStream stream = new FileInputStream(file);
        String name = Normalizer.lowerCase(file.getName());
        if (name.endsWith("".gz"") || name.endsWith("".z"")) {
            // unfortunately file input streams don't support marks (why not?), so we will close and reopen after read
            boolean zipped;
            try {
                zipped = (stream.read() == 0x1f && stream.read() == 0x8b); // gzip magic bytes
            } finally {
                stream.close();

            }
            stream = zipped ? new GZIPInputStream(new FileInputStream(file)) : new FileInputStream(file);
        }
        return parseInputStream(stream, charsetName, baseUri, parser);
    }

    /**
     * Parses a Document from an input steam.
     * @param in input stream to parse. The stream will be closed after reading.
     * @param charsetName character set of input (optional)
     * @param baseUri base URI of document, to resolve relative links against
     * @return Document
     * @throws IOException on IO error
     */
    public static Document load(@WillClose InputStream in, @Nullable String charsetName, String baseUri) throws IOException {
        return parseInputStream(in, charsetName, baseUri, Parser.htmlParser());
    }

    /**
     * Parses a Document from an input steam, using the provided Parser.
     * @param in input stream to parse. The stream will be closed after reading.
     * @param charsetName character set of input (optional)
     * @param baseUri base URI of document, to resolve relative links against
     * @param parser alternate {@link Parser#xmlParser() parser} to use.
     * @return Document
     * @throws IOException on IO error
     */
    public static Document load(@WillClose InputStream in, @Nullable String charsetName, String baseUri, Parser parser) throws IOException {
        return parseInputStream(in, charsetName, baseUri, parser);
    }

    /**
     * Writes the input stream to the output stream. Doesn't close them.
     * @param in input stream to read from
     * @param out output stream to write to
     * @throws IOException on IO error
     */
    static void crossStreams(final InputStream in, final OutputStream out) throws IOException {
        final byte[] buffer = new byte[bufferSize];
        int len;
        while ((len = in.read(buffer)) != -1) {
            out.write(buffer, 0, len);
        }
    }

    static Document parseInputStream(@Nullable @WillClose InputStream input, @Nullable String charsetName, String baseUri, Parser parser) throws IOException  {
        if (input == null) // empty body
            return new Document(baseUri);
        input = ConstrainableInputStream.wrap(input, bufferSize, 0);

        @Nullable Document doc = null;

        // read the start of the stream and look for a BOM or meta charset
        try {
            input.mark(bufferSize);
            ByteBuffer firstBytes = readToByteBuffer(input, firstReadBufferSize - 1); // -1 because we read one more to see if completed. First read is < buffer size, so can't be invalid.
            boolean fullyRead = (input.read() == -1);
            input.reset();

            // look for BOM - overrides any other header or input
            BomCharset bomCharset = detectCharsetFromBom(firstBytes);
            if (bomCharset != null)
                charsetName = bomCharset.charset;

            if (charsetName == null) { // determine from meta. safe first parse as UTF-8
                try {
                    CharBuffer defaultDecoded = UTF_8.decode(firstBytes);
                    if (defaultDecoded.hasArray())
                        doc = parser.parseInput(new CharArrayReader(defaultDecoded.array(), defaultDecoded.arrayOffset(), defaultDecoded.limit()), baseUri);
                    else
                        doc = parser.parseInput(defaultDecoded.toString(), baseUri);
                } catch (UncheckedIOException e) {
                    throw e.ioException();
                }

                // look for <meta http-equiv=""Content-Type"" content=""text/html;charset=gb2312""> or HTML5 <meta charset=""gb2312"">
                Elements metaElements = doc.select(""meta[http-equiv=content-type], meta[charset]"");
                String foundCharset = null; // if not found, will keep utf-8 as best attempt
                for (Element meta : metaElements) {
                    if (meta.hasAttr(""http-equiv""))
                        foundCharset = getCharsetFromContentType(meta.attr(""content""));
                    if (foundCharset == null && meta.hasAttr(""charset""))
                        foundCharset = meta.attr(""charset"");
                    if (foundCharset != null)
                        break;
                }

                // look for <?xml encoding='ISO-8859-1'?>
                if (foundCharset == null && doc.childNodeSize() > 0) {
                    Node first = doc.childNode(0);
                    XmlDeclaration decl = null;
                    if (first instanceof XmlDeclaration)
                        decl = (XmlDeclaration) first;
                    else if (first instanceof Comment) {
                        Comment comment = (Comment) first;
                        if (comment.isXmlDeclaration())
                            decl = comment.asXmlDeclaration();
                    }
                    if (decl != null) {
                        if (decl.name().equalsIgnoreCase(""xml""))
                            foundCharset = decl.attr(""encoding"");
                    }
                }
                foundCharset = validateCharset(foundCharset);
                if (foundCharset != null && !foundCharset.equalsIgnoreCase(defaultCharsetName)) { // need to re-decode. (case insensitive check here to match how validate works)
                    foundCharset = foundCharset.trim().replaceAll(""[\""']"", """");
                    charsetName = foundCharset;
                    doc = null;
                } else if (!fullyRead) {
                    doc = null;
                }
            } else { // specified by content type header (or by user on file load)
                Validate.notEmpty(charsetName, ""Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML"");
            }
            if (doc == null) {
                if (charsetName == null)
                    charsetName = defaultCharsetName;
                BufferedReader reader = new BufferedReader(new InputStreamReader(input, Charset.forName(charsetName)), bufferSize); // Android level does not allow us try-with-resources
                try {
                    if (bomCharset != null && bomCharset.offset) { // creating the buffered reader ignores the input pos, so must skip here
                        long skipped = reader.skip(1);
                        Validate.isTrue(skipped == 1); // WTF if this fails.
                    }
                    try {
                        doc = parser.parseInput(reader, baseUri);
                    } catch (UncheckedIOException e) {
                        // io exception when parsing (not seen before because reading the stream as we go)
                        throw e.ioException();
                    }
                    Charset charset = charsetName.equals(defaultCharsetName) ? UTF_8 : Charset.forName(charsetName);
                    doc.outputSettings().charset(charset);
                    if (!charset.canEncode()) {
                        // some charsets can read but not encode; switch to an encodable charset and update the meta el
                        doc.charset(UTF_8);
                    }
                }
                finally {
                    reader.close();
                }
            }
        }
        finally {
            input.close();
        }
        return doc;
    }

    /**
     * Read the input stream into a byte buffer. To deal with slow input streams, you may interrupt the thread this
     * method is executing on. The data read until being interrupted will be available.
     * @param inStream the input stream to read from
     * @param maxSize the maximum size in bytes to read from the stream. Set to 0 to be unlimited.
     * @return the filled byte buffer
     * @throws IOException if an exception occurs whilst reading from the input stream.
     */
    public static ByteBuffer readToByteBuffer(InputStream inStream, int maxSize) throws IOException {
        Validate.isTrue(maxSize >= 0, ""maxSize must be 0 (unlimited) or larger"");
        final ConstrainableInputStream input = ConstrainableInputStream.wrap(inStream, bufferSize, maxSize);
        return input.readToByteBuffer(maxSize);
    }

    static ByteBuffer emptyByteBuffer() {
        return ByteBuffer.allocate(0);
    }

    /**
     * Parse out a charset from a content type header. If the charset is not supported, returns null (so the default
     * will kick in.)
     * @param contentType e.g. ""text/html; charset=EUC-JP""
     * @return ""EUC-JP"", or null if not found. Charset is trimmed and uppercased.
     */
    static @Nullable String getCharsetFromContentType(@Nullable String contentType) {
        if (contentType == null) return null;
        Matcher m = charsetPattern.matcher(contentType);
        if (m.find()) {
            String charset = m.group(1).trim();
            charset = charset.replace(""charset="", """");
            return validateCharset(charset);
        }
        return null;
    }

    private @Nullable static String validateCharset(@Nullable String cs) {
        if (cs == null || cs.length() == 0) return null;
        cs = cs.trim().replaceAll(""[\""']"", """");
        try {
            if (Charset.isSupported(cs)) return cs;
            cs = cs.toUpperCase(Locale.ENGLISH);
            if (Charset.isSupported(cs)) return cs;
        } catch (IllegalCharsetNameException e) {
            // if our this charset matching fails.... we just take the default
        }
        return null;
    }

    /**
     * Creates a random string, suitable for use as a mime boundary
     */
    static String mimeBoundary() {
        final StringBuilder mime = StringUtil.borrowBuilder();
        final Random rand = new Random();
        for (int i = 0; i < boundaryLength; i++) {
            mime.append(mimeBoundaryChars[rand.nextInt(mimeBoundaryChars.length)]);
        }
        return StringUtil.releaseBuilder(mime);
    }

    private static @Nullable BomCharset detectCharsetFromBom(final ByteBuffer byteData) {
        @SuppressWarnings(""UnnecessaryLocalVariable"") final Buffer buffer = byteData; // .mark and rewind used to return Buffer, now ByteBuffer, so cast for backward compat
        buffer.mark();
        byte[] bom = new byte[4];
        if (byteData.remaining() >= bom.length) {
            byteData.get(bom);
            buffer.rewind();
        }
        if (bom[0] == 0x00 && bom[1] == 0x00 && bom[2] == (byte) 0xFE && bom[3] == (byte) 0xFF || // BE
            bom[0] == (byte) 0xFF && bom[1] == (byte) 0xFE && bom[2] == 0x00 && bom[3] == 0x00) { // LE
            return new BomCharset(""UTF-32"", false); // and I hope it's on your system
        } else if (bom[0] == (byte) 0xFE && bom[1] == (byte) 0xFF || // BE
            bom[0] == (byte) 0xFF && bom[1] == (byte) 0xFE) {
            return new BomCharset(""UTF-16"", false); // in all Javas
        } else if (bom[0] == (byte) 0xEF && bom[1] == (byte) 0xBB && bom[2] == (byte) 0xBF) {
            return new BomCharset(""UTF-8"", true); // in all Javas
            // 16 and 32 decoders consume the BOM to determine be/le; utf-8 should be consumed here
        }
        return null;
    }

    private static class BomCharset {
        private final String charset;
        private final boolean offset;

        public BomCharset(String charset, boolean offset) {
            this.charset = charset;
            this.offset = offset;
        }
    }
}
"
jhy/jsoup,src/test/java/org/jsoup/safety/SafelistTest.java,"package org.jsoup.safety;

import org.jsoup.nodes.Attribute;
import org.jsoup.nodes.Attributes;
import org.jsoup.nodes.Element;
import org.jsoup.parser.Tag;
import org.junit.jupiter.api.Test;

import static org.junit.jupiter.api.Assertions.assertFalse;
import static org.junit.jupiter.api.Assertions.assertNotEquals;

public class SafelistTest {
    private static final String TEST_TAG = ""testTag"";
    private static final String TEST_ATTRIBUTE = ""testAttribute"";
    private static final String TEST_SCHEME = ""valid-scheme"";
    private static final String TEST_VALUE = TEST_SCHEME + ""://testValue"";

    @Test
    public void testCopyConstructor_noSideEffectOnTags() {
        Safelist safelist1 = Safelist.none().addTags(TEST_TAG);
        Safelist safelist2 = new Safelist(safelist1);
        safelist1.addTags(""invalidTag"");

        assertFalse(safelist2.isSafeTag(""invalidTag""));
    }

    @Test
    public void testCopyConstructor_noSideEffectOnAttributes() {
        Safelist safelist1 = Safelist.none().addAttributes(TEST_TAG, TEST_ATTRIBUTE);
        Safelist safelist2 = new Safelist(safelist1);
        safelist1.addAttributes(TEST_TAG, ""invalidAttribute"");

        assertFalse(safelist2.isSafeAttribute(TEST_TAG, null, new Attribute(""invalidAttribute"", TEST_VALUE)));
    }

    @Test
    public void testCopyConstructor_noSideEffectOnEnforcedAttributes() {
        Safelist safelist1 = Safelist.none().addEnforcedAttribute(TEST_TAG, TEST_ATTRIBUTE, TEST_VALUE);
        Safelist safelist2 = new Safelist(safelist1);
        safelist1.addEnforcedAttribute(TEST_TAG, TEST_ATTRIBUTE, ""invalidValue"");

        for (Attribute enforcedAttribute : safelist2.getEnforcedAttributes(TEST_TAG)) {
            assertNotEquals(""invalidValue"", enforcedAttribute.getValue());
        }
    }

    @Test
    public void testCopyConstructor_noSideEffectOnProtocols() {
        final String invalidScheme = ""invalid-scheme"";
        Safelist safelist1 = Safelist.none()
                .addAttributes(TEST_TAG, TEST_ATTRIBUTE)
                .addProtocols(TEST_TAG, TEST_ATTRIBUTE, TEST_SCHEME);
        Safelist safelist2 = new Safelist(safelist1);
        safelist1.addProtocols(TEST_TAG, TEST_ATTRIBUTE, invalidScheme);

        Attributes attributes = new Attributes();
        Attribute invalidAttribute = new Attribute(TEST_ATTRIBUTE, invalidScheme + ""://someValue"");
        attributes.put(invalidAttribute);
        Element invalidElement = new Element(Tag.valueOf(TEST_TAG), """", attributes);

        assertFalse(safelist2.isSafeAttribute(TEST_TAG, invalidElement, invalidAttribute));
    }


}
"
jhy/jsoup,src/test/java/org/jsoup/nodes/FormElementTest.java,"package org.jsoup.nodes;

import org.jsoup.Connection;
import org.jsoup.Jsoup;
import org.jsoup.integration.TestServer;
import org.jsoup.integration.servlets.CookieServlet;
import org.jsoup.integration.servlets.EchoServlet;
import org.jsoup.integration.servlets.FileServlet;
import org.jsoup.select.Elements;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Test;

import java.io.IOException;
import java.util.List;

import static org.junit.jupiter.api.Assertions.*;

/**
 * Tests for FormElement
 *
 * @author Jonathan Hedley
 */
public class FormElementTest {
    @BeforeAll
    public static void setUp() {
        TestServer.start();
    }

    @Test public void hasAssociatedControls() {
        //""button"", ""fieldset"", ""input"", ""keygen"", ""object"", ""output"", ""select"", ""textarea""
        String html = ""<form id=1><button id=1><fieldset id=2 /><input id=3><keygen id=4><object id=5><output id=6>"" +
                ""<select id=7><option></select><textarea id=8><p id=9>"";
        Document doc = Jsoup.parse(html);

        FormElement form = (FormElement) doc.select(""form"").first();
        assertEquals(8, form.elements().size());
    }

    @Test public void createsFormData() {
        String html = ""<form><input name='one' value='two'><select name='three'><option value='not'>"" +
                ""<option value='four' selected><option value='five' selected><textarea name=six>seven</textarea>"" +
                ""<input name='seven' type='radio' value='on' checked><input name='seven' type='radio' value='off'>"" +
                ""<input name='eight' type='checkbox' checked><input name='nine' type='checkbox' value='unset'>"" +
                ""<input name='ten' value='text' disabled>"" +
                ""<input name='eleven' value='text' type='button'>"" +
                ""</form>"";
        Document doc = Jsoup.parse(html);
        FormElement form = (FormElement) doc.select(""form"").first();
        List<Connection.KeyVal> data = form.formData();

        assertEquals(6, data.size());
        assertEquals(""one=two"", data.get(0).toString());
        assertEquals(""three=four"", data.get(1).toString());
        assertEquals(""three=five"", data.get(2).toString());
        assertEquals(""six=seven"", data.get(3).toString());
        assertEquals(""seven=on"", data.get(4).toString()); // set
        assertEquals(""eight=on"", data.get(5).toString()); // default
        // nine should not appear, not checked checkbox
        // ten should not appear, disabled
        // eleven should not appear, button
    }

    @Test public void formDataUsesFirstAttribute() {
        String html = ""<form><input name=test value=foo name=test2 value=bar>"";
        Document doc = Jsoup.parse(html);
        FormElement form = (FormElement) doc.selectFirst(""form"");
        assertEquals(""test=foo"", form.formData().get(0).toString());
    }

    @Test public void createsSubmitableConnection() {
        String html = ""<form action='/search'><input name='q'></form>"";
        Document doc = Jsoup.parse(html, ""http://example.com/"");
        doc.select(""[name=q]"").attr(""value"", ""jsoup"");

        FormElement form = ((FormElement) doc.select(""form"").first());
        Connection con = form.submit();

        assertEquals(Connection.Method.GET, con.request().method());
        assertEquals(""http://example.com/search"", con.request().url().toExternalForm());
        List<Connection.KeyVal> dataList = (List<Connection.KeyVal>) con.request().data();
        assertEquals(""q=jsoup"", dataList.get(0).toString());

        doc.select(""form"").attr(""method"", ""post"");
        Connection con2 = form.submit();
        assertEquals(Connection.Method.POST, con2.request().method());
    }

    @Test public void actionWithNoValue() {
        String html = ""<form><input name='q'></form>"";
        Document doc = Jsoup.parse(html, ""http://example.com/"");
        FormElement form = ((FormElement) doc.select(""form"").first());
        Connection con = form.submit();

        assertEquals(""http://example.com/"", con.request().url().toExternalForm());
    }

    @Test public void actionWithNoBaseUri() {
        String html = ""<form><input name='q'></form>"";
        Document doc = Jsoup.parse(html);
        FormElement form = ((FormElement) doc.select(""form"").first());


        boolean threw = false;
        try {
            form.submit();
        } catch (IllegalArgumentException e) {
            threw = true;
            assertEquals(""Could not determine a form action URL for submit. Ensure you set a base URI when parsing."",
                    e.getMessage());
        }
        assertTrue(threw);
    }

    @Test public void formsAddedAfterParseAreFormElements() {
        Document doc = Jsoup.parse(""<body />"");
        doc.body().html(""<form action='http://example.com/search'><input name='q' value='search'>"");
        Element formEl = doc.select(""form"").first();
        assertTrue(formEl instanceof FormElement);

        FormElement form = (FormElement) formEl;
        assertEquals(1, form.elements().size());
    }

    @Test public void controlsAddedAfterParseAreLinkedWithForms() {
        Document doc = Jsoup.parse(""<body />"");
        doc.body().html(""<form />"");

        Element formEl = doc.select(""form"").first();
        formEl.append(""<input name=foo value=bar>"");

        assertTrue(formEl instanceof FormElement);
        FormElement form = (FormElement) formEl;
        assertEquals(1, form.elements().size());

        List<Connection.KeyVal> data = form.formData();
        assertEquals(""foo=bar"", data.get(0).toString());
    }

    @Test public void usesOnForCheckboxValueIfNoValueSet() {
        Document doc = Jsoup.parse(""<form><input type=checkbox checked name=foo></form>"");
        FormElement form = (FormElement) doc.select(""form"").first();
        List<Connection.KeyVal> data = form.formData();
        assertEquals(""on"", data.get(0).value());
        assertEquals(""foo"", data.get(0).key());
    }

    @Test public void adoptedFormsRetainInputs() {
        // test for https://github.com/jhy/jsoup/issues/249
        String html = ""<html>\n"" +
                ""<body>  \n"" +
                ""  <table>\n"" +
                ""      <form action=\""/hello.php\"" method=\""post\"">\n"" +
                ""      <tr><td>User:</td><td> <input type=\""text\"" name=\""user\"" /></td></tr>\n"" +
                ""      <tr><td>Password:</td><td> <input type=\""password\"" name=\""pass\"" /></td></tr>\n"" +
                ""      <tr><td><input type=\""submit\"" name=\""login\"" value=\""login\"" /></td></tr>\n"" +
                ""   </form>\n"" +
                ""  </table>\n"" +
                ""</body>\n"" +
                ""</html>"";
        Document doc = Jsoup.parse(html);
        FormElement form = (FormElement) doc.select(""form"").first();
        List<Connection.KeyVal> data = form.formData();
        assertEquals(3, data.size());
        assertEquals(""user"", data.get(0).key());
        assertEquals(""pass"", data.get(1).key());
        assertEquals(""login"", data.get(2).key());
    }

    @Test public void removeFormElement() {
        String html = ""<html>\n"" +
                ""  <body> \n"" +
                ""      <form action=\""/hello.php\"" method=\""post\"">\n"" +
                ""      User:<input type=\""text\"" name=\""user\"" />\n"" +
                ""      Password:<input type=\""password\"" name=\""pass\"" />\n"" +
                ""      <input type=\""submit\"" name=\""login\"" value=\""login\"" />\n"" +
                ""   </form>\n"" +
                ""  </body>\n"" +
                ""</html>  "";
        Document doc = Jsoup.parse(html);
        FormElement form = (FormElement) doc.selectFirst(""form"");
        Element pass = form.selectFirst(""input[name=pass]"");
        pass.remove();

        List<Connection.KeyVal> data = form.formData();
        assertEquals(2, data.size());
        assertEquals(""user"", data.get(0).key());
        assertEquals(""login"", data.get(1).key());
        assertNull(doc.selectFirst(""input[name=pass]""));
    }

    @Test public void formSubmissionCarriesCookiesFromSession() throws IOException {
        String echoUrl = EchoServlet.Url; // this is a dirty hack to initialize the EchoServlet(!)
        Document cookieDoc = Jsoup.connect(CookieServlet.Url)
            .data(CookieServlet.SetCookiesParam, ""1"")
            .get();
        Document formDoc = cookieDoc.connection().newRequest() // carries cookies from above set
            .url(FileServlet.urlTo(""/htmltests/upload-form.html""))
            .get();
        FormElement form = formDoc.select(""form"").forms().get(0);
        Document echo = form.submit().post();

        assertEquals(echoUrl, echo.location());
        Elements els = echo.select(""th:contains(Cookie: One)"");
        // ensure that the cookies are there and in path-specific order (two with same name)
        assertEquals(""EchoServlet"", els.get(0).nextElementSibling().text());
        assertEquals(""Root"", els.get(1).nextElementSibling().text());

        // make sure that the session following kept unique requests
        assertTrue(cookieDoc.connection().response().url().toExternalForm().contains(""CookieServlet""));
        assertTrue(formDoc.connection().response().url().toExternalForm().contains(""upload-form""));
        assertTrue(echo.connection().response().url().toExternalForm().contains(""EchoServlet""));
    }
}
"
jhy/jsoup,src/test/java/org/jsoup/parser/TokeniserTest.java,"package org.jsoup.parser;

import org.jsoup.Jsoup;
import org.jsoup.nodes.*;
import org.jsoup.select.Elements;
import org.junit.jupiter.api.Test;

import java.nio.charset.Charset;
import java.util.Arrays;

import static org.jsoup.parser.CharacterReader.maxBufferLen;
import static org.junit.jupiter.api.Assertions.*;

public class TokeniserTest {
    @Test
    public void bufferUpInAttributeVal() {
        // https://github.com/jhy/jsoup/issues/967

        // check each double, singlem, unquoted impls
        String[] quotes = {""\"""", ""'"", """"};
        for (String quote : quotes) {
            String preamble = ""<img src="" + quote;
            String tail = ""bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb"";
            StringBuilder sb = new StringBuilder(preamble);

            final int charsToFillBuffer = maxBufferLen - preamble.length();
            for (int i = 0; i < charsToFillBuffer; i++) {
                sb.append('a');
            }

            sb.append('X'); // First character to cross character buffer boundary
            sb.append(tail).append(quote).append("">\n"");

            String html = sb.toString();
            Document doc = Jsoup.parse(html);
            String src = doc.select(""img"").attr(""src"");

            assertTrue(src.contains(""X""), ""Handles for quote "" + quote);
            assertTrue(src.contains(tail));
        }
    }

    @Test public void handleSuperLargeTagNames() {
        // unlikely, but valid. so who knows.

        StringBuilder sb = new StringBuilder(maxBufferLen);
        do {
            sb.append(""LargeTagName"");
        } while (sb.length() < maxBufferLen);
        String tag = sb.toString();
        String html = ""<"" + tag + "">One</"" + tag + "">"";

        Document doc = Parser.htmlParser().settings(ParseSettings.preserveCase).parseInput(html, """");
        Elements els = doc.select(tag);
        assertEquals(1, els.size());
        Element el = els.first();
        assertNotNull(el);
        assertEquals(""One"", el.text());
        assertEquals(tag, el.tagName());
    }

    @Test public void handleSuperLargeAttributeName() {
        StringBuilder sb = new StringBuilder(maxBufferLen);
        do {
            sb.append(""LargAttributeName"");
        } while (sb.length() < maxBufferLen);
        String attrName = sb.toString();
        String html = ""<p "" + attrName + ""=foo>One</p>"";

        Document doc = Jsoup.parse(html);
        Elements els = doc.getElementsByAttribute(attrName);
        assertEquals(1, els.size());
        Element el = els.first();
        assertNotNull(el);
        assertEquals(""One"", el.text());
        Attribute attribute = el.attributes().asList().get(0);
        assertEquals(attrName.toLowerCase(), attribute.getKey());
        assertEquals(""foo"", attribute.getValue());
    }

    @Test public void handleLargeText() {
        StringBuilder sb = new StringBuilder(maxBufferLen);
        do {
            sb.append(""A Large Amount of Text"");
        } while (sb.length() < maxBufferLen);
        String text = sb.toString();
        String html = ""<p>"" + text + ""</p>"";

        Document doc = Jsoup.parse(html);
        Elements els = doc.select(""p"");
        assertEquals(1, els.size());
        Element el = els.first();

        assertNotNull(el);
        assertEquals(text, el.text());
    }

    @Test public void handleLargeComment() {
        StringBuilder sb = new StringBuilder(maxBufferLen);
        do {
            sb.append(""Quite a comment "");
        } while (sb.length() < maxBufferLen);
        String comment = sb.toString();
        String html = ""<p><!-- "" + comment + "" --></p>"";

        Document doc = Jsoup.parse(html);
        Elements els = doc.select(""p"");
        assertEquals(1, els.size());
        Element el = els.first();

        assertNotNull(el);
        Comment child = (Comment) el.childNode(0);
        assertEquals("" "" + comment + "" "", child.getData());
    }

    @Test public void handleLargeCdata() {
        StringBuilder sb = new StringBuilder(maxBufferLen);
        do {
            sb.append(""Quite a lot of CDATA <><><><>"");
        } while (sb.length() < maxBufferLen);
        String cdata = sb.toString();
        String html = ""<p><![CDATA["" + cdata + ""]]></p>"";

        Document doc = Jsoup.parse(html);
        Elements els = doc.select(""p"");
        assertEquals(1, els.size());
        Element el = els.first();

        assertNotNull(el);
        TextNode child = (TextNode) el.childNode(0);
        assertEquals(cdata, el.text());
        assertEquals(cdata, child.getWholeText());
    }

    @Test public void handleLargeTitle() {
        StringBuilder sb = new StringBuilder(maxBufferLen);
        do {
            sb.append(""Quite a long title"");
        } while (sb.length() < maxBufferLen);
        String title = sb.toString();
        String html = ""<title>"" + title + ""</title>"";

        Document doc = Jsoup.parse(html);
        Elements els = doc.select(""title"");
        assertEquals(1, els.size());
        Element el = els.first();

        assertNotNull(el);
        TextNode child = (TextNode) el.childNode(0);
        assertEquals(title, el.text());
        assertEquals(title, child.getWholeText());
        assertEquals(title, doc.title());
    }

    @Test public void cp1252Entities() {
        assertEquals(""\u20ac"", Jsoup.parse(""&#0128;"").text());
        assertEquals(""\u201a"", Jsoup.parse(""&#0130;"").text());
        assertEquals(""\u20ac"", Jsoup.parse(""&#x80;"").text());
    }

    @Test public void cp1252EntitiesProduceError() {
        Parser parser = new Parser(new HtmlTreeBuilder());
        parser.setTrackErrors(10);
        assertEquals(""\u20ac"", parser.parseInput(""<html><body>&#0128;</body></html>"", """").text());
        assertEquals(1, parser.getErrors().size());
    }

    @Test public void cp1252SubstitutionTable() {
        for (int i = 0; i < Tokeniser.win1252Extensions.length; i++) {
            String s = new String(new byte[]{ (byte) (i + Tokeniser.win1252ExtensionsStart) }, Charset.forName(""Windows-1252""));
            assertEquals(1, s.length());

            // some of these characters are illegal
            if (s.charAt(0) == '\ufffd') { continue; }

            assertEquals(s.charAt(0), Tokeniser.win1252Extensions[i], ""At: "" + i);
        }
    }

    @Test public void canParseVeryLongBogusComment() {
        StringBuilder commentData = new StringBuilder(maxBufferLen);
        do {
            commentData.append(""blah blah blah blah "");
        } while (commentData.length() < maxBufferLen);
        String expectedCommentData = commentData.toString();
        String testMarkup = ""<html><body><!"" + expectedCommentData + ""></body></html>"";
        Parser parser = new Parser(new HtmlTreeBuilder());

        Document doc = parser.parseInput(testMarkup, """");

        Node commentNode = doc.body().childNode(0);
        assertTrue(commentNode instanceof Comment, ""Expected comment node"");
        assertEquals(expectedCommentData, ((Comment)commentNode).getData());
    }

    @Test public void canParseCdataEndingAtEdgeOfBuffer() {
        String cdataStart = ""<![CDATA["";
        String cdataEnd = ""]]>"";
        int bufLen = maxBufferLen - cdataStart.length() - 1;    // also breaks with -2, but not with -3 or 0
        char[] cdataContentsArray = new char[bufLen];
        Arrays.fill(cdataContentsArray, 'x');
        String cdataContents = new String(cdataContentsArray);
        String testMarkup = cdataStart + cdataContents + cdataEnd;
        Parser parser = new Parser(new HtmlTreeBuilder());

        Document doc = parser.parseInput(testMarkup, """");

        Node cdataNode = doc.body().childNode(0);
        assertTrue(cdataNode instanceof CDataNode, ""Expected CDATA node"");
        assertEquals(cdataContents, ((CDataNode)cdataNode).text());
    }
}
"
jhy/jsoup,src/main/java/org/jsoup/nodes/DataNode.java,"package org.jsoup.nodes;

import java.io.IOException;

/**
 A data node, for contents of style, script tags etc, where contents should not show in text().

 @author Jonathan Hedley, jonathan@hedley.net */
public class DataNode extends LeafNode {

    /**
     Create a new DataNode.
     @param data data contents
     */
    public DataNode(String data) {
        value = data;
    }

    public String nodeName() {
        return ""#data"";
    }

    /**
     Get the data contents of this node. Will be unescaped and with original new lines, space etc.
     @return data
     */
    public String getWholeData() {
        return coreValue();
    }

    /**
     * Set the data contents of this node.
     * @param data unencoded data
     * @return this node, for chaining
     */
    public DataNode setWholeData(String data) {
        coreValue(data);
        return this;
    }

	void outerHtmlHead(Appendable accum, int depth, Document.OutputSettings out) throws IOException {
        accum.append(getWholeData()); // data is not escaped in return from data nodes, so "" in script, style is plain
    }

	void outerHtmlTail(Appendable accum, int depth, Document.OutputSettings out) {}

    @Override
    public String toString() {
        return outerHtml();
    }

    @Override
    public DataNode clone() {
        return (DataNode) super.clone();
    }
}
"
jhy/jsoup,src/main/java/org/jsoup/parser/Parser.java,"package org.jsoup.parser;

import org.jsoup.nodes.Document;
import org.jsoup.nodes.Element;
import org.jsoup.nodes.Node;

import java.io.Reader;
import java.io.StringReader;
import java.util.List;

/**
 * Parses HTML into a {@link org.jsoup.nodes.Document}. Generally best to use one of the  more convenient parse methods
 * in {@link org.jsoup.Jsoup}.
 */
public class Parser {
    private TreeBuilder treeBuilder;
    private ParseErrorList errors;
    private ParseSettings settings;
    private boolean trackPosition = false;

    /**
     * Create a new Parser, using the specified TreeBuilder
     * @param treeBuilder TreeBuilder to use to parse input into Documents.
     */
    public Parser(TreeBuilder treeBuilder) {
        this.treeBuilder = treeBuilder;
        settings = treeBuilder.defaultSettings();
        errors = ParseErrorList.noTracking();
    }

    /**
     Creates a new Parser as a deep copy of this; including initializing a new TreeBuilder. Allows independent (multi-threaded) use.
     @return a copied parser
     */
    public Parser newInstance() {
        return new Parser(this);
    }

    private Parser(Parser copy) {
        treeBuilder = copy.treeBuilder.newInstance(); // because extended
        errors = new ParseErrorList(copy.errors); // only copies size, not contents
        settings = new ParseSettings(copy.settings);
        trackPosition = copy.trackPosition;
    }
    
    public Document parseInput(String html, String baseUri) {
        return treeBuilder.parse(new StringReader(html), baseUri, this);
    }

    public Document parseInput(Reader inputHtml, String baseUri) {
        return treeBuilder.parse(inputHtml, baseUri, this);
    }

    public List<Node> parseFragmentInput(String fragment, Element context, String baseUri) {
        return treeBuilder.parseFragment(fragment, context, baseUri, this);
    }
    // gets & sets
    /**
     * Get the TreeBuilder currently in use.
     * @return current TreeBuilder.
     */
    public TreeBuilder getTreeBuilder() {
        return treeBuilder;
    }

    /**
     * Update the TreeBuilder used when parsing content.
     * @param treeBuilder new TreeBuilder
     * @return this, for chaining
     */
    public Parser setTreeBuilder(TreeBuilder treeBuilder) {
        this.treeBuilder = treeBuilder;
        treeBuilder.parser = this;
        return this;
    }

    /**
     * Check if parse error tracking is enabled.
     * @return current track error state.
     */
    public boolean isTrackErrors() {
        return errors.getMaxSize() > 0;
    }

    /**
     * Enable or disable parse error tracking for the next parse.
     * @param maxErrors the maximum number of errors to track. Set to 0 to disable.
     * @return this, for chaining
     */
    public Parser setTrackErrors(int maxErrors) {
        errors = maxErrors > 0 ? ParseErrorList.tracking(maxErrors) : ParseErrorList.noTracking();
        return this;
    }

    /**
     * Retrieve the parse errors, if any, from the last parse.
     * @return list of parse errors, up to the size of the maximum errors tracked.
     * @see #setTrackErrors(int)
     */
    public ParseErrorList getErrors() {
        return errors;
    }

    /**
     Test if position tracking is enabled. If it is, Nodes will have a Position to track where in the original input
     source they were created from. By default, tracking is not enabled.
     * @return current track position setting
     */
    public boolean isTrackPosition() {
        return trackPosition;
    }

    /**
     Enable or disable source position tracking. If enabled, Nodes will have a Position to track where in the original
     input source they were created from.
     @param trackPosition position tracking setting; {@code true} to enable
     @return this Parser, for chaining
     */
    public Parser setTrackPosition(boolean trackPosition) {
        this.trackPosition = trackPosition;
        return this;
    }

    /**
     Update the ParseSettings of this Parser, to control the case sensitivity of tags and attributes.
     * @param settings the new settings
     * @return this Parser
     */
    public Parser settings(ParseSettings settings) {
        this.settings = settings;
        return this;
    }

    /**
     Gets the current ParseSettings for this Parser
     * @return current ParseSettings
     */
    public ParseSettings settings() {
        return settings;
    }

    /**
     (An internal method, visible for Element. For HTML parse, signals that script and style text should be treated as
     Data Nodes).
     */
    public boolean isContentForTagData(String normalName) {
        return getTreeBuilder().isContentForTagData(normalName);
    }

    // static parse functions below
    /**
     * Parse HTML into a Document.
     *
     * @param html HTML to parse
     * @param baseUri base URI of document (i.e. original fetch location), for resolving relative URLs.
     *
     * @return parsed Document
     */
    public static Document parse(String html, String baseUri) {
        TreeBuilder treeBuilder = new HtmlTreeBuilder();
        return treeBuilder.parse(new StringReader(html), baseUri, new Parser(treeBuilder));
    }

    /**
     * Parse a fragment of HTML into a list of nodes. The context element, if supplied, supplies parsing context.
     *
     * @param fragmentHtml the fragment of HTML to parse
     * @param context (optional) the element that this HTML fragment is being parsed for (i.e. for inner HTML). This
     * provides stack context (for implicit element creation).
     * @param baseUri base URI of document (i.e. original fetch location), for resolving relative URLs.
     *
     * @return list of nodes parsed from the input HTML. Note that the context element, if supplied, is not modified.
     */
    public static List<Node> parseFragment(String fragmentHtml, Element context, String baseUri) {
        HtmlTreeBuilder treeBuilder = new HtmlTreeBuilder();
        return treeBuilder.parseFragment(fragmentHtml, context, baseUri, new Parser(treeBuilder));
    }

    /**
     * Parse a fragment of HTML into a list of nodes. The context element, if supplied, supplies parsing context.
     *
     * @param fragmentHtml the fragment of HTML to parse
     * @param context (optional) the element that this HTML fragment is being parsed for (i.e. for inner HTML). This
     * provides stack context (for implicit element creation).
     * @param baseUri base URI of document (i.e. original fetch location), for resolving relative URLs.
     * @param errorList list to add errors to
     *
     * @return list of nodes parsed from the input HTML. Note that the context element, if supplied, is not modified.
     */
    public static List<Node> parseFragment(String fragmentHtml, Element context, String baseUri, ParseErrorList errorList) {
        HtmlTreeBuilder treeBuilder = new HtmlTreeBuilder();
        Parser parser = new Parser(treeBuilder);
        parser.errors = errorList;
        return treeBuilder.parseFragment(fragmentHtml, context, baseUri, parser);
    }

    /**
     * Parse a fragment of XML into a list of nodes.
     *
     * @param fragmentXml the fragment of XML to parse
     * @param baseUri base URI of document (i.e. original fetch location), for resolving relative URLs.
     * @return list of nodes parsed from the input XML.
     */
    public static List<Node> parseXmlFragment(String fragmentXml, String baseUri) {
        XmlTreeBuilder treeBuilder = new XmlTreeBuilder();
        return treeBuilder.parseFragment(fragmentXml, baseUri, new Parser(treeBuilder));
    }

    /**
     * Parse a fragment of HTML into the {@code body} of a Document.
     *
     * @param bodyHtml fragment of HTML
     * @param baseUri base URI of document (i.e. original fetch location), for resolving relative URLs.
     *
     * @return Document, with empty head, and HTML parsed into body
     */
    public static Document parseBodyFragment(String bodyHtml, String baseUri) {
        Document doc = Document.createShell(baseUri);
        Element body = doc.body();
        List<Node> nodeList = parseFragment(bodyHtml, body, baseUri);
        Node[] nodes = nodeList.toArray(new Node[0]); // the node list gets modified when re-parented
        for (int i = nodes.length - 1; i > 0; i--) {
            nodes[i].remove();
        }
        for (Node node : nodes) {
            body.appendChild(node);
        }
        return doc;
    }

    /**
     * Utility method to unescape HTML entities from a string
     * @param string HTML escaped string
     * @param inAttribute if the string is to be escaped in strict mode (as attributes are)
     * @return an unescaped string
     */
    public static String unescapeEntities(String string, boolean inAttribute) {
        Tokeniser tokeniser = new Tokeniser(new CharacterReader(string), ParseErrorList.noTracking());
        return tokeniser.unescapeEntities(inAttribute);
    }

    // builders

    /**
     * Create a new HTML parser. This parser treats input as HTML5, and enforces the creation of a normalised document,
     * based on a knowledge of the semantics of the incoming tags.
     * @return a new HTML parser.
     */
    public static Parser htmlParser() {
        return new Parser(new HtmlTreeBuilder());
    }

    /**
     * Create a new XML parser. This parser assumes no knowledge of the incoming tags and does not treat it as HTML,
     * rather creates a simple tree directly from the input.
     * @return a new simple XML parser.
     */
    public static Parser xmlParser() {
        return new Parser(new XmlTreeBuilder());
    }
}
"
jhy/jsoup,src/main/java/org/jsoup/UnsupportedMimeTypeException.java,"package org.jsoup;

import java.io.IOException;

/**
 * Signals that a HTTP response returned a mime type that is not supported.
 */
public class UnsupportedMimeTypeException extends IOException {
    private final String mimeType;
    private final String url;

    public UnsupportedMimeTypeException(String message, String mimeType, String url) {
        super(message);
        this.mimeType = mimeType;
        this.url = url;
    }

    public String getMimeType() {
        return mimeType;
    }

    public String getUrl() {
        return url;
    }

    @Override
    public String toString() {
        return super.toString() + "". Mimetype="" + mimeType + "", URL=""+url;
    }
}
"
jhy/jsoup,src/test/java/org/jsoup/select/QueryParserTest.java,"package org.jsoup.select;

import org.jsoup.Jsoup;
import org.jsoup.nodes.Document;
import org.junit.jupiter.api.Test;

import static org.junit.jupiter.api.Assertions.*;

/**
 * Tests for the Selector Query Parser.
 *
 * @author Jonathan Hedley
 */
public class QueryParserTest {

    @Test public void testConsumeSubQuery() {
        Document doc = Jsoup.parse(""<html><head>h</head><body>"" +
                ""<li><strong>l1</strong></li>"" +
                ""<a><li><strong>l2</strong></li></a>"" +
                ""<p><strong>yes</strong></p>"" +
                ""</body></html>"");
        assertEquals(""l1 l2 yes"", doc.body().select("">p>strong,>*>li>strong"").text());
        assertEquals(""l2 yes"", doc.select(""body>p>strong,body>*>li>strong"").text());
        assertEquals(""yes"", doc.select("">body>*>li>strong,>body>p>strong"").text());
        assertEquals(""l2"", doc.select("">body>p>strong,>body>*>li>strong"").text());
    }

    @Test public void testOrGetsCorrectPrecedence() {
        // tests that a selector ""a b, c d, e f"" evals to (a AND b) OR (c AND d) OR (e AND f)""
        // top level or, three child ands
        Evaluator eval = QueryParser.parse(""a b, c d, e f"");
        assertTrue(eval instanceof CombiningEvaluator.Or);
        CombiningEvaluator.Or or = (CombiningEvaluator.Or) eval;
        assertEquals(3, or.evaluators.size());
        for (Evaluator innerEval: or.evaluators) {
            assertTrue(innerEval instanceof CombiningEvaluator.And);
            CombiningEvaluator.And and = (CombiningEvaluator.And) innerEval;
            assertEquals(2, and.evaluators.size());
            assertTrue(and.evaluators.get(0) instanceof StructuralEvaluator.Parent);
            assertTrue(and.evaluators.get(1) instanceof Evaluator.Tag);
        }
    }

    @Test public void testParsesMultiCorrectly() {
        String query = "".foo > ol, ol > li + li"";
        Evaluator eval = QueryParser.parse(query);
        assertTrue(eval instanceof CombiningEvaluator.Or);
        CombiningEvaluator.Or or = (CombiningEvaluator.Or) eval;
        assertEquals(2, or.evaluators.size());

        CombiningEvaluator.And andLeft = (CombiningEvaluator.And) or.evaluators.get(0);
        CombiningEvaluator.And andRight = (CombiningEvaluator.And) or.evaluators.get(1);

        assertEquals("".foo > ol"", andLeft.toString());
        assertEquals(2, andLeft.evaluators.size());
        assertEquals(""ol > li + li"", andRight.toString());
        assertEquals(2, andRight.evaluators.size());
        assertEquals(query, eval.toString());
    }

    @Test public void exceptionOnUncloseAttribute() {
        assertThrows(Selector.SelectorParseException.class, () -> QueryParser.parse(""section > a[href=\""]""));
    }

    @Test public void testParsesSingleQuoteInContains() {
        assertThrows(Selector.SelectorParseException.class, () -> QueryParser.parse(""p:contains(One \"" One)""));
    }


    @Test public void exceptOnEmptySelector() {
        assertThrows(Selector.SelectorParseException.class, () -> QueryParser.parse(""""));
    }

    @Test public void exceptOnNullSelector() {
        assertThrows(Selector.SelectorParseException.class, () -> QueryParser.parse(null));
    }

    @Test public void okOnSpacesForeAndAft() {
        Evaluator parse = QueryParser.parse("" span div  "");
        assertEquals(""span div"", parse.toString());
    }

    @Test public void structuralEvaluatorsToString() {
        String q = ""a:not(:has(span.foo)) b d > e + f ~ g"";
        Evaluator parse = QueryParser.parse(q);
        assertEquals(q, parse.toString());
    }
}
"
jhy/jsoup,src/test/java/org/jsoup/parser/HtmlTreeBuilderTest.java,"package org.jsoup.parser;


import org.junit.jupiter.api.Test;

import javax.annotation.Nonnull;
import javax.annotation.ParametersAreNonnullByDefault;
import java.io.Reader;
import java.lang.annotation.Annotation;
import java.lang.reflect.Method;
import java.util.Arrays;
import java.util.List;

import static org.junit.jupiter.api.Assertions.*;

public class HtmlTreeBuilderTest {
    @Test
    public void ensureSearchArraysAreSorted() {
        List<Object[]> constants = HtmlTreeBuilderStateTest.findConstantArrays(HtmlTreeBuilder.class);
        HtmlTreeBuilderStateTest.ensureSorted(constants);
        assertEquals(8, constants.size());
    }

    @Test
    public void nonnull() {
        assertThrows(IllegalArgumentException.class, () -> {
                HtmlTreeBuilder treeBuilder = new HtmlTreeBuilder();
                treeBuilder.parse(null, null, null); // not sure how to test that these visual warnings actually appear! - test below checks for method annotation
            }
        ); // I'm not convinced that this lambda is easier to read than the old Junit 4 @Test(expected=IEA.class)...
    }

    @Test public void nonnullAssertions() throws NoSuchMethodException {
        Method parseMethod = TreeBuilder.class.getDeclaredMethod(""parse"", Reader.class, String.class, Parser.class);
        assertNotNull(parseMethod);
        Annotation[] declaredAnnotations = parseMethod.getDeclaredAnnotations();
        boolean seen = false;
        for (Annotation annotation : declaredAnnotations) {
            if (annotation.annotationType().isAssignableFrom(ParametersAreNonnullByDefault.class))
                seen = true;
        }

        // would need to rework this if/when that annotation moves from the method to the class / package.
        assertTrue(seen);

    }
}
"
jhy/jsoup,src/main/java/org/jsoup/select/NodeFilter.java,"package org.jsoup.select;

import org.jsoup.nodes.Node;

/**
 * Node filter interface. Provide an implementing class to {@link NodeTraversor} to iterate through nodes.
 * <p>
 * This interface provides two methods, {@code head} and {@code tail}. The head method is called when the node is first
 * seen, and the tail method when all of the node's children have been visited. As an example, head can be used to
 * create a start tag for a node, and tail to create the end tag.
 * </p>
 * <p>
 * For every node, the filter has to decide whether to:
 * <ul>
 * <li>continue ({@link FilterResult#CONTINUE}),</li>
 * <li>skip all children ({@link FilterResult#SKIP_CHILDREN}),</li>
 * <li>skip node entirely ({@link FilterResult#SKIP_ENTIRELY}),</li>
 * <li>remove the subtree ({@link FilterResult#REMOVE}),</li>
 * <li>interrupt the iteration and return ({@link FilterResult#STOP}).</li>
 * </ul>
 * The difference between {@link FilterResult#SKIP_CHILDREN} and {@link FilterResult#SKIP_ENTIRELY} is that the first
 * will invoke {@link NodeFilter#tail(Node, int)} on the node, while the latter will not.
 * Within {@link NodeFilter#tail(Node, int)}, both are equivalent to {@link FilterResult#CONTINUE}.
 * </p>
 */
public interface NodeFilter {
    /**
     * Filter decision.
     */
    enum FilterResult {
        /** Continue processing the tree */
        CONTINUE,
        /** Skip the child nodes, but do call {@link NodeFilter#tail(Node, int)} next. */
        SKIP_CHILDREN,
        /** Skip the subtree, and do not call {@link NodeFilter#tail(Node, int)}. */
        SKIP_ENTIRELY,
        /** Remove the node and its children */
        REMOVE,
        /** Stop processing */
        STOP
    }

    /**
     * Callback for when a node is first visited.
     * @param node the node being visited.
     * @param depth the depth of the node, relative to the root node. E.g., the root node has depth 0, and a child node of that will have depth 1.
     * @return Filter decision
     */
    FilterResult head(Node node, int depth);

    /**
     * Callback for when a node is last visited, after all of its descendants have been visited.
     * <p>This method has a default implementation to return {@link FilterResult#CONTINUE}.</p>
     * @param node the node being visited.
     * @param depth the depth of the node, relative to the root node. E.g., the root node has depth 0, and a child node of that will have depth 1.
     * @return Filter decision
     */
    default FilterResult tail(Node node, int depth) {
        return FilterResult.CONTINUE;
    }
}
"
jhy/jsoup,src/main/java/org/jsoup/parser/XmlTreeBuilder.java,"package org.jsoup.parser;

import org.jsoup.helper.Validate;
import org.jsoup.nodes.CDataNode;
import org.jsoup.nodes.Comment;
import org.jsoup.nodes.Document;
import org.jsoup.nodes.DocumentType;
import org.jsoup.nodes.Element;
import org.jsoup.nodes.Entities;
import org.jsoup.nodes.Node;
import org.jsoup.nodes.TextNode;
import org.jsoup.nodes.XmlDeclaration;

import javax.annotation.ParametersAreNonnullByDefault;
import java.io.Reader;
import java.io.StringReader;
import java.util.List;

/**
 * Use the {@code XmlTreeBuilder} when you want to parse XML without any of the HTML DOM rules being applied to the
 * document.
 * <p>Usage example: {@code Document xmlDoc = Jsoup.parse(html, baseUrl, Parser.xmlParser());}</p>
 *
 * @author Jonathan Hedley
 */
public class XmlTreeBuilder extends TreeBuilder {
    ParseSettings defaultSettings() {
        return ParseSettings.preserveCase;
    }

    @Override @ParametersAreNonnullByDefault
    protected void initialiseParse(Reader input, String baseUri, Parser parser) {
        super.initialiseParse(input, baseUri, parser);
        stack.add(doc); // place the document onto the stack. differs from HtmlTreeBuilder (not on stack)
        doc.outputSettings()
            .syntax(Document.OutputSettings.Syntax.xml)
            .escapeMode(Entities.EscapeMode.xhtml)
            .prettyPrint(false); // as XML, we don't understand what whitespace is significant or not
    }

    Document parse(Reader input, String baseUri) {
        return parse(input, baseUri, new Parser(this));
    }

    Document parse(String input, String baseUri) {
        return parse(new StringReader(input), baseUri, new Parser(this));
    }

    @Override
    XmlTreeBuilder newInstance() {
        return new XmlTreeBuilder();
    }

    @Override
    protected boolean process(Token token) {
        // start tag, end tag, doctype, comment, character, eof
        switch (token.type) {
            case StartTag:
                insert(token.asStartTag());
                break;
            case EndTag:
                popStackToClose(token.asEndTag());
                break;
            case Comment:
                insert(token.asComment());
                break;
            case Character:
                insert(token.asCharacter());
                break;
            case Doctype:
                insert(token.asDoctype());
                break;
            case EOF: // could put some normalisation here if desired
                break;
            default:
                Validate.fail(""Unexpected token type: "" + token.type);
        }
        return true;
    }

    protected void insertNode(Node node) {
        currentElement().appendChild(node);
        onNodeInserted(node, null);
    }

    protected void insertNode(Node node, Token token) {
        currentElement().appendChild(node);
        onNodeInserted(node, token);
    }

    Element insert(Token.StartTag startTag) {
        Tag tag = tagFor(startTag.name(), settings);
        // todo: wonder if for xml parsing, should treat all tags as unknown? because it's not html.
        if (startTag.hasAttributes())
            startTag.attributes.deduplicate(settings);

        Element el = new Element(tag, null, settings.normalizeAttributes(startTag.attributes));
        insertNode(el, startTag);
        if (startTag.isSelfClosing()) {
            if (!tag.isKnownTag()) // unknown tag, remember this is self closing for output. see above.
                tag.setSelfClosing();
        } else {
            stack.add(el);
        }
        return el;
    }

    void insert(Token.Comment commentToken) {
        Comment comment = new Comment(commentToken.getData());
        Node insert = comment;
        if (commentToken.bogus && comment.isXmlDeclaration()) {
            // xml declarations are emitted as bogus comments (which is right for html, but not xml)
            // so we do a bit of a hack and parse the data as an element to pull the attributes out
            XmlDeclaration decl = comment.asXmlDeclaration(); // else, we couldn't parse it as a decl, so leave as a comment
            if (decl != null)
                insert = decl;
        }
        insertNode(insert, commentToken);
    }

    void insert(Token.Character token) {
        final String data = token.getData();
        insertNode(token.isCData() ? new CDataNode(data) : new TextNode(data), token);
    }

    void insert(Token.Doctype d) {
        DocumentType doctypeNode = new DocumentType(settings.normalizeTag(d.getName()), d.getPublicIdentifier(), d.getSystemIdentifier());
        doctypeNode.setPubSysKey(d.getPubSysKey());
        insertNode(doctypeNode, d);
    }

    /**
     * If the stack contains an element with this tag's name, pop up the stack to remove the first occurrence. If not
     * found, skips.
     *
     * @param endTag tag to close
     */
    protected void popStackToClose(Token.EndTag endTag) {
        // like in HtmlTreeBuilder - don't scan up forever for very (artificially) deeply nested stacks
        String elName = settings.normalizeTag(endTag.tagName);
        Element firstFound = null;

        final int bottom = stack.size() - 1;
        final int upper = bottom >= maxQueueDepth ? bottom - maxQueueDepth : 0;

        for (int pos = stack.size() -1; pos >= upper; pos--) {
            Element next = stack.get(pos);
            if (next.nodeName().equals(elName)) {
                firstFound = next;
                break;
            }
        }
        if (firstFound == null)
            return; // not found, skip

        for (int pos = stack.size() -1; pos >= 0; pos--) {
            Element next = stack.get(pos);
            stack.remove(pos);
            if (next == firstFound) {
                onNodeClosed(next, endTag);
                break;
            }
        }
    }
    private static final int maxQueueDepth = 256; // an arbitrary tension point between real XML and crafted pain



    List<Node> parseFragment(String inputFragment, String baseUri, Parser parser) {
        initialiseParse(new StringReader(inputFragment), baseUri, parser);
        runParser();
        return doc.childNodes();
    }

    List<Node> parseFragment(String inputFragment, Element context, String baseUri, Parser parser) {
        return parseFragment(inputFragment, baseUri, parser);
    }
}
"
jhy/jsoup,src/test/java/org/jsoup/nodes/DocumentTest.java,"package org.jsoup.nodes;

import org.jsoup.Jsoup;
import org.jsoup.TextUtil;
import org.jsoup.integration.ParseTest;
import org.jsoup.nodes.Document.OutputSettings;
import org.jsoup.nodes.Document.OutputSettings.Syntax;
import org.jsoup.parser.ParseSettings;
import org.jsoup.parser.Parser;
import org.jsoup.select.Elements;
import org.junit.jupiter.api.Disabled;
import org.junit.jupiter.api.Test;

import java.io.*;
import java.nio.charset.Charset;
import java.nio.charset.StandardCharsets;

import static org.junit.jupiter.api.Assertions.*;

/**
 Tests for Document.

 @author Jonathan Hedley, jonathan@hedley.net */
public class DocumentTest {
    private static final String charsetUtf8 = ""UTF-8"";
    private static final String charsetIso8859 = ""ISO-8859-1"";


    @Test public void setTextPreservesDocumentStructure() {
        Document doc = Jsoup.parse(""<p>Hello</p>"");
        doc.text(""Replaced"");
        assertEquals(""Replaced"", doc.text());
        assertEquals(""Replaced"", doc.body().text());
        assertEquals(1, doc.select(""head"").size());
    }

    @Test public void testTitles() {
        Document noTitle = Jsoup.parse(""<p>Hello</p>"");
        Document withTitle = Jsoup.parse(""<title>First</title><title>Ignore</title><p>Hello</p>"");

        assertEquals("""", noTitle.title());
        noTitle.title(""Hello"");
        assertEquals(""Hello"", noTitle.title());
        assertEquals(""Hello"", noTitle.select(""title"").first().text());

        assertEquals(""First"", withTitle.title());
        withTitle.title(""Hello"");
        assertEquals(""Hello"", withTitle.title());
        assertEquals(""Hello"", withTitle.select(""title"").first().text());

        Document normaliseTitle = Jsoup.parse(""<title>   Hello\nthere   \n   now   \n"");
        assertEquals(""Hello there now"", normaliseTitle.title());
    }

    @Test public void testOutputEncoding() {
        Document doc = Jsoup.parse(""<p title=œÄ>œÄ & < > </p>"");
        // default is utf-8
        assertEquals(""<p title=\""œÄ\"">œÄ &amp; &lt; &gt;</p>"", doc.body().html());
        assertEquals(""UTF-8"", doc.outputSettings().charset().name());

        doc.outputSettings().charset(""ascii"");
        assertEquals(Entities.EscapeMode.base, doc.outputSettings().escapeMode());
        assertEquals(""<p title=\""&#x3c0;\"">&#x3c0; &amp; &lt; &gt;</p>"", doc.body().html());

        doc.outputSettings().escapeMode(Entities.EscapeMode.extended);
        assertEquals(""<p title=\""&pi;\"">&pi; &amp; &lt; &gt;</p>"", doc.body().html());
    }

    @Test public void testXhtmlReferences() {
        Document doc = Jsoup.parse(""&lt; &gt; &amp; &quot; &apos; &times;"");
        doc.outputSettings().escapeMode(Entities.EscapeMode.xhtml);
        assertEquals(""&lt; &gt; &amp; \"" ' √ó"", doc.body().html());
    }

    @Test public void testNormalisesStructure() {
        Document doc = Jsoup.parse(""<html><head><script>one</script><noscript><p>two</p></noscript></head><body><p>three</p></body><p>four</p></html>"");
        assertEquals(""<html><head><script>one</script><noscript>&lt;p&gt;two</noscript></head><body><p>three</p><p>four</p></body></html>"", TextUtil.stripNewlines(doc.html()));
    }

    @Test public void accessorsWillNormalizeStructure() {
        Document doc = new Document("""");
        assertEquals("""", doc.html());

        Element body = doc.body();
        assertEquals(""body"", body.tagName());
        Element head = doc.head();
        assertEquals(""head"", head.tagName());
        assertEquals(""<html><head></head><body></body></html>"", TextUtil.stripNewlines(doc.html()));
    }

    @Test public void accessorsAreCaseInsensitive() {
        Parser parser = Parser.htmlParser().settings(ParseSettings.preserveCase);
        Document doc = parser.parseInput(""<!DOCTYPE html><HTML><HEAD><TITLE>SHOUTY</TITLE></HEAD><BODY>HELLO</BODY></HTML>"", """");

        Element body = doc.body();
        assertEquals(""BODY"", body.tagName());
        assertEquals(""body"", body.normalName());
        Element head = doc.head();
        assertEquals(""HEAD"", head.tagName());
        assertEquals(""body"", body.normalName());

        Element root = doc.selectFirst(""html"");
        assertEquals(""HTML"", root.tagName());
        assertEquals(""html"", root.normalName());
        assertEquals(""SHOUTY"", doc.title());
    }

    @Test public void testClone() {
        Document doc = Jsoup.parse(""<title>Hello</title> <p>One<p>Two"");
        Document clone = doc.clone();

        assertEquals(""<html><head><title>Hello</title></head><body><p>One</p><p>Two</p></body></html>"", TextUtil.stripNewlines(clone.html()));
        clone.title(""Hello there"");
        clone.expectFirst(""p"").text(""One more"").attr(""id"", ""1"");
        assertEquals(""<html><head><title>Hello there</title></head><body><p id=\""1\"">One more</p><p>Two</p></body></html>"", TextUtil.stripNewlines(clone.html()));
        assertEquals(""<html><head><title>Hello</title></head><body><p>One</p><p>Two</p></body></html>"", TextUtil.stripNewlines(doc.html()));
    }

    @Test void testBasicIndent() {
        Document doc = Jsoup.parse(""<title>Hello</title> <p>One<p>Two"");
        String expect = ""<html>\n <head>\n  <title>Hello</title>\n </head>\n <body>\n  <p>One</p>\n  <p>Two</p>\n </body>\n</html>"";
        assertEquals(expect, doc.html());
    }

    @Test public void testClonesDeclarations() {
        Document doc = Jsoup.parse(""<!DOCTYPE html><html><head><title>Doctype test"");
        Document clone = doc.clone();

        assertEquals(doc.html(), clone.html());
        assertEquals(""<!doctype html><html><head><title>Doctype test</title></head><body></body></html>"",
                TextUtil.stripNewlines(clone.html()));
    }

    @Test public void testLocation() throws IOException {
    	File in = ParseTest.getFile(""/htmltests/yahoo-jp.html.gz"");
        Document doc = Jsoup.parse(in, ""UTF-8"", ""http://www.yahoo.co.jp/index.html"");
        String location = doc.location();
        String baseUri = doc.baseUri();
        assertEquals(""http://www.yahoo.co.jp/index.html"",location);
        assertEquals(""http://www.yahoo.co.jp/_ylh=X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/"",baseUri);
        in = ParseTest.getFile(""/htmltests/nyt-article-1.html.gz"");
        doc = Jsoup.parse(in, null, ""http://www.nytimes.com/2010/07/26/business/global/26bp.html?hp"");
        location = doc.location();
        baseUri = doc.baseUri();
        assertEquals(""http://www.nytimes.com/2010/07/26/business/global/26bp.html?hp"",location);
        assertEquals(""http://www.nytimes.com/2010/07/26/business/global/26bp.html?hp"",baseUri);
    }

    @Test public void testLocationFromString() {
        Document doc = Jsoup.parse(""<p>Hello"");
        assertEquals("""", doc.location());
    }

    @Test public void testHtmlAndXmlSyntax() {
        String h = ""<!DOCTYPE html><body><img async checked='checked' src='&<>\""'>&lt;&gt;&amp;&quot;<foo />bar"";
        Document doc = Jsoup.parse(h);

        doc.outputSettings().syntax(Syntax.html);
        assertEquals(""<!doctype html>\n"" +
                ""<html>\n"" +
                "" <head></head>\n"" +
                "" <body>\n"" +
                ""  <img async checked src=\""&amp;<>&quot;\"">&lt;&gt;&amp;\""<foo />bar\n"" +
                "" </body>\n"" +
                ""</html>"", doc.html());

        doc.outputSettings().syntax(Document.OutputSettings.Syntax.xml);
        assertEquals(""<!DOCTYPE html>\n"" +
                ""<html>\n"" +
                "" <head></head>\n"" +
                "" <body>\n"" +
                ""  <img async=\""\"" checked=\""checked\"" src=\""&amp;&lt;>&quot;\"" />&lt;&gt;&amp;\""<foo />bar\n"" +
                "" </body>\n"" +
                ""</html>"", doc.html());
    }

    @Test public void htmlParseDefaultsToHtmlOutputSyntax() {
        Document doc = Jsoup.parse(""x"");
        assertEquals(Syntax.html, doc.outputSettings().syntax());
    }

    @Test public void testHtmlAppendable() {
    	String htmlContent = ""<html><head><title>Hello</title></head><body><p>One</p><p>Two</p></body></html>"";
    	Document document = Jsoup.parse(htmlContent);
    	OutputSettings outputSettings = new OutputSettings();

    	outputSettings.prettyPrint(false);
    	document.outputSettings(outputSettings);
    	assertEquals(htmlContent, document.html(new StringWriter()).toString());
    }

    @Test public void testOverflowClone() {
        StringBuilder sb = new StringBuilder();
        sb.append(""<head><base href='https://jsoup.org/'>"");
        for (int i = 0; i < 100000; i++) {
            sb.append(""<div>"");
        }
        sb.append(""<p>Hello <a href='/example.html'>there</a>"");

        Document doc = Jsoup.parse(sb.toString());

        String expectedLink = ""https://jsoup.org/example.html"";
        assertEquals(expectedLink, doc.selectFirst(""a"").attr(""abs:href""));
        Document clone = doc.clone();
        doc.hasSameValue(clone);
        assertEquals(expectedLink, clone.selectFirst(""a"").attr(""abs:href""));
    }

    @Test public void DocumentsWithSameContentAreEqual() {
        Document docA = Jsoup.parse(""<div/>One"");
        Document docB = Jsoup.parse(""<div/>One"");
        Document docC = Jsoup.parse(""<div/>Two"");

        assertNotEquals(docA, docB);
        assertEquals(docA, docA);
        assertEquals(docA.hashCode(), docA.hashCode());
        assertNotEquals(docA.hashCode(), docC.hashCode());
    }

    @Test public void DocumentsWithSameContentAreVerifiable() {
        Document docA = Jsoup.parse(""<div/>One"");
        Document docB = Jsoup.parse(""<div/>One"");
        Document docC = Jsoup.parse(""<div/>Two"");

        assertTrue(docA.hasSameValue(docB));
        assertFalse(docA.hasSameValue(docC));
    }

    @Test
    public void testMetaCharsetUpdateUtf8() {
        final Document doc = createHtmlDocument(""changeThis"");
        doc.updateMetaCharsetElement(true);
        doc.charset(Charset.forName(charsetUtf8));

        final String htmlCharsetUTF8 = ""<html>\n"" +
                                        "" <head>\n"" +
                                        ""  <meta charset=\"""" + charsetUtf8 + ""\"">\n"" +
                                        "" </head>\n"" +
                                        "" <body></body>\n"" +
                                        ""</html>"";
        assertEquals(htmlCharsetUTF8, doc.toString());

        Element selectedElement = doc.select(""meta[charset]"").first();
        assertEquals(charsetUtf8, doc.charset().name());
        assertEquals(charsetUtf8, selectedElement.attr(""charset""));
        assertEquals(doc.charset(), doc.outputSettings().charset());
    }

    @Test
    public void testMetaCharsetUpdateIso8859() {
        final Document doc = createHtmlDocument(""changeThis"");
        doc.updateMetaCharsetElement(true);
        doc.charset(Charset.forName(charsetIso8859));

        final String htmlCharsetISO = ""<html>\n"" +
                                        "" <head>\n"" +
                                        ""  <meta charset=\"""" + charsetIso8859 + ""\"">\n"" +
                                        "" </head>\n"" +
                                        "" <body></body>\n"" +
                                        ""</html>"";
        assertEquals(htmlCharsetISO, doc.toString());

        Element selectedElement = doc.select(""meta[charset]"").first();
        assertEquals(charsetIso8859, doc.charset().name());
        assertEquals(charsetIso8859, selectedElement.attr(""charset""));
        assertEquals(doc.charset(), doc.outputSettings().charset());
    }

    @Test
    public void testMetaCharsetUpdateNoCharset() {
        final Document docNoCharset = Document.createShell("""");
        docNoCharset.updateMetaCharsetElement(true);
        docNoCharset.charset(Charset.forName(charsetUtf8));

        assertEquals(charsetUtf8, docNoCharset.select(""meta[charset]"").first().attr(""charset""));

        final String htmlCharsetUTF8 = ""<html>\n"" +
                                        "" <head>\n"" +
                                        ""  <meta charset=\"""" + charsetUtf8 + ""\"">\n"" +
                                        "" </head>\n"" +
                                        "" <body></body>\n"" +
                                        ""</html>"";
        assertEquals(htmlCharsetUTF8, docNoCharset.toString());
    }

    @Test
    public void testMetaCharsetUpdateDisabled() {
        final Document docDisabled = Document.createShell("""");

        final String htmlNoCharset = ""<html>\n"" +
                                        "" <head></head>\n"" +
                                        "" <body></body>\n"" +
                                        ""</html>"";
        assertEquals(htmlNoCharset, docDisabled.toString());
        assertNull(docDisabled.select(""meta[charset]"").first());
    }

    @Test
    public void testMetaCharsetUpdateDisabledNoChanges() {
        final Document doc = createHtmlDocument(""dontTouch"");

        final String htmlCharset = ""<html>\n"" +
                                    "" <head>\n"" +
                                    ""  <meta charset=\""dontTouch\"">\n"" +
                                    ""  <meta name=\""charset\"" content=\""dontTouch\"">\n"" +
                                    "" </head>\n"" +
                                    "" <body></body>\n"" +
                                    ""</html>"";
        assertEquals(htmlCharset, doc.toString());

        Element selectedElement = doc.select(""meta[charset]"").first();
        assertNotNull(selectedElement);
        assertEquals(""dontTouch"", selectedElement.attr(""charset""));

        selectedElement = doc.select(""meta[name=charset]"").first();
        assertNotNull(selectedElement);
        assertEquals(""dontTouch"", selectedElement.attr(""content""));
    }

    @Test
    public void testMetaCharsetUpdateEnabledAfterCharsetChange() {
        final Document doc = createHtmlDocument(""dontTouch"");
        doc.charset(Charset.forName(charsetUtf8));

        Element selectedElement = doc.select(""meta[charset]"").first();
        assertEquals(charsetUtf8, selectedElement.attr(""charset""));
        assertTrue(doc.select(""meta[name=charset]"").isEmpty());
    }

    @Test
    public void testMetaCharsetUpdateCleanup() {
        final Document doc = createHtmlDocument(""dontTouch"");
        doc.updateMetaCharsetElement(true);
        doc.charset(Charset.forName(charsetUtf8));

        final String htmlCharsetUTF8 = ""<html>\n"" +
                                        "" <head>\n"" +
                                        ""  <meta charset=\"""" + charsetUtf8 + ""\"">\n"" +
                                        "" </head>\n"" +
                                        "" <body></body>\n"" +
                                        ""</html>"";

        assertEquals(htmlCharsetUTF8, doc.toString());
    }

    @Test
    public void testMetaCharsetUpdateXmlUtf8() {
        final Document doc = createXmlDocument(""1.0"", ""changeThis"", true);
        doc.updateMetaCharsetElement(true);
        doc.charset(Charset.forName(charsetUtf8));

        final String xmlCharsetUTF8 = ""<?xml version=\""1.0\"" encoding=\"""" + charsetUtf8 + ""\""?>\n"" +
                                        ""<root>\n"" +
                                        "" node\n"" +
                                        ""</root>"";
        assertEquals(xmlCharsetUTF8, doc.toString());

        XmlDeclaration selectedNode = (XmlDeclaration) doc.childNode(0);
        assertEquals(charsetUtf8, doc.charset().name());
        assertEquals(charsetUtf8, selectedNode.attr(""encoding""));
        assertEquals(doc.charset(), doc.outputSettings().charset());
    }

    @Test
    public void testMetaCharsetUpdateXmlIso8859() {
        final Document doc = createXmlDocument(""1.0"", ""changeThis"", true);
        doc.updateMetaCharsetElement(true);
        doc.charset(Charset.forName(charsetIso8859));

        final String xmlCharsetISO = ""<?xml version=\""1.0\"" encoding=\"""" + charsetIso8859 + ""\""?>\n"" +
                                        ""<root>\n"" +
                                        "" node\n"" +
                                        ""</root>"";
        assertEquals(xmlCharsetISO, doc.toString());

        XmlDeclaration selectedNode = (XmlDeclaration) doc.childNode(0);
        assertEquals(charsetIso8859, doc.charset().name());
        assertEquals(charsetIso8859, selectedNode.attr(""encoding""));
        assertEquals(doc.charset(), doc.outputSettings().charset());
    }

    @Test
    public void testMetaCharsetUpdateXmlNoCharset() {
        final Document doc = createXmlDocument(""1.0"", ""none"", false);
        doc.updateMetaCharsetElement(true);
        doc.charset(Charset.forName(charsetUtf8));

        final String xmlCharsetUTF8 = ""<?xml version=\""1.0\"" encoding=\"""" + charsetUtf8 + ""\""?>\n"" +
                                        ""<root>\n"" +
                                        "" node\n"" +
                                        ""</root>"";
        assertEquals(xmlCharsetUTF8, doc.toString());

        XmlDeclaration selectedNode = (XmlDeclaration) doc.childNode(0);
        assertEquals(charsetUtf8, selectedNode.attr(""encoding""));
    }

    @Test
    public void testMetaCharsetUpdateXmlDisabled() {
        final Document doc = createXmlDocument(""none"", ""none"", false);

        final String xmlNoCharset = ""<root>\n"" +
                                    "" node\n"" +
                                    ""</root>"";
        assertEquals(xmlNoCharset, doc.toString());
    }

    @Test
    public void testMetaCharsetUpdateXmlDisabledNoChanges() {
        final Document doc = createXmlDocument(""dontTouch"", ""dontTouch"", true);

        final String xmlCharset = ""<?xml version=\""dontTouch\"" encoding=\""dontTouch\""?>\n"" +
                                    ""<root>\n"" +
                                    "" node\n"" +
                                    ""</root>"";
        assertEquals(xmlCharset, doc.toString());

        XmlDeclaration selectedNode = (XmlDeclaration) doc.childNode(0);
        assertEquals(""dontTouch"", selectedNode.attr(""encoding""));
        assertEquals(""dontTouch"", selectedNode.attr(""version""));
    }

    @Test
    public void testMetaCharsetUpdatedDisabledPerDefault() {
        final Document doc = createHtmlDocument(""none"");
        assertFalse(doc.updateMetaCharsetElement());
    }

    private Document createHtmlDocument(String charset) {
        final Document doc = Document.createShell("""");
        doc.head().appendElement(""meta"").attr(""charset"", charset);
        doc.head().appendElement(""meta"").attr(""name"", ""charset"").attr(""content"", charset);

        return doc;
    }

    private Document createXmlDocument(String version, String charset, boolean addDecl) {
        final Document doc = new Document("""");
        doc.appendElement(""root"").text(""node"");
        doc.outputSettings().syntax(Syntax.xml);

        if(addDecl) {
            XmlDeclaration decl = new XmlDeclaration(""xml"", false);
            decl.attr(""version"", version);
            decl.attr(""encoding"", charset);
            doc.prependChild(decl);
        }

        return doc;
    }

    @Test
    public void testShiftJisRoundtrip() throws Exception {
        String input =
                ""<html>""
                        +   ""<head>""
                        +     ""<meta http-equiv=\""content-type\"" content=\""text/html; charset=Shift_JIS\"" />""
                        +   ""</head>""
                        +   ""<body>""
                        +     ""before&nbsp;after""
                        +   ""</body>""
                        + ""</html>"";
        InputStream is = new ByteArrayInputStream(input.getBytes(StandardCharsets.US_ASCII));

        Document doc = Jsoup.parse(is, null, ""http://example.com"");
        doc.outputSettings().escapeMode(Entities.EscapeMode.xhtml);

        String output = new String(doc.html().getBytes(doc.outputSettings().charset()), doc.outputSettings().charset());

        assertFalse(output.contains(""?""), ""Should not have contained a '?'."");
        assertTrue(output.contains(""&#xa0;"") || output.contains(""&nbsp;""),
                ""Should have contained a '&#xa0;' or a '&nbsp;'."");
    }

    @Test public void parseAndHtmlOnDifferentThreads() throws InterruptedException {
        String html = ""<p>Alrighty then it's not \uD83D\uDCA9. <span>Next</span></p>""; // üí©
        String asci = ""<p>Alrighty then it's not &#x1f4a9;. <span>Next</span></p>"";

        final Document doc = Jsoup.parse(html);
        final String[] out = new String[1];
        final Elements p = doc.select(""p"");
        assertEquals(html, p.outerHtml());

        Thread thread = new Thread(() -> {
            out[0] = p.outerHtml();
            doc.outputSettings().charset(StandardCharsets.US_ASCII);
        });
        thread.start();
        thread.join();

        assertEquals(html, out[0]);
        assertEquals(StandardCharsets.US_ASCII, doc.outputSettings().charset());
        assertEquals(asci, p.outerHtml());
    }

    @Test public void testDocumentTypeGet() {
        String html = ""\n\n<!-- comment -->  <!doctype html><p>One</p>"";
        Document doc = Jsoup.parse(html);
        DocumentType documentType = doc.documentType();
        assertNotNull(documentType);
        assertEquals(""html"", documentType.name());
    }

    @Test public void framesetSupportsBodyMethod() {
        String html = ""<html><head><title>Frame Test</title></head><frameset id=id><frame src=foo.html></frameset>"";
        Document doc = Jsoup.parse(html);
        Element head = doc.head();
        assertNotNull(head);
        assertEquals(""Frame Test"", doc.title());

        // Frameset docs per html5 spec have no body element - but instead a frameset elelemt
        assertNull(doc.selectFirst(""body""));
        Element frameset = doc.selectFirst(""frameset"");
        assertNotNull(frameset);

        // the body() method returns body or frameset and does not otherwise modify the document
        // doing it in body() vs parse keeps the html close to original for round-trip option
        Element body = doc.body();
        assertNotNull(body);
        assertSame(frameset, body);
        assertEquals(""frame"", body.child(0).tagName());

        assertNull(doc.selectFirst(""body"")); // did not vivify a body element

        String expected = ""<html>\n"" +
            "" <head>\n"" +
            ""  <title>Frame Test</title>\n"" +
            "" </head>\n"" +
            "" <frameset id=\""id\"">\n"" +
            ""  <frame src=\""foo.html\"">\n"" +
            "" </frameset>\n"" +
            ""</html>"";
        assertEquals(expected, doc.html());
    }
}
"
jhy/jsoup,src/main/java/org/jsoup/select/CombiningEvaluator.java,"package org.jsoup.select;

import org.jsoup.internal.StringUtil;
import org.jsoup.nodes.Element;

import javax.annotation.Nullable;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;

/**
 * Base combining (and, or) evaluator.
 */
public abstract class CombiningEvaluator extends Evaluator {
    final ArrayList<Evaluator> evaluators;
    int num = 0;

    CombiningEvaluator() {
        super();
        evaluators = new ArrayList<>();
    }

    CombiningEvaluator(Collection<Evaluator> evaluators) {
        this();
        this.evaluators.addAll(evaluators);
        updateNumEvaluators();
    }

    @Nullable Evaluator rightMostEvaluator() {
        return num > 0 ? evaluators.get(num - 1) : null;
    }
    
    void replaceRightMostEvaluator(Evaluator replacement) {
        evaluators.set(num - 1, replacement);
    }

    void updateNumEvaluators() {
        // used so we don't need to bash on size() for every match test
        num = evaluators.size();
    }

    public static final class And extends CombiningEvaluator {
        And(Collection<Evaluator> evaluators) {
            super(evaluators);
        }

        And(Evaluator... evaluators) {
            this(Arrays.asList(evaluators));
        }

        @Override
        public boolean matches(Element root, Element node) {
            for (int i = num - 1; i >= 0; i--) { // process backwards so that :matchText is evaled earlier, to catch parent query. todo - should redo matchText to virtually expand during match, not pre-match (see SelectorTest#findBetweenSpan)
                Evaluator s = evaluators.get(i);
                if (!s.matches(root, node))
                    return false;
            }
            return true;
        }

        @Override
        public String toString() {
            return StringUtil.join(evaluators, """");
        }
    }

    public static final class Or extends CombiningEvaluator {
        /**
         * Create a new Or evaluator. The initial evaluators are ANDed together and used as the first clause of the OR.
         * @param evaluators initial OR clause (these are wrapped into an AND evaluator).
         */
        Or(Collection<Evaluator> evaluators) {
            super();
            if (num > 1)
                this.evaluators.add(new And(evaluators));
            else // 0 or 1
                this.evaluators.addAll(evaluators);
            updateNumEvaluators();
        }

        Or(Evaluator... evaluators) { this(Arrays.asList(evaluators)); }

        Or() {
            super();
        }

        public void add(Evaluator e) {
            evaluators.add(e);
            updateNumEvaluators();
        }

        @Override
        public boolean matches(Element root, Element node) {
            for (int i = 0; i < num; i++) {
                Evaluator s = evaluators.get(i);
                if (s.matches(root, node))
                    return true;
            }
            return false;
        }

        @Override
        public String toString() {
            return StringUtil.join(evaluators, "", "");
        }
    }
}
"
jhy/jsoup,src/test/java/org/jsoup/integration/servlets/CookieServlet.java,"package org.jsoup.integration.servlets;

import org.jsoup.integration.TestServer;

import javax.servlet.ServletException;
import javax.servlet.http.Cookie;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.io.PrintWriter;

public class CookieServlet extends BaseServlet{
    public static final String Url = TestServer.map(CookieServlet.class);
    public static final String SetCookiesParam = ""setCookies"";
    public static final String LocationParam = ""loc"";


    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse res) throws ServletException, IOException {
        doIt(req, res);
    }

    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse res) throws ServletException, IOException {
        doIt(req, res);
    }

    @Override
    protected void doPut(HttpServletRequest req, HttpServletResponse res) throws ServletException, IOException {
        doIt(req, res);
    }

    private void doIt(HttpServletRequest req, HttpServletResponse res) throws IOException {
        // Do we want to set cookies?
        if (req.getParameter(SetCookiesParam) != null)
            setCookies(res);

        // Do we want to redirect elsewhere?
        String loc = req.getParameter(LocationParam);
        if (loc != null) {
            res.sendRedirect(loc);
            return;
        }

        // print out the cookies that were received
        res.setContentType(TextHtml);
        res.setStatus(200);

        PrintWriter w = res.getWriter();
        w.println(""<table>"");
        final Cookie[] cookies = req.getCookies();
        if (cookies != null) {
            for (Cookie cookie : cookies) {
                EchoServlet.write(w, cookie.getName(), cookie.getValue());
            }
        }
        w.println(""</table>"");
    }

    private void setCookies(HttpServletResponse res) {
        Cookie one = new Cookie(""One"", ""Root"");
        one.setPath(""/"");
        res.addCookie(one);

        Cookie two = new Cookie(""One"", ""CookieServlet"");
        two.setPath(""/CookieServlet"");
        two.setHttpOnly(true);
        two.setComment(""Quite nice"");
        res.addCookie(two);

        Cookie three = new Cookie(""One"", ""EchoServlet"");
        three.setPath(""/EchoServlet"");
        res.addCookie(three);
    }

}
"
jhy/jsoup,src/main/java/org/jsoup/parser/ParseSettings.java,"package org.jsoup.parser;

import org.jsoup.nodes.Attributes;
import javax.annotation.Nullable;
import static org.jsoup.internal.Normalizer.lowerCase;

/**
 * Controls parser case settings, to optionally preserve tag and/or attribute name case.
 */
public class ParseSettings {
    /**
     * HTML default settings: both tag and attribute names are lower-cased during parsing.
     */
    public static final ParseSettings htmlDefault;
    /**
     * Preserve both tag and attribute case.
     */
    public static final ParseSettings preserveCase;

    static {
        htmlDefault = new ParseSettings(false, false);
        preserveCase = new ParseSettings(true, true);
    }

    private final boolean preserveTagCase;
    private final boolean preserveAttributeCase;

    /**
     * Returns true if preserving tag name case.
     */
    public boolean preserveTagCase() {
        return preserveTagCase;
    }

    /**
     * Returns true if preserving attribute case.
     */
    public boolean preserveAttributeCase() {
        return preserveAttributeCase;
    }

    /**
     * Define parse settings.
     * @param tag preserve tag case?
     * @param attribute preserve attribute name case?
     */
    public ParseSettings(boolean tag, boolean attribute) {
        preserveTagCase = tag;
        preserveAttributeCase = attribute;
    }

    ParseSettings(ParseSettings copy) {
        this(copy.preserveTagCase, copy.preserveAttributeCase);
    }

    /**
     * Normalizes a tag name according to the case preservation setting.
     */
    public String normalizeTag(String name) {
        name = name.trim();
        if (!preserveTagCase)
            name = lowerCase(name);
        return name;
    }

    /**
     * Normalizes an attribute according to the case preservation setting.
     */
    public String normalizeAttribute(String name) {
        name = name.trim();
        if (!preserveAttributeCase)
            name = lowerCase(name);
        return name;
    }

    @Nullable Attributes normalizeAttributes(@Nullable Attributes attributes) {
        if (attributes != null && !preserveAttributeCase) {
            attributes.normalize();
        }
        return attributes;
    }

    /** Returns the normal name that a Tag will have (trimmed and lower-cased) */
    static String normalName(String name) {
        return lowerCase(name.trim());
    }
}
"
jhy/jsoup,src/main/java/org/jsoup/helper/Validate.java,"package org.jsoup.helper;

import javax.annotation.Nullable;

/**
 * Validators to check that method arguments meet expectations. 
 */
public final class Validate {
    
    private Validate() {}

    /**
     * Validates that the object is not null
     * @param obj object to test
     * @throws ValidationException if the object is null
     */
    public static void notNull(@Nullable Object obj) {
        if (obj == null)
            throw new ValidationException(""Object must not be null"");
    }

    /**
     Validates that the parameter is not null

     * @param obj the parameter to test
     * @param param the name of the parameter, for presentation in the validation exception.
     * @throws ValidationException if the object is null
     */
    public static void notNullParam(@Nullable final Object obj, final String param) {
        if (obj == null)
            throw new ValidationException(String.format(""The parameter '%s' must not be null."", param));
    }

    /**
     * Validates that the object is not null
     * @param obj object to test
     * @param msg message to include in the Exception if validation fails
     * @throws ValidationException if the object is null
     */
    public static void notNull(@Nullable Object obj, String msg) {
        if (obj == null)
            throw new ValidationException(msg);
    }

    /**
     Verifies the input object is not null, and returns that object. Effectively this casts a nullable object to a non-
     null object. (Works around lack of Objects.requestNonNull in Android version.)
     * @param obj nullable object to case to not-null
     * @return the object, or throws an exception if it is null
     * @throws ValidationException if the object is null
     */
    public static Object ensureNotNull(@Nullable Object obj) {
        if (obj == null)
            throw new ValidationException(""Object must not be null"");
        else return obj;
    }

    /**
     Verifies the input object is not null, and returns that object. Effectively this casts a nullable object to a non-
     null object. (Works around lack of Objects.requestNonNull in Android version.)
     * @param obj nullable object to case to not-null
     * @param msg the String format message to include in the validation exception when thrown
     * @param args the arguments to the msg
     * @return the object, or throws an exception if it is null
     * @throws ValidationException if the object is null
     */
    public static Object ensureNotNull(@Nullable Object obj, String msg, Object... args) {
        if (obj == null)
            throw new ValidationException(String.format(msg, args));
        else return obj;
    }

    /**
     * Validates that the value is true
     * @param val object to test
     * @throws ValidationException if the object is not true
     */
    public static void isTrue(boolean val) {
        if (!val)
            throw new ValidationException(""Must be true"");
    }

    /**
     * Validates that the value is true
     * @param val object to test
     * @param msg message to include in the Exception if validation fails
     * @throws ValidationException if the object is not true
     */
    public static void isTrue(boolean val, String msg) {
        if (!val)
            throw new ValidationException(msg);
    }

    /**
     * Validates that the value is false
     * @param val object to test
     * @throws ValidationException if the object is not false
     */
    public static void isFalse(boolean val) {
        if (val)
            throw new ValidationException(""Must be false"");
    }

    /**
     * Validates that the value is false
     * @param val object to test
     * @param msg message to include in the Exception if validation fails
     * @throws ValidationException if the object is not false
     */
    public static void isFalse(boolean val, String msg) {
        if (val)
            throw new ValidationException(msg);
    }

    /**
     * Validates that the array contains no null elements
     * @param objects the array to test
     * @throws ValidationException if the array contains a null element
     */
    public static void noNullElements(Object[] objects) {
        noNullElements(objects, ""Array must not contain any null objects"");
    }

    /**
     * Validates that the array contains no null elements
     * @param objects the array to test
     * @param msg message to include in the Exception if validation fails
     * @throws ValidationException if the array contains a null element
     */
    public static void noNullElements(Object[] objects, String msg) {
        for (Object obj : objects)
            if (obj == null)
                throw new ValidationException(msg);
    }

    /**
     * Validates that the string is not null and is not empty
     * @param string the string to test
     * @throws ValidationException if the string is null or empty
     */
    public static void notEmpty(@Nullable String string) {
        if (string == null || string.length() == 0)
            throw new ValidationException(""String must not be empty"");
    }

    /**
     Validates that the string parameter is not null and is not empty
     * @param string the string to test
     * @param param the name of the parameter, for presentation in the validation exception.
     * @throws ValidationException if the string is null or empty
     */
    public static void notEmptyParam(@Nullable final String string, final String param) {
        if (string == null || string.length() == 0)
            throw new ValidationException(String.format(""The '%s' parameter must not be empty."", param));
    }

    /**
     * Validates that the string is not null and is not empty
     * @param string the string to test
     * @param msg message to include in the Exception if validation fails
     * @throws ValidationException if the string is null or empty
     */
    public static void notEmpty(@Nullable String string, String msg) {
        if (string == null || string.length() == 0)
            throw new ValidationException(msg);
    }

    /**
     * Blow up if we reach an unexpected state.
     * @param msg message to think about
     * @throws IllegalStateException if we reach this state
     */
    public static void wtf(String msg) {
        throw new IllegalStateException(msg);
    }

    /**
     Cause a failure.
     @param msg message to output.
     @throws IllegalStateException if we reach this state
     */
    public static void fail(String msg) {
        throw new ValidationException(msg);
    }
}
"
jhy/jsoup,src/test/java/org/jsoup/nodes/CommentTest.java,"package org.jsoup.nodes;

import org.jsoup.Jsoup;
import org.junit.jupiter.api.Test;

import static org.junit.jupiter.api.Assertions.*;

public class CommentTest {
    private Comment comment = new Comment("" This is one heck of a comment! "");
    private Comment decl = new Comment(""?xml encoding='ISO-8859-1'?"");

    @Test
    public void nodeName() {
        assertEquals(""#comment"", comment.nodeName());
    }

    @Test
    public void getData() {
        assertEquals("" This is one heck of a comment! "", comment.getData());
    }

    @Test
    public void testToString() {
        assertEquals(""<!-- This is one heck of a comment! -->"", comment.toString());

        Document doc = Jsoup.parse(""<div><!-- comment--></div>"");
        assertEquals(""<div>\n <!-- comment-->\n</div>"", doc.body().html());

        doc = Jsoup.parse(""<p>One<!-- comment -->Two</p>"");
        assertEquals(""<p>One<!-- comment -->Two</p>"", doc.body().html());
        assertEquals(""OneTwo"", doc.text());
    }

    @Test
    public void testHtmlNoPretty() {
        Document doc = Jsoup.parse(""<!-- a simple comment -->"");
        doc.outputSettings().prettyPrint(false);
        assertEquals(""<!-- a simple comment --><html><head></head><body></body></html>"", doc.html());
        Node node = doc.childNode(0);
        Comment c1 = (Comment) node;
        assertEquals(""<!-- a simple comment -->"", c1.outerHtml());
    }

    @Test
    public void testClone() {
        Comment c1 = comment.clone();
        assertNotSame(comment, c1);
        assertEquals(comment.getData(), comment.getData());
        c1.setData(""New"");
        assertEquals(""New"", c1.getData());
        assertNotEquals(c1.getData(), comment.getData());
    }

    @Test
    public void isXmlDeclaration() {
        assertFalse(comment.isXmlDeclaration());
        assertTrue(decl.isXmlDeclaration());
    }

    @Test
    public void asXmlDeclaration() {
        XmlDeclaration xmlDeclaration = decl.asXmlDeclaration();
        assertNotNull(xmlDeclaration);
    }
}
"
jhy/jsoup,src/test/java/org/jsoup/integration/servlets/FileServlet.java,"package org.jsoup.integration.servlets;

import org.jsoup.integration.ParseTest;
import org.jsoup.integration.TestServer;

import javax.servlet.ServletOutputStream;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.File;
import java.io.IOException;
import java.nio.file.Files;

public class FileServlet extends BaseServlet {
    public static final String Url = TestServer.map(FileServlet.class);
    public static final String ContentTypeParam = ""contentType"";
    public static final String DefaultType = ""text/html"";

    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse res) throws IOException {
        String contentType = req.getParameter(ContentTypeParam);
        if (contentType == null)
            contentType = DefaultType;
        String location = req.getPathInfo();

        File file = ParseTest.getFile(location);
        if (file.exists()) {
            res.setContentType(contentType);
            if (file.getName().endsWith(""gz""))
                res.addHeader(""Content-Encoding"", ""gzip"");
            res.setStatus(HttpServletResponse.SC_OK);

            ServletOutputStream out = res.getOutputStream();
            Files.copy(file.toPath(), out);
            out.flush();
        } else {
            res.setStatus(HttpServletResponse.SC_NOT_FOUND);
        }
    }

    public static String urlTo(String path) {
        return Url + path;
    }

    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse res) throws IOException {
        doGet(req, res);
    }
}
"
jhy/jsoup,src/main/java/org/jsoup/helper/ValidationException.java,"package org.jsoup.helper;

import java.util.ArrayList;
import java.util.List;

/**
 Validation exceptions, as thrown by the methods in {@link Validate}.
 */
public class ValidationException extends IllegalArgumentException {

    public static final String Validator = Validate.class.getName();

    public ValidationException(String msg) {
        super(msg);
    }

    @Override
    public synchronized Throwable fillInStackTrace() {
        // Filters out the Validate class from the stacktrace, to more clearly point at the root-cause.

        super.fillInStackTrace();

        StackTraceElement[] stackTrace = getStackTrace();
        List<StackTraceElement> filteredTrace = new ArrayList<>();
        for (StackTraceElement trace : stackTrace) {
            if (trace.getClassName().equals(Validator)) continue;
            filteredTrace.add(trace);
        }

        setStackTrace(filteredTrace.toArray(new StackTraceElement[0]));

        return this;
    }
}
"
jhy/jsoup,src/main/java/org/jsoup/HttpStatusException.java,"package org.jsoup;

import java.io.IOException;

/**
 * Signals that a HTTP request resulted in a not OK HTTP response.
 */
public class HttpStatusException extends IOException {
    private final int statusCode;
    private final String url;

    public HttpStatusException(String message, int statusCode, String url) {
        super(message + "". Status="" + statusCode + "", URL=["" + url + ""]"");
        this.statusCode = statusCode;
        this.url = url;
    }

    public int getStatusCode() {
        return statusCode;
    }

    public String getUrl() {
        return url;
    }
}
"
jhy/jsoup,src/test/java/org/jsoup/integration/servlets/HelloServlet.java,"package org.jsoup.integration.servlets;

import org.jsoup.integration.TestServer;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;

public class HelloServlet extends BaseServlet {
    public static final String Url = TestServer.map(HelloServlet.class);

    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse res) throws IOException {
        res.setContentType(TextHtml);
        res.setStatus(HttpServletResponse.SC_OK);

        String doc = ""<p>Hello, World!"";
        res.getWriter().write(doc);
    }
}
"
jhy/jsoup,src/main/java/org/jsoup/nodes/FormElement.java,"package org.jsoup.nodes;

import org.jsoup.Connection;
import org.jsoup.Jsoup;
import org.jsoup.helper.HttpConnection;
import org.jsoup.helper.Validate;
import org.jsoup.parser.Tag;
import org.jsoup.select.Elements;

import java.util.ArrayList;
import java.util.List;

/**
 * A HTML Form Element provides ready access to the form fields/controls that are associated with it. It also allows a
 * form to easily be submitted.
 */
public class FormElement extends Element {
    private final Elements elements = new Elements();

    /**
     * Create a new, standalone form element.
     *
     * @param tag        tag of this element
     * @param baseUri    the base URI
     * @param attributes initial attributes
     */
    public FormElement(Tag tag, String baseUri, Attributes attributes) {
        super(tag, baseUri, attributes);
    }

    /**
     * Get the list of form control elements associated with this form.
     * @return form controls associated with this element.
     */
    public Elements elements() {
        return elements;
    }

    /**
     * Add a form control element to this form.
     * @param element form control to add
     * @return this form element, for chaining
     */
    public FormElement addElement(Element element) {
        elements.add(element);
        return this;
    }

    @Override
    protected void removeChild(Node out) {
        super.removeChild(out);
        elements.remove(out);
    }

    /**
     Prepare to submit this form. A Connection object is created with the request set up from the form values. This
     Connection will inherit the settings and the cookies (etc) of the connection/session used to request this Document
     (if any), as available in {@link Document#connection()}
     <p>You can then set up other options (like user-agent, timeout, cookies), then execute it.</p>

     @return a connection prepared from the values of this form, in the same session as the one used to request it
     @throws IllegalArgumentException if the form's absolute action URL cannot be determined. Make sure you pass the
     document's base URI when parsing.
     */
    public Connection submit() {
        String action = hasAttr(""action"") ? absUrl(""action"") : baseUri();
        Validate.notEmpty(action, ""Could not determine a form action URL for submit. Ensure you set a base URI when parsing."");
        Connection.Method method = attr(""method"").equalsIgnoreCase(""POST"") ?
                Connection.Method.POST : Connection.Method.GET;

        Document owner = ownerDocument();
        Connection connection = owner != null? owner.connection().newRequest() : Jsoup.newSession();
        return connection.url(action)
                .data(formData())
                .method(method);
    }

    /**
     * Get the data that this form submits. The returned list is a copy of the data, and changes to the contents of the
     * list will not be reflected in the DOM.
     * @return a list of key vals
     */
    public List<Connection.KeyVal> formData() {
        ArrayList<Connection.KeyVal> data = new ArrayList<>();

        // iterate the form control elements and accumulate their values
        for (Element el: elements) {
            if (!el.tag().isFormSubmittable()) continue; // contents are form listable, superset of submitable
            if (el.hasAttr(""disabled"")) continue; // skip disabled form inputs
            String name = el.attr(""name"");
            if (name.length() == 0) continue;
            String type = el.attr(""type"");

            if (type.equalsIgnoreCase(""button"")) continue; // browsers don't submit these

            if (""select"".equals(el.normalName())) {
                Elements options = el.select(""option[selected]"");
                boolean set = false;
                for (Element option: options) {
                    data.add(HttpConnection.KeyVal.create(name, option.val()));
                    set = true;
                }
                if (!set) {
                    Element option = el.selectFirst(""option"");
                    if (option != null)
                        data.add(HttpConnection.KeyVal.create(name, option.val()));
                }
            } else if (""checkbox"".equalsIgnoreCase(type) || ""radio"".equalsIgnoreCase(type)) {
                // only add checkbox or radio if they have the checked attribute
                if (el.hasAttr(""checked"")) {
                    final String val = el.val().length() >  0 ? el.val() : ""on"";
                    data.add(HttpConnection.KeyVal.create(name, val));
                }
            } else {
                data.add(HttpConnection.KeyVal.create(name, el.val()));
            }
        }
        return data;
    }

    @Override
    public FormElement clone() {
        return (FormElement) super.clone();
    }
}
"
jhy/jsoup,src/main/java/org/jsoup/internal/ConstrainableInputStream.java,"package org.jsoup.internal;

import org.jsoup.helper.Validate;

import java.io.BufferedInputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.net.SocketTimeoutException;
import java.nio.ByteBuffer;

/**
 * A jsoup internal class (so don't use it as there is no contract API) that enables constraints on an Input Stream,
 * namely a maximum read size, and the ability to Thread.interrupt() the read.
 */
public final class ConstrainableInputStream extends BufferedInputStream {
    private static final int DefaultSize = 1024 * 32;

    private final boolean capped;
    private final int maxSize;
    private long startTime;
    private long timeout = 0; // optional max time of request
    private int remaining;
    private boolean interrupted;

    private ConstrainableInputStream(InputStream in, int bufferSize, int maxSize) {
        super(in, bufferSize);
        Validate.isTrue(maxSize >= 0);
        this.maxSize = maxSize;
        remaining = maxSize;
        capped = maxSize != 0;
        startTime = System.nanoTime();
    }

    /**
     * If this InputStream is not already a ConstrainableInputStream, let it be one.
     * @param in the input stream to (maybe) wrap
     * @param bufferSize the buffer size to use when reading
     * @param maxSize the maximum size to allow to be read. 0 == infinite.
     * @return a constrainable input stream
     */
    public static ConstrainableInputStream wrap(InputStream in, int bufferSize, int maxSize) {
        return in instanceof ConstrainableInputStream
            ? (ConstrainableInputStream) in
            : new ConstrainableInputStream(in, bufferSize, maxSize);
    }

    @Override
    public int read(byte[] b, int off, int len) throws IOException {
        if (interrupted || capped && remaining <= 0)
            return -1;
        if (Thread.interrupted()) {
            // interrupted latches, because parse() may call twice (and we still want the thread interupt to clear)
            interrupted = true;
            return -1;
        }
        if (expired())
            throw new SocketTimeoutException(""Read timeout"");

        if (capped && len > remaining)
            len = remaining; // don't read more than desired, even if available

        try {
            final int read = super.read(b, off, len);
            remaining -= read;
            return read;
        } catch (SocketTimeoutException e) {
            return 0;
        }
    }

    /**
     * Reads this inputstream to a ByteBuffer. The supplied max may be less than the inputstream's max, to support
     * reading just the first bytes.
     */
    public ByteBuffer readToByteBuffer(int max) throws IOException {
        Validate.isTrue(max >= 0, ""maxSize must be 0 (unlimited) or larger"");
        final boolean localCapped = max > 0; // still possibly capped in total stream
        final int bufferSize = localCapped && max < DefaultSize ? max : DefaultSize;
        final byte[] readBuffer = new byte[bufferSize];
        final ByteArrayOutputStream outStream = new ByteArrayOutputStream(bufferSize);

        int read;
        int remaining = max;
        while (true) {
            read = read(readBuffer, 0, localCapped ? Math.min(remaining, bufferSize) : bufferSize);
            if (read == -1) break;
            if (localCapped) { // this local byteBuffer cap may be smaller than the overall maxSize (like when reading first bytes)
                if (read >= remaining) {
                    outStream.write(readBuffer, 0, remaining);
                    break;
                }
                remaining -= read;
            }
            outStream.write(readBuffer, 0, read);
        }
        return ByteBuffer.wrap(outStream.toByteArray());
    }

    @Override
    public void reset() throws IOException {
        super.reset();
        remaining = maxSize - markpos;
    }

    public ConstrainableInputStream timeout(long startTimeNanos, long timeoutMillis) {
        this.startTime = startTimeNanos;
        this.timeout = timeoutMillis * 1000000;
        return this;
    }

    private boolean expired() {
        if (timeout == 0)
            return false;

        final long now = System.nanoTime();
        final long dur = now - startTime;
        return (dur > timeout);
    }
}
"
jhy/jsoup,src/test/java/org/jsoup/integration/ConnectIT.java,"package org.jsoup.integration;

import org.jsoup.Connection;
import org.jsoup.Jsoup;
import org.jsoup.integration.servlets.FileServlet;
import org.jsoup.integration.servlets.SlowRider;
import org.jsoup.internal.ConstrainableInputStream;
import org.jsoup.nodes.Document;
import org.jsoup.nodes.Element;
import org.junit.jupiter.api.Test;

import java.io.BufferedInputStream;
import java.io.IOException;
import java.net.SocketTimeoutException;
import java.nio.ByteBuffer;
import java.nio.charset.StandardCharsets;

import static org.junit.jupiter.api.Assertions.*;

/**
 * Failsafe integration tests for Connect methods. These take a bit longer to run, so included as Integ, not Unit, tests.
 */
public class ConnectIT {
    // Slow Rider tests.
    @Test
    public void canInterruptBodyStringRead() throws InterruptedException {
        // todo - implement in interruptable channels, so it's immediate
        final String[] body = new String[1];
        Thread runner = new Thread(() -> {
            try {
                Connection.Response res = Jsoup.connect(SlowRider.Url)
                    .timeout(15 * 1000)
                    .execute();
                body[0] = res.body();
            } catch (IOException e) {
                throw new RuntimeException(e);
            }

        });

        runner.start();
        Thread.sleep(1000 * 3);
        runner.interrupt();
        assertTrue(runner.isInterrupted());
        runner.join();

        assertTrue(body[0].length() > 0);
        assertTrue(body[0].contains(""<p>Are you still there?""));
    }

    @Test
    public void canInterruptDocumentRead() throws InterruptedException {
        // todo - implement in interruptable channels, so it's immediate
        final String[] body = new String[1];
        Thread runner = new Thread(() -> {
            try {
                Connection.Response res = Jsoup.connect(SlowRider.Url)
                    .timeout(15 * 1000)
                    .execute();
                body[0] = res.parse().text();
            } catch (IOException e) {
                throw new RuntimeException(e);
            }

        });

        runner.start();
        Thread.sleep(1000 * 3);
        runner.interrupt();
        assertTrue(runner.isInterrupted());
        runner.join();

        assertEquals(0, body[0].length()); // doesn't ready a failed doc
    }

    @Test
    public void totalTimeout() throws IOException {
        int timeout = 3 * 1000;
        long start = System.currentTimeMillis();
        boolean threw = false;
        try {
            Jsoup.connect(SlowRider.Url).timeout(timeout).get();
        } catch (SocketTimeoutException e) {
            long end = System.currentTimeMillis();
            long took = end - start;
            assertTrue(took > timeout, (""Time taken was "" + took));
            assertTrue(took < timeout * 1.8, (""Time taken was "" + took));
            threw = true;
        }

        assertTrue(threw);
    }

    @Test
    public void slowReadOk() throws IOException {
        // make sure that a slow read that is under the request timeout is still OK
        Document doc = Jsoup.connect(SlowRider.Url)
            .data(SlowRider.MaxTimeParam, ""2000"") // the request completes in 2 seconds
            .get();

        Element h1 = doc.selectFirst(""h1"");
        assertEquals(""outatime"", h1.text());
    }

    @Test
    public void infiniteReadSupported() throws IOException {
        Document doc = Jsoup.connect(SlowRider.Url)
            .timeout(0)
            .data(SlowRider.MaxTimeParam, ""2000"")
            .get();

        Element h1 = doc.selectFirst(""h1"");
        assertEquals(""outatime"", h1.text());
    }

    @Test
    public void remainingAfterFirstRead() throws IOException {
        int bufferSize = 5 * 1024;
        int capSize = 100 * 1024;

        String url = FileServlet.urlTo(""/htmltests/large.html""); // 280 K
        ConstrainableInputStream stream;
        try (BufferedInputStream inputStream = Jsoup.connect(url).maxBodySize(capSize)
            .execute().bodyStream()) {

            assertTrue(inputStream instanceof ConstrainableInputStream);
            stream = (ConstrainableInputStream) inputStream;

            // simulates parse which does a limited read first
            stream.mark(bufferSize);
            ByteBuffer firstBytes = stream.readToByteBuffer(bufferSize);

            byte[] array = firstBytes.array();
            String firstText = new String(array, StandardCharsets.UTF_8);
            assertTrue(firstText.startsWith(""<html><head><title>Large""));
            assertEquals(bufferSize, array.length);

            boolean fullyRead = stream.read() == -1;
            assertFalse(fullyRead);

            // reset and read again
            stream.reset();
            ByteBuffer fullRead = stream.readToByteBuffer(0);
            byte[] fullArray = fullRead.array();
            assertEquals(capSize, fullArray.length);
            String fullText = new String(fullArray, StandardCharsets.UTF_8);
            assertTrue(fullText.startsWith(firstText));
        }
    }

    @Test
    public void noLimitAfterFirstRead() throws IOException {
        int bufferSize = 5 * 1024;

        String url = FileServlet.urlTo(""/htmltests/large.html""); // 280 K
        ConstrainableInputStream stream;
        try (BufferedInputStream inputStream = Jsoup.connect(url).execute().bodyStream()) {
            assertTrue(inputStream instanceof ConstrainableInputStream);
            stream = (ConstrainableInputStream) inputStream;

            // simulates parse which does a limited read first
            stream.mark(bufferSize);
            ByteBuffer firstBytes = stream.readToByteBuffer(bufferSize);
            byte[] array = firstBytes.array();
            String firstText = new String(array, StandardCharsets.UTF_8);
            assertTrue(firstText.startsWith(""<html><head><title>Large""));
            assertEquals(bufferSize, array.length);

            // reset and read fully
            stream.reset();
            ByteBuffer fullRead = stream.readToByteBuffer(0);
            byte[] fullArray = fullRead.array();
            assertEquals(280735, fullArray.length);
            String fullText = new String(fullArray, StandardCharsets.UTF_8);
            assertTrue(fullText.startsWith(firstText));
        }
    }
}
"
jhy/jsoup,src/main/java/org/jsoup/internal/FieldsAreNonnullByDefault.java,"package org.jsoup.internal;

import javax.annotation.Nonnull;
import javax.annotation.meta.TypeQualifierDefault;
import java.lang.annotation.Documented;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;

@Documented
@Nonnull
@TypeQualifierDefault(ElementType.FIELD)
@Retention(value = RetentionPolicy.CLASS)

/**
 Indicates that fields types are not nullable, unless otherwise specified by @Nullable.
 @see javax.annotation.ParametersAreNonnullByDefault
 */
public @interface FieldsAreNonnullByDefault {
}
"
jhy/jsoup,src/test/java/org/jsoup/integration/servlets/RedirectServlet.java,"package org.jsoup.integration.servlets;

import org.jsoup.integration.TestServer;

import javax.servlet.http.Cookie;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

public class RedirectServlet extends BaseServlet {
    public static final String Url = TestServer.map(RedirectServlet.class);
    public static final String LocationParam = ""loc"";
    public static final String CodeParam = ""code"";
    public static final String SetCookiesParam = ""setCookies"";
    private static final int DefaultCode = HttpServletResponse.SC_MOVED_TEMPORARILY;

    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse res) {
        String location = req.getParameter(LocationParam);
        if (location == null)
            location = """";

        int intCode = DefaultCode;
        String code = req.getParameter(CodeParam);
        if (code != null)
            intCode = Integer.parseInt(code);

        if (req.getParameter(SetCookiesParam) != null) {
            res.addCookie(new Cookie(""token"", ""asdfg123""));
            res.addCookie(new Cookie(""uid"", ""jhy""));
        }

        res.setHeader(""Location"", location);
        res.setStatus(intCode);
    }

    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse res) {
        doGet(req, res);
    }
}
"
jhy/jsoup,src/test/java/org/jsoup/helper/W3CDomTest.java,"package org.jsoup.helper;

import org.jsoup.Jsoup;
import org.jsoup.TextUtil;
import org.jsoup.integration.ParseTest;
import org.jsoup.nodes.Element;
import org.jsoup.nodes.TextNode;
import org.junit.jupiter.api.Test;
import org.w3c.dom.Document;
import org.w3c.dom.DocumentType;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import org.xml.sax.InputSource;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.transform.OutputKeys;
import javax.xml.xpath.XPathConstants;
import javax.xml.xpath.XPathExpression;
import javax.xml.xpath.XPathExpressionException;
import javax.xml.xpath.XPathFactory;
import java.io.ByteArrayInputStream;
import java.io.File;
import java.io.IOException;
import java.io.StringReader;
import java.nio.charset.StandardCharsets;
import java.util.Locale;
import java.util.Map;

import static org.junit.jupiter.api.Assertions.*;

public class W3CDomTest {

    private static Document parseXml(String xml, boolean nameSpaceAware) {
        try {
            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
            factory.setNamespaceAware(nameSpaceAware);
            DocumentBuilder builder = factory.newDocumentBuilder();
            builder.setEntityResolver((publicId, systemId) -> {
                if (systemId.contains(""about:legacy-compat"")) { // <!doctype html>
                    return new InputSource(new StringReader(""""));
                } else {
                    return null;
                }
            });
            Document dom = builder.parse(new ByteArrayInputStream(xml.getBytes(StandardCharsets.UTF_8)));
            dom.normalizeDocument();
            return dom;
        } catch (Exception e) {
            throw new IllegalStateException(e);
        }
    }

    @Test
    public void simpleConversion() {
        String html = ""<html><head><title>W3c</title></head><body><p class='one' id=12>Text</p><!-- comment --><invalid>What<script>alert('!')"";
        org.jsoup.nodes.Document doc = Jsoup.parse(html);

        W3CDom w3c = new W3CDom();
        Document wDoc = w3c.fromJsoup(doc);
        NodeList meta = wDoc.getElementsByTagName(""META"");
        assertEquals(0, meta.getLength());

        String out = W3CDom.asString(wDoc, W3CDom.OutputXml());
        String expected = ""<?xml version=\""1.0\"" encoding=\""UTF-8\""?><html><head><title>W3c</title></head><body><p class=\""one\"" id=\""12\"">Text</p><!-- comment --><invalid>What<script>alert('!')</script></invalid></body></html>"";
        assertEquals(expected, TextUtil.stripNewlines(out));

        Document roundTrip = parseXml(out, true);
        assertEquals(""Text"", roundTrip.getElementsByTagName(""p"").item(0).getTextContent());

        // check we can set properties
        Map<String, String> properties = W3CDom.OutputXml();
        properties.put(OutputKeys.INDENT, ""yes"");
        String furtherOut = W3CDom.asString(wDoc, properties);
        assertTrue(furtherOut.length() > out.length()); // wanted to assert formatting, but actual indentation is platform specific so breaks in CI
        String furtherExpected =
            ""<?xml version=\""1.0\"" encoding=\""UTF-8\""?><html><head><title>W3c</title></head><body><p class=\""one\"" id=\""12\"">Text</p><!-- comment --><invalid>What<script>alert('!')</script></invalid></body></html>"";
        assertEquals(furtherExpected, TextUtil.stripNewlines(furtherOut)); // on windows, DOM will write newlines as \r\n
    }

    @Test
    public void convertsGoogle() throws IOException {
        File in = ParseTest.getFile(""/htmltests/google-ipod.html.gz"");
        org.jsoup.nodes.Document doc = Jsoup.parse(in, ""UTF8"");

        W3CDom w3c = new W3CDom();
        Document wDoc = w3c.fromJsoup(doc);
        Node htmlEl = wDoc.getChildNodes().item(1);
        assertNull(htmlEl.getNamespaceURI());
        assertEquals(""html"", htmlEl.getLocalName());
        assertEquals(""html"", htmlEl.getNodeName());

        DocumentType doctype = wDoc.getDoctype();
        Node doctypeNode = wDoc.getChildNodes().item(0);
        assertSame(doctype, doctypeNode);
        assertEquals(""html"", doctype.getName());

        String xml = W3CDom.asString(wDoc, W3CDom.OutputXml());
        assertTrue(xml.contains(""ipod""));

        Document roundTrip = parseXml(xml, true);
        assertEquals(""Images"", roundTrip.getElementsByTagName(""a"").item(0).getTextContent());
    }

    @Test
    public void convertsGoogleLocation() throws IOException {
        File in = ParseTest.getFile(""/htmltests/google-ipod.html.gz"");
        org.jsoup.nodes.Document doc = Jsoup.parse(in, ""UTF8"");

        W3CDom w3c = new W3CDom();
        Document wDoc = w3c.fromJsoup(doc);

        String out = w3c.asString(wDoc);
        assertEquals(doc.location(), wDoc.getDocumentURI());
    }

    @Test
    public void namespacePreservation() throws IOException {
        File in = ParseTest.getFile(""/htmltests/namespaces.xhtml"");
        org.jsoup.nodes.Document jsoupDoc;
        jsoupDoc = Jsoup.parse(in, ""UTF-8"");

        Document doc;
        org.jsoup.helper.W3CDom jDom = new org.jsoup.helper.W3CDom();
        doc = jDom.fromJsoup(jsoupDoc);

        Node htmlEl = doc.getChildNodes().item(0);
        assertEquals(""http://www.w3.org/1999/xhtml"", htmlEl.getNamespaceURI());
        assertEquals(""html"", htmlEl.getLocalName());
        assertEquals(""html"", htmlEl.getNodeName());

        // inherits default namespace
        Node head = htmlEl.getFirstChild().getNextSibling();
        assertEquals(""http://www.w3.org/1999/xhtml"", head.getNamespaceURI());
        assertEquals(""head"", head.getLocalName());
        assertEquals(""head"", head.getNodeName());

        Node epubTitle = htmlEl.getChildNodes().item(3).getChildNodes().item(3);
        assertEquals(""Check"", epubTitle.getTextContent());
        assertEquals(""http://www.idpf.org/2007/ops"", epubTitle.getNamespaceURI());
        assertEquals(""title"", epubTitle.getLocalName());
        assertEquals(""epub:title"", epubTitle.getNodeName());

        Node xSection = epubTitle.getNextSibling().getNextSibling();
        assertEquals(""urn:test"", xSection.getNamespaceURI());
        assertEquals(""section"", xSection.getLocalName());
        assertEquals(""x:section"", xSection.getNodeName());

        // https://github.com/jhy/jsoup/issues/977
        // does not keep last set namespace
        Node svg = xSection.getNextSibling().getNextSibling();
        assertEquals(""http://www.w3.org/2000/svg"", svg.getNamespaceURI());
        assertEquals(""svg"", svg.getLocalName());
        assertEquals(""svg"", svg.getNodeName());

        Node path = svg.getChildNodes().item(1);
        assertEquals(""http://www.w3.org/2000/svg"", path.getNamespaceURI());
        assertEquals(""path"", path.getLocalName());
        assertEquals(""path"", path.getNodeName());

        Node clip = path.getChildNodes().item(1);
        assertEquals(""http://example.com/clip"", clip.getNamespaceURI());
        assertEquals(""clip"", clip.getLocalName());
        assertEquals(""clip"", clip.getNodeName());
        assertEquals(""456"", clip.getTextContent());

        Node picture = svg.getNextSibling().getNextSibling();
        assertEquals(""http://www.w3.org/1999/xhtml"", picture.getNamespaceURI());
        assertEquals(""picture"", picture.getLocalName());
        assertEquals(""picture"", picture.getNodeName());

        Node img = picture.getFirstChild();
        assertEquals(""http://www.w3.org/1999/xhtml"", img.getNamespaceURI());
        assertEquals(""img"", img.getLocalName());
        assertEquals(""img"", img.getNodeName());

    }

    @Test
    public void handlesInvalidAttributeNames() {
        String html = ""<html><head></head><body style=\""color: red\"" \"" name\""></body></html>"";
        org.jsoup.nodes.Document jsoupDoc;
        jsoupDoc = Jsoup.parse(html);
        Element body = jsoupDoc.select(""body"").first();
        assertTrue(body.hasAttr(""\"""")); // actually an attribute with key '""'. Correct per HTML5 spec, but w3c xml dom doesn't dig it
        assertTrue(body.hasAttr(""name\""""));

        Document w3Doc = W3CDom.convert(jsoupDoc);
        String xml = W3CDom.asString(w3Doc, W3CDom.OutputXml());
        assertEquals(""<?xml version=\""1.0\"" encoding=\""UTF-8\""?><html><head/><body name=\""\"" style=\""color: red\""/></html>"", xml);
    }

    @Test
    public void htmlInputDocMaintainsHtmlAttributeNames() {
        String html = ""<!DOCTYPE html><html><head></head><body><p h√†nh=\""1\"" h√¨nh=\""2\"">unicode attr names</p></body></html>"";
        org.jsoup.nodes.Document jsoupDoc;
        jsoupDoc = Jsoup.parse(html);

        Document w3Doc = W3CDom.convert(jsoupDoc);
        String out = W3CDom.asString(w3Doc, W3CDom.OutputHtml());
        String expected = ""<!DOCTYPE html SYSTEM \""about:legacy-compat\""><html><head><META http-equiv=\""Content-Type\"" content=\""text/html; charset=UTF-8\""></head><body><p h√†nh=\""1\"" h√¨nh=\""2\"">unicode attr names</p></body></html>"";
        assertEquals(expected, TextUtil.stripNewlines(out));
    }

    @Test
    public void xmlInputDocMaintainsHtmlAttributeNames() {
        String html = ""<!DOCTYPE html><html><head></head><body><p h√†nh=\""1\"" h√¨nh=\""2\"">unicode attr names coerced</p></body></html>"";
        org.jsoup.nodes.Document jsoupDoc;
        jsoupDoc = Jsoup.parse(html);
        jsoupDoc.outputSettings().syntax(org.jsoup.nodes.Document.OutputSettings.Syntax.xml);

        Document w3Doc = W3CDom.convert(jsoupDoc);
        String out = W3CDom.asString(w3Doc, W3CDom.OutputHtml());
        String expected = ""<!DOCTYPE html SYSTEM \""about:legacy-compat\""><html><head><META http-equiv=\""Content-Type\"" content=\""text/html; charset=UTF-8\""></head><body><p hnh=\""2\"">unicode attr names coerced</p></body></html>"";
        assertEquals(expected, TextUtil.stripNewlines(out));
    }

    @Test
    public void handlesInvalidTagAsText() {
        org.jsoup.nodes.Document jsoup = Jsoup.parse(""<„Ç§„É≥„Çª„É≥„ÉÜ„Ç£„Éñ„ÅßÈ´òÂèéÂÖ•ÔºÅ>Text <p>More</p>"");

        Document w3Doc = W3CDom.convert(jsoup);
        String xml = W3CDom.asString(w3Doc, W3CDom.OutputXml());
        assertEquals(""<?xml version=\""1.0\"" encoding=\""UTF-8\""?><html><head/><body>&lt;„Ç§„É≥„Çª„É≥„ÉÜ„Ç£„Éñ„ÅßÈ´òÂèéÂÖ•ÔºÅ&gt;Text <p>More</p></body></html>"", xml);
    }

    @Test
    public void treatsUndeclaredNamespaceAsLocalName() {
        String html = ""<fb:like>One</fb:like>"";
        org.jsoup.nodes.Document doc = Jsoup.parse(html);

        Document w3Doc = new W3CDom().fromJsoup(doc);
        Node htmlEl = w3Doc.getFirstChild();

        assertNull(htmlEl.getNamespaceURI());
        assertEquals(""html"", htmlEl.getLocalName());
        assertEquals(""html"", htmlEl.getNodeName());

        Node fb = htmlEl.getFirstChild().getNextSibling().getFirstChild();
        assertNull(fb.getNamespaceURI());
        assertEquals(""like"", fb.getLocalName());
        assertEquals(""fb:like"", fb.getNodeName());
    }

    @Test
    public void xmlnsXpathTest() throws XPathExpressionException {
        W3CDom w3c = new W3CDom();
        String html = ""<html><body><div>hello</div></body></html>"";
        Document dom = w3c.fromJsoup(Jsoup.parse(html));
        NodeList nodeList = xpath(dom, ""//body"");// no ns, so needs no prefix
        assertEquals(""div"", nodeList.item(0).getLocalName());

        // default output is namespace aware, so query needs to be as well
        html = ""<html xmlns='http://www.w3.org/1999/xhtml'><body id='One'><div>hello</div></body></html>"";
        dom = w3c.fromJsoup(Jsoup.parse(html));
        nodeList = xpath(dom, ""//body"");
        assertNull(nodeList); // no matches

        dom = w3c.fromJsoup(Jsoup.parse(html));
        nodeList = xpath(dom, ""//*[local-name()=\""body\""]"");
        assertNotNull(nodeList);
        assertEquals(1, nodeList.getLength());
        assertEquals(""div"", nodeList.item(0).getLocalName());
        assertEquals(""http://www.w3.org/1999/xhtml"", nodeList.item(0).getNamespaceURI());
        assertNull(nodeList.item(0).getPrefix());

        // get rid of the name space awareness
        String xml = w3c.asString(dom);
        dom = parseXml(xml, false);
        Node item = (Node) xpath(dom, ""//body"");
        assertEquals(""body"", item.getNodeName());
        assertNull(item.getNamespaceURI());
        assertNull(item.getPrefix());

        // put back, will get zero
        dom = parseXml(xml, true);
        nodeList = xpath(dom, ""//body"");
        assertNull(nodeList);
    }

    @Test
    void canDisableNamespaces() throws XPathExpressionException {
        W3CDom w3c = new W3CDom();
        assertTrue(w3c.namespaceAware());

        w3c.namespaceAware(false);
        assertFalse(w3c.namespaceAware());

        String html = ""<html xmlns='http://www.w3.org/1999/xhtml'><body id='One'><div>hello</div></body></html>"";
        Document dom = w3c.fromJsoup(Jsoup.parse(html));
        NodeList nodeList = xpath(dom, ""//body"");// no ns, so needs no prefix
        assertEquals(""div"", nodeList.item(0).getLocalName());
    }

    private NodeList xpath(Document w3cDoc, String query) throws XPathExpressionException {
        XPathExpression xpath = XPathFactory.newInstance().newXPath().compile(query);
        return ((NodeList) xpath.evaluate(w3cDoc, XPathConstants.NODE));
    }

    @Test
    public void testRoundTripDoctype() {
        // TODO - not super happy with this output - but plain DOM doesn't let it out, and don't want to rebuild the writer
        // because we have Saxon on the test classpath, the transformer will change to that, and so case may change (e.g. Java base in META, Saxon is meta for HTML)
        String base = ""<!DOCTYPE html><p>One</p>"";
        assertEqualsIgnoreCase(""<!DOCTYPE html SYSTEM \""about:legacy-compat\""><html><head><META http-equiv=\""Content-Type\"" content=\""text/html; charset=UTF-8\""></head><body><p>One</p></body></html>"",
            output(base, true));
        assertEqualsIgnoreCase(""<?xml version=\""1.0\"" encoding=\""UTF-8\""?><!DOCTYPE html SYSTEM \""about:legacy-compat\""><html><head/><body><p>One</p></body></html>"", output(base, false));

        String publicDoc = ""<!DOCTYPE html PUBLIC \""-//W3C//DTD XHTML 1.0 Transitional//EN\"" \""http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\"">"";
        assertEqualsIgnoreCase(""<!DOCTYPE html PUBLIC \""-//W3C//DTD XHTML 1.0 Transitional//EN\"" \""http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\""><html><head><META http-equiv=\""Content-Type\"" content=\""text/html; charset=UTF-8\""></head><body></body></html>"", output(publicDoc, true));
        // different impls will have different XML formatting. OpenJDK 13 default gives this: <body /> but others have <body/>, so just check start
        assertTrue(output(publicDoc, false).startsWith(""<?xml version=\""1.0\"" encoding=\""UTF-8\""?><!DOCTYPE html PUBLIC""));

        String systemDoc = ""<!DOCTYPE html SYSTEM \""exampledtdfile.dtd\"">"";
        assertEqualsIgnoreCase(""<!DOCTYPE html SYSTEM \""exampledtdfile.dtd\""><html><head><META http-equiv=\""Content-Type\"" content=\""text/html; charset=UTF-8\""></head><body></body></html>"", output(systemDoc, true));
        assertEqualsIgnoreCase(""<?xml version=\""1.0\"" encoding=\""UTF-8\""?><!DOCTYPE html SYSTEM \""exampledtdfile.dtd\""><html><head/><body/></html>"", output(systemDoc, false));

        String legacyDoc = ""<!DOCTYPE html SYSTEM \""about:legacy-compat\"">"";
        assertEqualsIgnoreCase(""<!DOCTYPE html SYSTEM \""about:legacy-compat\""><html><head><META http-equiv=\""Content-Type\"" content=\""text/html; charset=UTF-8\""></head><body></body></html>"", output(legacyDoc, true));
        assertEqualsIgnoreCase(""<?xml version=\""1.0\"" encoding=\""UTF-8\""?><!DOCTYPE html SYSTEM \""about:legacy-compat\""><html><head/><body/></html>"", output(legacyDoc, false));

        String noDoctype = ""<p>One</p>"";
        assertEqualsIgnoreCase(""<html><head><META http-equiv=\""Content-Type\"" content=\""text/html; charset=UTF-8\""></head><body><p>One</p></body></html>"", output(noDoctype, true));
        assertEqualsIgnoreCase(""<?xml version=\""1.0\"" encoding=\""UTF-8\""?><html><head/><body><p>One</p></body></html>"", output(noDoctype, false));
    }

    private String output(String in, boolean modeHtml) {
        org.jsoup.nodes.Document jdoc = Jsoup.parse(in);
        Document w3c = W3CDom.convert(jdoc);

        Map<String, String> properties = modeHtml ? W3CDom.OutputHtml() : W3CDom.OutputXml();
        return TextUtil.normalizeSpaces(W3CDom.asString(w3c, properties));
    }

    private void assertEqualsIgnoreCase(String want, String have) {
        assertEquals(want.toLowerCase(Locale.ROOT), have.toLowerCase(Locale.ROOT));
    }

    @Test public void convertsElementsAndMaintainsSource() {
        org.jsoup.nodes.Document jdoc = Jsoup.parse(""<body><div><p>One</div><div><p>Two"");
        W3CDom w3CDom = new W3CDom();
        Element jDiv = jdoc.selectFirst(""div"");
        assertNotNull(jDiv);
        Document doc = w3CDom.fromJsoup(jDiv);
        Node div = w3CDom.contextNode(doc);

        assertEquals(""div"", div.getLocalName());
        assertEquals(jDiv, div.getUserData(W3CDom.SourceProperty));

        Node textNode = div.getFirstChild().getFirstChild();
        assertEquals(""One"", textNode.getTextContent());
        assertEquals(Node.TEXT_NODE, textNode.getNodeType());

        org.jsoup.nodes.TextNode jText = (TextNode) jDiv.childNode(0).childNode(0);
        assertEquals(jText, textNode.getUserData(W3CDom.SourceProperty));
    }

}
"
jhy/jsoup,src/test/java/org/jsoup/nodes/AttributeTest.java,"package org.jsoup.nodes;

import org.jsoup.Jsoup;
import org.jsoup.parser.ParseSettings;
import org.jsoup.parser.Parser;
import org.junit.jupiter.api.Test;

import static org.junit.jupiter.api.Assertions.*;

public class AttributeTest {
    @Test
    public void html() {
        Attribute attr = new Attribute(""key"", ""value &"");
        assertEquals(""key=\""value &amp;\"""", attr.html());
        assertEquals(attr.html(), attr.toString());
    }

    @Test public void testWithSupplementaryCharacterInAttributeKeyAndValue() {
        String s = new String(Character.toChars(135361));
        Attribute attr = new Attribute(s, ""A"" + s + ""B"");
        assertEquals(s + ""=\""A"" + s + ""B\"""", attr.html());
        assertEquals(attr.html(), attr.toString());
    }

    @Test public void validatesKeysNotEmpty() {
        assertThrows(IllegalArgumentException.class, () -> new Attribute("" "", ""Check""));
    }

    @Test public void validatesKeysNotEmptyViaSet() {
        assertThrows(IllegalArgumentException.class, () -> {
            Attribute attr = new Attribute(""One"", ""Check"");
            attr.setKey("" "");
        });
    }

    @Test public void booleanAttributesAreEmptyStringValues() {
        Document doc = Jsoup.parse(""<div hidden>"");
        Attributes attributes = doc.body().child(0).attributes();
        assertEquals("""", attributes.get(""hidden""));

        Attribute first = attributes.iterator().next();
        assertEquals(""hidden"", first.getKey());
        assertEquals("""", first.getValue());
        assertFalse(first.hasDeclaredValue());
        assertTrue(Attribute.isBooleanAttribute(first.getKey()));
    }

    @Test public void settersOnOrphanAttribute() {
        Attribute attr = new Attribute(""one"", ""two"");
        attr.setKey(""three"");
        String oldVal = attr.setValue(""four"");
        assertEquals(""two"", oldVal);
        assertEquals(""three"", attr.getKey());
        assertEquals(""four"", attr.getValue());
        assertNull(attr.parent);
    }

    @Test public void hasValue() {
        Attribute a1 = new Attribute(""one"", """");
        Attribute a2 = new Attribute(""two"", null);
        Attribute a3 = new Attribute(""thr"", ""thr"");

        assertTrue(a1.hasDeclaredValue());
        assertFalse(a2.hasDeclaredValue());
        assertTrue(a3.hasDeclaredValue());
    }

    @Test public void canSetValueToNull() {
        Attribute attr = new Attribute(""one"", ""val"");
        String oldVal = attr.setValue(null);
        assertEquals(""one"", attr.html());
        assertEquals(""val"", oldVal);

        oldVal = attr.setValue(""foo"");
        assertEquals("""", oldVal); // string, not null
    }

    @Test void booleanAttributesAreNotCaseSensitive() {
        // https://github.com/jhy/jsoup/issues/1656
        assertTrue(Attribute.isBooleanAttribute(""required""));
        assertTrue(Attribute.isBooleanAttribute(""REQUIRED""));
        assertTrue(Attribute.isBooleanAttribute(""rEQUIREd""));
        assertFalse(Attribute.isBooleanAttribute(""random string""));

        String html = ""<a href=autofocus REQUIRED>One</a>"";
        Document doc = Jsoup.parse(html);
        assertEquals(""<a href=\""autofocus\"" required>One</a>"", doc.selectFirst(""a"").outerHtml());

        Document doc2 = Jsoup.parse(html, Parser.htmlParser().settings(ParseSettings.preserveCase));
        assertEquals(""<a href=\""autofocus\"" REQUIRED>One</a>"", doc2.selectFirst(""a"").outerHtml());
    }
}
"
jhy/jsoup,src/test/java/org/jsoup/internal/StringUtilTest.java,"package org.jsoup.internal;

import org.jsoup.Jsoup;
import org.junit.jupiter.api.Test;

import java.util.Arrays;
import java.util.Collections;

import static org.jsoup.internal.StringUtil.normaliseWhitespace;
import static org.jsoup.internal.StringUtil.resolve;
import static org.junit.jupiter.api.Assertions.*;

public class StringUtilTest {

    @Test
    public void join() {
        assertEquals("""", StringUtil.join(Collections.singletonList(""""), "" ""));
        assertEquals(""one"", StringUtil.join(Collections.singletonList(""one""), "" ""));
        assertEquals(""one two three"", StringUtil.join(Arrays.asList(""one"", ""two"", ""three""), "" ""));
    }

    @Test public void padding() {
        assertEquals("""", StringUtil.padding(0));
        assertEquals("" "", StringUtil.padding(1));
        assertEquals(""  "", StringUtil.padding(2));
        assertEquals(""               "", StringUtil.padding(15));
        assertEquals(""                              "", StringUtil.padding(45)); // we default to tap out at 30

        // memoization is up to 21 blocks (0 to 20 spaces) and exits early before min checks making maxPaddingWidth unused
        assertEquals("""", StringUtil.padding(0, -1));
        assertEquals(""                    "", StringUtil.padding(20, -1));

        // this test escapes memoization and continues through
        assertEquals(""                     "", StringUtil.padding(21, -1));

        // this test escapes memoization and using unlimited length (-1) will allow requested spaces
        assertEquals(""                              "", StringUtil.padding(30, -1));
        assertEquals(""                                             "", StringUtil.padding(45, -1));

        // we tap out at 0 for this test
        assertEquals("""", StringUtil.padding(0, 0));

        // as memoization is escaped, setting zero for max padding will not allow any requested width
        assertEquals("""", StringUtil.padding(21, 0));

        // we tap out at 30 for these tests making > 30 use 30
        assertEquals("""", StringUtil.padding(0, 30));
        assertEquals("" "", StringUtil.padding(1, 30));
        assertEquals(""  "", StringUtil.padding(2, 30));
        assertEquals(""               "", StringUtil.padding(15, 30));
        assertEquals(""                              "", StringUtil.padding(45, 30));

        // max applies regardless of memoized
        assertEquals(5, StringUtil.padding(20, 5).length());
    }

    @Test public void paddingInACan() {
        String[] padding = StringUtil.padding;
        assertEquals(21, padding.length);
        for (int i = 0; i < padding.length; i++) {
            assertEquals(i, padding[i].length());
        }
    }

    @Test public void isBlank() {
        assertTrue(StringUtil.isBlank(null));
        assertTrue(StringUtil.isBlank(""""));
        assertTrue(StringUtil.isBlank(""      ""));
        assertTrue(StringUtil.isBlank(""   \r\n  ""));

        assertFalse(StringUtil.isBlank(""hello""));
        assertFalse(StringUtil.isBlank(""   hello   ""));
    }

    @Test public void isNumeric() {
        assertFalse(StringUtil.isNumeric(null));
        assertFalse(StringUtil.isNumeric("" ""));
        assertFalse(StringUtil.isNumeric(""123 546""));
        assertFalse(StringUtil.isNumeric(""hello""));
        assertFalse(StringUtil.isNumeric(""123.334""));

        assertTrue(StringUtil.isNumeric(""1""));
        assertTrue(StringUtil.isNumeric(""1234""));
    }

    @Test public void isWhitespace() {
        assertTrue(StringUtil.isWhitespace('\t'));
        assertTrue(StringUtil.isWhitespace('\n'));
        assertTrue(StringUtil.isWhitespace('\r'));
        assertTrue(StringUtil.isWhitespace('\f'));
        assertTrue(StringUtil.isWhitespace(' '));

        assertFalse(StringUtil.isWhitespace('\u00a0'));
        assertFalse(StringUtil.isWhitespace('\u2000'));
        assertFalse(StringUtil.isWhitespace('\u3000'));
    }

    @Test public void normaliseWhiteSpace() {
        assertEquals("" "", normaliseWhitespace(""    \r \n \r\n""));
        assertEquals("" hello there "", normaliseWhitespace(""   hello   \r \n  there    \n""));
        assertEquals(""hello"", normaliseWhitespace(""hello""));
        assertEquals(""hello there"", normaliseWhitespace(""hello\nthere""));
    }

    @Test public void normaliseWhiteSpaceHandlesHighSurrogates() {
        String test71540chars = ""\ud869\udeb2\u304b\u309a  1"";
        String test71540charsExpectedSingleWhitespace = ""\ud869\udeb2\u304b\u309a 1"";

        assertEquals(test71540charsExpectedSingleWhitespace, normaliseWhitespace(test71540chars));
        String extractedText = Jsoup.parse(test71540chars).text();
        assertEquals(test71540charsExpectedSingleWhitespace, extractedText);
    }

    @Test public void resolvesRelativeUrls() {
        assertEquals(""http://example.com/one/two?three"", resolve(""http://example.com"", ""./one/two?three""));
        assertEquals(""http://example.com/one/two?three"", resolve(""http://example.com?one"", ""./one/two?three""));
        assertEquals(""http://example.com/one/two?three#four"", resolve(""http://example.com"", ""./one/two?three#four""));
        assertEquals(""https://example.com/one"", resolve(""http://example.com/"", ""https://example.com/one""));
        assertEquals(""http://example.com/one/two.html"", resolve(""http://example.com/two/"", ""../one/two.html""));
        assertEquals(""https://example2.com/one"", resolve(""https://example.com/"", ""//example2.com/one""));
        assertEquals(""https://example.com:8080/one"", resolve(""https://example.com:8080"", ""./one""));
        assertEquals(""https://example2.com/one"", resolve(""http://example.com/"", ""https://example2.com/one""));
        assertEquals(""https://example.com/one"", resolve(""wrong"", ""https://example.com/one""));
        assertEquals(""https://example.com/one"", resolve(""https://example.com/one"", """"));
        assertEquals("""", resolve(""wrong"", ""also wrong""));
        assertEquals(""ftp://example.com/one"", resolve(""ftp://example.com/two/"", ""../one""));
        assertEquals(""ftp://example.com/one/two.c"", resolve(""ftp://example.com/one/"", ""./two.c""));
        assertEquals(""ftp://example.com/one/two.c"", resolve(""ftp://example.com/one/"", ""two.c""));
        // examples taken from rfc3986 section 5.4.2
        assertEquals(""http://example.com/g"", resolve(""http://example.com/b/c/d;p?q"", ""../../../g""));
        assertEquals(""http://example.com/g"", resolve(""http://example.com/b/c/d;p?q"", ""../../../../g""));
        assertEquals(""http://example.com/g"", resolve(""http://example.com/b/c/d;p?q"", ""/./g""));
        assertEquals(""http://example.com/g"", resolve(""http://example.com/b/c/d;p?q"", ""/../g""));
        assertEquals(""http://example.com/b/c/g."", resolve(""http://example.com/b/c/d;p?q"", ""g.""));
        assertEquals(""http://example.com/b/c/.g"", resolve(""http://example.com/b/c/d;p?q"", "".g""));
        assertEquals(""http://example.com/b/c/g.."", resolve(""http://example.com/b/c/d;p?q"", ""g..""));
        assertEquals(""http://example.com/b/c/..g"", resolve(""http://example.com/b/c/d;p?q"", ""..g""));
        assertEquals(""http://example.com/b/g"", resolve(""http://example.com/b/c/d;p?q"", ""./../g""));
        assertEquals(""http://example.com/b/c/g/"", resolve(""http://example.com/b/c/d;p?q"", ""./g/.""));
        assertEquals(""http://example.com/b/c/g/h"", resolve(""http://example.com/b/c/d;p?q"", ""g/./h""));
        assertEquals(""http://example.com/b/c/h"", resolve(""http://example.com/b/c/d;p?q"", ""g/../h""));
        assertEquals(""http://example.com/b/c/g;x=1/y"", resolve(""http://example.com/b/c/d;p?q"", ""g;x=1/./y""));
        assertEquals(""http://example.com/b/c/y"", resolve(""http://example.com/b/c/d;p?q"", ""g;x=1/../y""));
        assertEquals(""http://example.com/b/c/g?y/./x"", resolve(""http://example.com/b/c/d;p?q"", ""g?y/./x""));
        assertEquals(""http://example.com/b/c/g?y/../x"", resolve(""http://example.com/b/c/d;p?q"", ""g?y/../x""));
        assertEquals(""http://example.com/b/c/g#s/./x"", resolve(""http://example.com/b/c/d;p?q"", ""g#s/./x""));
        assertEquals(""http://example.com/b/c/g#s/../x"", resolve(""http://example.com/b/c/d;p?q"", ""g#s/../x""));
    }

    @Test void stripsControlCharsFromUrls() {
        // should resovle to an absolute url:
        assertEquals(""foo:bar"", resolve(""\nhttps://\texample.com/"", ""\r\nfo\to:ba\br""));
    }

    @Test void allowsSpaceInUrl() {
        assertEquals(""https://example.com/foo bar/"", resolve(""HTTPS://example.com/example/"", ""../foo bar/""));
    }

    @Test
    void isAscii() {
        assertTrue(StringUtil.isAscii(""""));
        assertTrue(StringUtil.isAscii(""example.com""));
        assertTrue(StringUtil.isAscii(""One Two""));
        assertFalse(StringUtil.isAscii(""üßî""));
        assertFalse(StringUtil.isAscii(""ÊµãËØï""));
        assertFalse(StringUtil.isAscii(""ÊµãËØï.com""));
    }
}
"
jhy/jsoup,src/test/java/org/jsoup/integration/FuzzFixesTest.java,"package org.jsoup.integration;

import org.jsoup.Jsoup;
import org.jsoup.nodes.Document;
import org.jsoup.parser.Parser;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.MethodSource;

import java.io.File;
import java.io.IOException;
import java.util.stream.Stream;

import static org.junit.jupiter.api.Assertions.assertNotNull;
import static org.junit.jupiter.api.Assertions.assertTrue;

/**
 Tests fixes for issues raised by the OSS Fuzz project @ https://oss-fuzz.com/testcases?project=jsoup. Contains inline
 string cases causing exceptions. Timeout tests are in FuzzFixesIT.
 */
public class FuzzFixesTest {

    private static Stream<File> testFiles() {
        File[] files = FuzzFixesIT.testDir.listFiles();
        assertNotNull(files);
        assertTrue(files.length > 10);

        return Stream.of(files);
    }

    @Test
    public void blankAbsAttr() {
        // https://github.com/jhy/jsoup/issues/1541
        String html = ""b<bodY abs: abs:abs: abs:abs:abs>"";
        Document doc = Jsoup.parse(html);
        assertNotNull(doc);
    }

    @Test
    public void bookmark() {
        // https://github.com/jhy/jsoup/issues/1576
        String html = ""<?a<U<P<A "";
        Document doc = Jsoup.parse(html);
        assertNotNull(doc);

        Document xmlDoc = Parser.xmlParser().parseInput(html, """");
        assertNotNull(xmlDoc);
    }

    @ParameterizedTest
    @MethodSource(""testFiles"")
    void testHtmlParse(File file) throws IOException {
        Document doc = Jsoup.parse(file, ""UTF-8"", ""https://example.com/"");
        assertNotNull(doc);
    }

    @ParameterizedTest
    @MethodSource(""testFiles"")
    void testXmlParse(File file) throws IOException {
        Document doc = Jsoup.parse(file, ""UTF-8"", ""https://example.com/"", Parser.xmlParser());
        assertNotNull(doc);
    }
}
"
jhy/jsoup,src/test/java/org/jsoup/nodes/DocumentTypeTest.java,"package org.jsoup.nodes;

import org.jsoup.Jsoup;
import org.jsoup.parser.Parser;
import org.junit.jupiter.api.Test;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertThrows;

/**
 * Tests for the DocumentType node
 *
 * @author Jonathan Hedley, http://jonathanhedley.com/
 */
public class DocumentTypeTest {
    @Test
    public void constructorValidationOkWithBlankName() {
        new DocumentType("""","""", """");
    }

    @Test
    public void constructorValidationThrowsExceptionOnNulls() {
        assertThrows(IllegalArgumentException.class, () -> new DocumentType(""html"", null, null));
    }

    @Test
    public void constructorValidationOkWithBlankPublicAndSystemIds() {
        new DocumentType(""html"","""", """");
    }

    @Test public void outerHtmlGeneration() {
        DocumentType html5 = new DocumentType(""html"", """", """");
        assertEquals(""<!doctype html>"", html5.outerHtml());

        DocumentType publicDocType = new DocumentType(""html"", ""-//IETF//DTD HTML//"", """");
        assertEquals(""<!DOCTYPE html PUBLIC \""-//IETF//DTD HTML//\"">"", publicDocType.outerHtml());

        DocumentType systemDocType = new DocumentType(""html"", """", ""http://www.ibm.com/data/dtd/v11/ibmxhtml1-transitional.dtd"");
        assertEquals(""<!DOCTYPE html SYSTEM \""http://www.ibm.com/data/dtd/v11/ibmxhtml1-transitional.dtd\"">"", systemDocType.outerHtml());

        DocumentType combo = new DocumentType(""notHtml"", ""--public"", ""--system"");
        assertEquals(""<!DOCTYPE notHtml PUBLIC \""--public\"" \""--system\"">"", combo.outerHtml());
        assertEquals(""notHtml"", combo.name());
        assertEquals(""--public"", combo.publicId());
        assertEquals(""--system"", combo.systemId());
    }

    @Test public void testRoundTrip() {
        String base = ""<!DOCTYPE html>"";
        assertEquals(""<!doctype html>"", htmlOutput(base));
        assertEquals(base, xmlOutput(base));

        String publicDoc = ""<!DOCTYPE html PUBLIC \""-//W3C//DTD XHTML 1.0 Transitional//EN\"" \""http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\"">"";
        assertEquals(publicDoc, htmlOutput(publicDoc));
        assertEquals(publicDoc, xmlOutput(publicDoc));

        String systemDoc = ""<!DOCTYPE html SYSTEM \""exampledtdfile.dtd\"">"";
        assertEquals(systemDoc, htmlOutput(systemDoc));
        assertEquals(systemDoc, xmlOutput(systemDoc));

        String legacyDoc = ""<!DOCTYPE html SYSTEM \""about:legacy-compat\"">"";
        assertEquals(legacyDoc, htmlOutput(legacyDoc));
        assertEquals(legacyDoc, xmlOutput(legacyDoc));
    }

    private String htmlOutput(String in) {
        DocumentType type = (DocumentType) Jsoup.parse(in).childNode(0);
        return type.outerHtml();
    }

    private String xmlOutput(String in) {
        return Jsoup.parse(in, """", Parser.xmlParser()).childNode(0).outerHtml();
    }
}
"
jhy/jsoup,src/test/java/org/jsoup/select/TraversorTest.java,"package org.jsoup.select;

import org.jsoup.Jsoup;
import org.jsoup.TextUtil;
import org.jsoup.nodes.Document;
import org.jsoup.nodes.Element;
import org.jsoup.nodes.Node;
import org.jsoup.nodes.TextNode;
import org.junit.jupiter.api.Test;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertNotNull;

public class TraversorTest {
    // Note: NodeTraversor.traverse(new NodeVisitor) is tested in
    // ElementsTest#traverse()

    @Test
    public void filterVisit() {
        Document doc = Jsoup.parse(""<div><p>Hello</p></div><div>There</div>"");
        final StringBuilder accum = new StringBuilder();
        NodeTraversor.filter(new NodeFilter() {
            @Override
            public FilterResult head(Node node, int depth) {
                accum.append(""<"").append(node.nodeName()).append("">"");
                return FilterResult.CONTINUE;
            }

            @Override
            public FilterResult tail(Node node, int depth) {
                accum.append(""</"").append(node.nodeName()).append("">"");
                return FilterResult.CONTINUE;
            }
        }, doc.select(""div""));
        assertEquals(""<div><p><#text></#text></p></div><div><#text></#text></div>"", accum.toString());
    }

    @Test
    public void filterSkipChildren() {
        Document doc = Jsoup.parse(""<div><p>Hello</p></div><div>There</div>"");
        final StringBuilder accum = new StringBuilder();
        NodeTraversor.filter(new NodeFilter() {
            @Override
            public FilterResult head(Node node, int depth) {
                accum.append(""<"").append(node.nodeName()).append("">"");
                // OMIT contents of p:
                return (""p"".equals(node.nodeName())) ? FilterResult.SKIP_CHILDREN : FilterResult.CONTINUE;
            }

            @Override
            public FilterResult tail(Node node, int depth) {
                accum.append(""</"").append(node.nodeName()).append("">"");
                return FilterResult.CONTINUE;
            }
        }, doc.select(""div""));
        assertEquals(""<div><p></p></div><div><#text></#text></div>"", accum.toString());
    }

    @Test
    public void filterSkipEntirely() {
        Document doc = Jsoup.parse(""<div><p>Hello</p></div><div>There</div>"");
        final StringBuilder accum = new StringBuilder();
        NodeTraversor.filter(new NodeFilter() {
            @Override
            public FilterResult head(Node node, int depth) {
                // OMIT p:
                if (""p"".equals(node.nodeName()))
                    return FilterResult.SKIP_ENTIRELY;
                accum.append(""<"").append(node.nodeName()).append("">"");
                return FilterResult.CONTINUE;
            }

            @Override
            public FilterResult tail(Node node, int depth) {
                accum.append(""</"").append(node.nodeName()).append("">"");
                return FilterResult.CONTINUE;
            }
        }, doc.select(""div""));
        assertEquals(""<div></div><div><#text></#text></div>"", accum.toString());
    }

    @Test
    public void filterRemove() {
        Document doc = Jsoup.parse(""<div><p>Hello</p></div><div>There be <b>bold</b></div>"");
        NodeTraversor.filter(new NodeFilter() {
            @Override
            public FilterResult head(Node node, int depth) {
                // Delete ""p"" in head:
                return (""p"".equals(node.nodeName())) ? FilterResult.REMOVE : FilterResult.CONTINUE;
            }

            @Override
            public FilterResult tail(Node node, int depth) {
                // Delete ""b"" in tail:
                return (""b"".equals(node.nodeName())) ? FilterResult.REMOVE : FilterResult.CONTINUE;
            }
        }, doc.select(""div""));
        assertEquals(""<div></div>\n<div>\n There be\n</div>"", doc.select(""body"").html());
    }

    @Test
    public void filterStop() {
        Document doc = Jsoup.parse(""<div><p>Hello</p></div><div>There</div>"");
        final StringBuilder accum = new StringBuilder();
        NodeTraversor.filter(new NodeFilter() {
            @Override
            public FilterResult head(Node node, int depth) {
                accum.append(""<"").append(node.nodeName()).append("">"");
                return FilterResult.CONTINUE;
            }

            @Override
            public FilterResult tail(Node node, int depth) {
                accum.append(""</"").append(node.nodeName()).append("">"");
                // Stop after p.
                return (""p"".equals(node.nodeName())) ? FilterResult.STOP : FilterResult.CONTINUE;
            }
        }, doc.select(""div""));
        assertEquals(""<div><p><#text></#text></p>"", accum.toString());
    }

    @Test public void replaceElement() {
        // https://github.com/jhy/jsoup/issues/1289
        // test we can replace an element during traversal
        String html = ""<div><p>One <i>two</i> <i>three</i> four.</p></div>"";
        Document doc = Jsoup.parse(html);

        NodeTraversor.traverse(new NodeVisitor() {
            @Override
            public void head(Node node, int depth) {
                if (node instanceof Element) {
                    Element el = (Element) node;
                    if (el.normalName().equals(""i"")) {
                        Element u = new Element(""u"").insertChildren(0, el.childNodes());
                        el.replaceWith(u);
                    }
                }
            }

            @Override
            public void tail(Node node, int depth) {}
        }, doc);

        Element p = doc.selectFirst(""p"");
        assertNotNull(p);
        assertEquals(""<p>One <u>two</u> <u>three</u> four.</p>"", p.outerHtml());
    }

    @Test public void canAddChildren() {
        Document doc = Jsoup.parse(""<div><p></p><p></p></div>"");

        NodeTraversor.traverse(new NodeVisitor() {
            int i = 0;
            @Override
            public void head(Node node, int depth) {
                if (node.nodeName().equals(""p"")) {
                    Element p = (Element) node;
                    p.append(""<span>"" + i++ + ""</span>"");
                }
            }

            @Override
            public void tail(Node node, int depth) {
                if (node.nodeName().equals(""p"")) {
                    Element p = (Element) node;
                    p.append(""<span>"" + i++ + ""</span>"");
                }
            }
        }, doc);

        assertEquals(""<div>\n"" +
            "" <p><span>0</span><span>1</span></p>\n"" +
            "" <p><span>2</span><span>3</span></p>\n"" +
            ""</div>"", doc.body().html());
    }

    @Test public void canSpecifyOnlyHead() {
        // really, a compilation test - works as a lambda if just head
        Document doc = Jsoup.parse(""<div><p>One</p></div>"");
        final int[] count = {0};
        NodeTraversor.traverse((node, depth) -> count[0]++, doc);
        assertEquals(7, count[0]);
    }

    @Test public void canRemoveDuringHead() {
        Document doc = Jsoup.parse(""<div><p id=1>Zero<p id=1>One<p id=2>Two<p>Three</div>"");
        NodeTraversor.traverse((node, depth) -> {
            if (node.attr(""id"").equals(""1""))
                node.remove();
            else if (node instanceof TextNode && ((TextNode) node).text().equals(""Three""))
                node.remove();
        }, doc);

        assertEquals(""<div><p id=\""2\"">Two</p><p></p></div>"", TextUtil.stripNewlines(doc.body().html()));
    }
}
"
jhy/jsoup,src/main/java/org/jsoup/safety/package-info.java,"/**
 Contains the jsoup HTML cleaner, and safelist definitions.
 */
package org.jsoup.safety;
"
jhy/jsoup,src/main/java/org/jsoup/nodes/CDataNode.java,"package org.jsoup.nodes;

import org.jsoup.UncheckedIOException;

import java.io.IOException;

/**
 * A Character Data node, to support CDATA sections.
 */
public class CDataNode extends TextNode {
    public CDataNode(String text) {
        super(text);
    }

    @Override
    public String nodeName() {
        return ""#cdata"";
    }

    /**
     * Get the unencoded, <b>non-normalized</b> text content of this CDataNode.
     * @return unencoded, non-normalized text
     */
    @Override
    public String text() {
        return getWholeText();
    }

    @Override
    void outerHtmlHead(Appendable accum, int depth, Document.OutputSettings out) throws IOException {
        accum
            .append(""<![CDATA["")
            .append(getWholeText());
    }

    @Override
    void outerHtmlTail(Appendable accum, int depth, Document.OutputSettings out) {
        try {
            accum.append(""]]>"");
        } catch (IOException e) {
            throw new UncheckedIOException(e);
        }
    }

    @Override
    public CDataNode clone() {
        return (CDataNode) super.clone();
    }
}
"
jhy/jsoup,src/main/java/org/jsoup/parser/Tag.java,"package org.jsoup.parser;

import org.jsoup.helper.Validate;
import org.jsoup.internal.Normalizer;

import java.util.HashMap;
import java.util.Map;

/**
 * HTML Tag capabilities.
 *
 * @author Jonathan Hedley, jonathan@hedley.net
 */
public class Tag implements Cloneable {
    private static final Map<String, Tag> tags = new HashMap<>(); // map of known tags

    private String tagName;
    private String normalName; // always the lower case version of this tag, regardless of case preservation mode
    private boolean isBlock = true; // block
    private boolean formatAsBlock = true; // should be formatted as a block
    private boolean empty = false; // can hold nothing; e.g. img
    private boolean selfClosing = false; // can self close (<foo />). used for unknown tags that self close, without forcing them as empty.
    private boolean preserveWhitespace = false; // for pre, textarea, script etc
    private boolean formList = false; // a control that appears in forms: input, textarea, output etc
    private boolean formSubmit = false; // a control that can be submitted in a form: input etc

    private Tag(String tagName) {
        this.tagName = tagName;
        normalName = Normalizer.lowerCase(tagName);
    }

    /**
     * Get this tag's name.
     *
     * @return the tag's name
     */
    public String getName() {
        return tagName;
    }

    /**
     * Get this tag's normalized (lowercased) name.
     * @return the tag's normal name.
     */
    public String normalName() {
        return normalName;
    }

    /**
     * Get a Tag by name. If not previously defined (unknown), returns a new generic tag, that can do anything.
     * <p>
     * Pre-defined tags (P, DIV etc) will be ==, but unknown tags are not registered and will only .equals().
     * </p>
     * 
     * @param tagName Name of tag, e.g. ""p"". Case insensitive.
     * @param settings used to control tag name sensitivity
     * @return The tag, either defined or new generic.
     */
    public static Tag valueOf(String tagName, ParseSettings settings) {
        Validate.notNull(tagName);
        Tag tag = tags.get(tagName);

        if (tag == null) {
            tagName = settings.normalizeTag(tagName); // the name we'll use
            Validate.notEmpty(tagName);
            String normalName = Normalizer.lowerCase(tagName); // the lower-case name to get tag settings off
            tag = tags.get(normalName);

            if (tag == null) {
                // not defined: create default; go anywhere, do anything! (incl be inside a <p>)
                tag = new Tag(tagName);
                tag.isBlock = false;
            } else if (settings.preserveTagCase() && !tagName.equals(normalName))  {
                tag = tag.clone(); // get a new version vs the static one, so name update doesn't reset all
                tag.tagName = tagName;
            }
        }
        return tag;
    }

    /**
     * Get a Tag by name. If not previously defined (unknown), returns a new generic tag, that can do anything.
     * <p>
     * Pre-defined tags (P, DIV etc) will be ==, but unknown tags are not registered and will only .equals().
     * </p>
     *
     * @param tagName Name of tag, e.g. ""p"". <b>Case sensitive</b>.
     * @return The tag, either defined or new generic.
     */
    public static Tag valueOf(String tagName) {
        return valueOf(tagName, ParseSettings.preserveCase);
    }

    /**
     * Gets if this is a block tag.
     *
     * @return if block tag
     */
    public boolean isBlock() {
        return isBlock;
    }

    /**
     * Gets if this tag should be formatted as a block (or as inline)
     *
     * @return if should be formatted as block or inline
     */
    public boolean formatAsBlock() {
        return formatAsBlock;
    }

    /**
     * Gets if this tag is an inline tag.
     *
     * @return if this tag is an inline tag.
     */
    public boolean isInline() {
        return !isBlock;
    }

    /**
     * Get if this is an empty tag
     *
     * @return if this is an empty tag
     */
    public boolean isEmpty() {
        return empty;
    }

    /**
     * Get if this tag is self closing.
     *
     * @return if this tag should be output as self closing.
     */
    public boolean isSelfClosing() {
        return empty || selfClosing;
    }

    /**
     * Get if this is a pre-defined tag, or was auto created on parsing.
     *
     * @return if a known tag
     */
    public boolean isKnownTag() {
        return tags.containsKey(tagName);
    }

    /**
     * Check if this tagname is a known tag.
     *
     * @param tagName name of tag
     * @return if known HTML tag
     */
    public static boolean isKnownTag(String tagName) {
        return tags.containsKey(tagName);
    }

    /**
     * Get if this tag should preserve whitespace within child text nodes.
     *
     * @return if preserve whitespace
     */
    public boolean preserveWhitespace() {
        return preserveWhitespace;
    }

    /**
     * Get if this tag represents a control associated with a form. E.g. input, textarea, output
     * @return if associated with a form
     */
    public boolean isFormListed() {
        return formList;
    }

    /**
     * Get if this tag represents an element that should be submitted with a form. E.g. input, option
     * @return if submittable with a form
     */
    public boolean isFormSubmittable() {
        return formSubmit;
    }

    Tag setSelfClosing() {
        selfClosing = true;
        return this;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (!(o instanceof Tag)) return false;

        Tag tag = (Tag) o;

        if (!tagName.equals(tag.tagName)) return false;
        if (empty != tag.empty) return false;
        if (formatAsBlock != tag.formatAsBlock) return false;
        if (isBlock != tag.isBlock) return false;
        if (preserveWhitespace != tag.preserveWhitespace) return false;
        if (selfClosing != tag.selfClosing) return false;
        if (formList != tag.formList) return false;
        return formSubmit == tag.formSubmit;
    }

    @Override
    public int hashCode() {
        int result = tagName.hashCode();
        result = 31 * result + (isBlock ? 1 : 0);
        result = 31 * result + (formatAsBlock ? 1 : 0);
        result = 31 * result + (empty ? 1 : 0);
        result = 31 * result + (selfClosing ? 1 : 0);
        result = 31 * result + (preserveWhitespace ? 1 : 0);
        result = 31 * result + (formList ? 1 : 0);
        result = 31 * result + (formSubmit ? 1 : 0);
        return result;
    }

    @Override
    public String toString() {
        return tagName;
    }

    @Override
    protected Tag clone() {
        try {
            return (Tag) super.clone();
        } catch (CloneNotSupportedException e) {
            throw new RuntimeException(e);
        }
    }

    // internal static initialisers:
    // prepped from http://www.w3.org/TR/REC-html40/sgml/dtd.html and other sources
    private static final String[] blockTags = {
            ""html"", ""head"", ""body"", ""frameset"", ""script"", ""noscript"", ""style"", ""meta"", ""link"", ""title"", ""frame"",
            ""noframes"", ""section"", ""nav"", ""aside"", ""hgroup"", ""header"", ""footer"", ""p"", ""h1"", ""h2"", ""h3"", ""h4"", ""h5"", ""h6"",
            ""ul"", ""ol"", ""pre"", ""div"", ""blockquote"", ""hr"", ""address"", ""figure"", ""figcaption"", ""form"", ""fieldset"", ""ins"",
            ""del"", ""dl"", ""dt"", ""dd"", ""li"", ""table"", ""caption"", ""thead"", ""tfoot"", ""tbody"", ""colgroup"", ""col"", ""tr"", ""th"",
            ""td"", ""video"", ""audio"", ""canvas"", ""details"", ""menu"", ""plaintext"", ""template"", ""article"", ""main"",
            ""svg"", ""math"", ""center"", ""template"",
            ""dir"", ""applet"", ""marquee"", ""listing"" // deprecated but still known / special handling
    };
    private static final String[] inlineTags = {
            ""object"", ""base"", ""font"", ""tt"", ""i"", ""b"", ""u"", ""big"", ""small"", ""em"", ""strong"", ""dfn"", ""code"", ""samp"", ""kbd"",
            ""var"", ""cite"", ""abbr"", ""time"", ""acronym"", ""mark"", ""ruby"", ""rt"", ""rp"", ""a"", ""img"", ""br"", ""wbr"", ""map"", ""q"",
            ""sub"", ""sup"", ""bdo"", ""iframe"", ""embed"", ""span"", ""input"", ""select"", ""textarea"", ""label"", ""button"", ""optgroup"",
            ""option"", ""legend"", ""datalist"", ""keygen"", ""output"", ""progress"", ""meter"", ""area"", ""param"", ""source"", ""track"",
            ""summary"", ""command"", ""device"", ""area"", ""basefont"", ""bgsound"", ""menuitem"", ""param"", ""source"", ""track"",
            ""data"", ""bdi"", ""s"", ""strike"", ""nobr""
    };
    private static final String[] emptyTags = {
            ""meta"", ""link"", ""base"", ""frame"", ""img"", ""br"", ""wbr"", ""embed"", ""hr"", ""input"", ""keygen"", ""col"", ""command"",
            ""device"", ""area"", ""basefont"", ""bgsound"", ""menuitem"", ""param"", ""source"", ""track""
    };
    // todo - rework this to format contents as inline; and update html emitter in Element. Same output, just neater.
    private static final String[] formatAsInlineTags = {
            ""title"", ""a"", ""p"", ""h1"", ""h2"", ""h3"", ""h4"", ""h5"", ""h6"", ""pre"", ""address"", ""li"", ""th"", ""td"", ""script"", ""style"",
            ""ins"", ""del"", ""s""
    };
    private static final String[] preserveWhitespaceTags = {
            ""pre"", ""plaintext"", ""title"", ""textarea""
            // script is not here as it is a data node, which always preserve whitespace
    };
    // todo: I think we just need submit tags, and can scrub listed
    private static final String[] formListedTags = {
            ""button"", ""fieldset"", ""input"", ""keygen"", ""object"", ""output"", ""select"", ""textarea""
    };
    private static final String[] formSubmitTags = {
            ""input"", ""keygen"", ""object"", ""select"", ""textarea""
    };

    static {
        // creates
        for (String tagName : blockTags) {
            Tag tag = new Tag(tagName);
            register(tag);
        }
        for (String tagName : inlineTags) {
            Tag tag = new Tag(tagName);
            tag.isBlock = false;
            tag.formatAsBlock = false;
            register(tag);
        }

        // mods:
        for (String tagName : emptyTags) {
            Tag tag = tags.get(tagName);
            Validate.notNull(tag);
            tag.empty = true;
        }

        for (String tagName : formatAsInlineTags) {
            Tag tag = tags.get(tagName);
            Validate.notNull(tag);
            tag.formatAsBlock = false;
        }

        for (String tagName : preserveWhitespaceTags) {
            Tag tag = tags.get(tagName);
            Validate.notNull(tag);
            tag.preserveWhitespace = true;
        }

        for (String tagName : formListedTags) {
            Tag tag = tags.get(tagName);
            Validate.notNull(tag);
            tag.formList = true;
        }

        for (String tagName : formSubmitTags) {
            Tag tag = tags.get(tagName);
            Validate.notNull(tag);
            tag.formSubmit = true;
        }
    }

    private static void register(Tag tag) {
        tags.put(tag.tagName, tag);
    }
}
"
jhy/jsoup,src/test/java/org/jsoup/nodes/PositionTest.java,"package org.jsoup.nodes;

import org.jsoup.Jsoup;
import org.jsoup.integration.servlets.FileServlet;
import org.jsoup.parser.Parser;
import org.junit.jupiter.api.Test;

import java.io.IOException;

import static org.junit.jupiter.api.Assertions.*;

/**
 Functional tests for the Position tracking behavior (across nodes, treebuilder, etc.)
 */
class PositionTest {
    static Parser TrackingParser = Parser.htmlParser().setTrackPosition(true);

    @Test void parserTrackDefaults() {
        Parser htmlParser = Parser.htmlParser();
        assertFalse(htmlParser.isTrackPosition());
        htmlParser.setTrackPosition(true);
        assertTrue(htmlParser.isTrackPosition());

        Parser xmlParser = Parser.htmlParser();
        assertFalse(xmlParser.isTrackPosition());
        xmlParser.setTrackPosition(true);
        assertTrue(xmlParser.isTrackPosition());
    }

    @Test void tracksPosition() {
        String html = ""<p id=1\n class=foo>\n<span>Hello\n &reg;\n there &copy.</span> now.\n <!-- comment --> "";
        Document doc = Jsoup.parse(html, TrackingParser);

        Element body = doc.expectFirst(""body"");
        Element p = doc.expectFirst(""p"");
        Element span = doc.expectFirst(""span"");
        TextNode text = (TextNode) span.firstChild();
        assertNotNull(text);
        TextNode now = (TextNode) span.nextSibling();
        assertNotNull(now);
        Comment comment = (Comment) now.nextSibling();
        assertNotNull(comment);

        assertFalse(body.sourceRange().isTracked());

        Range pRange = p.sourceRange();
        assertEquals(""1,1:0-2,12:19"", pRange.toString());

        // no explicit P closer
        Range pEndRange = p.endSourceRange();
        assertFalse(pEndRange.isTracked());

        Range.Position pStart = pRange.start();
        assertTrue(pStart.isTracked());
        assertEquals(0, pStart.pos());
        assertEquals(1, pStart.columnNumber());
        assertEquals(1, pStart.lineNumber());
        assertEquals(""1,1:0"", pStart.toString());

        Range.Position pEnd = pRange.end();
        assertTrue(pStart.isTracked());
        assertEquals(19, pEnd.pos());
        assertEquals(12, pEnd.columnNumber());
        assertEquals(2, pEnd.lineNumber());
        assertEquals(""2,12:19"", pEnd.toString());

        assertEquals(""3,1:20"", span.sourceRange().start().toString());
        assertEquals(""3,7:26"", span.sourceRange().end().toString());

        // span end tag
        Range spanEnd = span.endSourceRange();
        assertTrue(spanEnd.isTracked());
        assertEquals(""5,14:52-5,21:59"", spanEnd.toString());

        String wholeText = text.getWholeText();
        assertEquals(""Hello\n ¬Æ\n there ¬©."", wholeText);
        String textOrig = ""Hello\n &reg;\n there &copy."";
        Range textRange = text.sourceRange();
        assertEquals(textRange.end().pos() -  textRange.start().pos(), textOrig.length());
        assertEquals(""3,7:26"", textRange.start().toString());
        assertEquals(""5,14:52"", textRange.end().toString());

        assertEquals(""6,2:66"", comment.sourceRange().start().toString());
        assertEquals(""6,18:82"", comment.sourceRange().end().toString());
    }

    @Test void tracksMarkup() {
        String html = ""<!doctype\nhtml>\n<title>jsoup &copy;\n2022</title><body>\n<![CDATA[\n<jsoup>\n]]>"";
        Document doc = Jsoup.parse(html, TrackingParser);

        DocumentType doctype = doc.documentType();
        assertNotNull(doctype);
        assertEquals(""html"", doctype.name());
        assertEquals(""1,1:0-2,6:15"", doctype.sourceRange().toString());

        Element title = doc.expectFirst(""title"");
        TextNode titleText = (TextNode) title.firstChild();
        assertNotNull(titleText);
        assertEquals(""jsoup ¬©\n2022"", title.text());
        assertEquals(titleText.getWholeText(), title.text());
        assertEquals(""3,1:16-3,8:23"", title.sourceRange().toString());
        assertEquals(""3,8:23-4,5:40"", titleText.sourceRange().toString());

        CDataNode cdata = (CDataNode) doc.body().childNode(1);
        assertEquals(""\n<jsoup>\n"", cdata.text());
        assertEquals(""5,1:55-7,4:76"", cdata.sourceRange().toString());
    }

    @Test void tracksDataNodes() {
        String html = ""<head>\n<script>foo;\nbar()\n5 <= 4;</script>"";
        Document doc = Jsoup.parse(html, TrackingParser);

        Element script = doc.expectFirst(""script"");
        assertNotNull(script);
        assertEquals(""2,1:7-2,9:15"", script.sourceRange().toString());
        DataNode data = (DataNode) script.firstChild();
        assertNotNull(data);
        assertEquals(""2,9:15-4,8:33"", data.sourceRange().toString());
    }

    @Test void tracksXml() {
        String xml = ""<?xml version=\""1.0\"" encoding=\""utf-8\""?>\n<!doctype html>\n<rss url=foo>\nXML\n</rss>\n<!-- comment -->"";
        Document doc = Jsoup.parse(xml, Parser.xmlParser().setTrackPosition(true));

        XmlDeclaration decl = (XmlDeclaration) doc.childNode(0);
        assertEquals(""1,1:0-1,39:38"", decl.sourceRange().toString());

        DocumentType doctype = (DocumentType) doc.childNode(2);
        assertEquals(""2,1:39-2,16:54"", doctype.sourceRange().toString());

        Element rss = doc.firstElementChild();
        assertNotNull(rss);
        assertEquals(""3,1:55-3,14:68"", rss.sourceRange().toString());
        assertEquals(""5,1:73-5,7:79"", rss.endSourceRange().toString());

        TextNode text = (TextNode) rss.firstChild();
        assertNotNull(text);
        assertEquals(""3,14:68-5,1:73"", text.sourceRange().toString());

        Comment comment = (Comment) rss.nextSibling().nextSibling();
        assertEquals(""6,1:80-6,17:96"", comment.sourceRange().toString());
    }

    @Test void tracksFromFetch() throws IOException {
        String url = FileServlet.urlTo(""/htmltests/large.html""); // 280 K
        Document doc = Jsoup.connect(url).parser(TrackingParser).get();

        Element firstP = doc.expectFirst(""p"");
        assertNotNull(firstP);
        assertEquals(""4,1:53-4,4:56"", firstP.sourceRange().toString());

        Element p = doc.expectFirst(""#xy"");
        assertNotNull(p);
        assertEquals(""1000,1:279646-1000,10:279655"", p.sourceRange().toString());
        assertEquals(""1000,567:280212-1000,571:280216"", p.endSourceRange().toString());

        TextNode text = (TextNode) p.firstChild();
        assertNotNull(text);
        assertEquals(""1000,10:279655-1000,357:280002"", text.sourceRange().toString());
    }

    @Test void tracksFromXmlFetch() throws IOException {
        String url = FileServlet.urlTo(""/htmltests/test-rss.xml"");
        Document doc = Jsoup.connect(url).parser(Parser.xmlParser().setTrackPosition(true)).get();

        Element item = doc.expectFirst(""item + item"");
        assertNotNull(item);
        assertEquals(""13,5:496-13,11:502"", item.sourceRange().toString());
        assertEquals(""17,5:779-17,12:786"", item.endSourceRange().toString());
    }

}"
jhy/jsoup,src/test/java/org/jsoup/nodes/NodeTest.java,"package org.jsoup.nodes;

import org.jsoup.Jsoup;
import org.jsoup.TextUtil;
import org.jsoup.parser.Tag;
import org.jsoup.select.NodeVisitor;
import org.junit.jupiter.api.Test;

import java.util.List;

import static org.junit.jupiter.api.Assertions.*;

/**
 Tests Nodes

 @author Jonathan Hedley, jonathan@hedley.net */
public class NodeTest {
    @Test public void handlesBaseUri() {
        Tag tag = Tag.valueOf(""a"");
        Attributes attribs = new Attributes();
        attribs.put(""relHref"", ""/foo"");
        attribs.put(""absHref"", ""http://bar/qux"");

        Element noBase = new Element(tag, """", attribs);
        assertEquals("""", noBase.absUrl(""relHref"")); // with no base, should NOT fallback to href attrib, whatever it is
        assertEquals(""http://bar/qux"", noBase.absUrl(""absHref"")); // no base but valid attrib, return attrib

        Element withBase = new Element(tag, ""http://foo/"", attribs);
        assertEquals(""http://foo/foo"", withBase.absUrl(""relHref"")); // construct abs from base + rel
        assertEquals(""http://bar/qux"", withBase.absUrl(""absHref"")); // href is abs, so returns that
        assertEquals("""", withBase.absUrl(""noval""));

        Element dodgyBase = new Element(tag, ""wtf://no-such-protocol/"", attribs);
        assertEquals(""http://bar/qux"", dodgyBase.absUrl(""absHref"")); // base fails, but href good, so get that
        assertEquals("""", dodgyBase.absUrl(""relHref"")); // base fails, only rel href, so return nothing
    }

    @Test public void setBaseUriIsRecursive() {
        Document doc = Jsoup.parse(""<div><p></p></div>"");
        String baseUri = ""https://jsoup.org"";
        doc.setBaseUri(baseUri);

        assertEquals(baseUri, doc.baseUri());
        assertEquals(baseUri, doc.select(""div"").first().baseUri());
        assertEquals(baseUri, doc.select(""p"").first().baseUri());
    }

    @Test public void handlesAbsPrefix() {
        Document doc = Jsoup.parse(""<a href=/foo>Hello</a>"", ""https://jsoup.org/"");
        Element a = doc.select(""a"").first();
        assertEquals(""/foo"", a.attr(""href""));
        assertEquals(""https://jsoup.org/foo"", a.attr(""abs:href""));
        assertTrue(a.hasAttr(""abs:href""));
    }

    @Test public void handlesAbsOnImage() {
        Document doc = Jsoup.parse(""<p><img src=\""/rez/osi_logo.png\"" /></p>"", ""https://jsoup.org/"");
        Element img = doc.select(""img"").first();
        assertEquals(""https://jsoup.org/rez/osi_logo.png"", img.attr(""abs:src""));
        assertEquals(img.absUrl(""src""), img.attr(""abs:src""));
    }

    @Test public void handlesAbsPrefixOnHasAttr() {
        // 1: no abs url; 2: has abs url
        Document doc = Jsoup.parse(""<a id=1 href='/foo'>One</a> <a id=2 href='https://jsoup.org/'>Two</a>"");
        Element one = doc.select(""#1"").first();
        Element two = doc.select(""#2"").first();

        assertFalse(one.hasAttr(""abs:href""));
        assertTrue(one.hasAttr(""href""));
        assertEquals("""", one.absUrl(""href""));

        assertTrue(two.hasAttr(""abs:href""));
        assertTrue(two.hasAttr(""href""));
        assertEquals(""https://jsoup.org/"", two.absUrl(""href""));
    }

    @Test public void literalAbsPrefix() {
        // if there is a literal attribute ""abs:xxx"", don't try and make absolute.
        Document doc = Jsoup.parse(""<a abs:href='odd'>One</a>"");
        Element el = doc.select(""a"").first();
        assertTrue(el.hasAttr(""abs:href""));
        assertEquals(""odd"", el.attr(""abs:href""));
    }

    @Test public void handleAbsOnFileUris() {
        Document doc = Jsoup.parse(""<a href='password'>One/a><a href='/var/log/messages'>Two</a>"", ""file:/etc/"");
        Element one = doc.select(""a"").first();
        assertEquals(""file:/etc/password"", one.absUrl(""href""));
        Element two = doc.select(""a"").get(1);
        assertEquals(""file:/var/log/messages"", two.absUrl(""href""));
    }

    @Test
    public void handleAbsOnLocalhostFileUris() {
        Document doc = Jsoup.parse(""<a href='password'>One/a><a href='/var/log/messages'>Two</a>"", ""file://localhost/etc/"");
        Element one = doc.select(""a"").first();
        assertEquals(""file://localhost/etc/password"", one.absUrl(""href""));
    }

    @Test
    public void handlesAbsOnProtocolessAbsoluteUris() {
        Document doc1 = Jsoup.parse(""<a href='//example.net/foo'>One</a>"", ""http://example.com/"");
        Document doc2 = Jsoup.parse(""<a href='//example.net/foo'>One</a>"", ""https://example.com/"");

        Element one = doc1.select(""a"").first();
        Element two = doc2.select(""a"").first();

        assertEquals(""http://example.net/foo"", one.absUrl(""href""));
        assertEquals(""https://example.net/foo"", two.absUrl(""href""));

        Document doc3 = Jsoup.parse(""<img src=//www.google.com/images/errors/logo_sm.gif alt=Google>"", ""https://google.com"");
        assertEquals(""https://www.google.com/images/errors/logo_sm.gif"", doc3.select(""img"").attr(""abs:src""));
    }

    /*
    Test for an issue with Java's abs URL handler.
     */
    @Test public void absHandlesRelativeQuery() {
        Document doc = Jsoup.parse(""<a href='?foo'>One</a> <a href='bar.html?foo'>Two</a>"", ""https://jsoup.org/path/file?bar"");

        Element a1 = doc.select(""a"").first();
        assertEquals(""https://jsoup.org/path/file?foo"", a1.absUrl(""href""));

        Element a2 = doc.select(""a"").get(1);
        assertEquals(""https://jsoup.org/path/bar.html?foo"", a2.absUrl(""href""));
    }

    @Test public void absHandlesDotFromIndex() {
        Document doc = Jsoup.parse(""<a href='./one/two.html'>One</a>"", ""http://example.com"");
        Element a1 = doc.select(""a"").first();
        assertEquals(""http://example.com/one/two.html"", a1.absUrl(""href""));
    }

    @Test public void handlesAbsOnUnknownProtocols() {
        // https://github.com/jhy/jsoup/issues/1610
        // URL would throw on unknown protocol tel: as no stream handler is registered

        String[] urls = {""mailto:example@example.com"", ""tel:867-5309""}; // mail has a handler, tel doesn't
        for (String url : urls) {
            Attributes attr = new Attributes().put(""href"", url);
            Element noBase = new Element(Tag.valueOf(""a""), null, attr);
            assertEquals(url, noBase.absUrl(""href""));

            Element withBase = new Element(Tag.valueOf(""a""), ""http://example.com/"", attr);
            assertEquals(url, withBase.absUrl(""href""));
        }
    }

    @Test public void testRemove() {
        Document doc = Jsoup.parse(""<p>One <span>two</span> three</p>"");
        Element p = doc.select(""p"").first();
        p.childNode(0).remove();

        assertEquals(""two three"", p.text());
        assertEquals(""<span>two</span> three"", TextUtil.stripNewlines(p.html()));
    }

    @Test public void testReplace() {
        Document doc = Jsoup.parse(""<p>One <span>two</span> three</p>"");
        Element p = doc.select(""p"").first();
        Element insert = doc.createElement(""em"").text(""foo"");
        p.childNode(1).replaceWith(insert);

        assertEquals(""One <em>foo</em> three"", p.html());
    }

    @Test public void ownerDocument() {
        Document doc = Jsoup.parse(""<p>Hello"");
        Element p = doc.select(""p"").first();
        assertSame(p.ownerDocument(), doc);
        assertSame(doc.ownerDocument(), doc);
        assertNull(doc.parent());
    }

    @Test public void root() {
        Document doc = Jsoup.parse(""<div><p>Hello"");
        Element p = doc.select(""p"").first();
        Node root = p.root();
        assertSame(doc, root);
        assertNull(root.parent());
        assertSame(doc.root(), doc);
        assertSame(doc.root(), doc.ownerDocument());

        Element standAlone = new Element(Tag.valueOf(""p""), """");
        assertNull(standAlone.parent());
        assertSame(standAlone.root(), standAlone);
        assertNull(standAlone.ownerDocument());
    }

    @Test public void before() {
        Document doc = Jsoup.parse(""<p>One <b>two</b> three</p>"");
        Element newNode = new Element(Tag.valueOf(""em""), """");
        newNode.appendText(""four"");

        doc.select(""b"").first().before(newNode);
        assertEquals(""<p>One <em>four</em><b>two</b> three</p>"", doc.body().html());

        doc.select(""b"").first().before(""<i>five</i>"");
        assertEquals(""<p>One <em>four</em><i>five</i><b>two</b> three</p>"", doc.body().html());
    }

    @Test public void after() {
        Document doc = Jsoup.parse(""<p>One <b>two</b> three</p>"");
        Element newNode = new Element(Tag.valueOf(""em""), """");
        newNode.appendText(""four"");

        doc.select(""b"").first().after(newNode);
        assertEquals(""<p>One <b>two</b><em>four</em> three</p>"", doc.body().html());

        doc.select(""b"").first().after(""<i>five</i>"");
        assertEquals(""<p>One <b>two</b><i>five</i><em>four</em> three</p>"", doc.body().html());
    }

    @Test public void unwrap() {
        Document doc = Jsoup.parse(""<div>One <span>Two <b>Three</b></span> Four</div>"");
        Element span = doc.select(""span"").first();
        Node twoText = span.childNode(0);
        Node node = span.unwrap();

        assertEquals(""<div>One Two <b>Three</b> Four</div>"", TextUtil.stripNewlines(doc.body().html()));
        assertTrue(node instanceof TextNode);
        assertEquals(""Two "", ((TextNode) node).text());
        assertEquals(node, twoText);
        assertEquals(node.parent(), doc.select(""div"").first());
    }

    @Test public void unwrapNoChildren() {
        Document doc = Jsoup.parse(""<div>One <span></span> Two</div>"");
        Element span = doc.select(""span"").first();
        Node node = span.unwrap();
        assertEquals(""<div>One  Two</div>"", TextUtil.stripNewlines(doc.body().html()));
        assertNull(node);
    }

    @Test public void traverse() {
        Document doc = Jsoup.parse(""<div><p>Hello</p></div><div>There</div>"");
        final StringBuilder accum = new StringBuilder();
        doc.select(""div"").first().traverse(new NodeVisitor() {
            @Override
            public void head(Node node, int depth) {
                accum.append(""<"").append(node.nodeName()).append("">"");
            }

            @Override
            public void tail(Node node, int depth) {
                accum.append(""</"").append(node.nodeName()).append("">"");
            }
        });
        assertEquals(""<div><p><#text></#text></p></div>"", accum.toString());
    }

    @Test public void forEachNode() {
        Document doc = Jsoup.parse(""<div><p>Hello</p></div><div>There</div><div id=1>Gone<p></div>"");
        doc.forEachNode(node -> {
            if (node instanceof TextNode) {
                TextNode textNode = (TextNode) node;
                if (textNode.text().equals(""There"")) {
                    textNode.text(""There Now"");
                    textNode.after(""<p>Another"");
                }
            } else if (node.attr(""id"").equals(""1""))
                node.remove();
        });
        assertEquals(""<div><p>Hello</p></div><div>There Now<p>Another</p></div>"", TextUtil.stripNewlines(doc.body().html()));
    }

    @Test public void orphanNodeReturnsNullForSiblingElements() {
        Node node = new Element(Tag.valueOf(""p""), """");
        Element el = new Element(Tag.valueOf(""p""), """");

        assertEquals(0, node.siblingIndex());
        assertEquals(0, node.siblingNodes().size());

        assertNull(node.previousSibling());
        assertNull(node.nextSibling());

        assertEquals(0, el.siblingElements().size());
        assertNull(el.previousElementSibling());
        assertNull(el.nextElementSibling());
    }

    @Test public void nodeIsNotASiblingOfItself() {
        Document doc = Jsoup.parse(""<div><p>One<p>Two<p>Three</div>"");
        Element p2 = doc.select(""p"").get(1);

        assertEquals(""Two"", p2.text());
        List<Node> nodes = p2.siblingNodes();
        assertEquals(2, nodes.size());
        assertEquals(""<p>One</p>"", nodes.get(0).outerHtml());
        assertEquals(""<p>Three</p>"", nodes.get(1).outerHtml());
    }

    @Test public void childNodesCopy() {
        Document doc = Jsoup.parse(""<div id=1>Text 1 <p>One</p> Text 2 <p>Two<p>Three</div><div id=2>"");
        Element div1 = doc.select(""#1"").first();
        Element div2 = doc.select(""#2"").first();
        List<Node> divChildren = div1.childNodesCopy();
        assertEquals(5, divChildren.size());
        TextNode tn1 = (TextNode) div1.childNode(0);
        TextNode tn2 = (TextNode) divChildren.get(0);
        tn2.text(""Text 1 updated"");
        assertEquals(""Text 1 "", tn1.text());
        div2.insertChildren(-1, divChildren);
        assertEquals(""<div id=\""1\"">Text 1 <p>One</p> Text 2 <p>Two</p><p>Three</p></div><div id=\""2\"">Text 1 updated""
            +""<p>One</p> Text 2 <p>Two</p><p>Three</p></div>"", TextUtil.stripNewlines(doc.body().html()));
    }

    @Test public void supportsClone() {
        Document doc = org.jsoup.Jsoup.parse(""<div class=foo>Text</div>"");
        Element el = doc.select(""div"").first();
        assertTrue(el.hasClass(""foo""));

        Element elClone = doc.clone().select(""div"").first();
        assertTrue(elClone.hasClass(""foo""));
        assertEquals(""Text"", elClone.text());

        el.removeClass(""foo"");
        el.text(""None"");
        assertFalse(el.hasClass(""foo""));
        assertTrue(elClone.hasClass(""foo""));
        assertEquals(""None"", el.text());
        assertEquals(""Text"", elClone.text());
    }

    @Test public void changingAttributeValueShouldReplaceExistingAttributeCaseInsensitive() {
        Document document = Jsoup.parse(""<INPUT id=\""foo\"" NAME=\""foo\"" VALUE=\""\"">"");
        Element inputElement = document.select(""#foo"").first();

        inputElement.attr(""value"",""bar"");

        assertEquals(singletonAttributes(), getAttributesCaseInsensitive(inputElement));
    }

    private Attributes getAttributesCaseInsensitive(Element element) {
        Attributes matches = new Attributes();
        for (Attribute attribute : element.attributes()) {
            if (attribute.getKey().equalsIgnoreCase(""value"")) {
                matches.put(attribute);
            }
        }
        return matches;
    }

    private Attributes singletonAttributes() {
        Attributes attributes = new Attributes();
        attributes.put(""value"", ""bar"");
        return attributes;
    }

    @Test void clonedNodesHaveOwnerDocsAndIndependentSettings() {
        // https://github.com/jhy/jsoup/issues/763
        Document doc = Jsoup.parse(""<div>Text</div><div>Two</div>"");
        doc.outputSettings().prettyPrint(false);
        Element div = doc.selectFirst(""div"");
        assertNotNull(div);
        TextNode text = (TextNode) div.childNode(0);
        assertNotNull(text);

        TextNode textClone = text.clone();
        Document docClone = textClone.ownerDocument();
        assertNotNull(docClone);
        assertFalse(docClone.outputSettings().prettyPrint());
        assertNotSame(doc, docClone);

        doc.outputSettings().prettyPrint(true);
        assertTrue(doc.outputSettings().prettyPrint());
        assertFalse(docClone.outputSettings().prettyPrint());
        assertEquals(1, docClone.childNodes().size()); // check did not get the second div as the owner's children
        assertEquals(textClone, docClone.childNode(0)); // note not the head or the body -- not normalized
    }

    @Test
    void firstAndLastChild() {
        String html = ""<div>One <span>Two</span> <a href></a> Three</div>"";
        Document doc = Jsoup.parse(html);
        Element div = doc.selectFirst(""div"");
        Element a = doc.selectFirst(""a"");
        assertNotNull(div);
        assertNotNull(a);

        // nodes
        TextNode first = (TextNode) div.firstChild();
        assertEquals(""One "", first.text());

        TextNode last = (TextNode) div.lastChild();
        assertEquals("" Three"", last.text());

        assertNull(a.firstChild());
        assertNull(a.lastChild());

        // elements
        Element firstEl = div.firstElementChild();
        assertEquals(""span"", firstEl.tagName());

        Element lastEl = div.lastElementChild();
        assertEquals(""a"", lastEl.tagName());

        assertNull(a.firstElementChild());
        assertNull(a.lastElementChild());

        assertNull(firstEl.firstElementChild());
        assertNull(firstEl.lastElementChild());
    }
}
"
jhy/jsoup,src/test/java/org/jsoup/integration/UrlConnectTest.java,"package org.jsoup.integration;

import org.jsoup.Connection;
import org.jsoup.Jsoup;
import org.jsoup.UnsupportedMimeTypeException;
import org.jsoup.helper.W3CDom;
import org.jsoup.internal.StringUtil;
import org.jsoup.nodes.Document;
import org.jsoup.nodes.FormElement;
import org.jsoup.parser.HtmlTreeBuilder;
import org.jsoup.parser.Parser;
import org.jsoup.parser.XmlTreeBuilder;
import org.junit.jupiter.api.Disabled;
import org.junit.jupiter.api.Test;

import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.net.ConnectException;
import java.net.InetSocketAddress;
import java.net.Proxy;
import java.net.URL;
import java.util.List;

import static org.junit.jupiter.api.Assertions.*;

/**
 Tests the URL connection. Not enabled by default, so tests don't require network connection.

 @author Jonathan Hedley, jonathan@hedley.net */
@Disabled // ignored by default so tests don't require network access. comment out to enable.
// todo: rebuild these into a local Jetty test server, so not reliant on the vagaries of the internet.
public class UrlConnectTest {
    private static final String WEBSITE_WITH_INVALID_CERTIFICATE = ""https://certs.cac.washington.edu/CAtest/"";
    private static final String WEBSITE_WITH_SNI = ""https://jsoup.org/"";
    public static String browserUa = ""Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/49.0.2623.112 Safari/537.36"";

    @Test
    public void fetchBaidu() throws IOException {
        Connection.Response res = Jsoup.connect(""http://www.baidu.com/"").timeout(10*1000).execute();
        Document doc = res.parse();

        assertEquals(""GBK"", doc.outputSettings().charset().displayName());
        assertEquals(""GBK"", res.charset());
        assert(res.hasCookie(""BAIDUID""));
        assertEquals(""text/html;charset=gbk"", res.contentType());
    }

    @Test
    public void exceptOnUnknownContentType() {
        String url = ""http://direct.jsoup.org/rez/osi_logo.png""; // not text/* but image/png, should throw
        boolean threw = false;
        try {
            Document doc = Jsoup.parse(new URL(url), 3000);
        } catch (UnsupportedMimeTypeException e) {
            threw = true;
            assertEquals(""org.jsoup.UnsupportedMimeTypeException: Unhandled content type. Must be text/*, application/xml, or application/xhtml+xml. Mimetype=image/png, URL=http://direct.jsoup.org/rez/osi_logo.png"", e.toString());
            assertEquals(url, e.getUrl());
            assertEquals(""image/png"", e.getMimeType());
        } catch (IOException e) {
        }
        assertTrue(threw);
    }

    @Test
    public void ignoresContentTypeIfSoConfigured() throws IOException {
        Document doc = Jsoup.connect(""https://jsoup.org/rez/osi_logo.png"").ignoreContentType(true).get();
        assertEquals("""", doc.title()); // this will cause an ugly parse tree
    }

    private static String ihVal(String key, Document doc) {
        return doc.select(""th:contains(""+key+"") + td"").first().text();
    }

    @Test
    public void followsTempRedirect() throws IOException {
        Connection con = Jsoup.connect(""http://direct.infohound.net/tools/302.pl""); // http://jsoup.org
        Document doc = con.get();
        assertTrue(doc.title().contains(""jsoup""));
    }

    @Test
    public void followsNewTempRedirect() throws IOException {
        Connection con = Jsoup.connect(""http://direct.infohound.net/tools/307.pl""); // http://jsoup.org
        Document doc = con.get();
        assertTrue(doc.title().contains(""jsoup""));
        assertEquals(""https://jsoup.org/"", con.response().url().toString());
    }

    @Test
    public void postRedirectsFetchWithGet() throws IOException {
        Connection con = Jsoup.connect(""http://direct.infohound.net/tools/302.pl"")
                .data(""Argument"", ""Riposte"")
                .method(Connection.Method.POST);
        Connection.Response res = con.execute();
        assertEquals(""https://jsoup.org/"", res.url().toExternalForm());
        assertEquals(Connection.Method.GET, res.method());
    }

    @Test
    public void followsRedirectToHttps() throws IOException {
        Connection con = Jsoup.connect(""http://direct.infohound.net/tools/302-secure.pl""); // https://www.google.com
        con.data(""id"", ""5"");
        Document doc = con.get();
        assertTrue(doc.title().contains(""Google""));
    }

    @Test
    public void followsRelativeRedirect() throws IOException {
        Connection con = Jsoup.connect(""http://direct.infohound.net/tools/302-rel.pl""); // to /tidy/
        Document doc = con.post();
        assertTrue(doc.title().contains(""HTML Tidy Online""));
    }

    @Test
    public void followsRelativeDotRedirect() throws IOException {
        // redirects to ""./ok.html"", should resolve to http://direct.infohound.net/tools/ok.html
        Connection con = Jsoup.connect(""http://direct.infohound.net/tools/302-rel-dot.pl""); // to ./ok.html
        Document doc = con.post();
        assertTrue(doc.title().contains(""OK""));
        assertEquals(doc.location(), ""http://direct.infohound.net/tools/ok.html"");
    }

    @Test
    public void followsRelativeDotRedirect2() throws IOException {
        //redirects to ""esportspenedes.cat/./ep/index.php"", should resolve to ""esportspenedes.cat/ep/index.php""
        Connection con = Jsoup.connect(""http://esportspenedes.cat"")  // note lack of trailing / - server should redir to / first, then to ./ep/...; but doesn't'
                .timeout(10000);
        Document doc = con.post();
        assertEquals(doc.location(), ""http://esportspenedes.cat/ep/index.php"");
    }

    @Test
    public void followsRedirectsWithWithespaces() throws IOException {
        Connection con = Jsoup.connect(""http://tinyurl.com/kgofxl8""); // to http://www.google.com/?q=white spaces
        Document doc = con.get();
        assertTrue(doc.title().contains(""Google""));
    }

    @Test
    public void gracefullyHandleBrokenLocationRedirect() throws IOException {
        Connection con = Jsoup.connect(""http://aag-ye.com""); // has Location: http:/temp/AAG_New/en/index.php
        con.get(); // would throw exception on error
        assertTrue(true);
    }

    @Test
    public void ignores500tExceptionIfSoConfigured() throws IOException {
        Connection con = Jsoup.connect(""http://direct.infohound.net/tools/500.pl"").ignoreHttpErrors(true);
        Connection.Response res = con.execute();
        Document doc = res.parse();
        assertEquals(500, res.statusCode());
        assertEquals(""Application Error"", res.statusMessage());
        assertEquals(""Woops"", doc.select(""h1"").first().text());
    }

    @Test
    public void ignores500WithNoContentExceptionIfSoConfigured() throws IOException {
        Connection con = Jsoup.connect(""http://direct.infohound.net/tools/500-no-content.pl"").ignoreHttpErrors(true);
        Connection.Response res = con.execute();
        Document doc = res.parse();
        assertEquals(500, res.statusCode());
        assertEquals(""Application Error"", res.statusMessage());
    }

    @Test
    public void ignores200WithNoContentExceptionIfSoConfigured() throws IOException {
        Connection con = Jsoup.connect(""http://direct.infohound.net/tools/200-no-content.pl"").ignoreHttpErrors(true);
        Connection.Response res = con.execute();
        Document doc = res.parse();
        assertEquals(200, res.statusCode());
        assertEquals(""All Good"", res.statusMessage());
    }

    @Test
    public void handles200WithNoContent() throws IOException {
        Connection con = Jsoup
            .connect(""http://direct.infohound.net/tools/200-no-content.pl"")
            .userAgent(browserUa);
        Connection.Response res = con.execute();
        Document doc = res.parse();
        assertEquals(200, res.statusCode());

        con = Jsoup
            .connect(""http://direct.infohound.net/tools/200-no-content.pl"")
            .parser(Parser.xmlParser())
            .userAgent(browserUa);
        res = con.execute();
        doc = res.parse();
        assertEquals(200, res.statusCode());
    }

    @Test
    public void doesntRedirectIfSoConfigured() throws IOException {
        Connection con = Jsoup.connect(""http://direct.infohound.net/tools/302.pl"").followRedirects(false);
        Connection.Response res = con.execute();
        assertEquals(302, res.statusCode());
        assertEquals(""http://jsoup.org"", res.header(""Location""));
    }

    @Test
    public void redirectsResponseCookieToNextResponse() throws IOException {
        Connection con = Jsoup.connect(""http://direct.infohound.net/tools/302-cookie.pl"");
        Connection.Response res = con.execute();
        assertEquals(""asdfg123"", res.cookie(""token"")); // confirms that cookies set on 1st hit are presented in final result
        Document doc = res.parse();
        assertEquals(""token=asdfg123; uid=jhy"", ihVal(""HTTP_COOKIE"", doc)); // confirms that redirected hit saw cookie
    }

    @Test
    public void maximumRedirects() {
        boolean threw = false;
        try {
            Document doc = Jsoup.connect(""http://direct.infohound.net/tools/loop.pl"").get();
        } catch (IOException e) {
            assertTrue(e.getMessage().contains(""Too many redirects""));
            threw = true;
        }
        assertTrue(threw);
    }

    @Test
    public void handlesDodgyCharset() throws IOException {
        // tests that when we get back ""UFT8"", that it is recognised as unsupported, and falls back to default instead
        String url = ""http://direct.infohound.net/tools/bad-charset.pl"";
        Connection.Response res = Jsoup.connect(url).execute();
        assertEquals(""text/html; charset=UFT8"", res.header(""Content-Type"")); // from the header
        assertNull(res.charset()); // tried to get from header, not supported, so returns null
        Document doc = res.parse(); // would throw an error if charset unsupported
        assertTrue(doc.text().contains(""Hello!""));
        assertEquals(""UTF-8"", res.charset()); // set from default on parse
    }

    /**
     * Verify that security disabling feature works properly.
     * <p/>
     * 1. try to hit url with invalid certificate and evaluate that exception is thrown
     *
     * @throws Exception
     */
    @Test
    public void testUnsafeFail() throws Exception {
        String url = WEBSITE_WITH_INVALID_CERTIFICATE;
        assertThrows(IOException.class, () -> Jsoup.connect(url).execute());
    }


    /**
     * Verify that requests to websites with SNI fail on jdk 1.6
     * <p/>
     * read for more details:
     * http://en.wikipedia.org/wiki/Server_Name_Indication
     *
     * Test is ignored independent from others as it requires JDK 1.6
     * @throws Exception
     */
    @Test
    public void testSNIFail() throws Exception {
        assertThrows(IOException.class, () -> Jsoup.connect(WEBSITE_WITH_SNI).execute());
    }

    @Test
    public void shouldWorkForCharsetInExtraAttribute() throws IOException {
        Connection.Response res = Jsoup.connect(""https://www.creditmutuel.com/groupe/fr/"").execute();
        Document doc = res.parse(); // would throw an error if charset unsupported
        assertEquals(""ISO-8859-1"", res.charset());
    }

    // The following tests were added to test specific domains if they work. All code paths
    // which make the following test green are tested in other unit or integration tests, so the following lines
    // could be deleted

    @Test
    public void shouldSelectFirstCharsetOnWeirdMultileCharsetsInMetaTags() throws IOException {
        Connection.Response res = Jsoup.connect(""http://aamo.info/"").execute();
        res.parse(); // would throw an error if charset unsupported
        assertEquals(""ISO-8859-1"", res.charset());
    }

    @Test
    public void shouldParseBrokenHtml5MetaCharsetTagCorrectly() throws IOException {
        Connection.Response res = Jsoup.connect(""http://9kuhkep.net"").execute();
        res.parse(); // would throw an error if charset unsupported
        assertEquals(""UTF-8"", res.charset());
    }

    @Test
    public void shouldEmptyMetaCharsetCorrectly() throws IOException {
        Connection.Response res = Jsoup.connect(""http://aastmultimedia.com"").execute();
        res.parse(); // would throw an error if charset unsupported
        assertEquals(""UTF-8"", res.charset());
    }

    @Test
    public void shouldWorkForDuplicateCharsetInTag() throws IOException {
        Connection.Response res = Jsoup.connect(""http://aaptsdassn.org"").execute();
        Document doc = res.parse(); // would throw an error if charset unsupported
        assertEquals(""ISO-8859-1"", res.charset());
    }

    @Test
    public void handles201Created() throws IOException {
        Document doc = Jsoup.connect(""http://direct.infohound.net/tools/201.pl"").get(); // 201, location=jsoup
        assertEquals(""https://jsoup.org/"", doc.location());
    }

    /*
     Proxy tests. Assumes local proxy running on 8888, without system propery set (so that specifying it is required).
     */

    @Test
    public void fetchViaHttpProxy() throws IOException {
        String url = ""https://jsoup.org"";
        Proxy proxy = new Proxy(Proxy.Type.HTTP, InetSocketAddress.createUnresolved(""localhost"", 8888));
        Document doc = Jsoup.connect(url).proxy(proxy).get();
        assertTrue(doc.title().contains(""jsoup""));
    }

    @Test
    public void fetchViaHttpProxySetByArgument() throws IOException {
        String url = ""https://jsoup.org"";
        Document doc = Jsoup.connect(url).proxy(""localhost"", 8888).get();
        assertTrue(doc.title().contains(""jsoup""));
    }

    @Test
    public void invalidProxyFails() {
        boolean caught = false;
        String url = ""https://jsoup.org"";
        try {
            Document doc = Jsoup.connect(url).proxy(""localhost"", 8889).get();
        } catch (IOException e) {
            caught = e instanceof ConnectException;
        }
        assertTrue(caught);
    }

    @Test
    public void proxyGetAndSet() throws IOException {
        String url = ""https://jsoup.org"";
        Proxy proxy = new Proxy(Proxy.Type.HTTP, InetSocketAddress.createUnresolved(""localhost"", 8889)); // invalid
        final Connection con = Jsoup.connect(url).proxy(proxy);

        assert con.request().proxy() == proxy;
        con.request().proxy(null); // disable
        Document doc = con.get();
        assertTrue(doc.title().contains(""jsoup"")); // would fail if actually went via proxy
    }

    @Test
    public void throwsIfRequestBodyForGet() throws IOException {
        boolean caught = false;
        String url = ""https://jsoup.org"";
        try {
            Document doc = Jsoup.connect(url).requestBody(""fail"").get();
        } catch (IllegalArgumentException e) {
            caught = true;
        }
        assertTrue(caught);
    }

    @Test
    public void canSpecifyResponseCharset() throws IOException {
        // both these docs have <80> in there as euro/control char depending on charset
        String noCharsetUrl = ""http://direct.infohound.net/tools/Windows-1252-nocharset.html"";
        String charsetUrl = ""http://direct.infohound.net/tools/Windows-1252-charset.html"";

        // included in meta
        Connection.Response res1 = Jsoup.connect(charsetUrl).execute();
        assertNull(res1.charset()); // not set in headers
        final Document doc1 = res1.parse();
        assertEquals(""windows-1252"", doc1.charset().displayName()); // but determined at parse time
        assertEquals(""Cost is ‚Ç¨100"", doc1.select(""p"").text());
        assertTrue(doc1.text().contains(""‚Ç¨""));

        // no meta, no override
        Connection.Response res2 = Jsoup.connect(noCharsetUrl).execute();
        assertNull(res2.charset()); // not set in headers
        final Document doc2 = res2.parse();
        assertEquals(""UTF-8"", doc2.charset().displayName()); // so defaults to utf-8
        assertEquals(""Cost is ÔøΩ100"", doc2.select(""p"").text());
        assertTrue(doc2.text().contains(""ÔøΩ""));

        // no meta, let's override
        Connection.Response res3 = Jsoup.connect(noCharsetUrl).execute();
        assertNull(res3.charset()); // not set in headers
        res3.charset(""windows-1252"");
        assertEquals(""windows-1252"", res3.charset()); // read back
        final Document doc3 = res3.parse();
        assertEquals(""windows-1252"", doc3.charset().displayName()); // from override
        assertEquals(""Cost is ‚Ç¨100"", doc3.select(""p"").text());
        assertTrue(doc3.text().contains(""‚Ç¨""));
    }

    @Test
    public void handlesUnescapedRedirects() throws IOException {
        // URL locations should be url safe (ascii) but are often not, so we should try to guess
        // in this case the location header is utf-8, but defined in spec as iso8859, so detect, convert, encode
        String url = ""http://direct.infohound.net/tools/302-utf.pl"";
        String urlEscaped = ""http://direct.infohound.net/tools/test%F0%9F%92%A9.html"";

        Connection.Response res = Jsoup.connect(url).execute();
        Document doc = res.parse();
        assertEquals(doc.body().text(), ""\uD83D\uDCA9!"");
        assertEquals(doc.location(), urlEscaped);

        Connection.Response res2 = Jsoup.connect(url).followRedirects(false).execute();
        assertEquals(""/tools/test\uD83D\uDCA9.html"", res2.header(""Location""));
        // if we didn't notice it was utf8, would look like: Location: /tools/test√∞¬ü¬í¬©.html
    }

    @Test public void handlesEscapesInRedirecct() throws IOException {
        Document doc = Jsoup.connect(""http://infohound.net/tools/302-escaped.pl"").get();
        assertEquals(""http://infohound.net/tools/q.pl?q=one%20two"", doc.location());

        doc = Jsoup.connect(""http://infohound.net/tools/302-white.pl"").get();
        assertEquals(""http://infohound.net/tools/q.pl?q=one%20two"", doc.location());
    }

    @Test
    public void handlesUt8fInUrl() throws IOException {
        String url = ""http://direct.infohound.net/tools/test\uD83D\uDCA9.html"";
        String urlEscaped = ""http://direct.infohound.net/tools/test%F0%9F%92%A9.html"";

        Connection.Response res = Jsoup.connect(url).execute();
        Document doc = res.parse();
        assertEquals(""\uD83D\uDCA9!"", doc.body().text());
        assertEquals(urlEscaped, doc.location());
    }

    @Test
    public void inWildUtfRedirect() throws IOException {
        Connection.Response res = Jsoup.connect(""http://brabantn.ws/Q4F"").execute();
        Document doc = res.parse();
        assertEquals(
            ""http://www.omroepbrabant.nl/?news/2474781303/Gestrande+ree+in+Oss+niet+verdoofd,+maar+doodgeschoten+%E2%80%98Dit+kan+gewoon+niet,+bizar%E2%80%99+[VIDEO].aspx"",
            doc.location()
            );
    }

    @Test
    public void inWildUtfRedirect2() throws IOException {
        Connection.Response res = Jsoup.connect(""https://ssl.souq.com/sa-en/2724288604627/s"").execute();
        Document doc = res.parse();
        assertEquals(
            ""https://saudi.souq.com/sa-en/%D8%AE%D8%B2%D9%86%D8%A9-%D8%A2%D9%85%D9%86%D8%A9-3-%D8%B7%D8%A8%D9%82%D8%A7%D8%AA-%D8%A8%D9%86%D8%B8%D8%A7%D9%85-%D9%82%D9%81%D9%84-%D8%A5%D9%84%D9%83%D8%AA%D8%B1%D9%88%D9%86%D9%8A-bsd11523-6831477/i/?ctype=dsrch"",
            doc.location()
        );
    }

   @Test public void handlesEscapedRedirectUrls() throws IOException {
        String url = ""http://www.altalex.com/documents/news/2016/12/06/questioni-civilistiche-conseguenti-alla-depenalizzazione"";
        // sends: Location:http://shop.wki.it/shared/sso/sso.aspx?sso=&url=http%3a%2f%2fwww.altalex.com%2fsession%2fset%2f%3freturnurl%3dhttp%253a%252f%252fwww.altalex.com%253a80%252fdocuments%252fnews%252f2016%252f12%252f06%252fquestioni-civilistiche-conseguenti-alla-depenalizzazione
        // then to: http://www.altalex.com/session/set/?returnurl=http%3a%2f%2fwww.altalex.com%3a80%2fdocuments%2fnews%2f2016%2f12%2f06%2fquestioni-civilistiche-conseguenti-alla-depenalizzazione&sso=RDRG6T684G4AK2E7U591UGR923
        // then : http://www.altalex.com:80/documents/news/2016/12/06/questioni-civilistiche-conseguenti-alla-depenalizzazione

        // bug is that jsoup goes to
        // 	GET /shared/sso/sso.aspx?sso=&url=http%253a%252f%252fwww.altalex.com%252fsession%252fset%252f%253freturnurl%253dhttp%25253a%25252f%25252fwww.altalex.com%25253a80%25252fdocuments%25252fnews%25252f2016%25252f12%25252f06%25252fquestioni-civilistiche-conseguenti-alla-depenalizzazione HTTP/1.1
        // i.e. double escaped

        Connection.Response res = Jsoup.connect(url)
                .proxy(""localhost"", 8888)
                .execute();
        Document doc = res.parse();
        assertEquals(200, res.statusCode());
    }

    @Test public void handlesUnicodeInQuery() throws IOException {
        Document doc = Jsoup.connect(""https://www.google.pl/search?q=gƒÖska"").get();
        assertEquals(""gƒÖska - Szukaj w Google"", doc.title());

        doc = Jsoup.connect(""http://mov-world.net/archiv/TV/A/%23No.Title/"").get();
        assertEquals(""Index of /archiv/TV/A/%23No.Title"", doc.title());
    }

    @Test public void handlesSuperDeepPage() throws IOException {
        // https://github.com/jhy/jsoup/issues/955

        long start = System.currentTimeMillis();
        String url = ""http://sv.stargate.wikia.com/wiki/M2J"";
        Document doc = Jsoup.connect(url).get();
        assertEquals(""M2J | Sv.stargate Wiki | FANDOM powered by Wikia"", doc.title());
        assertEquals(110160, doc.select(""dd"").size());
        // those are all <dl><dd> stacked in each other. wonder how that got generated?
        assertTrue(System.currentTimeMillis() - start < 1000);
    }

    @Test public void handles966() throws IOException {
        // http://szshb.nxszs.gov.cn/
        // https://github.com/jhy/jsoup/issues/966

        Document doc = Jsoup.connect(""http://szshb.nxszs.gov.cn/"").get();

        assertEquals(""Áü≥Âò¥Â±±Â∏ÇÁéØÂ¢É‰øùÊä§Â±Ä"", doc.title());
    }

    @Test public void canRequestIdn() throws IOException {
        String url = ""https://r√§ksm√∂rg√•s.josefsson.org/"";
        Document doc = Jsoup.connect(url).get();

        assertEquals(""https://xn--rksmrgs-5wao1o.josefsson.org/"", doc.location());
        assertTrue(doc.title().contains(""R√§ksm√∂rg√•s.josef√üon.org""));
    }

}
"
jhy/jsoup,src/main/java/org/jsoup/parser/Tokeniser.java,"package org.jsoup.parser;

import org.jsoup.helper.Validate;
import org.jsoup.internal.StringUtil;
import org.jsoup.nodes.Entities;

import javax.annotation.Nullable;
import java.util.Arrays;

/**
 * Readers the input stream into tokens.
 */
final class Tokeniser {
    static final char replacementChar = '\uFFFD'; // replaces null character
    private static final char[] notCharRefCharsSorted = new char[]{'\t', '\n', '\r', '\f', ' ', '<', '&'};

    // Some illegal character escapes are parsed by browsers as windows-1252 instead. See issue #1034
    // https://html.spec.whatwg.org/multipage/parsing.html#numeric-character-reference-end-state
    static final int win1252ExtensionsStart = 0x80;
    static final int[] win1252Extensions = new int[] {
            // we could build this manually, but Windows-1252 is not a standard java charset so that could break on
            // some platforms - this table is verified with a test
            0x20AC, 0x0081, 0x201A, 0x0192, 0x201E, 0x2026, 0x2020, 0x2021,
            0x02C6, 0x2030, 0x0160, 0x2039, 0x0152, 0x008D, 0x017D, 0x008F,
            0x0090, 0x2018, 0x2019, 0x201C, 0x201D, 0x2022, 0x2013, 0x2014,
            0x02DC, 0x2122, 0x0161, 0x203A, 0x0153, 0x009D, 0x017E, 0x0178,
    };

    static {
        Arrays.sort(notCharRefCharsSorted);
    }

    private final CharacterReader reader; // html input
    private final ParseErrorList errors; // errors found while tokenising

    private TokeniserState state = TokeniserState.Data; // current tokenisation state
    @Nullable private Token emitPending = null; // the token we are about to emit on next read
    private boolean isEmitPending = false;
    @Nullable private String charsString = null; // characters pending an emit. Will fall to charsBuilder if more than one
    private final StringBuilder charsBuilder = new StringBuilder(1024); // buffers characters to output as one token, if more than one emit per read
    StringBuilder dataBuffer = new StringBuilder(1024); // buffers data looking for </script>

    Token.StartTag startPending = new Token.StartTag();
    Token.EndTag endPending = new Token.EndTag();
    Token.Tag tagPending = startPending; // tag we are building up: start or end pending
    Token.Character charPending = new Token.Character();
    Token.Doctype doctypePending = new Token.Doctype(); // doctype building up
    Token.Comment commentPending = new Token.Comment(); // comment building up
    @Nullable private String lastStartTag; // the last start tag emitted, to test appropriate end tag
    @Nullable private String lastStartCloseSeq; // ""</"" + lastStartTag, so we can quickly check for that in RCData

    private static final int Unset = -1;
    private int markupStartPos, charStartPos = Unset; // reader pos at the start of markup / characters. updated on state transition

    Tokeniser(CharacterReader reader, ParseErrorList errors) {
        this.reader = reader;
        this.errors = errors;
    }

    Token read() {
        while (!isEmitPending) {
            state.read(this, reader);
        }

        // if emit is pending, a non-character token was found: return any chars in buffer, and leave token for next read:
        final StringBuilder cb = this.charsBuilder;
        if (cb.length() != 0) {
            String str = cb.toString();
            cb.delete(0, cb.length());
            Token token = charPending.data(str);
            charsString = null;
            return token;
        } else if (charsString != null) {
            Token token = charPending.data(charsString);
            charsString = null;
            return token;
        } else {
            isEmitPending = false;
            assert emitPending != null;
            return emitPending;
        }
    }

    void emit(Token token) {
        Validate.isFalse(isEmitPending);

        emitPending = token;
        isEmitPending = true;
        token.startPos(markupStartPos);
        token.endPos(reader.pos());
        charStartPos = Unset;

        if (token.type == Token.TokenType.StartTag) {
            Token.StartTag startTag = (Token.StartTag) token;
            lastStartTag = startTag.tagName;
            lastStartCloseSeq = null; // only lazy inits
        } else if (token.type == Token.TokenType.EndTag) {
            Token.EndTag endTag = (Token.EndTag) token;
            if (endTag.hasAttributes())
                error(""Attributes incorrectly present on end tag [/%s]"", endTag.normalName());
        }
    }

    void emit(final String str) {
        // buffer strings up until last string token found, to emit only one token for a run of character refs etc.
        // does not set isEmitPending; read checks that
        if (charsString == null) {
            charsString = str;
        } else {
            if (charsBuilder.length() == 0) { // switching to string builder as more than one emit before read
                charsBuilder.append(charsString);
            }
            charsBuilder.append(str);
        }
        charPending.startPos(charStartPos);
        charPending.endPos(reader.pos());
    }

    // variations to limit need to create temp strings
    void emit(final StringBuilder str) {
        if (charsString == null) {
            charsString = str.toString();
        } else {
            if (charsBuilder.length() == 0) {
                charsBuilder.append(charsString);
            }
            charsBuilder.append(str);
        }
        charPending.startPos(charStartPos);
        charPending.endPos(reader.pos());
    }

    void emit(char c) {
        if (charsString == null) {
            charsString = String.valueOf(c);
        } else {
            if (charsBuilder.length() == 0) {
                charsBuilder.append(charsString);
            }
            charsBuilder.append(c);
        }
        charPending.startPos(charStartPos);
        charPending.endPos(reader.pos());
    }

    void emit(char[] chars) {
        emit(String.valueOf(chars));
    }

    void emit(int[] codepoints) {
        emit(new String(codepoints, 0, codepoints.length));
    }

    TokeniserState getState() {
        return state;
    }

    void transition(TokeniserState newState) {
        // track markup / data position on state transitions
        switch (newState) {
            case TagOpen:
                markupStartPos = reader.pos();
                break;
            case Data:
                if (charStartPos == Unset) // don't reset when we are jumping between e.g data -> char ref -> data
                    charStartPos = reader.pos();
        }

        this.state = newState;
    }

    void advanceTransition(TokeniserState newState) {
        transition(newState);
        reader.advance();
    }

    final private int[] codepointHolder = new int[1]; // holder to not have to keep creating arrays
    final private int[] multipointHolder = new int[2];
    @Nullable int[] consumeCharacterReference(@Nullable Character additionalAllowedCharacter, boolean inAttribute) {
        if (reader.isEmpty())
            return null;
        if (additionalAllowedCharacter != null && additionalAllowedCharacter == reader.current())
            return null;
        if (reader.matchesAnySorted(notCharRefCharsSorted))
            return null;

        final int[] codeRef = codepointHolder;
        reader.mark();
        if (reader.matchConsume(""#"")) { // numbered
            boolean isHexMode = reader.matchConsumeIgnoreCase(""X"");
            String numRef = isHexMode ? reader.consumeHexSequence() : reader.consumeDigitSequence();
            if (numRef.length() == 0) { // didn't match anything
                characterReferenceError(""numeric reference with no numerals"");
                reader.rewindToMark();
                return null;
            }

            reader.unmark();
            if (!reader.matchConsume("";""))
                characterReferenceError(""missing semicolon on [&#%s]"", numRef); // missing semi
            int charval = -1;
            try {
                int base = isHexMode ? 16 : 10;
                charval = Integer.valueOf(numRef, base);
            } catch (NumberFormatException ignored) {
            } // skip
            if (charval == -1 || (charval >= 0xD800 && charval <= 0xDFFF) || charval > 0x10FFFF) {
                characterReferenceError(""character [%s] outside of valid range"", charval);
                codeRef[0] = replacementChar;
            } else {
                // fix illegal unicode characters to match browser behavior
                if (charval >= win1252ExtensionsStart && charval < win1252ExtensionsStart + win1252Extensions.length) {
                    characterReferenceError(""character [%s] is not a valid unicode code point"", charval);
                    charval = win1252Extensions[charval - win1252ExtensionsStart];
                }

                // todo: implement number replacement table
                // todo: check for extra illegal unicode points as parse errors
                codeRef[0] = charval;
            }
            return codeRef;
        } else { // named
            // get as many letters as possible, and look for matching entities.
            String nameRef = reader.consumeLetterThenDigitSequence();
            boolean looksLegit = reader.matches(';');
            // found if a base named entity without a ;, or an extended entity with the ;.
            boolean found = (Entities.isBaseNamedEntity(nameRef) || (Entities.isNamedEntity(nameRef) && looksLegit));

            if (!found) {
                reader.rewindToMark();
                if (looksLegit) // named with semicolon
                    characterReferenceError(""invalid named reference [%s]"", nameRef);
                return null;
            }
            if (inAttribute && (reader.matchesLetter() || reader.matchesDigit() || reader.matchesAny('=', '-', '_'))) {
                // don't want that to match
                reader.rewindToMark();
                return null;
            }

            reader.unmark();
            if (!reader.matchConsume("";""))
                characterReferenceError(""missing semicolon on [&%s]"", nameRef); // missing semi
            int numChars = Entities.codepointsForName(nameRef, multipointHolder);
            if (numChars == 1) {
                codeRef[0] = multipointHolder[0];
                return codeRef;
            } else if (numChars ==2) {
                return multipointHolder;
            } else {
                Validate.fail(""Unexpected characters returned for "" + nameRef);
                return multipointHolder;
            }
        }
    }

    Token.Tag createTagPending(boolean start) {
        tagPending = start ? startPending.reset() : endPending.reset();
        return tagPending;
    }

    void emitTagPending() {
        tagPending.finaliseTag();
        emit(tagPending);
    }

    void createCommentPending() {
        commentPending.reset();
    }

    void emitCommentPending() {
        emit(commentPending);
    }

    void createBogusCommentPending() {
        commentPending.reset();
        commentPending.bogus = true;
    }

    void createDoctypePending() {
        doctypePending.reset();
    }

    void emitDoctypePending() {
        emit(doctypePending);
    }

    void createTempBuffer() {
        Token.reset(dataBuffer);
    }

    boolean isAppropriateEndTagToken() {
        return lastStartTag != null && tagPending.name().equalsIgnoreCase(lastStartTag);
    }

    @Nullable String appropriateEndTagName() {
        return lastStartTag; // could be null
    }

    /** Returns the closer sequence {@code </lastStart} */
    String appropriateEndTagSeq() {
        if (lastStartCloseSeq == null) // reset on start tag emit
            lastStartCloseSeq = ""</"" + lastStartTag;
        return lastStartCloseSeq;
    }

    void error(TokeniserState state) {
        if (errors.canAddError())
            errors.add(new ParseError(reader, ""Unexpected character '%s' in input state [%s]"", reader.current(), state));
    }

    void eofError(TokeniserState state) {
        if (errors.canAddError())
            errors.add(new ParseError(reader, ""Unexpectedly reached end of file (EOF) in input state [%s]"", state));
    }

    private void characterReferenceError(String message, Object... args) {
        if (errors.canAddError())
            errors.add(new ParseError(reader, String.format(""Invalid character reference: "" + message, args)));
    }

    void error(String errorMsg) {
        if (errors.canAddError())
            errors.add(new ParseError(reader, errorMsg));
    }

    void error(String errorMsg, Object... args) {
        if (errors.canAddError())
            errors.add(new ParseError(reader, errorMsg, args));
    }

    boolean currentNodeInHtmlNS() {
        // todo: implement namespaces correctly
        return true;
        // Element currentNode = currentNode();
        // return currentNode != null && currentNode.namespace().equals(""HTML"");
    }

    /**
     * Utility method to consume reader and unescape entities found within.
     * @param inAttribute if the text to be unescaped is in an attribute
     * @return unescaped string from reader
     */
    String unescapeEntities(boolean inAttribute) {
        StringBuilder builder = StringUtil.borrowBuilder();
        while (!reader.isEmpty()) {
            builder.append(reader.consumeTo('&'));
            if (reader.matches('&')) {
                reader.consume();
                int[] c = consumeCharacterReference(null, inAttribute);
                if (c == null || c.length==0)
                    builder.append('&');
                else {
                    builder.appendCodePoint(c[0]);
                    if (c.length == 2)
                        builder.appendCodePoint(c[1]);
                }

            }
        }
        return StringUtil.releaseBuilder(builder);
    }
}
"
jhy/jsoup,src/test/java/org/jsoup/integration/Benchmark.java,"package org.jsoup.integration;

import java.util.Date;

/**
 Does an A/B test on two methods, and prints out how long each took.

 @author Jonathan Hedley, jonathan@hedley.net */
public class Benchmark {
    public static void run(Runnable a, Runnable b, int count) {
        long aMillis;
        long bMillis;

        print(""Running test A (x%d)"", count);
        aMillis = time(a, count);
        print(""Running test B"");
        bMillis = time(b, count);

        print(""\nResults:"");
        print(""A: %.2fs"", aMillis / 1000f);
        print(""B: %.2fs"", bMillis / 1000f);
        print(""\nB ran in %.2f %% time of A\n"", (bMillis *1f / aMillis * 1f) * 100f);
    }

    private static long time(Runnable test, int count) {
        Date start = new Date();
        for (int i = 0; i < count; i++) {
            test.run();
        }
        Date end = new Date();
        return end.getTime() - start.getTime();
    }

    private static void print(String msgFormat, Object... msgParams) {
        System.out.println(String.format(msgFormat, msgParams));
    }
}
"
jhy/jsoup,src/test/java/org/jsoup/integration/FuzzFixesIT.java,"package org.jsoup.integration;

import org.jsoup.Jsoup;
import org.jsoup.nodes.Document;
import org.jsoup.parser.Parser;
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.MethodSource;

import java.io.File;
import java.io.IOException;
import java.util.stream.Stream;

import static org.junit.jupiter.api.Assertions.assertNotNull;
import static org.junit.jupiter.api.Assertions.assertTrue;

/**
 Tests fixes for issues raised by the <a href=""https://oss-fuzz.com/testcases?project=jsoup"">OSS Fuzz project</a>. As
 some of these are timeout tests - run each file 100 times and ensure under time.
 */
public class FuzzFixesIT {
    static int numIters = 50;
    static int timeout = 30; // external fuzzer is set to 60 for 100 runs
    static File testDir = ParseTest.getFile(""/fuzztests/"");

    private static Stream<File> testFiles() {
        File[] files = testDir.listFiles();
        assertNotNull(files);
        assertTrue(files.length > 10);

        return Stream.of(files);
    }

    @ParameterizedTest
    @MethodSource(""testFiles"")
    void testHtmlParse(File file) throws IOException {
        long startTime = System.currentTimeMillis();
        long completeBy = startTime + timeout * 1000L;

        for (int i = 0; i < numIters; i++) {
            Document doc = Jsoup.parse(file, ""UTF-8"", ""https://example.com/"");
            assertNotNull(doc);
            if (System.currentTimeMillis() > completeBy)
                Assertions.fail(String.format(""Timeout: only completed %d iters of [%s] in %d seconds"", i, file.getName(), timeout));
        }
    }

    @ParameterizedTest
    @MethodSource(""testFiles"")
    void testXmlParse(File file) throws IOException {
        long startTime = System.currentTimeMillis();
        long completeBy = startTime + timeout * 1000L;

        for (int i = 0; i < numIters; i++) {
            Document doc = Jsoup.parse(file, ""UTF-8"", ""https://example.com/"", Parser.xmlParser());
            assertNotNull(doc);
            if (System.currentTimeMillis() > completeBy)
                Assertions.fail(String.format(""Timeout: only completed %d iters of [%s] in %d seconds"", i, file.getName(), timeout));
        }
    }
}
"
jhy/jsoup,src/test/java/org/jsoup/parser/TokeniserStateTest.java,"package org.jsoup.parser;

import org.jsoup.Jsoup;
import org.jsoup.TextUtil;
import org.jsoup.nodes.Comment;
import org.jsoup.nodes.Document;
import org.jsoup.nodes.Element;
import org.jsoup.nodes.TextNode;
import org.jsoup.select.Elements;
import org.junit.jupiter.api.Test;

import java.util.Arrays;

import static org.junit.jupiter.api.Assertions.assertArrayEquals;
import static org.junit.jupiter.api.Assertions.assertEquals;

public class TokeniserStateTest {

    final char[] whiteSpace = { '\t', '\n', '\r', '\f', ' ' };
    final char[] quote = { '\'', '""' };

    @Test
    public void ensureSearchArraysAreSorted() {
        char[][] arrays = {
            TokeniserState.attributeNameCharsSorted,
            TokeniserState.attributeValueUnquoted
        };

        for (char[] array : arrays) {
            char[] copy = Arrays.copyOf(array, array.length);
            Arrays.sort(array);
            assertArrayEquals(array, copy);
        }
    }

    @Test
    public void testCharacterReferenceInRcdata() {
        String body = ""<textarea>You&I</textarea>"";
        Document doc = Jsoup.parse(body);
        Elements els = doc.select(""textarea"");
        assertEquals(""You&I"", els.text());
    }

    @Test
    public void testBeforeTagName() {
        for (char c : whiteSpace) {
            String body = String.format(""<div%c>test</div>"", c);
            Document doc = Jsoup.parse(body);
            Elements els = doc.select(""div"");
            assertEquals(""test"", els.text());
        }
    }

    @Test
    public void testEndTagOpen() {
        String body;
        Document doc;
        Elements els;

        body = ""<div>hello world</"";
        doc = Jsoup.parse(body);
        els = doc.select(""div"");
        assertEquals(""hello world</"", els.text());

        body = ""<div>hello world</div>"";
        doc = Jsoup.parse(body);
        els = doc.select(""div"");
        assertEquals(""hello world"", els.text());

        body = ""<div>fake</></div>"";
        doc = Jsoup.parse(body);
        els = doc.select(""div"");
        assertEquals(""fake"", els.text());

        body = ""<div>fake</?</div>"";
        doc = Jsoup.parse(body);
        els = doc.select(""div"");
        assertEquals(""fake"", els.text());
    }

    @Test
    public void testRcdataLessthanSign() {
        String body;
        Document doc;
        Elements els;

        body = ""<textarea><fake></textarea>"";
        doc = Jsoup.parse(body);
        els = doc.select(""textarea"");
        assertEquals(""<fake>"", els.text());

        body = ""<textarea><open"";
        doc = Jsoup.parse(body);
        els = doc.select(""textarea"");
        assertEquals("""", els.text());

        body = ""<textarea>hello world</?fake</textarea>"";
        doc = Jsoup.parse(body);
        els = doc.select(""textarea"");
        assertEquals(""hello world</?fake"", els.text());
    }

    @Test
    public void testRCDATAEndTagName() {
        for (char c : whiteSpace) {
            String body = String.format(""<textarea>data</textarea%c>"", c);
            Document doc = Jsoup.parse(body);
            Elements els = doc.select(""textarea"");
            assertEquals(""data"", els.text());
        }
    }

    @Test
    public void testCommentEndCoverage() {
        String html = ""<html><head></head><body><img src=foo><!-- <table><tr><td></table> --! --- --><p>Hello</p></body></html>"";
        Document doc = Jsoup.parse(html);

        Element body = doc.body();
        Comment comment = (Comment) body.childNode(1);
        assertEquals("" <table><tr><td></table> --! --- "", comment.getData());
        Element p = body.child(1);
        TextNode text = (TextNode) p.childNode(0);
        assertEquals(""Hello"", text.getWholeText());
    }

    @Test
    public void testCommentEndBangCoverage() {
        String html = ""<html><head></head><body><img src=foo><!-- <table><tr><td></table> --!---!>--><p>Hello</p></body></html>"";
        Document doc = Jsoup.parse(html);

        Element body = doc.body();
        Comment comment = (Comment) body.childNode(1);
        assertEquals("" <table><tr><td></table> --!-"", comment.getData());
        Element p = body.child(1);
        TextNode text = (TextNode) p.childNode(0);
        assertEquals(""Hello"", text.getWholeText());
    }

    @Test
    public void testPublicIdentifiersWithWhitespace() {
        String expectedOutput = ""<!DOCTYPE html PUBLIC \""-//W3C//DTD HTML 4.0//EN\"">"";
        for (char q : quote) {
            for (char ws : whiteSpace) {
                String[] htmls = {
                        String.format(""<!DOCTYPE html%cPUBLIC %c-//W3C//DTD HTML 4.0//EN%c>"", ws, q, q),
                        String.format(""<!DOCTYPE html %cPUBLIC %c-//W3C//DTD HTML 4.0//EN%c>"", ws, q, q),
                        String.format(""<!DOCTYPE html PUBLIC%c%c-//W3C//DTD HTML 4.0//EN%c>"", ws, q, q),
                        String.format(""<!DOCTYPE html PUBLIC %c%c-//W3C//DTD HTML 4.0//EN%c>"", ws, q, q),
                        String.format(""<!DOCTYPE html PUBLIC %c-//W3C//DTD HTML 4.0//EN%c%c>"", q, q, ws),
                        String.format(""<!DOCTYPE html PUBLIC%c-//W3C//DTD HTML 4.0//EN%c%c>"", q, q, ws)
                    };
                for (String html : htmls) {
                    Document doc = Jsoup.parse(html);
                    assertEquals(expectedOutput, doc.childNode(0).outerHtml());
                }
            }
        }
    }

    @Test
    public void testSystemIdentifiersWithWhitespace() {
        String expectedOutput = ""<!DOCTYPE html SYSTEM \""http://www.w3.org/TR/REC-html40/strict.dtd\"">"";
        for (char q : quote) {
            for (char ws : whiteSpace) {
                String[] htmls = {
                        String.format(""<!DOCTYPE html%cSYSTEM %chttp://www.w3.org/TR/REC-html40/strict.dtd%c>"", ws, q, q),
                        String.format(""<!DOCTYPE html %cSYSTEM %chttp://www.w3.org/TR/REC-html40/strict.dtd%c>"", ws, q, q),
                        String.format(""<!DOCTYPE html SYSTEM%c%chttp://www.w3.org/TR/REC-html40/strict.dtd%c>"", ws, q, q),
                        String.format(""<!DOCTYPE html SYSTEM %c%chttp://www.w3.org/TR/REC-html40/strict.dtd%c>"", ws, q, q),
                        String.format(""<!DOCTYPE html SYSTEM %chttp://www.w3.org/TR/REC-html40/strict.dtd%c%c>"", q, q, ws),
                        String.format(""<!DOCTYPE html SYSTEM%chttp://www.w3.org/TR/REC-html40/strict.dtd%c%c>"", q, q, ws)
                    };
                for (String html : htmls) {
                    Document doc = Jsoup.parse(html);
                    assertEquals(expectedOutput, doc.childNode(0).outerHtml());
                }
            }
        }
    }

    @Test
    public void testPublicAndSystemIdentifiersWithWhitespace() {
        String expectedOutput = ""<!DOCTYPE html PUBLIC \""-//W3C//DTD HTML 4.0//EN\""""
                + "" \""http://www.w3.org/TR/REC-html40/strict.dtd\"">"";
    	for (char q : quote) {
            for (char ws : whiteSpace) {
                String[] htmls = {
                        String.format(""<!DOCTYPE html PUBLIC %c-//W3C//DTD HTML 4.0//EN%c""
                                + ""%c%chttp://www.w3.org/TR/REC-html40/strict.dtd%c>"", q, q, ws, q, q),
                        String.format(""<!DOCTYPE html PUBLIC %c-//W3C//DTD HTML 4.0//EN%c""
                                + ""%chttp://www.w3.org/TR/REC-html40/strict.dtd%c>"", q, q, q, q)
                    };
                for (String html : htmls) {
                    Document doc = Jsoup.parse(html);
                    assertEquals(expectedOutput, doc.childNode(0).outerHtml());
                }
            }
        }
    }

    @Test public void handlesLessInTagThanAsNewTag() {
        // out of spec, but clear author intent
        String html = ""<p\n<p<div id=one <span>Two"";
        Document doc = Jsoup.parse(html);
        assertEquals(""<p></p><p></p><div id=\""one\""><span>Two</span></div>"", TextUtil.stripNewlines(doc.body().html()));
    }

    @Test
    public void testUnconsumeAtBufferBoundary() {
        String triggeringSnippet = ""<a href=\""\""foo"";
        char[] padding = new char[CharacterReader.readAheadLimit - triggeringSnippet.length() + 2]; // The ""foo"" part must be just at the limit.
        Arrays.fill(padding, ' ');
        String paddedSnippet = String.valueOf(padding) + triggeringSnippet;
        ParseErrorList errorList = ParseErrorList.tracking(1);

        Parser.parseFragment(paddedSnippet, null, """", errorList);

        assertEquals(CharacterReader.readAheadLimit - 1, errorList.get(0).getPosition());
    }

    @Test
    public void testUnconsumeAfterBufferUp() {
        // test for after consume() a bufferUp occurs (look-forward) but then attempts to unconsume. Would throw a ""No buffer left to unconsume""
        String triggeringSnippet = ""<title>One <span>Two"";
        char[] padding = new char[CharacterReader.readAheadLimit - triggeringSnippet.length() + 8]; // The ""<span"" part must be just at the limit. The ""containsIgnoreCase"" scan does a bufferUp, losing the unconsume
        Arrays.fill(padding, ' ');
        String paddedSnippet = String.valueOf(padding) + triggeringSnippet;
        ParseErrorList errorList = ParseErrorList.tracking(1);
        Parser.parseFragment(paddedSnippet, null, """", errorList);
        // just asserting we don't get a WTF on unconsume
    }

    @Test
    public void testOpeningAngleBracketInsteadOfAttribute() {
        String triggeringSnippet = ""<html <"";
        ParseErrorList errorList = ParseErrorList.tracking(1);

        Parser.parseFragment(triggeringSnippet, null, """", errorList);

        assertEquals(6, errorList.get(0).getPosition());
    }

    @Test
    public void testMalformedSelfClosingTag() {
        String triggeringSnippet = ""<html /ouch"";
        ParseErrorList errorList = ParseErrorList.tracking(1);

        Parser.parseFragment(triggeringSnippet, null, """", errorList);

        assertEquals(7, errorList.get(0).getPosition());
    }

    @Test
    public void testOpeningAngleBracketInTagName() {
        String triggeringSnippet = ""<html<"";
        ParseErrorList errorList = ParseErrorList.tracking(1);

        Parser.parseFragment(triggeringSnippet, null, """", errorList);

        assertEquals(5, errorList.get(0).getPosition());
    }

    @Test
    public void rcData() {
        Document doc = Jsoup.parse(""<title>One \0Two</title>"");
        assertEquals(""One ÔøΩTwo"", doc.title());
    }

    @Test
    public void plaintext() {
        Document doc = Jsoup.parse(""<div>One<plaintext><div>Two</plaintext>\0no < Return"");
        assertEquals(""<html><head></head><body><div>One<plaintext>&lt;div&gt;Two&lt;/plaintext&gt;ÔøΩno &lt; Return</plaintext></div></body></html>"", TextUtil.stripNewlines(doc.html()));
    }

    @Test
    public void nullInTag() {
        Document doc = Jsoup.parse(""<di\0v>One</di\0v>Two"");
        assertEquals(""<diÔøΩv>\n One\n</diÔøΩv>Two"", doc.body().html());
    }

    @Test
    public void attributeValUnquoted() {
        Document doc = Jsoup.parse(""<p name=foo&lt;bar>"");
        Element p = doc.selectFirst(""p"");
        assertEquals(""foo<bar"", p.attr(""name""));

        doc = Jsoup.parse(""<p foo="");
        assertEquals(""<p foo></p>"", doc.body().html());
    }
}
"
jhy/jsoup,src/test/java/org/jsoup/parser/ParserIT.java,"package org.jsoup.parser;

import org.jsoup.nodes.Document;
import org.junit.jupiter.api.Disabled;
import org.junit.jupiter.api.Test;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertTrue;

/**
 * Longer running Parser tests.
 */

public class ParserIT {
    @Test
    @Disabled // disabled by default now, as there more specific unconsume tests
    public void testIssue1251() {
        // https://github.com/jhy/jsoup/issues/1251
        StringBuilder str = new StringBuilder(""<a href=\""\""ca"");
        for (int countSpaces = 0; countSpaces < 100000; countSpaces++) {
            try {
                Parser.htmlParser().setTrackErrors(1).parseInput(str.toString(), """");
            } catch (Exception e) {
                throw new AssertionError(""failed at length "" + str.length(), e);
            }
            str.insert(countSpaces, ' ');
        }
    }

    @Test
    public void handlesDeepStack() {
        // inspired by http://sv.stargate.wikia.com/wiki/M2J and https://github.com/jhy/jsoup/issues/955
        // I didn't put it in the integration tests, because explorer and intellij kept dieing trying to preview/index it

        // Arrange
        StringBuilder longBody = new StringBuilder(500000);
        for (int i = 0; i < 25000; i++) {
            longBody.append(i).append(""<dl><dd>"");
        }
        for (int i = 0; i < 25000; i++) {
            longBody.append(i).append(""</dd></dl>"");
        }

        // Act
        long start = System.currentTimeMillis();
        Document doc = Parser.parseBodyFragment(longBody.toString(), """");

        // Assert
        assertEquals(2, doc.body().childNodeSize());
        assertEquals(25000, doc.select(""dd"").size());
        assertTrue(System.currentTimeMillis() - start < 20000); // I get ~ 1.5 seconds, but others have reported slower
        // was originally much longer, or stack overflow.
    }
}
"
jhy/jsoup,src/test/java/org/jsoup/nodes/LeafNodeTest.java,"package org.jsoup.nodes;

import org.jsoup.Jsoup;
import org.jsoup.select.Elements;
import org.jsoup.select.NodeFilter;
import org.junit.jupiter.api.Test;

import static org.junit.jupiter.api.Assertions.*;

public class LeafNodeTest {

    @Test
    public void doesNotGetAttributesTooEasily() {
        // test to make sure we're not setting attributes on all nodes right away
        String body = ""<p>One <!-- Two --> Three<![CDATA[Four]]></p>"";
        Document doc = Jsoup.parse(body);
        assertTrue(hasAnyAttributes(doc)); // should have one - the base uri on the doc

        Element html = doc.child(0);
        assertFalse(hasAnyAttributes(html));

        String s = doc.outerHtml();
        assertFalse(hasAnyAttributes(html));

        Elements els = doc.select(""p"");
        Element p = els.first();
        assertEquals(1, els.size());
        assertFalse(hasAnyAttributes(html));

        els = doc.select(""p.none"");
        assertFalse(hasAnyAttributes(html));

        String id = p.id();
        assertEquals("""", id);
        assertFalse(p.hasClass(""Foobs""));
        assertFalse(hasAnyAttributes(html));

        p.addClass(""Foobs"");
        assertTrue(p.hasClass(""Foobs""));
        assertTrue(hasAnyAttributes(html));
        assertTrue(hasAnyAttributes(p));

        Attributes attributes = p.attributes();
        assertTrue(attributes.hasKey(""class""));
        p.clearAttributes();
        assertFalse(hasAnyAttributes(p));
        assertFalse(hasAnyAttributes(html));
        assertFalse(attributes.hasKey(""class""));
    }

    private boolean hasAnyAttributes(Node node) {
        final boolean[] found = new boolean[1];
        node.filter(new NodeFilter() {
            @Override
            public FilterResult head(Node node, int depth) {
                if (node.hasAttributes()) {
                    found[0] = true;
                    return FilterResult.STOP;
                } else {
                    return FilterResult.CONTINUE;
                }
            }

            @Override
            public FilterResult tail(Node node, int depth) {
                return FilterResult.CONTINUE;
            }
        });
        return found[0];
    }
}
"
jhy/jsoup,src/main/java/org/jsoup/Connection.java,"package org.jsoup;

import org.jsoup.nodes.Document;
import org.jsoup.parser.Parser;

import javax.annotation.Nullable;
import javax.net.ssl.SSLSocketFactory;
import java.io.BufferedInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.net.CookieStore;
import java.net.Proxy;
import java.net.URL;
import java.util.Collection;
import java.util.List;
import java.util.Map;

/**
 The Connection interface is a convenient HTTP client and session object to fetch content from the web, and parse them
 into Documents.
 <p>To start a new session, use either {@link org.jsoup.Jsoup#newSession()} or {@link org.jsoup.Jsoup#connect(String)}.
 Connections contain {@link Connection.Request} and {@link Connection.Response} objects (once executed). Configuration
 settings (URL, timeout, useragent, etc) set on a session will be applied by default to each subsequent request.</p>
 <p>To start a new request from the session, use {@link #newRequest()}.</p>
 <p>Cookies are stored in memory for the duration of the session. For that reason, do not use one single session for all
 requests in a long-lived application, or you are likely to run out of memory, unless care is taken to clean up the
 cookie store. The cookie store for the session is available via {@link #cookieStore()}. You may provide your own
 implementation via {@link #cookieStore(java.net.CookieStore)} before making requests.</p>
 <p>Request configuration can be made using either the shortcut methods in Connection (e.g. {@link #userAgent(String)}),
 or by methods in the Connection.Request object directly. All request configuration must be made before the request is
 executed. When used as an ongoing session, initialize all defaults prior to making multi-threaded {@link
#newRequest()}s.</p>
 <p>Note that the term ""Connection"" used here does not mean that a long-lived connection is held against a server for
 the lifetime of the Connection object. A socket connection is only made at the point of request execution ({@link
#execute()}, {@link #get()}, or {@link #post()}), and the server's response consumed.</p>
 <p>For multi-threaded implementations, it is important to use a {@link #newRequest()} for each request. The session may
 be shared across threads but a given request, not.</p>
 */
@SuppressWarnings(""unused"")
public interface Connection {

    /**
     * GET and POST http methods.
     */
    enum Method {
        GET(false), POST(true), PUT(true), DELETE(false), PATCH(true), HEAD(false), OPTIONS(false), TRACE(false);

        private final boolean hasBody;

        Method(boolean hasBody) {
            this.hasBody = hasBody;
        }

        /**
         * Check if this HTTP method has/needs a request body
         * @return if body needed
         */
        public final boolean hasBody() {
            return hasBody;
        }
    }

    /**
     Creates a new request, using this Connection as the session-state and to initialize the connection settings (which may then be independently on the returned Connection.Request object).
     @return a new Connection object, with a shared Cookie Store and initialized settings from this Connection and Request
     @since 1.14.1
     */
    Connection newRequest();

    /**
     * Set the request URL to fetch. The protocol must be HTTP or HTTPS.
     * @param url URL to connect to
     * @return this Connection, for chaining
     */
    Connection url(URL url);

    /**
     * Set the request URL to fetch. The protocol must be HTTP or HTTPS.
     * @param url URL to connect to
     * @return this Connection, for chaining
     */
    Connection url(String url);

    /**
     * Set the proxy to use for this request. Set to <code>null</code> to disable a previously set proxy.
     * @param proxy proxy to use
     * @return this Connection, for chaining
     */
    Connection proxy(@Nullable Proxy proxy);

    /**
     * Set the HTTP proxy to use for this request.
     * @param host the proxy hostname
     * @param port the proxy port
     * @return this Connection, for chaining
     */
    Connection proxy(String host, int port);

    /**
     * Set the request user-agent header.
     * @param userAgent user-agent to use
     * @return this Connection, for chaining
     * @see org.jsoup.helper.HttpConnection#DEFAULT_UA
     */
    Connection userAgent(String userAgent);

    /**
     * Set the total request timeout duration. If a timeout occurs, an {@link java.net.SocketTimeoutException} will be thrown.
     * <p>The default timeout is <b>30 seconds</b> (30,000 millis). A timeout of zero is treated as an infinite timeout.
     * <p>Note that this timeout specifies the combined maximum duration of the connection time and the time to read
     * the full response.
     * @param millis number of milliseconds (thousandths of a second) before timing out connects or reads.
     * @return this Connection, for chaining
     * @see #maxBodySize(int)
     */
    Connection timeout(int millis);

    /**
     * Set the maximum bytes to read from the (uncompressed) connection into the body, before the connection is closed,
     * and the input truncated (i.e. the body content will be trimmed). <b>The default maximum is 2MB</b>. A max size of
     * <code>0</code> is treated as an infinite amount (bounded only by your patience and the memory available on your
     * machine).
     *
     * @param bytes number of bytes to read from the input before truncating
     * @return this Connection, for chaining
     */
    Connection maxBodySize(int bytes);

    /**
     * Set the request referrer (aka ""referer"") header.
     * @param referrer referrer to use
     * @return this Connection, for chaining
     */
    Connection referrer(String referrer);

    /**
     * Configures the connection to (not) follow server redirects. By default this is <b>true</b>.
     * @param followRedirects true if server redirects should be followed.
     * @return this Connection, for chaining
     */
    Connection followRedirects(boolean followRedirects);

    /**
     * Set the request method to use, GET or POST. Default is GET.
     * @param method HTTP request method
     * @return this Connection, for chaining
     */
    Connection method(Method method);

    /**
     * Configures the connection to not throw exceptions when a HTTP error occurs. (4xx - 5xx, e.g. 404 or 500). By
     * default this is <b>false</b>; an IOException is thrown if an error is encountered. If set to <b>true</b>, the
     * response is populated with the error body, and the status message will reflect the error.
     * @param ignoreHttpErrors - false (default) if HTTP errors should be ignored.
     * @return this Connection, for chaining
     */
    Connection ignoreHttpErrors(boolean ignoreHttpErrors);

    /**
     * Ignore the document's Content-Type when parsing the response. By default this is <b>false</b>, an unrecognised
     * content-type will cause an IOException to be thrown. (This is to prevent producing garbage by attempting to parse
     * a JPEG binary image, for example.) Set to true to force a parse attempt regardless of content type.
     * @param ignoreContentType set to true if you would like the content type ignored on parsing the response into a
     * Document.
     * @return this Connection, for chaining
     */
    Connection ignoreContentType(boolean ignoreContentType);

    /**
     * Set custom SSL socket factory
     * @param sslSocketFactory custom SSL socket factory
     * @return this Connection, for chaining
     */
    Connection sslSocketFactory(SSLSocketFactory sslSocketFactory);

    /**
     * Add a request data parameter. Request parameters are sent in the request query string for GETs, and in the
     * request body for POSTs. A request may have multiple values of the same name.
     * @param key data key
     * @param value data value
     * @return this Connection, for chaining
     */
    Connection data(String key, String value);

    /**
     * Add an input stream as a request data parameter. For GETs, has no effect, but for POSTS this will upload the
     * input stream.
     * @param key data key (form item name)
     * @param filename the name of the file to present to the remove server. Typically just the name, not path,
     * component.
     * @param inputStream the input stream to upload, that you probably obtained from a {@link java.io.FileInputStream}.
     * You must close the InputStream in a {@code finally} block.
     * @return this Connections, for chaining
     * @see #data(String, String, InputStream, String) if you want to set the uploaded file's mimetype.
     */
    Connection data(String key, String filename, InputStream inputStream);

    /**
     * Add an input stream as a request data parameter. For GETs, has no effect, but for POSTS this will upload the
     * input stream.
     * @param key data key (form item name)
     * @param filename the name of the file to present to the remove server. Typically just the name, not path,
     * component.
     * @param inputStream the input stream to upload, that you probably obtained from a {@link java.io.FileInputStream}.
     * @param contentType the Content Type (aka mimetype) to specify for this file.
     * You must close the InputStream in a {@code finally} block.
     * @return this Connections, for chaining
     */
    Connection data(String key, String filename, InputStream inputStream, String contentType);

    /**
     * Adds all of the supplied data to the request data parameters
     * @param data collection of data parameters
     * @return this Connection, for chaining
     */
    Connection data(Collection<KeyVal> data);

    /**
     * Adds all of the supplied data to the request data parameters
     * @param data map of data parameters
     * @return this Connection, for chaining
     */
    Connection data(Map<String, String> data);

    /**
     Add one or more request {@code key, val} data parameter pairs.<p>Multiple parameters may be set at once, e.g.:
     <code>.data(""name"", ""jsoup"", ""language"", ""Java"", ""language"", ""English"");</code> creates a query string like:
     <code>{@literal ?name=jsoup&language=Java&language=English}</code></p>
     <p>For GET requests, data parameters will be sent on the request query string. For POST (and other methods that
     contain a body), they will be sent as body form parameters, unless the body is explicitly set by {@link
    #requestBody(String)}, in which case they will be query string parameters.</p>

     @param keyvals a set of key value pairs.
     @return this Connection, for chaining
     */
    Connection data(String... keyvals);

    /**
     * Get the data KeyVal for this key, if any
     * @param key the data key
     * @return null if not set
     */
    @Nullable KeyVal data(String key);

    /**
     * Set a POST (or PUT) request body. Useful when a server expects a plain request body, not a set for URL
     * encoded form key/value pairs. E.g.:
     * <code><pre>Jsoup.connect(url)
     * .requestBody(json)
     * .header(""Content-Type"", ""application/json"")
     * .post();</pre></code>
     * If any data key/vals are supplied, they will be sent as URL query params.
     * @return this Request, for chaining
     */
    Connection requestBody(String body);

    /**
     * Set a request header.
     * @param name header name
     * @param value header value
     * @return this Connection, for chaining
     * @see org.jsoup.Connection.Request#headers()
     */
    Connection header(String name, String value);

    /**
     * Adds each of the supplied headers to the request.
     * @param headers map of headers name {@literal ->} value pairs
     * @return this Connection, for chaining
     * @see org.jsoup.Connection.Request#headers()
     */
    Connection headers(Map<String,String> headers);

    /**
     * Set a cookie to be sent in the request.
     * @param name name of cookie
     * @param value value of cookie
     * @return this Connection, for chaining
     */
    Connection cookie(String name, String value);

    /**
     * Adds each of the supplied cookies to the request.
     * @param cookies map of cookie name {@literal ->} value pairs
     * @return this Connection, for chaining
     */
    Connection cookies(Map<String, String> cookies);

    /**
     Provide a custom or pre-filled CookieStore to be used on requests made by this Connection.
     @param cookieStore a cookie store to use for subsequent requests
     @return this Connection, for chaining
     @since 1.14.1
     */
    Connection cookieStore(CookieStore cookieStore);

    /**
     Get the cookie store used by this Connection.
     @return the cookie store
     @since 1.14.1
     */
    CookieStore cookieStore();

    /**
     * Provide an alternate parser to use when parsing the response to a Document. If not set, defaults to the HTML
     * parser, unless the response content-type is XML, in which case the XML parser is used.
     * @param parser alternate parser
     * @return this Connection, for chaining
     */
    Connection parser(Parser parser);

    /**
     * Sets the default post data character set for x-www-form-urlencoded post data
     * @param charset character set to encode post data
     * @return this Connection, for chaining
     */
    Connection postDataCharset(String charset);

    /**
     * Execute the request as a GET, and parse the result.
     * @return parsed Document
     * @throws java.net.MalformedURLException if the request URL is not a HTTP or HTTPS URL, or is otherwise malformed
     * @throws HttpStatusException if the response is not OK and HTTP response errors are not ignored
     * @throws UnsupportedMimeTypeException if the response mime type is not supported and those errors are not ignored
     * @throws java.net.SocketTimeoutException if the connection times out
     * @throws IOException on error
     */
    Document get() throws IOException;

    /**
     * Execute the request as a POST, and parse the result.
     * @return parsed Document
     * @throws java.net.MalformedURLException if the request URL is not a HTTP or HTTPS URL, or is otherwise malformed
     * @throws HttpStatusException if the response is not OK and HTTP response errors are not ignored
     * @throws UnsupportedMimeTypeException if the response mime type is not supported and those errors are not ignored
     * @throws java.net.SocketTimeoutException if the connection times out
     * @throws IOException on error
     */
    Document post() throws IOException;

    /**
     * Execute the request.
     * @return a response object
     * @throws java.net.MalformedURLException if the request URL is not a HTTP or HTTPS URL, or is otherwise malformed
     * @throws HttpStatusException if the response is not OK and HTTP response errors are not ignored
     * @throws UnsupportedMimeTypeException if the response mime type is not supported and those errors are not ignored
     * @throws java.net.SocketTimeoutException if the connection times out
     * @throws IOException on error
     */
    Response execute() throws IOException;

    /**
     * Get the request object associated with this connection
     * @return request
     */
    Request request();

    /**
     * Set the connection's request
     * @param request new request object
     * @return this Connection, for chaining
     */
    Connection request(Request request);

    /**
     * Get the response, once the request has been executed.
     * @return response
     * @throws IllegalArgumentException if called before the response has been executed.
     */
    Response response();

    /**
     * Set the connection's response
     * @param response new response
     * @return this Connection, for chaining
     */
    Connection response(Response response);

    /**
     * Common methods for Requests and Responses
     * @param <T> Type of Base, either Request or Response
     */
    @SuppressWarnings(""UnusedReturnValue"")
    interface Base<T extends Base<T>> {
        /**
         * Get the URL of this Request or Response. For redirected responses, this will be the final destination URL.
         * @return URL
         * @throws IllegalArgumentException if called on a Request that was created without a URL.
         */
        URL url();

        /**
         * Set the URL
         * @param url new URL
         * @return this, for chaining
         */
        T url(URL url);

        /**
         * Get the request method, which defaults to <code>GET</code>
         * @return method
         */
        Method method();

        /**
         * Set the request method
         * @param method new method
         * @return this, for chaining
         */
        T method(Method method);

        /**
         * Get the value of a header. If there is more than one header value with the same name, the headers are returned
         * comma seperated, per <a href=""https://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html#sec4.2"">rfc2616-sec4</a>.
         * <p>
         * Header names are case insensitive.
         * </p>
         * @param name name of header (case insensitive)
         * @return value of header, or null if not set.
         * @see #hasHeader(String)
         * @see #cookie(String)
         */
        @Nullable String header(String name);

        /**
         * Get the values of a header.
         * @param name header name, case insensitive.
         * @return a list of values for this header, or an empty list if not set.
         */
        List<String> headers(String name);

        /**
         * Set a header. This method will overwrite any existing header with the same case insensitive name. (If there
         * is more than one value for this header, this method will update the first matching header.
         * @param name Name of header
         * @param value Value of header
         * @return this, for chaining
         * @see #addHeader(String, String)
         */
        T header(String name, String value);

        /**
         * Add a header. The header will be added regardless of whether a header with the same name already exists.
         * @param name Name of new header
         * @param value Value of new header
         * @return this, for chaining
         */
        T addHeader(String name, String value);

        /**
         * Check if a header is present
         * @param name name of header (case insensitive)
         * @return if the header is present in this request/response
         */
        boolean hasHeader(String name);

        /**
         * Check if a header is present, with the given value
         * @param name header name (case insensitive)
         * @param value value (case insensitive)
         * @return if the header and value pair are set in this req/res
         */
        boolean hasHeaderWithValue(String name, String value);

        /**
         * Remove headers by name. If there is more than one header with this name, they will all be removed.
         * @param name name of header to remove (case insensitive)
         * @return this, for chaining
         */
        T removeHeader(String name);

        /**
         * Retrieve all of the request/response header names and corresponding values as a map. For headers with multiple
         * values, only the first header is returned.
         * <p>Note that this is a view of the headers only, and changes made to this map will not be reflected in the
         * request/response object.</p>
         * @return headers
         * @see #multiHeaders()

         */
        Map<String, String> headers();

        /**
         * Retreive all of the headers, keyed by the header name, and with a list of values per header.
         * @return a list of multiple values per header.
         */
        Map<String, List<String>> multiHeaders();

        /**
         * Get a cookie value by name from this request/response.
         * <p>
         * Response objects have a simplified cookie model. Each cookie set in the response is added to the response
         * object's cookie key=value map. The cookie's path, domain, and expiry date are ignored.
         * </p>
         * @param name name of cookie to retrieve.
         * @return value of cookie, or null if not set
         */
        @Nullable String cookie(String name);

        /**
         * Set a cookie in this request/response.
         * @param name name of cookie
         * @param value value of cookie
         * @return this, for chaining
         */
        T cookie(String name, String value);

        /**
         * Check if a cookie is present
         * @param name name of cookie
         * @return if the cookie is present in this request/response
         */
        boolean hasCookie(String name);

        /**
         * Remove a cookie by name
         * @param name name of cookie to remove
         * @return this, for chaining
         */
        T removeCookie(String name);

        /**
         * Retrieve all of the request/response cookies as a map
         * @return cookies
         */
        Map<String, String> cookies();
    }

    /**
     * Represents a HTTP request.
     */
    @SuppressWarnings(""UnusedReturnValue"")
    interface Request extends Base<Request> {
        /**
         * Get the proxy used for this request.
         * @return the proxy; <code>null</code> if not enabled.
         */
        @Nullable Proxy proxy();

        /**
         * Update the proxy for this request.
         * @param proxy the proxy ot use; <code>null</code> to disable.
         * @return this Request, for chaining
         */
        Request proxy(@Nullable Proxy proxy);

        /**
         * Set the HTTP proxy to use for this request.
         * @param host the proxy hostname
         * @param port the proxy port
         * @return this Connection, for chaining
         */
        Request proxy(String host, int port);

        /**
         * Get the request timeout, in milliseconds.
         * @return the timeout in milliseconds.
         */
        int timeout();

        /**
         * Update the request timeout.
         * @param millis timeout, in milliseconds
         * @return this Request, for chaining
         */
        Request timeout(int millis);

        /**
         * Get the maximum body size, in bytes.
         * @return the maximum body size, in bytes.
         */
        int maxBodySize();

        /**
         * Update the maximum body size, in bytes.
         * @param bytes maximum body size, in bytes.
         * @return this Request, for chaining
         */
        Request maxBodySize(int bytes);

        /**
         * Get the current followRedirects configuration.
         * @return true if followRedirects is enabled.
         */
        boolean followRedirects();

        /**
         * Configures the request to (not) follow server redirects. By default this is <b>true</b>.
         * @param followRedirects true if server redirects should be followed.
         * @return this Request, for chaining
         */
        Request followRedirects(boolean followRedirects);

        /**
         * Get the current ignoreHttpErrors configuration.
         * @return true if errors will be ignored; false (default) if HTTP errors will cause an IOException to be
         * thrown.
         */
        boolean ignoreHttpErrors();

        /**
         * Configures the request to ignore HTTP errors in the response.
         * @param ignoreHttpErrors set to true to ignore HTTP errors.
         * @return this Request, for chaining
         */
        Request ignoreHttpErrors(boolean ignoreHttpErrors);

        /**
         * Get the current ignoreContentType configuration.
         * @return true if invalid content-types will be ignored; false (default) if they will cause an IOException to
         * be thrown.
         */
        boolean ignoreContentType();

        /**
         * Configures the request to ignore the Content-Type of the response.
         * @param ignoreContentType set to true to ignore the content type.
         * @return this Request, for chaining
         */
        Request ignoreContentType(boolean ignoreContentType);

        /**
         * Get the current custom SSL socket factory, if any.
         * @return custom SSL socket factory if set, null otherwise
         */
        @Nullable SSLSocketFactory sslSocketFactory();

        /**
         * Set a custom SSL socket factory.
         * @param sslSocketFactory SSL socket factory
         */
        void sslSocketFactory(SSLSocketFactory sslSocketFactory);

        /**
         * Add a data parameter to the request
         * @param keyval data to add.
         * @return this Request, for chaining
         */
        Request data(KeyVal keyval);

        /**
         * Get all of the request's data parameters
         * @return collection of keyvals
         */
        Collection<KeyVal> data();

        /**
         * Set a POST (or PUT) request body. Useful when a server expects a plain request body, not a set for URL
         * encoded form key/value pairs. E.g.:
         * <code><pre>Jsoup.connect(url)
         * .requestBody(json)
         * .header(""Content-Type"", ""application/json"")
         * .post();</pre></code>
         * If any data key/vals are supplied, they will be sent as URL query params.
         * @param body to use as the request body. Set to null to clear a previously set body.
         * @return this Request, for chaining
         */
        Request requestBody(@Nullable String body);

        /**
         * Get the current request body.
         * @return null if not set.
         */
        @Nullable String requestBody();

        /**
         * Specify the parser to use when parsing the document.
         * @param parser parser to use.
         * @return this Request, for chaining
         */
        Request parser(Parser parser);

        /**
         * Get the current parser to use when parsing the document.
         * @return current Parser
         */
        Parser parser();

        /**
         * Sets the post data character set for x-www-form-urlencoded post data
         * @param charset character set to encode post data
         * @return this Request, for chaining
         */
        Request postDataCharset(String charset);

        /**
         * Gets the post data character set for x-www-form-urlencoded post data
         * @return character set to encode post data
         */
        String postDataCharset();

    }

    /**
     * Represents a HTTP response.
     */
    interface Response extends Base<Response> {

        /**
         * Get the status code of the response.
         * @return status code
         */
        int statusCode();

        /**
         * Get the status message of the response.
         * @return status message
         */
        String statusMessage();

        /**
         * Get the character set name of the response, derived from the content-type header.
         * @return character set name if set, <b>null</b> if not
         */
        @Nullable String charset();

        /**
         * Set / override the response character set. When the document body is parsed it will be with this charset.
         * @param charset to decode body as
         * @return this Response, for chaining
         */
        Response charset(String charset);

        /**
         * Get the response content type (e.g. ""text/html"");
         * @return the response content type, or <b>null</b> if one was not set
         */
        @Nullable String contentType();

        /**
         * Read and parse the body of the response as a Document. If you intend to parse the same response multiple
         * times, you should {@link #bufferUp()} first.
         * @return a parsed Document
         * @throws IOException on error
         */
        Document parse() throws IOException;

        /**
         * Get the body of the response as a plain string.
         * @return body
         */
        String body();

        /**
         * Get the body of the response as an array of bytes.
         * @return body bytes
         */
        byte[] bodyAsBytes();

        /**
         * Read the body of the response into a local buffer, so that {@link #parse()} may be called repeatedly on the
         * same connection response (otherwise, once the response is read, its InputStream will have been drained and
         * may not be re-read). Calling {@link #body() } or {@link #bodyAsBytes()} has the same effect.
         * @return this response, for chaining
         * @throws UncheckedIOException if an IO exception occurs during buffering.
         */
        Response bufferUp();

        /**
         * Get the body of the response as a (buffered) InputStream. You should close the input stream when you're done with it.
         * Other body methods (like bufferUp, body, parse, etc) will not work in conjunction with this method.
         * <p>This method is useful for writing large responses to disk, without buffering them completely into memory first.</p>
         * @return the response body input stream
         */
        BufferedInputStream bodyStream();
    }

    /**
     * A Key:Value tuple(+), used for form data.
     */
    interface KeyVal {

        /**
         * Update the key of a keyval
         * @param key new key
         * @return this KeyVal, for chaining
         */
        KeyVal key(String key);

        /**
         * Get the key of a keyval
         * @return the key
         */
        String key();

        /**
         * Update the value of a keyval
         * @param value the new value
         * @return this KeyVal, for chaining
         */
        KeyVal value(String value);

        /**
         * Get the value of a keyval
         * @return the value
         */
        String value();

        /**
         * Add or update an input stream to this keyVal
         * @param inputStream new input stream
         * @return this KeyVal, for chaining
         */
        KeyVal inputStream(InputStream inputStream);

        /**
         * Get the input stream associated with this keyval, if any
         * @return input stream if set, or null
         */
        @Nullable InputStream inputStream();

        /**
         * Does this keyval have an input stream?
         * @return true if this keyval does indeed have an input stream
         */
        boolean hasInputStream();

        /**
         * Set the Content Type header used in the MIME body (aka mimetype) when uploading files.
         * Only useful if {@link #inputStream(InputStream)} is set.
         * <p>Will default to {@code application/octet-stream}.</p>
         * @param contentType the new content type
         * @return this KeyVal
         */
        KeyVal contentType(String contentType);

        /**
         * Get the current Content Type, or {@code null} if not set.
         * @return the current Content Type.
         */
        @Nullable String contentType();
    }
}
"
jhy/jsoup,src/main/java/org/jsoup/select/StructuralEvaluator.java,"package org.jsoup.select;

import org.jsoup.nodes.Element;
import org.jsoup.nodes.Node;

/**
 * Base structural evaluator.
 */
abstract class StructuralEvaluator extends Evaluator {
    Evaluator evaluator;

    static class Root extends Evaluator {
        @Override
        public boolean matches(Element root, Element element) {
            return root == element;
        }
    }

    static class Has extends StructuralEvaluator {
        final Collector.FirstFinder finder;

        public Has(Evaluator evaluator) {
            this.evaluator = evaluator;
            finder = new Collector.FirstFinder(evaluator);
        }

        @Override
        public boolean matches(Element root, Element element) {
            // for :has, we only want to match children (or below), not the input element. And we want to minimize GCs
            for (int i = 0; i < element.childNodeSize(); i++) {
                Node node = element.childNode(i);
                if (node instanceof Element) {
                    Element match = finder.find(element, (Element) node);
                    if (match != null)
                        return true;
                }
            }
            return false;
        }

        @Override
        public String toString() {
            return String.format("":has(%s)"", evaluator);
        }
    }

    static class Not extends StructuralEvaluator {
        public Not(Evaluator evaluator) {
            this.evaluator = evaluator;
        }

        @Override
        public boolean matches(Element root, Element node) {
            return !evaluator.matches(root, node);
        }

        @Override
        public String toString() {
            return String.format("":not(%s)"", evaluator);
        }
    }

    static class Parent extends StructuralEvaluator {
        public Parent(Evaluator evaluator) {
            this.evaluator = evaluator;
        }

        @Override
        public boolean matches(Element root, Element element) {
            if (root == element)
                return false;

            Element parent = element.parent();
            while (parent != null) {
                if (evaluator.matches(root, parent))
                    return true;
                if (parent == root)
                    break;
                parent = parent.parent();
            }
            return false;
        }

        @Override
        public String toString() {
            return String.format(""%s "", evaluator);
        }
    }

    static class ImmediateParent extends StructuralEvaluator {
        public ImmediateParent(Evaluator evaluator) {
            this.evaluator = evaluator;
        }

        @Override
        public boolean matches(Element root, Element element) {
            if (root == element)
                return false;

            Element parent = element.parent();
            return parent != null && evaluator.matches(root, parent);
        }

        @Override
        public String toString() {
            return String.format(""%s > "", evaluator);
        }
    }

    static class PreviousSibling extends StructuralEvaluator {
        public PreviousSibling(Evaluator evaluator) {
            this.evaluator = evaluator;
        }

        @Override
        public boolean matches(Element root, Element element) {
            if (root == element)
                return false;

            Element prev = element.previousElementSibling();

            while (prev != null) {
                if (evaluator.matches(root, prev))
                    return true;

                prev = prev.previousElementSibling();
            }
            return false;
        }

        @Override
        public String toString() {
            return String.format(""%s ~ "", evaluator);
        }
    }

    static class ImmediatePreviousSibling extends StructuralEvaluator {
        public ImmediatePreviousSibling(Evaluator evaluator) {
            this.evaluator = evaluator;
        }

        @Override
        public boolean matches(Element root, Element element) {
            if (root == element)
                return false;

            Element prev = element.previousElementSibling();
            return prev != null && evaluator.matches(root, prev);
        }

        @Override
        public String toString() {
            return String.format(""%s + "", evaluator);
        }
    }
}
"
jhy/jsoup,src/main/java/org/jsoup/nodes/Element.java,"package org.jsoup.nodes;

import org.jsoup.helper.ChangeNotifyingArrayList;
import org.jsoup.helper.Consumer;
import org.jsoup.helper.Validate;
import org.jsoup.internal.NonnullByDefault;
import org.jsoup.internal.StringUtil;
import org.jsoup.parser.ParseSettings;
import org.jsoup.parser.Tag;
import org.jsoup.select.Collector;
import org.jsoup.select.Elements;
import org.jsoup.select.Evaluator;
import org.jsoup.select.NodeFilter;
import org.jsoup.select.NodeTraversor;
import org.jsoup.select.NodeVisitor;
import org.jsoup.select.QueryParser;
import org.jsoup.select.Selector;

import javax.annotation.Nullable;
import java.io.IOException;
import java.lang.ref.WeakReference;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.regex.Pattern;
import java.util.regex.PatternSyntaxException;

import static org.jsoup.internal.Normalizer.normalize;

/**
 * A HTML element consists of a tag name, attributes, and child nodes (including text nodes and
 * other elements).
 *
 * From an Element, you can extract data, traverse the node graph, and manipulate the HTML.
 *
 * @author Jonathan Hedley, jonathan@hedley.net
 */
@NonnullByDefault
public class Element extends Node {
    private static final List<Element> EmptyChildren = Collections.emptyList();
    private static final Pattern ClassSplit = Pattern.compile(""\\s+"");
    private static final String BaseUriKey = Attributes.internalKey(""baseUri"");
    private Tag tag;
    private @Nullable WeakReference<List<Element>> shadowChildrenRef; // points to child elements shadowed from node children
    List<Node> childNodes;
    @Nullable Attributes attributes; // field is nullable but all methods for attributes are non-null

    /**
     * Create a new, standalone element.
     * @param tag tag name
     */
    public Element(String tag) {
        this(Tag.valueOf(tag), """", null);
    }

    /**
     * Create a new, standalone Element. (Standalone in that it has no parent.)
     *
     * @param tag tag of this element
     * @param baseUri the base URI (optional, may be null to inherit from parent, or """" to clear parent's)
     * @param attributes initial attributes (optional, may be null)
     * @see #appendChild(Node)
     * @see #appendElement(String)
     */
    public Element(Tag tag, @Nullable String baseUri, @Nullable Attributes attributes) {
        Validate.notNull(tag);
        childNodes = EmptyNodes;
        this.attributes = attributes;
        this.tag = tag;
        if (baseUri != null)
            this.setBaseUri(baseUri);
    }

    /**
     * Create a new Element from a Tag and a base URI.
     *
     * @param tag element tag
     * @param baseUri the base URI of this element. Optional, and will inherit from its parent, if any.
     * @see Tag#valueOf(String, ParseSettings)
     */
    public Element(Tag tag, @Nullable String baseUri) {
        this(tag, baseUri, null);
    }

    /**
     Internal test to check if a nodelist object has been created.
     */
    protected boolean hasChildNodes() {
        return childNodes != EmptyNodes;
    }

    protected List<Node> ensureChildNodes() {
        if (childNodes == EmptyNodes) {
            childNodes = new NodeList(this, 4);
        }
        return childNodes;
    }

    @Override
    protected boolean hasAttributes() {
        return attributes != null;
    }

    @Override
    public Attributes attributes() {
        if (attributes == null) // not using hasAttributes, as doesn't clear warning
            attributes = new Attributes();
        return attributes;
    }

    @Override
    public String baseUri() {
        return searchUpForAttribute(this, BaseUriKey);
    }

    private static String searchUpForAttribute(final Element start, final String key) {
        Element el = start;
        while (el != null) {
            if (el.attributes != null && el.attributes.hasKey(key))
                return el.attributes.get(key);
            el = el.parent();
        }
        return """";
    }

    @Override
    protected void doSetBaseUri(String baseUri) {
        attributes().put(BaseUriKey, baseUri);
    }

    @Override
    public int childNodeSize() {
        return childNodes.size();
    }

    @Override
    public String nodeName() {
        return tag.getName();
    }

    /**
     * Get the name of the tag for this element. E.g. {@code div}. If you are using {@link ParseSettings#preserveCase
     * case preserving parsing}, this will return the source's original case.
     *
     * @return the tag name
     */
    public String tagName() {
        return tag.getName();
    }

    /**
     * Get the normalized name of this Element's tag. This will always be the lowercased version of the tag, regardless
     * of the tag case preserving setting of the parser. For e.g., {@code <DIV>} and {@code <div>} both have a
     * normal name of {@code div}.
     * @return normal name
     */
    public String normalName() {
        return tag.normalName();
    }

    /**
     * Change (rename) the tag of this element. For example, convert a {@code <span>} to a {@code <div>} with
     * {@code el.tagName(""div"");}.
     *
     * @param tagName new tag name for this element
     * @return this element, for chaining
     * @see Elements#tagName(String)
     */
    public Element tagName(String tagName) {
        Validate.notEmptyParam(tagName, ""tagName"");
        tag = Tag.valueOf(tagName, NodeUtils.parser(this).settings()); // maintains the case option of the original parse
        return this;
    }

    /**
     * Get the Tag for this element.
     *
     * @return the tag object
     */
    public Tag tag() {
        return tag;
    }

    /**
     * Test if this element is a block-level element. (E.g. {@code <div> == true} or an inline element
     * {@code <span> == false}).
     *
     * @return true if block, false if not (and thus inline)
     */
    public boolean isBlock() {
        return tag.isBlock();
    }

    /**
     * Get the {@code id} attribute of this element.
     *
     * @return The id attribute, if present, or an empty string if not.
     */
    public String id() {
        return attributes != null ? attributes.getIgnoreCase(""id"") :"""";
    }

    /**
     Set the {@code id} attribute of this element.
     @param id the ID value to use
     @return this Element, for chaining
     */
    public Element id(String id) {
        Validate.notNull(id);
        attr(""id"", id);
        return this;
    }

    /**
     * Set an attribute value on this element. If this element already has an attribute with the
     * key, its value is updated; otherwise, a new attribute is added.
     *
     * @return this element
     */
    public Element attr(String attributeKey, String attributeValue) {
        super.attr(attributeKey, attributeValue);
        return this;
    }

    /**
     * Set a boolean attribute value on this element. Setting to <code>true</code> sets the attribute value to """" and
     * marks the attribute as boolean so no value is written out. Setting to <code>false</code> removes the attribute
     * with the same key if it exists.
     *
     * @param attributeKey the attribute key
     * @param attributeValue the attribute value
     *
     * @return this element
     */
    public Element attr(String attributeKey, boolean attributeValue) {
        attributes().put(attributeKey, attributeValue);
        return this;
    }

    /**
     * Get this element's HTML5 custom data attributes. Each attribute in the element that has a key
     * starting with ""data-"" is included the dataset.
     * <p>
     * E.g., the element {@code <div data-package=""jsoup"" data-language=""Java"" class=""group"">...} has the dataset
     * {@code package=jsoup, language=java}.
     * <p>
     * This map is a filtered view of the element's attribute map. Changes to one map (add, remove, update) are reflected
     * in the other map.
     * <p>
     * You can find elements that have data attributes using the {@code [^data-]} attribute key prefix selector.
     * @return a map of {@code key=value} custom data attributes.
     */
    public Map<String, String> dataset() {
        return attributes().dataset();
    }

    @Override @Nullable
    public final Element parent() {
        return (Element) parentNode;
    }

    /**
     * Get this element's parent and ancestors, up to the document root.
     * @return this element's stack of parents, closest first.
     */
    public Elements parents() {
        Elements parents = new Elements();
        accumulateParents(this, parents);
        return parents;
    }

    private static void accumulateParents(Element el, Elements parents) {
        Element parent = el.parent();
        if (parent != null && !parent.tagName().equals(""#root"")) {
            parents.add(parent);
            accumulateParents(parent, parents);
        }
    }

    /**
     * Get a child element of this element, by its 0-based index number.
     * <p>
     * Note that an element can have both mixed Nodes and Elements as children. This method inspects
     * a filtered list of children that are elements, and the index is based on that filtered list.
     * </p>
     *
     * @param index the index number of the element to retrieve
     * @return the child element, if it exists, otherwise throws an {@code IndexOutOfBoundsException}
     * @see #childNode(int)
     */
    public Element child(int index) {
        return childElementsList().get(index);
    }

    /**
     * Get the number of child nodes of this element that are elements.
     * <p>
     * This method works on the same filtered list like {@link #child(int)}. Use {@link #childNodes()} and {@link
     * #childNodeSize()} to get the unfiltered Nodes (e.g. includes TextNodes etc.)
     * </p>
     *
     * @return the number of child nodes that are elements
     * @see #children()
     * @see #child(int)
     */
    public int childrenSize() {
        return childElementsList().size();
    }

    /**
     * Get this element's child elements.
     * <p>
     * This is effectively a filter on {@link #childNodes()} to get Element nodes.
     * </p>
     * @return child elements. If this element has no children, returns an empty list.
     * @see #childNodes()
     */
    public Elements children() {
        return new Elements(childElementsList());
    }

    /**
     * Maintains a shadow copy of this element's child elements. If the nodelist is changed, this cache is invalidated.
     * TODO - think about pulling this out as a helper as there are other shadow lists (like in Attributes) kept around.
     * @return a list of child elements
     */
    List<Element> childElementsList() {
        if (childNodeSize() == 0)
            return EmptyChildren; // short circuit creating empty

        List<Element> children;
        if (shadowChildrenRef == null || (children = shadowChildrenRef.get()) == null) {
            final int size = childNodes.size();
            children = new ArrayList<>(size);
            //noinspection ForLoopReplaceableByForEach (beacause it allocates an Iterator which is wasteful here)
            for (int i = 0; i < size; i++) {
                final Node node = childNodes.get(i);
                if (node instanceof Element)
                    children.add((Element) node);
            }
            shadowChildrenRef = new WeakReference<>(children);
        }
        return children;
    }

    /**
     * Clears the cached shadow child elements.
     */
    @Override
    void nodelistChanged() {
        super.nodelistChanged();
        shadowChildrenRef = null;
    }

    /**
     * Get this element's child text nodes. The list is unmodifiable but the text nodes may be manipulated.
     * <p>
     * This is effectively a filter on {@link #childNodes()} to get Text nodes.
     * @return child text nodes. If this element has no text nodes, returns an
     * empty list.
     * </p>
     * For example, with the input HTML: {@code <p>One <span>Two</span> Three <br> Four</p>} with the {@code p} element selected:
     * <ul>
     *     <li>{@code p.text()} = {@code ""One Two Three Four""}</li>
     *     <li>{@code p.ownText()} = {@code ""One Three Four""}</li>
     *     <li>{@code p.children()} = {@code Elements[<span>, <br>]}</li>
     *     <li>{@code p.childNodes()} = {@code List<Node>[""One "", <span>, "" Three "", <br>, "" Four""]}</li>
     *     <li>{@code p.textNodes()} = {@code List<TextNode>[""One "", "" Three "", "" Four""]}</li>
     * </ul>
     */
    public List<TextNode> textNodes() {
        List<TextNode> textNodes = new ArrayList<>();
        for (Node node : childNodes) {
            if (node instanceof TextNode)
                textNodes.add((TextNode) node);
        }
        return Collections.unmodifiableList(textNodes);
    }

    /**
     * Get this element's child data nodes. The list is unmodifiable but the data nodes may be manipulated.
     * <p>
     * This is effectively a filter on {@link #childNodes()} to get Data nodes.
     * </p>
     * @return child data nodes. If this element has no data nodes, returns an
     * empty list.
     * @see #data()
     */
    public List<DataNode> dataNodes() {
        List<DataNode> dataNodes = new ArrayList<>();
        for (Node node : childNodes) {
            if (node instanceof DataNode)
                dataNodes.add((DataNode) node);
        }
        return Collections.unmodifiableList(dataNodes);
    }

    /**
     * Find elements that match the {@link Selector} CSS query, with this element as the starting context. Matched elements
     * may include this element, or any of its children.
     * <p>This method is generally more powerful to use than the DOM-type {@code getElementBy*} methods, because
     * multiple filters can be combined, e.g.:</p>
     * <ul>
     * <li>{@code el.select(""a[href]"")} - finds links ({@code a} tags with {@code href} attributes)
     * <li>{@code el.select(""a[href*=example.com]"")} - finds links pointing to example.com (loosely)
     * </ul>
     * <p>See the query syntax documentation in {@link org.jsoup.select.Selector}.</p>
     * <p>Also known as {@code querySelectorAll()} in the Web DOM.</p>
     *
     * @param cssQuery a {@link Selector} CSS-like query
     * @return an {@link Elements} list containing elements that match the query (empty if none match)
     * @see Selector selector query syntax
     * @see QueryParser#parse(String)
     * @throws Selector.SelectorParseException (unchecked) on an invalid CSS query.
     */
    public Elements select(String cssQuery) {
        return Selector.select(cssQuery, this);
    }

    /**
     * Find elements that match the supplied Evaluator. This has the same functionality as {@link #select(String)}, but
     * may be useful if you are running the same query many times (on many documents) and want to save the overhead of
     * repeatedly parsing the CSS query.
     * @param evaluator an element evaluator
     * @return an {@link Elements} list containing elements that match the query (empty if none match)
     */
    public Elements select(Evaluator evaluator) {
        return Selector.select(evaluator, this);
    }


    /**
     * Find the first Element that matches the {@link Selector} CSS query, with this element as the starting context.
     * <p>This is effectively the same as calling {@code element.select(query).first()}, but is more efficient as query
     * execution stops on the first hit.</p>
     * <p>Also known as {@code querySelector()} in the Web DOM.</p>
     * @param cssQuery cssQuery a {@link Selector} CSS-like query
     * @return the first matching element, or <b>{@code null}</b> if there is no match.
     * @see #expectFirst(String)
     */
    public @Nullable Element selectFirst(String cssQuery) {
        return Selector.selectFirst(cssQuery, this);
    }

    /**
     * Finds the first Element that matches the supplied Evaluator, with this element as the starting context, or
     * {@code null} if none match.
     *
     * @param evaluator an element evaluator
     * @return the first matching element (walking down the tree, starting from this element), or {@code null} if none
     * match.
     */
    public @Nullable Element selectFirst(Evaluator evaluator) {
        return Collector.findFirst(evaluator, this);
    }

    /**
     Just like {@link #selectFirst(String)}, but if there is no match, throws an {@link IllegalArgumentException}. This
     is useful if you want to simply abort processing on a failed match.
     @param cssQuery a {@link Selector} CSS-like query
     @return the first matching element
     @throws IllegalArgumentException if no match is found
     @since 1.15.2
     */
    public Element expectFirst(String cssQuery) {
        return (Element) Validate.ensureNotNull(
            Selector.selectFirst(cssQuery, this),
            parent() != null ?
                ""No elements matched the query '%s' on element '%s'."":
                ""No elements matched the query '%s' in the document.""
            , cssQuery, this.tagName()
        );
    }

    /**
     * Checks if this element matches the given {@link Selector} CSS query. Also knows as {@code matches()} in the Web
     * DOM.
     *
     * @param cssQuery a {@link Selector} CSS query
     * @return if this element matches the query
     */
    public boolean is(String cssQuery) {
        return is(QueryParser.parse(cssQuery));
    }

    /**
     * Check if this element matches the given evaluator.
     * @param evaluator an element evaluator
     * @return if this element matches
     */
    public boolean is(Evaluator evaluator) {
        return evaluator.matches(this.root(), this);
    }

    /**
     * Find the closest element up the tree of parents that matches the specified CSS query. Will return itself, an
     * ancestor, or {@code null} if there is no such matching element.
     * @param cssQuery a {@link Selector} CSS query
     * @return the closest ancestor element (possibly itself) that matches the provided evaluator. {@code null} if not
     * found.
     */
    public @Nullable Element closest(String cssQuery) {
        return closest(QueryParser.parse(cssQuery));
    }

    /**
     * Find the closest element up the tree of parents that matches the specified evaluator. Will return itself, an
     * ancestor, or {@code null} if there is no such matching element.
     * @param evaluator a query evaluator
     * @return the closest ancestor element (possibly itself) that matches the provided evaluator. {@code null} if not
     * found.
     */
    public @Nullable Element closest(Evaluator evaluator) {
        Validate.notNull(evaluator);
        Element el = this;
        final Element root = root();
        do {
            if (evaluator.matches(root, el))
                return el;
            el = el.parent();
        } while (el != null);
        return null;
    }

    /**
     Find Elements that match the supplied XPath expression.
     <p>Note that for convenience of writing the Xpath expression, namespaces are disabled, and queries can be
     expressed using the element's local name only.</p>
     <p>By default, XPath 1.0 expressions are supported. If you would to use XPath 2.0 or higher, you can provide an
     alternate XPathFactory implementation:</p>
     <ol>
     <li>Add the implementation to your classpath. E.g. to use <a href=""https://www.saxonica.com/products/products.xml"">Saxon-HE</a>, add <a href=""https://mvnrepository.com/artifact/net.sf.saxon/Saxon-HE"">net.sf.saxon:Saxon-HE</a> to your build.</li>
     <li>Set the system property <code>javax.xml.xpath.XPathFactory:jsoup</code> to the implementing classname. E.g.:<br>
     <code>System.setProperty(W3CDom.XPathFactoryProperty, ""net.sf.saxon.xpath.XPathFactoryImpl"");</code>
     </li>
     </ol>

     @param xpath XPath expression
     @return matching elements, or an empty list if none match.
     @see #selectXpath(String, Class)
     @since 1.14.3
     */
    public Elements selectXpath(String xpath) {
        return new Elements(NodeUtils.selectXpath(xpath, this, Element.class));
    }

    /**
     Find Nodes that match the supplied XPath expression.
     <p>For example, to select TextNodes under {@code p} elements: </p>
     <pre>List&lt;TextNode&gt; textNodes = doc.selectXpath(""//body//p//text()"", TextNode.class);</pre>
     <p>Note that in the jsoup DOM, Attribute objects are not Nodes. To directly select attribute values, do something
     like:</p>
     <pre>List&lt;String&gt; hrefs = doc.selectXpath(""//a"").eachAttr(""href"");</pre>
     @param xpath XPath expression
     @param nodeType the jsoup node type to return
     @see #selectXpath(String)
     @return a list of matching nodes
     @since 1.14.3
     */
    public <T extends Node> List<T> selectXpath(String xpath, Class<T> nodeType) {
        return NodeUtils.selectXpath(xpath, this, nodeType);
    }

    /**
     * Insert a node to the end of this Element's children. The incoming node will be re-parented.
     *
     * @param child node to add.
     * @return this Element, for chaining
     * @see #prependChild(Node)
     * @see #insertChildren(int, Collection)
     */
    public Element appendChild(Node child) {
        Validate.notNull(child);

        // was - Node#addChildren(child). short-circuits an array create and a loop.
        reparentChild(child);
        ensureChildNodes();
        childNodes.add(child);
        child.setSiblingIndex(childNodes.size() - 1);
        return this;
    }

    /**
     Insert the given nodes to the end of this Element's children.

     @param children nodes to add
     @return this Element, for chaining
     @see #insertChildren(int, Collection)
     */
    public Element appendChildren(Collection<? extends Node> children) {
        insertChildren(-1, children);
        return this;
    }

    /**
     * Add this element to the supplied parent element, as its next child.
     *
     * @param parent element to which this element will be appended
     * @return this element, so that you can continue modifying the element
     */
    public Element appendTo(Element parent) {
        Validate.notNull(parent);
        parent.appendChild(this);
        return this;
    }

    /**
     * Add a node to the start of this element's children.
     *
     * @param child node to add.
     * @return this element, so that you can add more child nodes or elements.
     */
    public Element prependChild(Node child) {
        Validate.notNull(child);

        addChildren(0, child);
        return this;
    }

    /**
     Insert the given nodes to the start of this Element's children.

     @param children nodes to add
     @return this Element, for chaining
     @see #insertChildren(int, Collection)
     */
    public Element prependChildren(Collection<? extends Node> children) {
        insertChildren(0, children);
        return this;
    }


    /**
     * Inserts the given child nodes into this element at the specified index. Current nodes will be shifted to the
     * right. The inserted nodes will be moved from their current parent. To prevent moving, copy the nodes first.
     *
     * @param index 0-based index to insert children at. Specify {@code 0} to insert at the start, {@code -1} at the
     * end
     * @param children child nodes to insert
     * @return this element, for chaining.
     */
    public Element insertChildren(int index, Collection<? extends Node> children) {
        Validate.notNull(children, ""Children collection to be inserted must not be null."");
        int currentSize = childNodeSize();
        if (index < 0) index += currentSize +1; // roll around
        Validate.isTrue(index >= 0 && index <= currentSize, ""Insert position out of bounds."");

        ArrayList<Node> nodes = new ArrayList<>(children);
        Node[] nodeArray = nodes.toArray(new Node[0]);
        addChildren(index, nodeArray);
        return this;
    }

    /**
     * Inserts the given child nodes into this element at the specified index. Current nodes will be shifted to the
     * right. The inserted nodes will be moved from their current parent. To prevent moving, copy the nodes first.
     *
     * @param index 0-based index to insert children at. Specify {@code 0} to insert at the start, {@code -1} at the
     * end
     * @param children child nodes to insert
     * @return this element, for chaining.
     */
    public Element insertChildren(int index, Node... children) {
        Validate.notNull(children, ""Children collection to be inserted must not be null."");
        int currentSize = childNodeSize();
        if (index < 0) index += currentSize +1; // roll around
        Validate.isTrue(index >= 0 && index <= currentSize, ""Insert position out of bounds."");

        addChildren(index, children);
        return this;
    }

    /**
     * Create a new element by tag name, and add it as the last child.
     *
     * @param tagName the name of the tag (e.g. {@code div}).
     * @return the new element, to allow you to add content to it, e.g.:
     *  {@code parent.appendElement(""h1"").attr(""id"", ""header"").text(""Welcome"");}
     */
    public Element appendElement(String tagName) {
        Element child = new Element(Tag.valueOf(tagName, NodeUtils.parser(this).settings()), baseUri());
        appendChild(child);
        return child;
    }

    /**
     * Create a new element by tag name, and add it as the first child.
     *
     * @param tagName the name of the tag (e.g. {@code div}).
     * @return the new element, to allow you to add content to it, e.g.:
     *  {@code parent.prependElement(""h1"").attr(""id"", ""header"").text(""Welcome"");}
     */
    public Element prependElement(String tagName) {
        Element child = new Element(Tag.valueOf(tagName, NodeUtils.parser(this).settings()), baseUri());
        prependChild(child);
        return child;
    }

    /**
     * Create and append a new TextNode to this element.
     *
     * @param text the unencoded text to add
     * @return this element
     */
    public Element appendText(String text) {
        Validate.notNull(text);
        TextNode node = new TextNode(text);
        appendChild(node);
        return this;
    }

    /**
     * Create and prepend a new TextNode to this element.
     *
     * @param text the unencoded text to add
     * @return this element
     */
    public Element prependText(String text) {
        Validate.notNull(text);
        TextNode node = new TextNode(text);
        prependChild(node);
        return this;
    }

    /**
     * Add inner HTML to this element. The supplied HTML will be parsed, and each node appended to the end of the children.
     * @param html HTML to add inside this element, after the existing HTML
     * @return this element
     * @see #html(String)
     */
    public Element append(String html) {
        Validate.notNull(html);
        List<Node> nodes = NodeUtils.parser(this).parseFragmentInput(html, this, baseUri());
        addChildren(nodes.toArray(new Node[0]));
        return this;
    }

    /**
     * Add inner HTML into this element. The supplied HTML will be parsed, and each node prepended to the start of the element's children.
     * @param html HTML to add inside this element, before the existing HTML
     * @return this element
     * @see #html(String)
     */
    public Element prepend(String html) {
        Validate.notNull(html);
        List<Node> nodes = NodeUtils.parser(this).parseFragmentInput(html, this, baseUri());
        addChildren(0, nodes.toArray(new Node[0]));
        return this;
    }

    /**
     * Insert the specified HTML into the DOM before this element (as a preceding sibling).
     *
     * @param html HTML to add before this element
     * @return this element, for chaining
     * @see #after(String)
     */
    @Override
    public Element before(String html) {
        return (Element) super.before(html);
    }

    /**
     * Insert the specified node into the DOM before this node (as a preceding sibling).
     * @param node to add before this element
     * @return this Element, for chaining
     * @see #after(Node)
     */
    @Override
    public Element before(Node node) {
        return (Element) super.before(node);
    }

    /**
     * Insert the specified HTML into the DOM after this element (as a following sibling).
     *
     * @param html HTML to add after this element
     * @return this element, for chaining
     * @see #before(String)
     */
    @Override
    public Element after(String html) {
        return (Element) super.after(html);
    }

    /**
     * Insert the specified node into the DOM after this node (as a following sibling).
     * @param node to add after this element
     * @return this element, for chaining
     * @see #before(Node)
     */
    @Override
    public Element after(Node node) {
        return (Element) super.after(node);
    }

    /**
     * Remove all of the element's child nodes. Any attributes are left as-is.
     * @return this element
     */
    @Override
    public Element empty() {
        childNodes.clear();
        return this;
    }

    /**
     * Wrap the supplied HTML around this element.
     *
     * @param html HTML to wrap around this element, e.g. {@code <div class=""head""></div>}. Can be arbitrarily deep.
     * @return this element, for chaining.
     */
    @Override
    public Element wrap(String html) {
        return (Element) super.wrap(html);
    }

    /**
     * Get a CSS selector that will uniquely select this element.
     * <p>
     * If the element has an ID, returns #id;
     * otherwise returns the parent (if any) CSS selector, followed by {@literal '>'},
     * followed by a unique selector for the element (tag.class.class:nth-child(n)).
     * </p>
     *
     * @return the CSS Path that can be used to retrieve the element in a selector.
     */
    public String cssSelector() {
        if (id().length() > 0) {
            // prefer to return the ID - but check that it's actually unique first!
            String idSel = ""#"" + id();
            Document doc = ownerDocument();
            if (doc != null) {
                Elements els = doc.select(idSel);
                if (els.size() == 1 && els.get(0) == this) // otherwise, continue to the nth-child impl
                    return idSel;
            } else {
                return idSel; // no ownerdoc, return the ID selector
            }
        }

        // Translate HTML namespace ns:tag to CSS namespace syntax ns|tag
        String tagName = tagName().replace(':', '|');
        StringBuilder selector = new StringBuilder(tagName);
        String classes = StringUtil.join(classNames(), ""."");
        if (classes.length() > 0)
            selector.append('.').append(classes);

        if (parent() == null || parent() instanceof Document) // don't add Document to selector, as will always have a html node
            return selector.toString();

        selector.insert(0, "" > "");
        if (parent().select(selector.toString()).size() > 1)
            selector.append(String.format(
                "":nth-child(%d)"", elementSiblingIndex() + 1));

        return parent().cssSelector() + selector.toString();
    }

    /**
     * Get sibling elements. If the element has no sibling elements, returns an empty list. An element is not a sibling
     * of itself, so will not be included in the returned list.
     * @return sibling elements
     */
    public Elements siblingElements() {
        if (parentNode == null)
            return new Elements(0);

        List<Element> elements = parent().childElementsList();
        Elements siblings = new Elements(elements.size() - 1);
        for (Element el: elements)
            if (el != this)
                siblings.add(el);
        return siblings;
    }

    /**
     * Gets the next sibling element of this element. E.g., if a {@code div} contains two {@code p}s,
     * the {@code nextElementSibling} of the first {@code p} is the second {@code p}.
     * <p>
     * This is similar to {@link #nextSibling()}, but specifically finds only Elements
     * </p>
     * @return the next element, or null if there is no next element
     * @see #previousElementSibling()
     */
    public @Nullable Element nextElementSibling() {
        if (parentNode == null) return null;
        List<Element> siblings = parent().childElementsList();
        int index = indexInList(this, siblings);
        if (siblings.size() > index+1)
            return siblings.get(index+1);
        else
            return null;
    }

    /**
     * Get each of the sibling elements that come after this element.
     *
     * @return each of the element siblings after this element, or an empty list if there are no next sibling elements
     */
    public Elements nextElementSiblings() {
        return nextElementSiblings(true);
    }

    /**
     * Gets the previous element sibling of this element.
     * @return the previous element, or null if there is no previous element
     * @see #nextElementSibling()
     */
    public @Nullable Element previousElementSibling() {
        if (parentNode == null) return null;
        List<Element> siblings = parent().childElementsList();
        int index = indexInList(this, siblings);
        if (index > 0)
            return siblings.get(index-1);
        else
            return null;
    }

    /**
     * Get each of the element siblings before this element.
     *
     * @return the previous element siblings, or an empty list if there are none.
     */
    public Elements previousElementSiblings() {
        return nextElementSiblings(false);
    }

    private Elements nextElementSiblings(boolean next) {
        Elements els = new Elements();
        if (parentNode == null)
            return  els;
        els.add(this);
        return next ?  els.nextAll() : els.prevAll();
    }

    /**
     * Gets the first Element sibling of this element. That may be this element.
     * @return the first sibling that is an element (aka the parent's first element child)
     */
    public Element firstElementSibling() {
        if (parent() != null) {
            List<Element> siblings = parent().childElementsList();
            return siblings.size() > 1 ? siblings.get(0) : this;
        } else
            return this; // orphan is its own first sibling
    }

    /**
     * Get the list index of this element in its element sibling list. I.e. if this is the first element
     * sibling, returns 0.
     * @return position in element sibling list
     */
    public int elementSiblingIndex() {
       if (parent() == null) return 0;
       return indexInList(this, parent().childElementsList());
    }

    /**
     * Gets the last element sibling of this element. That may be this element.
     * @return the last sibling that is an element (aka the parent's last element child)
     */
    public Element lastElementSibling() {
        if (parent() != null) {
            List<Element> siblings = parent().childElementsList();
            return siblings.size() > 1 ? siblings.get(siblings.size() - 1) : this;
        } else
            return this;
    }

    private static <E extends Element> int indexInList(Element search, List<E> elements) {
        final int size = elements.size();
        for (int i = 0; i < size; i++) {
            if (elements.get(i) == search)
                return i;
        }
        return 0;
    }

    /**
     Gets the first child of this Element that is an Element, or {@code null} if there is none.
     @return the first Element child node, or null.
     @see #firstChild()
     @see #lastElementChild()
     @since 1.15.2
     */
    public @Nullable Element firstElementChild() {
        final int size = childNodeSize();
        if (size == 0) return null;
        List<Node> children = ensureChildNodes();
        for (int i = 0; i < size; i++) {
            Node node = children.get(i);
            if (node instanceof Element) return (Element) node;
        }
        return null;
    }

    /**
     Gets the last child of this Element that is an Element, or @{code null} if there is none.
     @return the last Element child node, or null.
     @see #lastChild()
     @see #firstElementChild()
     @since 1.15.2
     */
    public @Nullable Element lastElementChild() {
        final int size = childNodeSize();
        if (size == 0) return null;
        List<Node> children = ensureChildNodes();
        for (int i = size -1; i >= 0; i--) {
            Node node = children.get(i);
            if (node instanceof Element) return (Element) node;
        }
        return null;
    }

    // DOM type methods

    /**
     * Finds elements, including and recursively under this element, with the specified tag name.
     * @param tagName The tag name to search for (case insensitively).
     * @return a matching unmodifiable list of elements. Will be empty if this element and none of its children match.
     */
    public Elements getElementsByTag(String tagName) {
        Validate.notEmpty(tagName);
        tagName = normalize(tagName);

        return Collector.collect(new Evaluator.Tag(tagName), this);
    }

    /**
     * Find an element by ID, including or under this element.
     * <p>
     * Note that this finds the first matching ID, starting with this element. If you search down from a different
     * starting point, it is possible to find a different element by ID. For unique element by ID within a Document,
     * use {@link Document#getElementById(String)}
     * @param id The ID to search for.
     * @return The first matching element by ID, starting with this element, or null if none found.
     */
    public @Nullable Element getElementById(String id) {
        Validate.notEmpty(id);

        Elements elements = Collector.collect(new Evaluator.Id(id), this);
        if (elements.size() > 0)
            return elements.get(0);
        else
            return null;
    }

    /**
     * Find elements that have this class, including or under this element. Case insensitive.
     * <p>
     * Elements can have multiple classes (e.g. {@code <div class=""header round first"">}. This method
     * checks each class, so you can find the above with {@code el.getElementsByClass(""header"");}.
     *
     * @param className the name of the class to search for.
     * @return elements with the supplied class name, empty if none
     * @see #hasClass(String)
     * @see #classNames()
     */
    public Elements getElementsByClass(String className) {
        Validate.notEmpty(className);

        return Collector.collect(new Evaluator.Class(className), this);
    }

    /**
     * Find elements that have a named attribute set. Case insensitive.
     *
     * @param key name of the attribute, e.g. {@code href}
     * @return elements that have this attribute, empty if none
     */
    public Elements getElementsByAttribute(String key) {
        Validate.notEmpty(key);
        key = key.trim();

        return Collector.collect(new Evaluator.Attribute(key), this);
    }

    /**
     * Find elements that have an attribute name starting with the supplied prefix. Use {@code data-} to find elements
     * that have HTML5 datasets.
     * @param keyPrefix name prefix of the attribute e.g. {@code data-}
     * @return elements that have attribute names that start with the prefix, empty if none.
     */
    public Elements getElementsByAttributeStarting(String keyPrefix) {
        Validate.notEmpty(keyPrefix);
        keyPrefix = keyPrefix.trim();

        return Collector.collect(new Evaluator.AttributeStarting(keyPrefix), this);
    }

    /**
     * Find elements that have an attribute with the specific value. Case insensitive.
     *
     * @param key name of the attribute
     * @param value value of the attribute
     * @return elements that have this attribute with this value, empty if none
     */
    public Elements getElementsByAttributeValue(String key, String value) {
        return Collector.collect(new Evaluator.AttributeWithValue(key, value), this);
    }

    /**
     * Find elements that either do not have this attribute, or have it with a different value. Case insensitive.
     *
     * @param key name of the attribute
     * @param value value of the attribute
     * @return elements that do not have a matching attribute
     */
    public Elements getElementsByAttributeValueNot(String key, String value) {
        return Collector.collect(new Evaluator.AttributeWithValueNot(key, value), this);
    }

    /**
     * Find elements that have attributes that start with the value prefix. Case insensitive.
     *
     * @param key name of the attribute
     * @param valuePrefix start of attribute value
     * @return elements that have attributes that start with the value prefix
     */
    public Elements getElementsByAttributeValueStarting(String key, String valuePrefix) {
        return Collector.collect(new Evaluator.AttributeWithValueStarting(key, valuePrefix), this);
    }

    /**
     * Find elements that have attributes that end with the value suffix. Case insensitive.
     *
     * @param key name of the attribute
     * @param valueSuffix end of the attribute value
     * @return elements that have attributes that end with the value suffix
     */
    public Elements getElementsByAttributeValueEnding(String key, String valueSuffix) {
        return Collector.collect(new Evaluator.AttributeWithValueEnding(key, valueSuffix), this);
    }

    /**
     * Find elements that have attributes whose value contains the match string. Case insensitive.
     *
     * @param key name of the attribute
     * @param match substring of value to search for
     * @return elements that have attributes containing this text
     */
    public Elements getElementsByAttributeValueContaining(String key, String match) {
        return Collector.collect(new Evaluator.AttributeWithValueContaining(key, match), this);
    }

    /**
     * Find elements that have attributes whose values match the supplied regular expression.
     * @param key name of the attribute
     * @param pattern compiled regular expression to match against attribute values
     * @return elements that have attributes matching this regular expression
     */
    public Elements getElementsByAttributeValueMatching(String key, Pattern pattern) {
        return Collector.collect(new Evaluator.AttributeWithValueMatching(key, pattern), this);

    }

    /**
     * Find elements that have attributes whose values match the supplied regular expression.
     * @param key name of the attribute
     * @param regex regular expression to match against attribute values. You can use <a href=""http://java.sun.com/docs/books/tutorial/essential/regex/pattern.html#embedded"">embedded flags</a> (such as (?i) and (?m) to control regex options.
     * @return elements that have attributes matching this regular expression
     */
    public Elements getElementsByAttributeValueMatching(String key, String regex) {
        Pattern pattern;
        try {
            pattern = Pattern.compile(regex);
        } catch (PatternSyntaxException e) {
            throw new IllegalArgumentException(""Pattern syntax error: "" + regex, e);
        }
        return getElementsByAttributeValueMatching(key, pattern);
    }

    /**
     * Find elements whose sibling index is less than the supplied index.
     * @param index 0-based index
     * @return elements less than index
     */
    public Elements getElementsByIndexLessThan(int index) {
        return Collector.collect(new Evaluator.IndexLessThan(index), this);
    }

    /**
     * Find elements whose sibling index is greater than the supplied index.
     * @param index 0-based index
     * @return elements greater than index
     */
    public Elements getElementsByIndexGreaterThan(int index) {
        return Collector.collect(new Evaluator.IndexGreaterThan(index), this);
    }

    /**
     * Find elements whose sibling index is equal to the supplied index.
     * @param index 0-based index
     * @return elements equal to index
     */
    public Elements getElementsByIndexEquals(int index) {
        return Collector.collect(new Evaluator.IndexEquals(index), this);
    }

    /**
     * Find elements that contain the specified string. The search is case insensitive. The text may appear directly
     * in the element, or in any of its descendants.
     * @param searchText to look for in the element's text
     * @return elements that contain the string, case insensitive.
     * @see Element#text()
     */
    public Elements getElementsContainingText(String searchText) {
        return Collector.collect(new Evaluator.ContainsText(searchText), this);
    }

    /**
     * Find elements that directly contain the specified string. The search is case insensitive. The text must appear directly
     * in the element, not in any of its descendants.
     * @param searchText to look for in the element's own text
     * @return elements that contain the string, case insensitive.
     * @see Element#ownText()
     */
    public Elements getElementsContainingOwnText(String searchText) {
        return Collector.collect(new Evaluator.ContainsOwnText(searchText), this);
    }

    /**
     * Find elements whose text matches the supplied regular expression.
     * @param pattern regular expression to match text against
     * @return elements matching the supplied regular expression.
     * @see Element#text()
     */
    public Elements getElementsMatchingText(Pattern pattern) {
        return Collector.collect(new Evaluator.Matches(pattern), this);
    }

    /**
     * Find elements whose text matches the supplied regular expression.
     * @param regex regular expression to match text against. You can use <a href=""http://java.sun.com/docs/books/tutorial/essential/regex/pattern.html#embedded"">embedded flags</a> (such as (?i) and (?m) to control regex options.
     * @return elements matching the supplied regular expression.
     * @see Element#text()
     */
    public Elements getElementsMatchingText(String regex) {
        Pattern pattern;
        try {
            pattern = Pattern.compile(regex);
        } catch (PatternSyntaxException e) {
            throw new IllegalArgumentException(""Pattern syntax error: "" + regex, e);
        }
        return getElementsMatchingText(pattern);
    }

    /**
     * Find elements whose own text matches the supplied regular expression.
     * @param pattern regular expression to match text against
     * @return elements matching the supplied regular expression.
     * @see Element#ownText()
     */
    public Elements getElementsMatchingOwnText(Pattern pattern) {
        return Collector.collect(new Evaluator.MatchesOwn(pattern), this);
    }

    /**
     * Find elements whose own text matches the supplied regular expression.
     * @param regex regular expression to match text against. You can use <a href=""http://java.sun.com/docs/books/tutorial/essential/regex/pattern.html#embedded"">embedded flags</a> (such as (?i) and (?m) to control regex options.
     * @return elements matching the supplied regular expression.
     * @see Element#ownText()
     */
    public Elements getElementsMatchingOwnText(String regex) {
        Pattern pattern;
        try {
            pattern = Pattern.compile(regex);
        } catch (PatternSyntaxException e) {
            throw new IllegalArgumentException(""Pattern syntax error: "" + regex, e);
        }
        return getElementsMatchingOwnText(pattern);
    }

    /**
     * Find all elements under this element (including self, and children of children).
     *
     * @return all elements
     */
    public Elements getAllElements() {
        return Collector.collect(new Evaluator.AllElements(), this);
    }

    /**
     Gets the <b>normalized, combined text</b> of this element and all its children. Whitespace is normalized and
     trimmed.
     <p>For example, given HTML {@code <p>Hello  <b>there</b> now! </p>}, {@code p.text()} returns {@code ""Hello there
    now!""}
     <p>If you do not want normalized text, use {@link #wholeText()}. If you want just the text of this node (and not
     children), use {@link #ownText()}
     <p>Note that this method returns the textual content that would be presented to a reader. The contents of data
     nodes (such as {@code <script>} tags are not considered text. Use {@link #data()} or {@link #html()} to retrieve
     that content.

     @return unencoded, normalized text, or empty string if none.
     @see #wholeText()
     @see #ownText()
     @see #textNodes()
     */
    public String text() {
        final StringBuilder accum = StringUtil.borrowBuilder();
        NodeTraversor.traverse(new NodeVisitor() {
            public void head(Node node, int depth) {
                if (node instanceof TextNode) {
                    TextNode textNode = (TextNode) node;
                    appendNormalisedText(accum, textNode);
                } else if (node instanceof Element) {
                    Element element = (Element) node;
                    if (accum.length() > 0 &&
                        (element.isBlock() || element.tag.normalName().equals(""br"")) &&
                        !TextNode.lastCharIsWhitespace(accum))
                        accum.append(' ');
                }
            }

            public void tail(Node node, int depth) {
                // make sure there is a space between block tags and immediately following text nodes <div>One</div>Two should be ""One Two"".
                if (node instanceof Element) {
                    Element element = (Element) node;
                    if (element.isBlock() && (node.nextSibling() instanceof TextNode) && !TextNode.lastCharIsWhitespace(accum))
                        accum.append(' ');
                }

            }
        }, this);

        return StringUtil.releaseBuilder(accum).trim();
    }

    /**
     * Get the (unencoded) text of all children of this element, including any newlines and spaces present in the
     * original.
     *
     * @return unencoded, un-normalized text
     * @see #text()
     */
    public String wholeText() {
        final StringBuilder accum = StringUtil.borrowBuilder();
        NodeTraversor.traverse((node, depth) -> appendWholeText(node, accum), this);
        return StringUtil.releaseBuilder(accum);
    }

    private static void appendWholeText(Node node, StringBuilder accum) {
        if (node instanceof TextNode) {
            accum.append(((TextNode) node).getWholeText());
        } else if (node instanceof Element) {
            appendNewlineIfBr((Element) node, accum);
        }
    }

    /**
     Get the (unencoded) text of this element, <b>not including</b> any child elements, including any newlines and spaces
     present in the original.

     @return unencoded, un-normalized text that is a direct child of this Element
     @see #text()
     @see #wholeText()
     @see #ownText()
     @since 1.15.1
     */
    public String wholeOwnText() {
        final StringBuilder accum = StringUtil.borrowBuilder();
        final int size = childNodeSize();
        for (int i = 0; i < size; i++) {
            Node node = childNodes.get(i);
            appendWholeText(node, accum);
        }

        return StringUtil.releaseBuilder(accum);
    }

    /**
     * Gets the (normalized) text owned by this element only; does not get the combined text of all children.
     * <p>
     * For example, given HTML {@code <p>Hello <b>there</b> now!</p>}, {@code p.ownText()} returns {@code ""Hello now!""},
     * whereas {@code p.text()} returns {@code ""Hello there now!""}.
     * Note that the text within the {@code b} element is not returned, as it is not a direct child of the {@code p} element.
     *
     * @return unencoded text, or empty string if none.
     * @see #text()
     * @see #textNodes()
     */
    public String ownText() {
        StringBuilder sb = StringUtil.borrowBuilder();
        ownText(sb);
        return StringUtil.releaseBuilder(sb).trim();
    }

    private void ownText(StringBuilder accum) {
        for (int i = 0; i < childNodeSize(); i++) {
            Node child = childNodes.get(i);
            if (child instanceof TextNode) {
                TextNode textNode = (TextNode) child;
                appendNormalisedText(accum, textNode);
            } else if (child instanceof Element) {
                appendWhitespaceIfBr((Element) child, accum);
            }
        }
    }

    private static void appendNormalisedText(StringBuilder accum, TextNode textNode) {
        String text = textNode.getWholeText();

        if (preserveWhitespace(textNode.parentNode) || textNode instanceof CDataNode)
            accum.append(text);
        else
            StringUtil.appendNormalisedWhitespace(accum, text, TextNode.lastCharIsWhitespace(accum));
    }

    /** For normalized text, treat a br element as a space, if there is not already a space. */
    private static void appendWhitespaceIfBr(Element element, StringBuilder accum) {
        if (element.tag.normalName().equals(""br"") && !TextNode.lastCharIsWhitespace(accum))
            accum.append("" "");
    }

    /** For WholeText, treat a br element as a newline. */
    private static void appendNewlineIfBr(Element element, StringBuilder accum) {
        if (element.tag.normalName().equals(""br""))
            accum.append(""\n"");
    }

    static boolean preserveWhitespace(@Nullable Node node) {
        // looks only at this element and five levels up, to prevent recursion & needless stack searches
        if (node instanceof Element) {
            Element el = (Element) node;
            int i = 0;
            do {
                if (el.tag.preserveWhitespace())
                    return true;
                el = el.parent();
                i++;
            } while (i < 6 && el != null);
        }
        return false;
    }

    /**
     * Set the text of this element. Any existing contents (text or elements) will be cleared.
     * <p>As a special case, for {@code <script>} and {@code <style>} tags, the input text will be treated as data,
     * not visible text.</p>
     * @param text unencoded text
     * @return this element
     */
    public Element text(String text) {
        Validate.notNull(text);
        empty();
        // special case for script/style in HTML: should be data node
        Document owner = ownerDocument();
        // an alternate impl would be to run through the parser
        if (owner != null && owner.parser().isContentForTagData(normalName()))
            appendChild(new DataNode(text));
        else
            appendChild(new TextNode(text));

        return this;
    }

    /**
     Test if this element has any text content (that is not just whitespace).
     @return true if element has non-blank text content.
     */
    public boolean hasText() {
        for (Node child: childNodes) {
            if (child instanceof TextNode) {
                TextNode textNode = (TextNode) child;
                if (!textNode.isBlank())
                    return true;
            } else if (child instanceof Element) {
                Element el = (Element) child;
                if (el.hasText())
                    return true;
            }
        }
        return false;
    }

    /**
     * Get the combined data of this element. Data is e.g. the inside of a {@code <script>} tag. Note that data is NOT the
     * text of the element. Use {@link #text()} to get the text that would be visible to a user, and {@code data()}
     * for the contents of scripts, comments, CSS styles, etc.
     *
     * @return the data, or empty string if none
     *
     * @see #dataNodes()
     */
    public String data() {
        StringBuilder sb = StringUtil.borrowBuilder();

        for (Node childNode : childNodes) {
            if (childNode instanceof DataNode) {
                DataNode data = (DataNode) childNode;
                sb.append(data.getWholeData());
            } else if (childNode instanceof Comment) {
                Comment comment = (Comment) childNode;
                sb.append(comment.getData());
            } else if (childNode instanceof Element) {
                Element element = (Element) childNode;
                String elementData = element.data();
                sb.append(elementData);
            } else if (childNode instanceof CDataNode) {
                // this shouldn't really happen because the html parser won't see the cdata as anything special when parsing script.
                // but incase another type gets through.
                CDataNode cDataNode = (CDataNode) childNode;
                sb.append(cDataNode.getWholeText());
            }
        }
        return StringUtil.releaseBuilder(sb);
    }

    /**
     * Gets the literal value of this element's ""class"" attribute, which may include multiple class names, space
     * separated. (E.g. on <code>&lt;div class=""header gray""&gt;</code> returns, ""<code>header gray</code>"")
     * @return The literal class attribute, or <b>empty string</b> if no class attribute set.
     */
    public String className() {
        return attr(""class"").trim();
    }

    /**
     * Get all of the element's class names. E.g. on element {@code <div class=""header gray"">},
     * returns a set of two elements {@code ""header"", ""gray""}. Note that modifications to this set are not pushed to
     * the backing {@code class} attribute; use the {@link #classNames(java.util.Set)} method to persist them.
     * @return set of classnames, empty if no class attribute
     */
    public Set<String> classNames() {
    	String[] names = ClassSplit.split(className());
    	Set<String> classNames = new LinkedHashSet<>(Arrays.asList(names));
    	classNames.remove(""""); // if classNames() was empty, would include an empty class

        return classNames;
    }

    /**
     Set the element's {@code class} attribute to the supplied class names.
     @param classNames set of classes
     @return this element, for chaining
     */
    public Element classNames(Set<String> classNames) {
        Validate.notNull(classNames);
        if (classNames.isEmpty()) {
            attributes().remove(""class"");
        } else {
            attributes().put(""class"", StringUtil.join(classNames, "" ""));
        }
        return this;
    }

    /**
     * Tests if this element has a class. Case insensitive.
     * @param className name of class to check for
     * @return true if it does, false if not
     */
    // performance sensitive
    public boolean hasClass(String className) {
        if (attributes == null)
            return false;

        final String classAttr = attributes.getIgnoreCase(""class"");
        final int len = classAttr.length();
        final int wantLen = className.length();

        if (len == 0 || len < wantLen) {
            return false;
        }

        // if both lengths are equal, only need compare the className with the attribute
        if (len == wantLen) {
            return className.equalsIgnoreCase(classAttr);
        }

        // otherwise, scan for whitespace and compare regions (with no string or arraylist allocations)
        boolean inClass = false;
        int start = 0;
        for (int i = 0; i < len; i++) {
            if (Character.isWhitespace(classAttr.charAt(i))) {
                if (inClass) {
                    // white space ends a class name, compare it with the requested one, ignore case
                    if (i - start == wantLen && classAttr.regionMatches(true, start, className, 0, wantLen)) {
                        return true;
                    }
                    inClass = false;
                }
            } else {
                if (!inClass) {
                    // we're in a class name : keep the start of the substring
                    inClass = true;
                    start = i;
                }
            }
        }

        // check the last entry
        if (inClass && len - start == wantLen) {
            return classAttr.regionMatches(true, start, className, 0, wantLen);
        }

        return false;
    }

    /**
     Add a class name to this element's {@code class} attribute.
     @param className class name to add
     @return this element
     */
    public Element addClass(String className) {
        Validate.notNull(className);

        Set<String> classes = classNames();
        classes.add(className);
        classNames(classes);

        return this;
    }

    /**
     Remove a class name from this element's {@code class} attribute.
     @param className class name to remove
     @return this element
     */
    public Element removeClass(String className) {
        Validate.notNull(className);

        Set<String> classes = classNames();
        classes.remove(className);
        classNames(classes);

        return this;
    }

    /**
     Toggle a class name on this element's {@code class} attribute: if present, remove it; otherwise add it.
     @param className class name to toggle
     @return this element
     */
    public Element toggleClass(String className) {
        Validate.notNull(className);

        Set<String> classes = classNames();
        if (classes.contains(className))
            classes.remove(className);
        else
            classes.add(className);
        classNames(classes);

        return this;
    }

    /**
     * Get the value of a form element (input, textarea, etc).
     * @return the value of the form element, or empty string if not set.
     */
    public String val() {
        if (normalName().equals(""textarea""))
            return text();
        else
            return attr(""value"");
    }

    /**
     * Set the value of a form element (input, textarea, etc).
     * @param value value to set
     * @return this element (for chaining)
     */
    public Element val(String value) {
        if (normalName().equals(""textarea""))
            text(value);
        else
            attr(""value"", value);
        return this;
    }

    /**
     Get the source range (start and end positions) of the end (closing) tag for this Element. Position tracking must be
     enabled prior to parsing the content.
     @return the range of the closing tag for this element, if it was explicitly closed in the source. {@code Untracked}
     otherwise.
     @see org.jsoup.parser.Parser#setTrackPosition(boolean)
     @see Node#sourceRange()
     @since 1.15.2
     */
    public Range endSourceRange() {
        return Range.of(this, false);
    }

    boolean shouldIndent(final Document.OutputSettings out) {
        return out.prettyPrint() && isFormatAsBlock(out) && !isInlineable(out);
    }

    void outerHtmlHead(final Appendable accum, int depth, final Document.OutputSettings out) throws IOException {
        if (shouldIndent(out)) {
            if (accum instanceof StringBuilder) {
                if (((StringBuilder) accum).length() > 0)
                    indent(accum, depth, out);
            } else {
                indent(accum, depth, out);
            }
        }
        accum.append('<').append(tagName());
        if (attributes != null) attributes.html(accum, out);

        // selfclosing includes unknown tags, isEmpty defines tags that are always empty
        if (childNodes.isEmpty() && tag.isSelfClosing()) {
            if (out.syntax() == Document.OutputSettings.Syntax.html && tag.isEmpty())
                accum.append('>');
            else
                accum.append("" />""); // <img> in html, <img /> in xml
        }
        else
            accum.append('>');
    }

    void outerHtmlTail(Appendable accum, int depth, Document.OutputSettings out) throws IOException {
        if (!(childNodes.isEmpty() && tag.isSelfClosing())) {
            if (out.prettyPrint() && (!childNodes.isEmpty() && (
                    tag.formatAsBlock() || (out.outline() && (childNodes.size()>1 || (childNodes.size()==1 && (childNodes.get(0) instanceof Element))))
            )))
                indent(accum, depth, out);
            accum.append(""</"").append(tagName()).append('>');
        }
    }

    /**
     * Retrieves the element's inner HTML. E.g. on a {@code <div>} with one empty {@code <p>}, would return
     * {@code <p></p>}. (Whereas {@link #outerHtml()} would return {@code <div><p></p></div>}.)
     *
     * @return String of HTML.
     * @see #outerHtml()
     */
    public String html() {
        StringBuilder accum = StringUtil.borrowBuilder();
        html(accum);
        String html = StringUtil.releaseBuilder(accum);
        return NodeUtils.outputSettings(this).prettyPrint() ? html.trim() : html;
    }

    @Override
    public <T extends Appendable> T html(T appendable) {
        final int size = childNodes.size();
        for (int i = 0; i < size; i++)
            childNodes.get(i).outerHtml(appendable);

        return appendable;
    }

    /**
     * Set this element's inner HTML. Clears the existing HTML first.
     * @param html HTML to parse and set into this element
     * @return this element
     * @see #append(String)
     */
    public Element html(String html) {
        empty();
        append(html);
        return this;
    }

    @Override
    public Element clone() {
        return (Element) super.clone();
    }

    @Override
    public Element shallowClone() {
        // simpler than implementing a clone version with no child copy
        return new Element(tag, baseUri(), attributes == null ? null : attributes.clone());
    }

    @Override
    protected Element doClone(@Nullable Node parent) {
        Element clone = (Element) super.doClone(parent);
        clone.attributes = attributes != null ? attributes.clone() : null;
        clone.childNodes = new NodeList(clone, childNodes.size());
        clone.childNodes.addAll(childNodes); // the children then get iterated and cloned in Node.clone

        return clone;
    }

    // overrides of Node for call chaining
    @Override
    public Element clearAttributes() {
        if (attributes != null) {
            super.clearAttributes();
            attributes = null;
        }

        return this;
    }

    @Override
    public Element removeAttr(String attributeKey) {
        return (Element) super.removeAttr(attributeKey);
    }

    @Override
    public Element root() {
        return (Element) super.root(); // probably a document, but always at least an element
    }

    @Override
    public Element traverse(NodeVisitor nodeVisitor) {
        return (Element) super.traverse(nodeVisitor);
    }

    @Override
    public Element forEachNode(Consumer<? super Node> action) {
        return (Element) super.forEachNode(action);
    }

    /**
     Perform the supplied action on this Element and each of its descendant Elements, during a depth-first traversal.
     Elements may be inspected, changed, added, replaced, or removed.
     @param action the function to perform on the element
     @return this Element, for chaining
     @see Node#forEachNode(Consumer)
     */
    public Element forEach(Consumer<? super Element> action) {
        Validate.notNull(action);
        NodeTraversor.traverse((node, depth) -> {
            if (node instanceof Element)
                action.accept((Element) node);
        }, this);
        return this;
    }

    @Override
    public Element filter(NodeFilter nodeFilter) {
        return  (Element) super.filter(nodeFilter);
    }

    private static final class NodeList extends ChangeNotifyingArrayList<Node> {
        private final Element owner;

        NodeList(Element owner, int initialCapacity) {
            super(initialCapacity);
            this.owner = owner;
        }

        public void onContentsChanged() {
            owner.nodelistChanged();
        }
    }

    private boolean isFormatAsBlock(Document.OutputSettings out) {
        return tag.formatAsBlock() || (parent() != null && parent().tag().formatAsBlock()) || out.outline();
    }

    private boolean isInlineable(Document.OutputSettings out) {
        return tag().isInline()
            && (parent() == null || parent().isBlock())
            && previousSibling() != null
            && !out.outline();
    }
}
"
